//WinQLVolume.cpp

// Copyright Querysoft Limited 2017
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Objects representing File System Volumes

#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "WinQL/System/FileSystem/WinQLVolume.h"
#include "WinQL/System/FileSystem/WinQLVolumeManagement.h"
#include "WinQAPI/Kernel32.h"
#include "SystemQOR/MSWindows/MSW_tchar.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	using namespace nsWinQAPI;

	//--Volume Helper-----------------------------------------------------------------

	__QOR_IMPLEMENT_OCLASS_LUID(CVolumeHelper);

	//--------------------------------------------------------------------------------
	CVolumeHelper::CVolumeHelper()
	{
		_WINQ_FCONTEXT("CVolumeHelper::CVolumeHelper");
	}

	//--------------------------------------------------------------------------------
	CVolumeHelper::CVolumeHelper(const CVolumeHelper& src)
	{
		_WINQ_FCONTEXT("CVolumeHelper::CVolumeHelper");
		*this = src;
	}

	//--------------------------------------------------------------------------------
	CVolumeHelper& CVolumeHelper::operator = (const CVolumeHelper& src)
	{
		_WINQ_FCONTEXT("CVolumeHelper::CVolumeHelper");
		if (&src != this)
		{
		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	CVolumeHelper::~CVolumeHelper()
	{
		_WINQ_FCONTEXT("CVolumeHelper::~CVolumeHelper");
	}

	//--------------------------------------------------------------------------------
	bool CVolumeHelper::SetLabel(const TCHAR* lpRootPathName, const TCHAR* lpVolumeName)
	{
		_WINQ_FCONTEXT("CVolumeHelper::SetLabel");
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::SetVolumeLabel(lpRootPathName, lpVolumeName) ? true : false;
		}__QOR_ENDPROTECT
			return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CVolumeHelper::GetInformation(const TCHAR* lpRootPathName, CVolumeHelper::VolumeInformation& VolumeInfo)
	{
		_WINQ_FCONTEXT("CVolumeHelper::GetInformation");
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetVolumeInformation(
				lpRootPathName,
				VolumeInfo.strName.GetBuffer(),
				VolumeInfo.strName.Allocation(),
				&VolumeInfo.ulSerialNumber,
				&VolumeInfo.ulMaximumComponentLength,
				&VolumeInfo.ulFileSystemFlags,
				VolumeInfo.strFileSystemName.GetBuffer(),
				VolumeInfo.strFileSystemName.Allocation()) ? true : false;
		VolumeInfo.strName.ReleaseBuffer();
		VolumeInfo.strFileSystemName.ReleaseBuffer();
		}__QOR_ENDPROTECT
			return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CVolumeHelper::GetInformationByHandle(CFile& File, ByHandleVolumeInformation& VolumeInfo)
	{
		_WINQ_FCONTEXT("CVolumeHelper::GetInformationByHandle");
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetVolumeInformationByHandleW(File.Handle()->Use(),
			VolumeInfo.strName.GetBuffer(), VolumeInfo.strName.Allocation(),
			&VolumeInfo.ulSerialNumber, &VolumeInfo.ulMaximumComponentLength, &VolumeInfo.ulFileSystemFlags,
			VolumeInfo.strFileSystemName.GetBuffer(), VolumeInfo.strFileSystemName.Allocation()) ? true : false;
		VolumeInfo.strName.ReleaseBuffer();
		VolumeInfo.strFileSystemName.ReleaseBuffer();
		}__QOR_ENDPROTECT
			return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CVolumeHelper::GetInformationByHandle(CFile& File, wchar_t* lpVolumeNameBuffer,
		unsigned long nVolumeNameSize, unsigned long* lpVolumeSerialNumber,
		unsigned long* lpMaximumComponentLength, unsigned long* lpFileSystemFlags, wchar_t* lpFileSystemNameBuffer, unsigned long nFileSystemNameSize)
	{
		_WINQ_FCONTEXT("CVolumeHelper::GetInformationByHandle");
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetVolumeInformationByHandleW(File.Handle()->Use(), lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize) ? true : false;
		}__QOR_ENDPROTECT
			return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CVolumeHelper::GetPathName(const TCHAR* lpszFileName, TCHAR* lpszVolumePathName, unsigned long cchBufferLength)
	{
		_WINQ_FCONTEXT("CVolumeHelper::GetPathName");
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetVolumePathName(lpszFileName, lpszVolumePathName, cchBufferLength) ? true : false;
		}__QOR_ENDPROTECT
			return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CVolumeHelper::GetPathNamesForName(const TCHAR* lpszVolumeName, TCHAR* lpszVolumePathNames, unsigned long cchBufferLength, unsigned long* lpcchReturnLength)
	{
		_WINQ_FCONTEXT("CVolumeHelper::GetPathNamesForName");
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetVolumePathNamesForVolumeName(lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength) ? true : false;
		}__QOR_ENDPROTECT
			return bResult;
	}

	//--------------------------------------------------------------------------------
	CVolume::CVolume(CTStringRef VolumeGUID) : m_GUID(*VolumeGUID)
	{
		GUID.Attach(this, &CVolume::GetGuid, nullptr);
		DeviceName.Attach(this, &CVolume::GetDeviceName, nullptr);
		PathNames.Attach(this, &CVolume::GetPathNames, nullptr);
		MountPoints.Attach(this, &CVolume::GetMountPoints, nullptr);
	}

	//--------------------------------------------------------------------------------
	CVolume::CVolume(const CVolume& src)
	{
		*this = src;
	}

	//--------------------------------------------------------------------------------
	CVolume& CVolume::operator = (const CVolume& src)
	{
		if (&src != this)
		{
			m_GUID = src.m_GUID;
			m_DeviceName = src.m_DeviceName;
			m_VecPathNames = src.m_VecPathNames;
		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	CTString CVolume::GetGuid()
	{
		return m_GUID;
	}

	//--------------------------------------------------------------------------------
	CTString CVolume::GetDeviceName()
	{
		if (m_DeviceName.IsEmpty())
		{
			CDosDeviceHelper Helper;
			CTString strTargetPath = m_GUID.Mid(4, m_GUID.Len() - 5);
			Helper.Query(strTargetPath, m_DeviceName);
		}
		return m_DeviceName;
	}

	//--------------------------------------------------------------------------------
	std::vector< CTString > CVolume::GetMountPoints()
	{
		if (m_VecMountPoints.size() == 0)
		{
			CTString strVolumePath = GetGuid();
			CFindMountPoint MountPointsSession(strVolumePath);
			if (MountPointsSession.IsValid())
			{
				do
				{
					if (!MountPointsSession.MountPoint().IsEmpty())
					{
						m_VecMountPoints.push_back(MountPointsSession.MountPoint());
					}
				} while (MountPointsSession.IsValid() && MountPointsSession.Next());
			}
		}
		return m_VecMountPoints;
	}

	//--------------------------------------------------------------------------------
	std::vector< CTString > CVolume::GetPathNames()
	{
		if (m_VecPathNames.size() == 0)
		{
			unsigned short CharCount = MaxPath + 1;
			CTString Names;
			const TCHAR* NameIdx = NULL;
			bool   Success = FALSE;

			do
			{
				//  Obtain all of the paths for this volume.
				unsigned long ulResult = 0;
				Success = m_Helper.GetPathNamesForName(m_GUID, Names.GetBufferSetLength(CharCount), CharCount, &ulResult);

				if (!Success && GetLastError() == ERROR_MORE_DATA)
				{
					CharCount = static_cast<unsigned short>(ulResult);
				}
				else
				{
					break;
				}
			} while (!Success);

			if (Success)
			{
				for (NameIdx = Names.GetBuffer();
					NameIdx[0] != L'\0';
					NameIdx += _tcslen(NameIdx) + 1)
				{
					m_VecPathNames.push_back(*(new CTString(NameIdx)));
				}
			}
		}
		return m_VecPathNames;
	}

	//--------------------------------------------------------------------------------
	CVolume::~CVolume()
	{
		//m_VecPathNames.erase(m_VecPathNames.begin(),m_VecPathNames.end());
	}

}//nsWin32
