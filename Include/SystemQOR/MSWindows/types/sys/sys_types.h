//sys_types.h

// Copyright Querysoft Limited 2016
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Win32 specific definitions associated with types

#ifndef WIN32_SYS_TYPES_H
#define WIN32_SYS_TYPES_H

#include "WinQL/Definitions/Constants.h"
#include "WinQL/Definitions/Overlapped.h"
#include "WinQL/Definitions/Exception.h"

#define imaginary _Imaginary

//Floating-point environment

// We should define #pragma STDC FENV_ACCESS on-off-switch

//  Here we should define these exceptions
//  FE_INVALID
//  FE_DIVBYZERO
//  FE_OVERFLOW
//  FE_UNDERFLOW
//  FE_INEXACT
#define FE_ALL_EXCEPT 0	//  Signals no exception is supported.

// Here we should define the rounding modes
//  FE_TONEAREST
//  FE_DOWNWARD
//  FE_UPWARD
//  FE_TOWARDZERO
//  We define no macro which signals no rounding mode is selectable.

//A constant expression of type float representing a quiet NaN. This symbolic constant is only defined if the implementation supports quiet NaNs for the float type.
//The following macros shall be defined for number classification. They represent the mutually-exclusive kinds of floating-point values. 
//They expand to integer constant expressions with distinct values. 
//Additional implementation-defined floating-point classifications, with macro definitions beginning with FP_ and an uppercase letter, may also be specified by the implementation.

#define ASSIGN_HUGE_VAL ( *(reinterpret_cast< const double* >( & __gcs_ullHuge ) ) )
#define ASSIGN_HUGE_VALL ( *(reinterpret_cast< const long double* >( & __gcs_ullHuge ) ) )
#define ASSIGN_HUGE_VALF ( *(reinterpret_cast< const float* >( & __gcs_ullHuge ) ) )

// The ISO C99 standard specifies that in C++ implementations these
// macros should only be defined if explicitly requested.
#if !defined __cplusplus || defined __STDC_LIMIT_MACROS

# if __WORDSIZE == 64
#  define __INT64_C(c)	c ## L
#  define __UINT64_C(c)	c ## UL
# else
#  define __INT64_C(c)	c ## LL
#  define __UINT64_C(c)	c ## ULL
# endif

// Limits of integral types.

// Minimum of signed integral types.
# define INT8_MIN		(-128)
# define INT16_MIN		(-32767-1)
# define INT32_MIN		(-2147483647-1)
# define INT64_MIN		(-__INT64_C(9223372036854775807)-1)
// Maximum of signed integral types.
# define INT8_MAX		(127)
# define INT16_MAX		(32767)
# define INT32_MAX		(2147483647)
# define INT64_MAX		(__INT64_C(9223372036854775807))

// Maximum of unsigned integral types.
# define UINT8_MAX		(255)
# define UINT16_MAX		(65535)
# define UINT32_MAX		(4294967295U)
# define UINT64_MAX		(__UINT64_C(18446744073709551615))


// Minimum of signed integral types having a minimum size.
# define INT_LEAST8_MIN		(-128)
# define INT_LEAST16_MIN	(-32767-1)
# define INT_LEAST32_MIN	(-2147483647-1)
# define INT_LEAST64_MIN	(-__INT64_C(9223372036854775807)-1)
// Maximum of signed integral types having a minimum size.
# define INT_LEAST8_MAX		(127)
# define INT_LEAST16_MAX	(32767)
# define INT_LEAST32_MAX	(2147483647)
# define INT_LEAST64_MAX	(__INT64_C(9223372036854775807))

// Maximum of unsigned integral types having a minimum size.
# define UINT_LEAST8_MAX	(255)
# define UINT_LEAST16_MAX	(65535)
# define UINT_LEAST32_MAX	(4294967295U)
# define UINT_LEAST64_MAX	(__UINT64_C(18446744073709551615))


// Minimum of fast signed integral types having a minimum size.
# define INT_FAST8_MIN		(-128)
# if __WORDSIZE == 64
#  define INT_FAST16_MIN	(-9223372036854775807L-1)
#  define INT_FAST32_MIN	(-9223372036854775807L-1)
# else
#  define INT_FAST16_MIN	(-2147483647-1)
#  define INT_FAST32_MIN	(-2147483647-1)
# endif
# define INT_FAST64_MIN		(-__INT64_C(9223372036854775807)-1)
// Maximum of fast signed integral types having a minimum size.
# define INT_FAST8_MAX		(127)
# if __WORDSIZE == 64
#  define INT_FAST16_MAX	(9223372036854775807L)
#  define INT_FAST32_MAX	(9223372036854775807L)
# else
#  define INT_FAST16_MAX	(2147483647)
#  define INT_FAST32_MAX	(2147483647)
# endif
# define INT_FAST64_MAX		(__INT64_C(9223372036854775807))

// Maximum of fast unsigned integral types having a minimum size.
# define UINT_FAST8_MAX		(255)
# if __WORDSIZE == 64
#  define UINT_FAST16_MAX	(18446744073709551615UL)
#  define UINT_FAST32_MAX	(18446744073709551615UL)
# else
#  define UINT_FAST16_MAX	(4294967295U)
#  define UINT_FAST32_MAX	(4294967295U)
# endif
# define UINT_FAST64_MAX	(__UINT64_C(18446744073709551615))


// Values to test for integral types holding `void *' pointer.
# if __WORDSIZE == 64
#  define INTPTR_MIN		(-9223372036854775807L-1)
#  define INTPTR_MAX		(9223372036854775807L)
#  define UINTPTR_MAX		(18446744073709551615UL)
# else
#  define INTPTR_MIN		(-2147483647-1)
#  define INTPTR_MAX		(2147483647)
#  define UINTPTR_MAX		(4294967295U)
# endif


// Minimum for largest signed integral type.
# define INTMAX_MIN		(-__INT64_C(9223372036854775807)-1)
// Maximum for largest signed integral type.
# define INTMAX_MAX		(__INT64_C(9223372036854775807))

// Maximum for largest unsigned integral type.
# define UINTMAX_MAX		(__UINT64_C(18446744073709551615))


// Limits of other integer types.

// Limits of `ptrdiff_t' type.
# if __WORDSIZE == 64
#  define PTRDIFF_MIN		(-9223372036854775807L-1)
#  define PTRDIFF_MAX		(9223372036854775807L)
# else
#  define PTRDIFF_MIN		(-2147483647-1)
#  define PTRDIFF_MAX		(2147483647)
# endif

// Limits of `sig_atomic_t'.
# define SIG_ATOMIC_MIN		(-2147483647-1)
# define SIG_ATOMIC_MAX		(2147483647)

// Limit of `size_t' type.
# if __WORDSIZE == 64
#  define SIZE_MAX		(18446744073709551615UL)
# else
#  define SIZE_MAX		(4294967295U)
# endif

// Limits of `wchar_t'.
# ifndef WCHAR_MIN
// These constants might also be defined in <wchar.h>.
#  define WCHAR_MIN		__WCHAR_MIN
#  define WCHAR_MAX		__WCHAR_MAX
# endif

// Limits of `wint_t'.
# define WINT_MIN		(0u)
# define WINT_MAX		(4294967295u)

#endif	// C++ && limit macros

// The ISO C99 standard specifies that in C++ implementations these
// should only be defined if explicitly requested.
#if !defined __cplusplus || defined __STDC_CONSTANT_MACROS

// Signed.
# define INT8_C(c)	c
# define INT16_C(c)	c
# define INT32_C(c)	c
# if __WORDSIZE == 64
#  define INT64_C(c)	c ## L
# else
#  define INT64_C(c)	c ## LL
# endif

// Unsigned.
# define UINT8_C(c)	c
# define UINT16_C(c)	c
# define UINT32_C(c)	c ## U
# if __WORDSIZE == 64
#  define UINT64_C(c)	c ## UL
# else
#  define UINT64_C(c)	c ## ULL
# endif

// Maximal type.
# if __WORDSIZE == 64
#  define INTMAX_C(c)	c ## L
#  define UINTMAX_C(c)	c ## UL
# else
#  define INTMAX_C(c)	c ## LL
#  define UINTMAX_C(c)	c ## ULL
# endif

#endif	// C++ && constant macros

//--------------------------------------------------------------------------------
namespace nsWin32
{
	//--------------------------------------------------------------------------------
	enum
	{
		RuntimeBinding_Lazy = 0x0001,	//Lazy function call binding
		RuntimeBinding_Now = 0x0002,	//Immediate function call binding
		RuntimeBinding_Global = 0x0100,	//If this bit is set in the MODE argument to dlopen	the symbols of the loaded object will be as if they were linked directly
		RuntimeBinding_Local = 0x0000,	//Opposite of RTLD_GLOBAL. This should be the defualt hence 0
	};

	typedef int errno_t;
	typedef Cmp_unsigned__int64 blkcnt_t;
	typedef unsigned long blksize_t;
	typedef unsigned int dev_t;
	typedef unsigned int nlink_t;
	typedef unsigned int _dev_t;
	typedef unsigned short ino_t;
	typedef Cmp_long_long id_t;	//[XSI]  Used as a general identifier; can be used to contain at least a pid_t, uid_t, or gid_t.
	typedef Cmp_unsigned__int64 fsblkcnt_t; //[XSI]  Used for file system block counts.  
	typedef unsigned long fsfilcnt_t;
	typedef int BOOL;

	//TOOD: work out what these really should be
	typedef unsigned int trace_event_id_t;
	typedef unsigned int trace_event_set_t;
	typedef unsigned int trace_id_t;
	typedef unsigned int useconds_t;
	typedef int	pid_t;

	typedef Cmp_unsigned__int32 uid_t;
	typedef Cmp_unsigned__int32 gid_t;					// Used for group IDs.

	typedef int             errno_t;
	typedef Cmp__int3264    ptrdiff_t;
	typedef Cmp__int3264    intptr_t;
	typedef long			off_t;

	typedef signed char			int8_t;
	typedef short int			int16_t;
	typedef int					int32_t;
	typedef Cmp_signed__int64	int64_t;

	// Unsigned.
	typedef unsigned char		uint8_t;
	typedef unsigned short int	uint16_t;
	typedef unsigned int		uint32_t;
	typedef Cmp_unsigned__int64	uint64_t;

	// Signed.
	typedef signed char			int_least8_t;
	typedef short int			int_least16_t;
	typedef int					int_least32_t;
	typedef Cmp__int64			int_least64_t;

	// Unsigned.
	typedef unsigned char		uint_least8_t;
	typedef unsigned short int	uint_least16_t;
	typedef unsigned int		uint_least32_t;
	typedef Cmp_unsigned__int64	uint_least64_t;

	// Fast types.

	// Signed.
	typedef signed char			int_fast8_t;
	typedef short				int_fast16_t;
	typedef int					int_fast32_t;
	typedef Cmp__int64			int_fast64_t;

	// Unsigned.
	typedef unsigned char		uint_fast8_t;
	typedef unsigned short		uint_fast16_t;
	typedef unsigned int		uint_fast32_t;
	typedef Cmp_unsigned__int64	uint_fast64_t;

	//typedef Cmp_int_ptr			intptr_t;
	typedef Cmp_uint_ptr		uintptr_t;

	// Largest integral types.
	typedef Cmp_long_long			intmax_t;
	typedef Cmp_unsigned_long_long	uintmax_t;

	typedef uint16_t in_port_t;
	typedef uint32_t in_addr_t;
	typedef unsigned long sa_family_t;

	//--------------------------------------------------------------------------------
	struct group
	{
		char*   gr_name;        // [XBD] group name
		char*   gr_passwd;      // [???] group password
		gid_t	gr_gid;         // [XBD] group id
		char**  gr_mem;         // [XBD] group members
	};

	//--------------------------------------------------------------------------------
	struct if_nameindex
	{
		unsigned if_index;//Numeric index of the interface
		char* if_name;//Null-terminated name of the interface
	};

	//--------------------------------------------------------------------------------
	typedef struct in_addr
	{
		union
		{
			struct
			{
				unsigned char s_b1, s_b2, s_b3, s_b4;
			} S_un_b;
			struct
			{
				unsigned short s_w1, s_w2;
			} S_un_w;
			unsigned long S_addr;
		} S_un;
		/*
		#	define s_addr  S_un.S_addr // can be used for most tcp & ip code
		#	define s_host  S_un.S_un_b.s_b2    // host on imp
		#	define s_net   S_un.S_un_b.s_b1    // network
		#	define s_imp   S_un.S_un_w.s_w2    // imp
		#	define s_impno S_un.S_un_b.s_b4    // imp #
		#	define s_lh    S_un.S_un_b.s_b3    // logical host
		*/
	} IN_ADDR, *PIN_ADDR, *LPIN_ADDR;

	//--------------------------------------------------------------------------------
	struct sockaddr_in
	{
		sa_family_t     sin_family;   //AF_INET. 
		in_port_t       sin_port;     //Port number. 
		in_addr			sin_addr;     //IP address. 
	};

	//--------------------------------------------------------------------------------
#ifdef s6_addr
#	undef s6_addr
#endif

	struct in6_addr
	{
		uint8_t s6_addr[ 16 ];
	};

	//--------------------------------------------------------------------------------
	struct sockaddr_in6
	{
		sa_family_t      sin6_family;    //AF_INET6. 
		in_port_t        sin6_port;      //Port number. 
		uint32_t         sin6_flowinfo;  //IPv6 traffic class and flow information. 
		in6_addr		 sin6_addr;      //IPv6 address. 
		uint32_t         sin6_scope_id;  //Set of interfaces for a scope. 
	};

	//--------------------------------------------------------------------------------
	struct ipv6_mreq
	{
		in6_addr ipv6mr_multiaddr;	//IPv6 multicast address. 
		unsigned ipv6mr_interface;	//Interface index. 
	};

	// Define offsetof macro 
#ifdef __cplusplus
#	ifdef _WIN64
#		define offsetof(s,m)   (size_t)( (ptrdiff_t)&reinterpret_cast<const volatile char&>((((s *)0)->m)) )
#	else
#		define offsetof(s,m)   (size_t)&reinterpret_cast<const volatile char&>((((s *)0)->m))
#	endif
#else
#	ifdef _WIN64
#		define offsetof(s,m)   (size_t)( (ptrdiff_t)&(((s *)0)->m) )
#	else
#		define offsetof(s,m)   (size_t)&(((s *)0)->m)
#	endif
#endif

#if (!__QCMP_FEATURE_PREDEFINESSIZE_T)
	typedef unsigned int size_t;
#endif

	typedef signed long ssize_t;
	typedef int key_t; //[XSI]  Used for XSI interprocess communication.
	typedef int mode_t;

	//--------------------------------------------------------------------------------
	struct ipc_perm
	{
		uid_t uid;      //Owner's user ID
		gid_t gid;      //Owner's group ID
		uid_t cuid;     //Creator's user ID
		gid_t cgid;     //Creator's group ID
		mode_t mode;    //Read/write permission
	};

	//--------------------------------------------------------------------------------
	struct posix_typed_mem_info
	{
		size_t posix_tmi_length;    //Maximum length which may be allocated from a types memory object
	};

	typedef long clock_t;

	//--------------------------------------------------------------------------------
	struct tms
	{
		clock_t  tms_utime;		//User CPU time. 
		clock_t  tms_stime;		//System CPU time. 
		clock_t  tms_cutime;	//User CPU time of terminated child processes. 
		clock_t  tms_cstime;	//System CPU time of terminated child processes. 
	};

	typedef long timer_t;
	typedef unsigned long suseconds_t;
	typedef int errno_t;
	typedef unsigned long clockid_t;

#if !defined (_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else  /* !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300 */
#define _W64
#endif  /* !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300 */
#endif  /* !defined (_W64) */

	typedef long __time32_t;   /* 32-bit time value */
	typedef Cmp_signed__int64 __time64_t;     /* 64-bit time value */

#ifdef _USE_32BIT_TIME_T
	typedef __time32_t time_t;      /* time value */
#else  /* _USE_32BIT_TIME_T */
	typedef __time64_t time_t;      /* time value */
#endif  /* _USE_32BIT_TIME_T */

	//--------------------------------------------------------------------------------
	struct timespec
	{
		time_t  tv_sec;   // Seconds
		long    tv_nsec;  // Nanoseconds
	};

	//--------------------------------------------------------------------------------
	struct itimerspec
	{
		timespec it_interval;
		timespec it_value;
	};

	//--------------------------------------------------------------------------------
	struct timeval
	{
		long tv_sec;
		long tv_usec;
	};

	//--------------------------------------------------------------------------------
	struct itimerval
	{
		timeval it_interval;	//Timer interval. 
		timeval it_value;		//Current value. 
	};

	//--------------------------------------------------------------------------------
	struct __timeb32
	{
		__time32_t time;
		unsigned short millitm;
		short timezone;
		short dstflag;
	};

	//--------------------------------------------------------------------------------
	struct timeb
	{
		time_t time;
		unsigned short millitm;
		short timezone;
		short dstflag;
	};

	//--------------------------------------------------------------------------------
	struct __timeb64
	{
		__time64_t time;
		unsigned short millitm;
		short timezone;
		short dstflag;
	};

#if	( !__QCMP_FEATURE_PREDEFINESSIZE_T )

#	ifdef _WIN64
	typedef Cmp_unsigned__int64    size_t;
#	else
	typedef _W64 unsigned int   size_t;
#	endif
#endif

	//--------------------------------------------------------------------------------
	struct tm
	{
		int tm_sec;     /* seconds after the minute - [0,59] */
		int tm_min;     /* minutes after the hour - [0,59] */
		int tm_hour;    /* hours since midnight - [0,23] */
		int tm_mday;    /* day of the month - [1,31] */
		int tm_mon;     /* months since January - [0,11] */
		int tm_year;    /* years since 1900 */
		int tm_wday;    /* days since Sunday - [0,6] */
		int tm_yday;    /* days since January 1 - [0,365] */
		int tm_isdst;   /* daylight savings time flag */
	};

	// Clock ticks macro - ANSI version
	__QCMP_STATIC_CONSTANT( int, ClocksPerSecond = 1000 );

	__QCMP_STATIC_CONSTANT( int, ITimerReal = 0 );			//Decrements in real time. 
	__QCMP_STATIC_CONSTANT( int, ITimerVirtual = 1 );			//Decrements in process virtual time. 
	__QCMP_STATIC_CONSTANT( int, ITimerProf = 2 );			//Decrements both in process virtual time and when the system is running on behalf of the process. 

															//--------------------------------------------------------------------------------
	struct _utimbuf
	{
		time_t actime;          /* access time */
		time_t modtime;         /* modification time */
	};

	//--------------------------------------------------------------------------------
	struct __utimbuf32
	{
		__time32_t actime;      // access time
		__time32_t modtime;     // modification time
	};

	//--------------------------------------------------------------------------------
	struct __utimbuf64
	{
		__time64_t actime;      // access time
		__time64_t modtime;     // modification time
	};

	__QCMP_INIT_STATIC( void*, MapFailed = (void*)( -1 ) );

	__QCMP_STATIC_CONSTANT( int, MapFixed = 0x00000001 );		//Interpret addr exactly. 
	__QCMP_STATIC_CONSTANT( int, MapPrivate = 0x00000002 );		//Changes are private. 
	__QCMP_STATIC_CONSTANT( int, MapShared = 0x00000004 );		//Share changes. 

	__QCMP_STATIC_CONSTANT( int, ProtectionExecutable = 1 );		//Page can be executed. 
	__QCMP_STATIC_CONSTANT( int, ProtectionNone = 2 );		//Page cannot be accessed. 
	__QCMP_STATIC_CONSTANT( int, ProtectionRead = 3 );		//Page can be read. 
	__QCMP_STATIC_CONSTANT( int, ProtectionWrite = 4 );		//Page can be written. 

	typedef unsigned int msgqnum_t;
	typedef unsigned int msglen_t;

	//--------------------------------------------------------------------------------
	struct msqid_ds
	{
		ipc_perm msg_perm;      //Operation permission structure
		msgqnum_t msg_qnum;     //Number of messages currently on queue
		msglen_t msg_qbytes;    //Maximum number of bytes allowed on queue
		pid_t msg_lspid;        //Process ID of last msgsnd
		pid_t msg_lrpid;        //Process ID of last msgrcv
		time_t msg_stime;       //Time of last msgsnd
		time_t msg_rtime;       //Time of last msgrcv
		time_t msg_ctime;       //Time of last change
	};

	typedef unsigned long rlim_t;

	//--------------------------------------------------------------------------------
	struct rlimit
	{
		rlim_t rlim_cur;    //The current (soft) limit
		rlim_t rlim_max;    //The hard limit
	};

	//--------------------------------------------------------------------------------
	struct rusage
	{
		timeval ru_utime;   //User time used
		timeval ru_stime;   //System time used
	};

	__QCMP_STATIC_CONSTANT( int, RLimitCore = 1 );		//Limit on size of core file. 
	__QCMP_STATIC_CONSTANT( int, RLimitCPU = 2 );		//Limit on CPU time per process. 
	__QCMP_STATIC_CONSTANT( int, RLimitData = 3 );		//Limit on data segment size. 
	__QCMP_STATIC_CONSTANT( int, RLimitFSize = 4 );		//Limit on file size. 
	__QCMP_STATIC_CONSTANT( int, RLimitNOFile = 5 );		//Limit on number of open files. 
	__QCMP_STATIC_CONSTANT( int, RLimitStack = 6 );		//Limit on stack size. 
	__QCMP_STATIC_CONSTANT( int, RLimitAddessSpace = 7 );		//Limit on address space size. 
	__QCMP_STATIC_CONSTANT( int, RLimInfinity = 8 );		//A value of rlim_t indicating no limit. 
	__QCMP_STATIC_CONSTANT( int, RLimSavedMax = 9 );		//A value of type rlim_t indicating an unrepresentable saved hard limit. 
	__QCMP_STATIC_CONSTANT( int, RLimSavedCur = 10 );		//A value of type rlim_t indicating an unrepresentable saved soft limit. 

	//--------------------------------------------------------------------------------
	struct fd_set
	{
		unsigned int  fd_count;
		Cmp_uint_ptr fd_array[ 64 ];
	};

	//--------------------------------------------------------------------------------
	struct semid_ds
	{
		ipc_perm sem_perm;			//Operation permission structure
		unsigned short sem_nsems;   //Number of semaphores in set
		time_t sem_otime;           //Last semop() time
		time_t sem_ctime;           //Last time changed by semctl()
	};

	//--------------------------------------------------------------------------------
	struct _semaphore
	{
		unsigned short semval;  //Semaphore value
		pid_t sempid;           //Process ID of last operation
		unsigned short semcnt;  //Number of processes waiting for semval to become greater than current value
		unsigned short semzcnt; //Number of processed waiting for semval to become 0
	};

	//--------------------------------------------------------------------------------
	struct sembuf
	{
		unsigned short sem_num; //Semaphore number
		short sem_op;           //Semaphore operation
		short sem_flg;          //Operation flags
	};

	typedef unsigned long shmatt_t;

	//--------------------------------------------------------------------------------
	struct shmid_ds
	{
		ipc_perm shm_perm;		//Operation permission structure. 
		size_t shm_segsz;		//Size of segment in bytes. 
		pid_t shm_lpid;			//Process ID of last shared memory operation. 
		pid_t shm_cpid;			//Process ID of creator. 
		shmatt_t shm_nattch;	//Number of current attaches. 
		time_t shm_atime;		//Time of last shmat(). 
		time_t shm_dtime;		//Time of last shmdt(). 
		time_t shm_ctime;		//Time of last change by shmctl(). 
	};

	__QCMP_STATIC_CONSTANT( unsigned short, S_IFmt = 0xF000 );	//[XSI]  Type of file. 
	__QCMP_STATIC_CONSTANT( unsigned short, S_IFBlk = 0xFFFF );	//Block special. 
	__QCMP_STATIC_CONSTANT( unsigned short, S_IFChr = 0x2000 );	//Character special. 
	__QCMP_STATIC_CONSTANT( unsigned short, S_IFifo = 0x1000 );	//FIFO special. 
	__QCMP_STATIC_CONSTANT( unsigned short, S_IFReg = 0x8000 );	//Regular. 
	__QCMP_STATIC_CONSTANT( unsigned short, S_IFDir = 0x4000 );	//Directory. 
	__QCMP_STATIC_CONSTANT( unsigned short, S_IFLnk = 0xFFFF );	//Symbolic link. 
	__QCMP_STATIC_CONSTANT( unsigned short, S_IFSock = 0xFFFF );	//Socket
	__QCMP_STATIC_CONSTANT( unsigned short, S_IExec = 0x0040 );
	__QCMP_STATIC_CONSTANT( unsigned short, S_IRead = 0x0100 );	// read permission, owner
	__QCMP_STATIC_CONSTANT( unsigned short, S_IWrite = 0x0080 );	// write permission, owner

	//--------------------------------------------------------------------------------
	typedef enum
	{
		P_ALL,
		P_PID,
		P_PGID
	} idtype_t;

	//--------------------------------------------------------------------------------
	struct utsname
	{
		char*	sysname;		//Name of this implementation of the operating system. 
		char*	nodename;		//Name of this node within the communications network to which this node is attached, if any. 
		char*	release;		//Current release level of this implementation. 
		char*	version;		//Current version level of this release. 
		char*	machine;		//Name of the hardware type on which the system is running.
	};

	//--------------------------------------------------------------------------------
	struct sockaddr_un
	{
		unsigned long sun_family;		//Address family. 
		char sun_path[ 1 ];			//Socket pathname. 
	};

	//--------------------------------------------------------------------------------
	struct iovec
	{
		void* iov_base;		//Base address of a memory region for input or output. 
		size_t iov_len;		//The size of the memory pointed to by iov_base. 
	};

	//--------------------------------------------------------------------------------
	struct statvfs
	{
		unsigned long f_bsize;    //File system block size. 
		unsigned long f_frsize;   //Fundamental file system block size. 
		fsblkcnt_t    f_blocks;   //Total number of blocks on file system in units of f_frsize. 
		fsblkcnt_t    f_bfree;    //Total number of free blocks. 
		fsblkcnt_t    f_bavail;   //Number of free blocks available to non-privileged process. 
		fsfilcnt_t    f_files;    //Total number of file serial numbers. 
		fsfilcnt_t    f_ffree;    //Total number of free file serial numbers. 
		fsfilcnt_t    f_favail;   //Number of file serial numbers available to non-privileged process. 
		unsigned long f_fsid;     //File system ID. 
		unsigned long f_flag;     //Bit mask of f_flag values. 
		unsigned long f_namemax;  //Maximum filename length. 
	};

	__QCMP_STATIC_CONSTANT( int, STReadOnly = 1 );
	__QCMP_STATIC_CONSTANT( int, STNoSUID = 2 );

	/*
	//Address families.
	#define AF_UNSPEC       0               // unspecified
	#define AF_UNIX         1               // local to host (pipes, portals)
	#define AF_INET         2               // internetwork: UDP, TCP, etc.
	#define AF_IMPLINK      3               // arpanet imp addresses
	#define AF_PUP          4               // pup protocols: e.g. BSP
	#define AF_CHAOS        5               // mit CHAOS protocols
	#define AF_IPX          6               // IPX and SPX
	#define AF_NS           6               // XEROX NS protocols
	#define AF_ISO          7               // ISO protocols
	#define AF_OSI          AF_ISO          // OSI is ISO
	#define AF_ECMA         8               // european computer manufacturers
	#define AF_DATAKIT      9               // datakit protocols
	#define AF_CCITT        10              // CCITT protocols, X.25 etc
	#define AF_SNA          11              // IBM SNA
	#define AF_DECnet       12              // DECnet
	#define AF_DLI          13              // Direct data link interface
	#define AF_LAT          14              // LAT
	#define AF_HYLINK       15              // NSC Hyperchannel
	#define AF_APPLETALK    16              // AppleTalk
	#define AF_NETBIOS      17              // NetBios-style addresses
	#define AF_VOICEVIEW    18              // VoiceView
	#define AF_FIREFOX      19              // FireFox
	#define AF_UNKNOWN1     20              // Somebody is using this!
	#define AF_BAN          21              // Banyan

	#define AF_MAX          22
	*/
	enum
	{
		AFINet = 2,
		AFUnix = 1,
		AFUnspec = 0,
		AFINet6 = 23,
	};

	//--------------------------------------------------------------------------------
	struct sockaddr
	{
		sa_family_t	sa_family;		//Address family. 
		char sa_data[ 14 ];			//Socket address (variable-length data). 
	};

	//--------------------------------------------------------------------------------
	//TODO:
	//the sockaddr_storage structure, which shall be:
	//Large enough to accommodate all supported protocol-specific address structures
	//Aligned at an appropriate boundary so that pointers to it can be cast as pointers to protocol-specific address structures and used to access the fields of those structures without alignment problems
	struct sockaddr_storage
	{
		sa_family_t ss_family;
	};


	//--------------------------------------------------------------------------------
	struct linger
	{
		int l_onoff;	//Indicates whether linger option is enabled. 
		int l_linger;	//Linger time, in seconds. 
	};

	__QCMP_STATIC_CONSTANT( int, SoLSocket = 1 );
	__QCMP_STATIC_CONSTANT( int, SCMRights = 1 );
	__QCMP_STATIC_CONSTANT( int, SockStream = 1 );
	__QCMP_STATIC_CONSTANT( int, SockDatagram = 2 );
	__QCMP_STATIC_CONSTANT( int, SockRaw = 3 );
	__QCMP_STATIC_CONSTANT( int, SockSeqPacket = 5 );

	__QCMP_STATIC_CONSTANT( int, SoAcceptConnection = 30 );				//Socket is accepting connections. 
	__QCMP_STATIC_CONSTANT( int, SoBroadcast = 6 );				//Transmission of broadcast messages is supported. 
	__QCMP_STATIC_CONSTANT( int, SoDebug = 1 );				//Debugging information is being recorded. 
	__QCMP_STATIC_CONSTANT( int, SoDontRoute = 5 );				//Bypass normal routing. 
	__QCMP_STATIC_CONSTANT( int, SoError = 4 );				//Socket error status. 
	__QCMP_STATIC_CONSTANT( int, SoKeepAlive = 9 );				//Connections are kept alive with periodic messages. 
	__QCMP_STATIC_CONSTANT( int, SoLinger = 13 );				//Socket lingers on close. 
	__QCMP_STATIC_CONSTANT( int, SoOutOfBandInline = 10 );				//Out-of-band data is transmitted in line. 
	__QCMP_STATIC_CONSTANT( int, SoRecvBuffer = 8 );				//Receive buffer size. 
	__QCMP_STATIC_CONSTANT( int, SoRecvLowWaterMark = 18 );				//Receive ``low water mark''. 
	__QCMP_STATIC_CONSTANT( int, SoRecvTimeout = 20 );				//Receive timeout. 
	__QCMP_STATIC_CONSTANT( int, SoReuseAddress = 2 );				//Reuse of local addresses is supported. 
	__QCMP_STATIC_CONSTANT( int, SoSendBuffer = 7 );				//Send buffer size. 
	__QCMP_STATIC_CONSTANT( int, SoSendLowWaterMark = 19 );				//Send ``low water mark''. 
	__QCMP_STATIC_CONSTANT( int, SoSendTimeout = 21 );				//Send timeout. 
	__QCMP_STATIC_CONSTANT( int, SoType = 3 );				//Socket type. 

	__QCMP_STATIC_CONSTANT( int, SoMaxConn = 128 );

	__QCMP_STATIC_CONSTANT( int, MsgCTrunc = 0x0008 );
	__QCMP_STATIC_CONSTANT( int, MsgDontRoute = 0x0004 );
	__QCMP_STATIC_CONSTANT( int, MsgEOR = 0x0080 );
	__QCMP_STATIC_CONSTANT( int, MsgOOB = 0x0001 );
	__QCMP_STATIC_CONSTANT( int, MsgNoSignal = 0x4000 );
	__QCMP_STATIC_CONSTANT( int, MsgPeek = 0x0002 );
	__QCMP_STATIC_CONSTANT( int, MsgTrunc = 0x0020 );
	__QCMP_STATIC_CONSTANT( int, MsgWaitAll = 0x0100 );

	__QCMP_STATIC_CONSTANT( int, ShutRead = 0 );
	__QCMP_STATIC_CONSTANT( int, ShutWrite = 1 );
	__QCMP_STATIC_CONSTANT( int, ShutReadWrite = 2 );

	typedef long socklen_t;
	typedef uint32_t in_addr_t;

	//--------------------------------------------------------------------------------
	struct msghdr
	{
		void* msg_name;			//Optional address. 
		socklen_t msg_namelen;	//Size of address. 
		iovec* msg_iov;			//Scatter/gather array. 
		int msg_iovlen;			//Members in msg_iov. 
		void* msg_control;		//Ancillary data; see below. 
		socklen_t msg_controllen; //Ancillary data buffer len. 
		int msg_flags;			//Flags on received message. 
	};

	//--------------------------------------------------------------------------------
	struct cmsghdr
	{
		socklen_t cmsg_len;		//Data byte count, including the cmsghdr. 
		int cmsg_level;			//Originating protocol. 
		int cmsg_type;			//Protocol-specific type. 
	};

	//--------------------------------------------------------------------------------
	struct wordexp_t
	{
		size_t we_wordc;    //Count of words matched
		char** we_wordv;    //Pointer to list of expanded words
		size_t we_offs;     //Slots to reserve at the beginning of we_wordv
	};

	typedef wchar_t wctrans_t;

	typedef unsigned long _fsize_t;

	typedef wchar_t wctype_t;

	__QCMP_STATIC_CONSTANT( int, WCharMin = 0 );
	__QCMP_STATIC_CONSTANT( int, WCharMax = 0xffff );

	typedef char* va_list;

	//--------------------------------------------------------------------------------
	struct _wfinddata32_t
	{
		unsigned    attrib;
		__time32_t  time_create;    /* -1 for FAT file systems */
		__time32_t  time_access;    /* -1 for FAT file systems */
		__time32_t  time_write;
		_fsize_t    size;
		wchar_t     name[ 260 ];
	};

	//--------------------------------------------------------------------------------
	struct _wfinddata32i64_t
	{
		unsigned    attrib;
		__time32_t  time_create;    /* -1 for FAT file systems */
		__time32_t  time_access;    /* -1 for FAT file systems */
		__time32_t  time_write;
		Cmp_signed__int64     size;
		wchar_t     name[ 260 ];
	};

	//--------------------------------------------------------------------------------
	struct _wfinddata64i32_t
	{
		unsigned    attrib;
		__time64_t  time_create;    /* -1 for FAT file systems */
		__time64_t  time_access;    /* -1 for FAT file systems */
		__time64_t  time_write;
		_fsize_t    size;
		wchar_t     name[ 260 ];
	};

	//--------------------------------------------------------------------------------
	struct _wfinddata64_t
	{
		unsigned    attrib;
		__time64_t  time_create;    /* -1 for FAT file systems */
		__time64_t  time_access;    /* -1 for FAT file systems */
		__time64_t  time_write;
		Cmp_signed__int64     size;
		wchar_t     name[ 260 ];
	};

#	ifdef _USE_32BIT_TIME_T
#define _wfinddata_t    _wfinddata32_t
#define _wfinddatai64_t _wfinddata32i64_t

#define _wfindfirst     _wfindfirst32
#define _wfindnext      _wfindnext32
#define _wfindfirsti64  _wfindfirst32i64
#define _wfindnexti64   _wfindnext32i64

#	else  /* _USE_32BIT_TIME_T */
#define _wfinddata_t    _wfinddata64i32_t
#define _wfinddatai64_t _wfinddata64_t

#	endif  /* _USE_32BIT_TIME_T */

	typedef int mbstate_t;
	typedef wchar_t _Wint_t;

	//--------------------------------------------------------------------------------
	struct utmpx
	{
		char* ut_user;		//User login name
		char* ut_id;		//Unspecified initialization
		char* ut_line;		//Device name
		pid_t ut_pid;		//Process ID
		short ut_type;		//Type of entry
		timeval ut_uv;		//Time entry was made
	};

	//--------------------------------------------------------------------------------
	struct utimbuf
	{
		time_t actime;      //Access time
		time_t modtime;     //Modification time
	};

	__QCMP_STATIC_CONSTANT( int, FileUnlock = 1 );
	__QCMP_STATIC_CONSTANT( int, FileLock = 2 );
	__QCMP_STATIC_CONSTANT( int, FileTryLock = 3 );
	__QCMP_STATIC_CONSTANT( int, FileTestLock = 4 );

	//--------------------------------------------------------------------------------
	enum
	{
		SCClockTick,
	};

	__QCMP_STATIC_CONSTANT( int, ULimitGetFileSize = 1 );
	__QCMP_STATIC_CONSTANT( int, ULimitSetFileSize = 2 );

	typedef unsigned int trace_attr_t;
	typedef unsigned int trace_event_id_t;
	typedef unsigned int trace_event_set_t;
	typedef unsigned int trace_id_t;

	//--------------------------------------------------------------------------------
	struct posix_trace_status_info
	{
		int	posix_stream_full_status;
		int	posix_stream_overrun_status;
		int	posix_stream_status;
		int	posix_log_full_status;
		int	posix_log_overrun_status;
		int	posix_stream_flush_error;
		int	posix_stream_flush_status;
	};

	//--------------------------------------------------------------------------------
	enum eSpeeds
	{
		B0 = 0,//Hang up 
		B50,//50 baud 
		B75,//75 baud 
		B110,//110 baud 
		B134,// 134.5 baud 
		B150,//150 baud 
		B200,// 200 baud 
		B300,//300 baud 
		B600,//600 baud 
		B1200,//1200 baud 
		B1800,//1800 baud 
		B2400,//2400 baud 
		B4800,//4800 baud 
		B9600,//9600 baud 
		B19200,//19200 baud 
		B38400,//38400 baud 
	};

	typedef int speed_t;
	typedef int tcflag_t;
	typedef unsigned char cc_t;

	__QCMP_STATIC_CONSTANT( int, nccs = 8 );

	//--------------------------------------------------------------------------------
	struct termios
	{
		tcflag_t  c_iflag;     //Input modes. 
		tcflag_t  c_oflag;     //Output modes. 
		tcflag_t  c_cflag;     //Control modes. 
		tcflag_t  c_lflag;     //Local modes. 
		cc_t      c_cc[ nccs ];  //Control characters.
	};

	__QCMP_STATIC_CONSTANT( int, TCSANow = 1 );	//Change attributes immediately. 
	__QCMP_STATIC_CONSTANT( int, TCSADrain = 2 );	//Change attributes when output has drained. 
	__QCMP_STATIC_CONSTANT( int, TCSAFlush = 3 );	//Change attributes when output has drained; also flush pending input. 

	__QCMP_STATIC_CONSTANT( int, Echo = 0x00000001 );	//Enable echo. 
	__QCMP_STATIC_CONSTANT( int, EchoE = 0x00000002 );	//Echo erase character as error-correcting backspace. 
	__QCMP_STATIC_CONSTANT( int, EchoK = 0x00000004 );	//Echo KILL. 
	__QCMP_STATIC_CONSTANT( int, EchoNL = 0x00000008 );	//Echo NL. 
	__QCMP_STATIC_CONSTANT( int, ICanon = 0x00000010 );	//Canonical input (erase and kill processing). 
	__QCMP_STATIC_CONSTANT( int, IExten = 0x00000020 );	//Enable extended input character processing. 
	__QCMP_STATIC_CONSTANT( int, ISig = 0x00000040 );	//Enable signals. 
	__QCMP_STATIC_CONSTANT( int, NoFlush = 0x00000080 );	//Disable flush after interrupt or quit. 
	__QCMP_STATIC_CONSTANT( int, ToStop = 0x00000100 );	//Send SIGTTOU for background output. 

	typedef Cmp_unsigned__int32	t_uscalar_t;
	typedef Cmp_signed__int32  t_scalar_t;

	__QCMP_STATIC_CONSTANT( int, FMNameSize = 260 );

	//--------------------------------------------------------------------------------
	struct bandinfo
	{
		int bi_flag;				//Flushing type. 
		unsigned char bi_pri;		//Priority band. 
	};

	//--------------------------------------------------------------------------------
	struct strbuf
	{
		char* buf;					//Pointer to buffer. 
		int len;					//Length of data. 
		int maxlen;					//Maximum buffer length. 
	};

	//--------------------------------------------------------------------------------
	struct strpeek
	{
		strbuf ctlbuf;				//The control portion of the message. 
		strbuf databuf;				//The data portion of the message. 
		t_uscalar_t flags;			//RS_HIPRI or 0. 
	};

	//--------------------------------------------------------------------------------
	struct strfdinsert
	{
		strbuf ctlbuf;				//The control portion of the message. 
		strbuf databuf;				//The data portion of the message. 
		int fildes;					//File descriptor of the other STREAM. 
		t_uscalar_t flags;			//RS_HIPRI or 0. 
		int offset;					//Relative location of the stored value.
	};

	//--------------------------------------------------------------------------------
	struct strioctl
	{
		int ic_cmd;					//ioctl() command. 
		char* ic_dp;				//Pointer to buffer. 
		int ic_len;					//Length of data. 
		int ic_timout;				//Timeout for response. 
	};

	//--------------------------------------------------------------------------------
	struct strrecvfd
	{
		int fd;						//Received file descriptor. 
		gid_t gid;					//GID of sender. 
		uid_t uid;					//UID of sender. 
	};

	//--------------------------------------------------------------------------------
	struct str_mlist
	{
		char l_name[ FMNameSize + 1 ];	//A STREAMS module name.
	};

	//--------------------------------------------------------------------------------
	struct str_list
	{
		str_mlist* sl_modlist;		//STREAMS module names. 
		int sl_nmods;				//Number of STREAMS module names.	
	};

#ifndef _TRUNCATE
	__QCMP_STATIC_CONSTANT( size_t, _TRUNCATE = ( (size_t)-1 ) );
	__QCMP_STATIC_CONSTANT( int, STRUNCATE = 80 );
#endif

	//TODO: move these to Compiler Types header as C++11 standard types
#if ( __QCMP_COMPILER == __QCMP_MSVC && _MSC_VER < 1900 )
	typedef unsigned short char16_t;//support this intrinsic type for clang/libc++
	typedef unsigned long char32_t;//support this intrinsic type for clang/libc++
#endif

	typedef int( __cdecl * _onexit_t )( void );

	//--------------------------------------------------------------------------------
	struct HeapInfo
	{
		int* _pentry;
		size_t _size;
		int _useflag;
	};

	typedef void( __cdecl *_PVFV )( void );
	typedef int( __cdecl *_PIFV )( void );
	typedef void( __cdecl *_PVFI )( int );

	__QCMP_STATIC_CONSTANT( int, ExitFailure = 1 );				//Unsuccessful termination for exit(); evaluates to a non-zero value. 
	__QCMP_STATIC_CONSTANT( int, ExitSuccess = 0 );				//Successful termination for exit(); evaluates to 0. 
	__QCMP_STATIC_CONSTANT( int, Null = 0 );
	__QCMP_STATIC_CONSTANT( int, RandMax = 32767 );			//Maximum value returned by rand(); at least 32767. 

															//--------------------------------------------------------------------------------
															// Data structure definitions for div and ldiv runtimes.
	typedef struct _div_t
	{
		int quot;
		int rem;
	} div_t;

	//--------------------------------------------------------------------------------
	typedef struct _ldiv_t
	{
		long quot;
		long rem;
	} ldiv_t;

	//--------------------------------------------------------------------------------
	__extension__ typedef struct
	{
		Cmp_long_long quot;		// Quotient.
		Cmp_long_long rem;		// Remainder.
	} lldiv_t;


	// Minimum and maximum macros

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))

	//
	// Sizes for buffers used by the _makepath() and _splitpath() functions.
	// note that the sizes include space for 0-terminator

	__QCMP_STATIC_CONSTANT( int, MaxPath = 260 );			//max. length of full pathname
	__QCMP_STATIC_CONSTANT( int, MaxDrive = 3 );			//max. length of drive component
	__QCMP_STATIC_CONSTANT( int, MaxDir = 256 );			//max. length of path component
	__QCMP_STATIC_CONSTANT( int, MaxFName = 256 );			//max. length of file name component
	__QCMP_STATIC_CONSTANT( int, MaxExt = 256 );			//max. length of extension component */

	__QCMP_STATIC_CONSTANT( int, WaitUntraced = 1 );
	__QCMP_STATIC_CONSTANT( int, WaitNoHang = 2 );

	//--------------------------------------------------------------------------------
	struct _finddata32_t
	{
		unsigned    attrib;
		__time32_t  time_create;    // -1 for FAT file systems
		__time32_t  time_access;    // -1 for FAT file systems
		__time32_t  time_write;
		unsigned long    size;
		char        name[ 260 ];
	};

	//--------------------------------------------------------------------------------
	struct _finddata32i64_t
	{
		unsigned    attrib;
		__time32_t  time_create;    // -1 for FAT file systems
		__time32_t  time_access;    // -1 for FAT file systems
		__time32_t  time_write;
		Cmp__int64     size;
		char        name[ 260 ];
	};

	//--------------------------------------------------------------------------------
	struct _finddata64i32_t
	{
		unsigned    attrib;
		__time64_t  time_create;    // -1 for FAT file systems
		__time64_t  time_access;    // -1 for FAT file systems
		__time64_t  time_write;
		unsigned long    size;
		char        name[ 260 ];
	};

	//--------------------------------------------------------------------------------
	struct __finddata64_t
	{
		unsigned    attrib;
		__time64_t  time_create;    // -1 for FAT file systems
		__time64_t  time_access;    // -1 for FAT file systems
		__time64_t  time_write;
		Cmp__int64     size;
		char        name[ 260 ];
	};

#ifdef _USE_32BIT_TIME_T
#	define _finddata_t     _finddata32_t
#	define _finddatai64_t  _finddata32i64_t
#else
#	define _finddata_t     _finddata64i32_t
#	define _finddatai64_t  __finddata64_t
#endif

	static const int sc_BufferSize = 1024;
	static const int sc_IOFullyBuffered = 0;
	static const int sc_IOLineBuffered = 1;
	static const int sc_IOUnbuffered = 2;
	static const int sc_MaxLength_ctermid = 255;
	static const int sc_MaxLength_tmpnam = 512;
	static const int sc_Seek_Cur = 0;//Seek relative to current position
	static const int sc_Seek_End = 1;//Seek relative to end-of-file
	static const int sc_Seek_Set = 2;//Seek relative to start-of-file
	static const int sc_EndOfFile = -1;//EOF
	static const char* sc_TempDirPrefix = "/tmp";
	static const int sc_MaxNumber_UniqueTempNames = 10000;

	typedef long off_t;

	struct _iobuf
	{
		char* _ptr;
		int   _cnt;
		char* _base;
		int   _flag;
		int   _file;
		int   _charbuf;
		int   _bufsiz;
		char* _tmpfname;
	};
	typedef struct _iobuf FILE;

	// Directory where temporary files may be created.

#define _P_tmpdir   "\\"
#define _wP_tmpdir  L"\\"

	//#define FILENAME_MAX    260
	//#define FOPEN_MAX       20
#define _SYS_OPEN       20


	// Define file position type
	typedef Cmp_long_long fpos_t;
#define _FPOSOFF(fp) ((long)(fp))

#define _IOREAD         0x0001
#define _IOWRT          0x0002

#define _IOMYBUF        0x0008
#define _IOEOF          0x0010
#define _IOERR          0x0020
#define _IOSTRG         0x0040
#define _IORW           0x0080

	// constants used by _set_output_format
#define _TWO_DIGIT_EXPONENT 0x1

#ifndef __cplusplus
#  define bool _Bool
#  define true 1
#  define false 0
#  define __bool_true_false_are_defined 1
#endif


	typedef char*  va_list;
#define _VA_LIST_DEFINED

#ifndef _ADDRESSOF
#ifdef  __cplusplus
#define _ADDRESSOF(v)   ( &reinterpret_cast<char const &>(v) )
#else
#define _ADDRESSOF(v)   ( &(v) )
#endif
#endif

#if	defined(_M_IA64)
#define _VA_ALIGN       8
#define _SLOTSIZEOF(t)   ( (sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1) )

#define _VA_STRUCT_ALIGN  16 

#define _ALIGNOF(ap) ((((ap)+_VA_STRUCT_ALIGN - 1) & ~(_VA_STRUCT_ALIGN -1)) - (ap))
#define _APALIGN(t,ap)  (__alignof(t) > 8 ? _ALIGNOF((uintptr_t) ap) : 0)

#else
#define _SLOTSIZEOF(t)   (sizeof(t))
#ifndef _APALIGN
#define _APALIGN(t,ap)  (__builtin_alignof(t))
#endif
#endif

#if defined(_M_IX86)

#	define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
#	define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#	define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#	define va_end(ap)      ( ap = (va_list)0 )
#	define va_copy( dest, src) ( dest = src )

#elif defined(_M_X64)

#define va_start(ap, x) ( __va_start(&ap, x) )
#define va_arg(ap, t)   \
    ( ( sizeof(t) > sizeof(__int64) || ( sizeof(t) & (sizeof(t) - 1) ) != 0 ) \
        ? **(t **)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) \
        :  *(t  *)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) )
#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_IA64)

#ifdef  __cplusplus	
#define va_start(ap,v)  ( __va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), _ADDRESSOF(v)) )
#else
#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _SLOTSIZEOF(v) )
#endif

#define va_arg(ap,t)    (*(t *)((ap += _SLOTSIZEOF(t)+ _APALIGN(t,ap)) -_SLOTSIZEOF(t)))
#define va_end(ap)      ( ap = (va_list)0 )

#endif

	typedef int posix_spawnattr_t;
	typedef int posix_spawn_file_actions_t;

	__QCMP_STATIC_CONSTANT( int, PosixSpawnResetIDs = 0x00000001 );
	__QCMP_STATIC_CONSTANT( int, PosixSpawnSetPGroup = 0x00000002 );
	__QCMP_STATIC_CONSTANT( int, PosixSpawnSetSchedParam = 0x00000004 );
	__QCMP_STATIC_CONSTANT( int, PosixSpawnSetScheduler = 0x00000008 );
	__QCMP_STATIC_CONSTANT( int, PosixSpawnSetSigDef = 0x00000010 );
	__QCMP_STATIC_CONSTANT( int, PosixSpawnSetSigMask = 0x00000020 );

	struct pthread_attr_t;

	typedef int sig_atomic_t;
	typedef Cmp_unsigned__int64 sigset_t;
	typedef void( __cdecl* psig_func )( int );

	//--------------------------------------------------------------------------------
	union sigval
	{
		int sival_int;
		void* sival_ptr;
	};

	//--------------------------------------------------------------------------------
	struct sigevent
	{
		int sigev_notify;
		int sigev_signo;
		union sigval sigev_value;
		void( *sigev_notify_function )( union sigval );
		pthread_attr_t* sigev_notify_attributes;

	};

	//--------------------------------------------------------------------------------
	struct siginfo_t
	{
		int si_signo;
		int si_code;
		int si_errno;
		int si_pid;
		uid_t si_uid;
		void* si_addr;
		int si_status;
		long si_band;
		sigval si_value;
	};

	__QCMP_STATIC_CONSTANT( int, SigRTMin = 0 );
	__QCMP_STATIC_CONSTANT( int, SigRTMax = 0 );

#   define NSIG 23			// maximum signal number + 1

	__QCMP_STATIC_CONSTANT( int, SigSys = 0 );		// Bad system call. 
	__QCMP_STATIC_CONSTANT( int, SigBus = 0 );		// Access to an undefined portion of a memory object.	
	__QCMP_STATIC_CONSTANT( int, SigHangup = 1 );		// Hangup.
	__QCMP_STATIC_CONSTANT( int, SigInterrupt = 2 );		//Terminal interrupt signal. (ANSI).
	__QCMP_STATIC_CONSTANT( int, SigQuit = 3 );		//Terminal quit signal.
	__QCMP_STATIC_CONSTANT( int, SigIllegal = 4 );		//Illegal instruction. 
	__QCMP_STATIC_CONSTANT( int, SigTrap = 5 );		// Trace/breakpoint trap. 
	__QCMP_STATIC_CONSTANT( int, SigAbort = 6 );		//Abort (ANSI).
														//#define SIGEMT		7	/* EMT instruction.  */	
	__QCMP_STATIC_CONSTANT( int, SigFloatingPoint = 8 );		// Erroneous arithmetic operation. 
	__QCMP_STATIC_CONSTANT( int, SigKill = 9 );		//Kill (cannot be caught or ignored).
													//#define	SIGBUS		10	/* BUS error (4.2 BSD).  */
	__QCMP_STATIC_CONSTANT( int, SigSegV = 11 );		//Segmentation violation (ANSI).  
														//#define SIGSYS		12	/* Bad system call.  */
	__QCMP_STATIC_CONSTANT( int, SigPipe = 13 );		// Write on a pipe with no one to read it.
	__QCMP_STATIC_CONSTANT( int, SigAlarm = 14 );		//Alarm clock (POSIX).		
	__QCMP_STATIC_CONSTANT( int, SigTerm = 15 );		// Termination signal.
	__QCMP_STATIC_CONSTANT( int, SigUrg = 16 );		//Urgent condition on socket (4.2 BSD).
	__QCMP_STATIC_CONSTANT( int, SigStop = 17 );		// Stop executing (cannot be caught or ignored).
	__QCMP_STATIC_CONSTANT( int, SigTermStop = 18 );		// Terminal stop signal.
	__QCMP_STATIC_CONSTANT( int, SigContinue = 19 );		// Continue executing, if stopped.	
	__QCMP_STATIC_CONSTANT( int, SigChild = 20 );		// Child process terminated, stopped, [XSI] or continued. 
	__QCMP_STATIC_CONSTANT( int, SigTTIN = 21 );		// Background process attempting read.	
	__QCMP_STATIC_CONSTANT( int, SigTTOU = 22 );		// Background process attempting write.
														//#define	SIGIO		23	/* I/O now possible (4.2 BSD).  */
	__QCMP_STATIC_CONSTANT( int, SigPoll = 23 );		// Pollable event.  
	__QCMP_STATIC_CONSTANT( int, SigXCPU = 24 );		//CPU limit exceeded (4.2 BSD).
	__QCMP_STATIC_CONSTANT( int, SigXFSz = 25 );		//File size limit exceeded (4.2 BSD).
														//#define SIGMSG		27	/* Input data is in the ring buffer.  */
	__QCMP_STATIC_CONSTANT( int, SigUsr1 = 30 );		// User-defined signal 1.
	__QCMP_STATIC_CONSTANT( int, SigUsr2 = 31 );		// User-defined signal 2. 	
	__QCMP_STATIC_CONSTANT( int, SigProf = 32 );		// Profiling timer expired.  

	__QCMP_STATIC_CONSTANT( int, SigVTAlarm = 34 );		// Virtual timer expired.


														//#define SIGIOT		SIGABRT	/* Abort (terminal) process.  */
														//#define SIGIOINT	SIGURG	/* Printer to backend error signal.  */
														//#define	SIGCLD		SIGCHLD	/* Same as SIGCHLD (System V).  */


														//#define SIGAIO		SIGIO	/* Base LAN I/O.  */
														//#define SIGPTY		SIGIO	/* PTY I/O.  */

														//#define	SIGWINCH	28	/* Window size change (4.3 BSD, Sun).  */
														//#define	SIGPWR		29	/* Power failure restart (System V).  */
														//#define SIGDANGER	33	/* System crash imminent.  */

														//#define SIGMIGRATE	35	/* Migrate process.  */
														//#define SIGPRE		36	/* Programming exception.  */
														//#define SIGVIRT		37	/* AIX virtual time alarm.  */
														//#define SIGARLM1	38	/* Reserved, don't use.  */
														//#define SIGWAITING	39	/* Reserved, don't use.  */
														//#define SIGCPUFAIL	59	/* Predictive de-configuration of processors.*/
														//#define SIGKAP		60	/* Keep alive poll from native keyboard.  */
														//#define SIGGRANT	SIGKAP	/* Monitor mode granted.  */
														//#define SIGRETRACT	61	/* Monitor mode should be relinguished.  */
														//#define SIGSOUND	62	/* Sound control has completed.  */
														//#define SIGSAK		63	/* Secure attentation key.  */
														//#define	_NSIG		64	/* Biggest signal number + 1
														//				   (including real-time signals).  */

	__QCMP_STATIC_CONSTANT( int, MinSigStackSize = 2048 );
	__QCMP_STATIC_CONSTANT( int, SigStackSize = 8192 );
	__QCMP_STATIC_CONSTANT( int, SASigInfo = 4 );	//Should be determined by ArchQOR?
													// Signal types
													/*
													#   define SIGINT          2       // interrupt
													#   define SIGILL          4       // illegal instruction - invalid function image
													#   define SIGFPE          8       // floating point exception
													#   define SIGSEGV         11      // segment violation
													#   define SIGTERM         15      // Software termination signal from kill
													#   define SIGBREAK        21      // Ctrl-Break sequence
													#   define SIGABRT         22      // abnormal termination triggered by abort call
													*/
#   define SIGABRT_COMPAT  6       /* SIGABRT compatible with other platforms, same as SIGABRT */

	typedef void( __cdecl* fpSig )( int );
	// signal action codes
	static fpSig SigDfl = ( void( __cdecl * )( int ) )0;	// default signal action
	static fpSig SigIgn = ( void( __cdecl * )( int ) )1;	// ignore signal
	static fpSig SigGet = ( void( __cdecl * )( int ) )2;	// return current value
	static fpSig SigSGE = ( void( __cdecl * )( int ) )3;	// signal gets error
	static fpSig SigAck = ( void( __cdecl * )( int ) )4;	// acknowledge

															/* internal use only! not valid as an argument to signal() */
															//#   define SIG_DIE (void (__cdecl *)(int))5           /* terminate process */	

															/* signal error value (returned by signal call on error) */
	static fpSig SigErr = ( void( __cdecl * )( int ) ) - 1;	//signal error value


	__QCMP_STATIC_CONSTANT( unsigned int, SAOnStack = 0x08000000 );

	__QCMP_STATIC_CONSTANT( int, SSOnStack = 1 );
	__QCMP_STATIC_CONSTANT( int, SSDisable = 2 );
	

#   define _pxcptinfoptrs  (*__pxcptinfoptrs())

	//--------------------------------------------------------------------------------
	struct sigaction
	{
		void( *sa_handler )( int );		//Pointer to a signal-catching function or one of the SIG_IGN or SIG_DFL. 
		sigset_t sa_mask;					//Set of signals to be blocked during execution of the signal handling function. 
		int sa_flags;						//Special flags. 
		void( *sa_sigaction )( int, siginfo_t*, void * );	//Pointer to a signal-catching function. 
	};

	//--------------------------------------------------------------------------------
	struct mcontext_t
	{
		int iDummy;				//TODO:
	};

	//--------------------------------------------------------------------------------
	struct stack_t
	{
		void* ss_sp;
		int ss_flags;
		size_t ss_size;
	};

	//--------------------------------------------------------------------------------
	struct ucontext_t
	{
		ucontext_t* uc_link;     //Pointer to the context that is resumed when this context returns. 
		sigset_t    uc_sigmask;  //The set of signals that are blocked when this context is active. 
		stack_t     uc_stack;    //The stack used by this context. 
		mcontext_t  uc_mcontext; //A machine-specific representation of the saved context. 
	};


	//Definitions specific to particular setjmp implementations.

#if defined (_M_IX86)

#	define _JBLEN  16
#	define _JBTYPE int

	//--------------------------------------------------------------------------------
	//Define jump buffer layout for x86 setjmp/longjmp.
	typedef struct __JUMP_BUFFER
	{
		unsigned long Ebp;
		unsigned long Ebx;
		unsigned long Edi;
		unsigned long Esi;
		unsigned long Esp;
		unsigned long Eip;
		unsigned long Registration;
		unsigned long TryLevel;
		unsigned long Cookie;
		unsigned long UnwindFunc;
		unsigned long UnwindData[ 6 ];
	} _JUMP_BUFFER;

#ifndef _INTERNAL_IFSTRIP_
	__QCMP_LINKAGE_C void __stdcall _NLG_Notify( unsigned long );
	__QCMP_LINKAGE_C void __stdcall _NLG_Return();
#endif  /* _INTERNAL_IFSTRIP_ */

#elif defined (_M_IA64)

	// Minimum length is 528 bytes
	// Since this is allocated as an array of "SETJMP_FLOAT128", the number of entries required is 33 (16-byte aligned).

	// Avoid conflicts with winnt.h FLOAT128 by giving the typedef another name.
	typedef _CRT_ALIGN( 16 ) struct _SETJMP_FLOAT128
	{
		Cmp__int64 LowPart;
		Cmp__int64 HighPart;
	} SETJMP_FLOAT128;

#	define _JBLEN  33
	typedef SETJMP_FLOAT128 _JBTYPE;
#	ifndef _INC_SETJMPEX
#		define setjmp  _setjmp
#	endif

	//Define jump buffer layout for IA64 setjmp/longjmp.

	//--------------------------------------------------------------------------------
	typedef struct __JUMP_BUFFER
	{
		//x86 reserved.

		unsigned long iAReserved[ 6 ];

		//x86 C9.0 compatibility

		unsigned long Registration;  // point to the UnwindData field.
		unsigned long TryLevel;      // ignored by setjmp
		unsigned long Cookie;        // set to "VC20" by setjmp
		unsigned long UnwindFunc;    // set to EM longjmp() by setjmp

									 /* First dword is zero to indicate it's an exception registration
									 * record prepared by EM setjmp function.
									 * Second dword is set to 0 for unsafe EM setjmp, and 1 for safe
									 * EM setjmp.
									 * Third dword is set to the setjmp site memory stack frame pointer.
									 * Fourth dword is set to the setjmp site backing store frame pointer.
									 */

		unsigned long UnwindData[ 6 ];

		// floating point status register, and preserved floating point registers fs0 - fs19

		SETJMP_FLOAT128 FltS0;
		SETJMP_FLOAT128 FltS1;
		SETJMP_FLOAT128 FltS2;
		SETJMP_FLOAT128 FltS3;
		SETJMP_FLOAT128 FltS4;
		SETJMP_FLOAT128 FltS5;
		SETJMP_FLOAT128 FltS6;
		SETJMP_FLOAT128 FltS7;
		SETJMP_FLOAT128 FltS8;
		SETJMP_FLOAT128 FltS9;
		SETJMP_FLOAT128 FltS10;
		SETJMP_FLOAT128 FltS11;
		SETJMP_FLOAT128 FltS12;
		SETJMP_FLOAT128 FltS13;
		SETJMP_FLOAT128 FltS14;
		SETJMP_FLOAT128 FltS15;
		SETJMP_FLOAT128 FltS16;
		SETJMP_FLOAT128 FltS17;
		SETJMP_FLOAT128 FltS18;
		SETJMP_FLOAT128 FltS19;

		Cmp__int64 FPSR;

		//return link and preserved branch registers bs0 - bs4

		Cmp__int64 StIIP;     // continuation address
		Cmp__int64 BrS0;
		Cmp__int64 BrS1;
		Cmp__int64 BrS2;
		Cmp__int64 BrS3;
		Cmp__int64 BrS4;

		//preserved general registers s0 - s3, sp, nats

		Cmp__int64 IntS0;
		Cmp__int64 IntS1;
		Cmp__int64 IntS2;
		Cmp__int64 IntS3;

		//bsp, pfs, unat, lc

		Cmp__int64 RsBSP;
		Cmp__int64 RsPFS;     // previous frame marker (cfm of setjmp's caller)
		Cmp__int64 ApUNAT;    // User Nat collection register (preserved)
		Cmp__int64 ApLC;      // loop counter

		Cmp__int64 IntSp;     // memory stack pointer
		Cmp__int64 IntNats;   // Nat bits of preserved integer regs s0 - s3
		Cmp__int64 Preds;     // predicates

	} _JUMP_BUFFER;

#elif defined (_M_AMD64)

	//--------------------------------------------------------------------------------
	typedef __declspec( align( 16 ) ) struct _SETJMP_FLOAT128
	{
		Cmp_unsigned__int64 Part[ 2 ];
	} SETJMP_FLOAT128;

#	define _JBLEN  16
	typedef SETJMP_FLOAT128 _JBTYPE;

#	ifndef _INC_SETJMPEX
#		define setjmp  _setjmp
#	endif

	//--------------------------------------------------------------------------------
	typedef struct _JUMP_BUFFER
	{
		Cmp_unsigned__int64 Frame;
		Cmp_unsigned__int64 Rbx;
		Cmp_unsigned__int64 Rsp;
		Cmp_unsigned__int64 Rbp;
		Cmp_unsigned__int64 Rsi;
		Cmp_unsigned__int64 Rdi;
		Cmp_unsigned__int64 R12;
		Cmp_unsigned__int64 R13;
		Cmp_unsigned__int64 R14;
		Cmp_unsigned__int64 R15;
		Cmp_unsigned__int64 Rip;
		Cmp_unsigned__int64 Spare;

		SETJMP_FLOAT128 Xmm6;
		SETJMP_FLOAT128 Xmm7;
		SETJMP_FLOAT128 Xmm8;
		SETJMP_FLOAT128 Xmm9;
		SETJMP_FLOAT128 Xmm10;
		SETJMP_FLOAT128 Xmm11;
		SETJMP_FLOAT128 Xmm12;
		SETJMP_FLOAT128 Xmm13;
		SETJMP_FLOAT128 Xmm14;
		SETJMP_FLOAT128 Xmm15;
	} _JUMP_BUFFER;

#endif


	// Define the buffer type for holding the state information
	typedef _JBTYPE jmp_buf[ _JBLEN ];

	//TODO:Fix this and move it to a machine constant
	typedef int sigjmp_buf[ 9 + 1 + ( sizeof( /*sigset_t*/Cmp_unsigned__int64 ) / sizeof( int ) ) ];

	class CSemaphore;

	//--------------------------------------------------------------------------------
	struct _sem_t
	{
		unsigned int valid;
		CSemaphore* s;
		volatile long value;
		void* vlock;
	};

	typedef _sem_t* sem_t;

	//--------------------------------------------------------------------------------
	typedef struct
	{
		char* key;
		void* data;
	} ENTRY;

	//--------------------------------------------------------------------------------
	typedef enum
	{
		FIND,
		ENTER
	} ACTION;

	//--------------------------------------------------------------------------------
	typedef enum
	{
		preorder,
		postorder,
		endorder,
		leaf
	} VISIT;

	__QCMP_STATIC_CONSTANT( int, SchedOther = 0 );
	__QCMP_STATIC_CONSTANT( int, SchedFIFO = 1 );
	__QCMP_STATIC_CONSTANT( int, SchedRR = 2 );
	__QCMP_STATIC_CONSTANT( int, SchedSporadic = 3 );
	__QCMP_STATIC_CONSTANT( int, SchedMin = SchedOther );
	__QCMP_STATIC_CONSTANT( int, SchedMax = SchedSporadic );

	//--------------------------------------------------------------------------------
	struct sched_param
	{
		int			sched_priority;
		int			sched_ss_low_priority;	//Low scheduling priority for sporadic server. 
		timespec	sched_ss_repl_period;	//Replenishment period for sporadic server. 
		timespec	sched_ss_init_budget;	//Initial budget for sporadic server. 
		int			sched_ss_max_repl;		//Maximum pending replenishments for sporadic server. 
	};

	//The <regex.h> header shall define the following symbolic constants for the cflags parameter to the regcomp() function:
	__QCMP_STATIC_CONSTANT( int, RegExtended = 0x00000001 );			//Use Extended Regular Expressions. 
	__QCMP_STATIC_CONSTANT( int, RegICase = 0x00000002 );			//Ignore case in match. 
	__QCMP_STATIC_CONSTANT( int, RegNoSub = 0x00000004 );			//Report only success or fail in regexec(). 
	__QCMP_STATIC_CONSTANT( int, RegNewLine = 0x00000008 );			//Change the handling of <newline>. 

																	//The <regex.h> header shall define the following symbolic constants for the eflags parameter to the regexec() function:
	__QCMP_STATIC_CONSTANT( int, RegNotBOL = 0x00000001 );			//The <circumflex> character ( '^' ), when taken as a special character, does not match the beginning of string. 
	__QCMP_STATIC_CONSTANT( int, RegNotEOL = 0x00000002 );			//The <dollar-sign> ( '$' ), when taken as a special character, does not match the end of string. 

																	//The <regex.h> header shall define the following symbolic constants as error return values:

	__QCMP_STATIC_CONSTANT( int, RegNoMatch = 1 );			//regexec() failed to match. 
	__QCMP_STATIC_CONSTANT( int, RegBadPat = 2 );			//Invalid regular expression. 
	__QCMP_STATIC_CONSTANT( int, RegECollate = 3 );			//Invalid collating element referenced. 
	__QCMP_STATIC_CONSTANT( int, RegECType = 4 );			//Invalid character class type referenced. 
	__QCMP_STATIC_CONSTANT( int, RegEEscape = 5 );			//Trailing <backslash> character in pattern. 
	__QCMP_STATIC_CONSTANT( int, RegESubReg = 6 );			//Number in \digit invalid or in error. 
	__QCMP_STATIC_CONSTANT( int, RegEBRack = 7 );			//"[]" imbalance. 
	__QCMP_STATIC_CONSTANT( int, RegEParen = 8 );			//"\(\)" or "()" imbalance. 
	__QCMP_STATIC_CONSTANT( int, RegEBrace = 9 );			//"\{\}" imbalance. 
	__QCMP_STATIC_CONSTANT( int, RegBadBr = 10 );			//Content of "\{\}" invalid: not a number, number too large, more than two numbers, first larger than second. 
	__QCMP_STATIC_CONSTANT( int, RegERange = 11 );			//Invalid endpoint in range expression. 
	__QCMP_STATIC_CONSTANT( int, RegESpace = 12 );			//Out of memory. 
	__QCMP_STATIC_CONSTANT( int, RegBadRpt = 13 );			//'?' , '*' , or '+' not preceded by valid regular expression. 

															//--------------------------------------------------------------------------------
	struct regex_t
	{
		size_t re_nsub;		//Number of parenthesized subexpressions.
	};

	typedef Cmp_int_ptr regoff_t;

	//--------------------------------------------------------------------------------
	struct regmatch_t
	{
		regoff_t    rm_so;    //Byte offset from start of string to start of substring. 
		regoff_t    rm_eo;    //Byte offset from start of string of the first character after the end of substring.
	};

	//--------------------------------------------------------------------------------
	struct passwd
	{
		char* pw_name;      //User's login name.
		uid_t pw_uid;       //Numerical user ID.
		gid_t pw_gid;       //Numerical group ID.
		char* pw_dir;       //Initial working directory.
		char* pw_shell;     //Program to use as shell.
	};

	class __QOR_INTERFACE( __WINQL ) CEvent;
	class __QOR_INTERFACE( __WINQL ) CThread;

	//--------------------------------------------------------------------------------
	struct pollfd
	{
		int    fd;		//The following descriptor being polled. 
		short  events;	//The input event flags
		short  revents;	//The output event flags
	};

	typedef unsigned int nfds_t;

	__QCMP_STATIC_CONSTANT( int, NLSetD = 1 );
	__QCMP_STATIC_CONSTANT( int, NLCatLocale = 1 );

	typedef	int	nl_item;
	typedef	void* nl_catd;

	__QCMP_STATIC_CONSTANT( int, AIPlatform = 0x00000001 );		//Socket address is intended for bind(). 
	__QCMP_STATIC_CONSTANT( int, AICannonName = 0x00000002 );		//Request for canonical name. 
	__QCMP_STATIC_CONSTANT( int, AINumericHost = 0x00000004 );		//Return numeric host address as name. 
	__QCMP_STATIC_CONSTANT( int, AINumericServ = 0x00000008 );		//Inhibit service name resolution. 
	__QCMP_STATIC_CONSTANT( int, AIV4Mapped = 0x00000010 );		//If no IPv6 addresses are found, query for IPv4 addresses and return them to the caller as IPv4-mapped IPv6 addresses. 
	__QCMP_STATIC_CONSTANT( int, AIAll = 0x00000020 );		//Query for both IPv4 and IPv6 addresses. 
	__QCMP_STATIC_CONSTANT( int, AIAddrConfig = 0x00000040 );		//Query for IPv4 addresses only when an IPv4 address is configured; query for IPv6 addresses only when an IPv6 address is configured. 

	__QCMP_STATIC_CONSTANT( int, NINoFQDN = 0x00000001 );		//Only the nodename portion of the FQDN is returned for local hosts. 
	__QCMP_STATIC_CONSTANT( int, NINumericHost = 0x00000002 );		//The numeric form of the node's address is returned instead of its name. 
	__QCMP_STATIC_CONSTANT( int, NINameReqd = 0x00000004 );		//Return an error if the node's name cannot be located in the database. 
	__QCMP_STATIC_CONSTANT( int, NINumericServ = 0x00000008 );		//The numeric form of the service address is returned instead of its name. 
	__QCMP_STATIC_CONSTANT( int, NINumericScope = 0x00000010 );

	__QCMP_STATIC_CONSTANT( int, NIDGram = 0x00000001 );		//Indicates that the service is a datagram service (SOCK_DGRAM). 

	__QCMP_STATIC_CONSTANT( int, EAIAgain = 1 );				//The name could not be resolved at this time. Future attempts may succeed. 
	__QCMP_STATIC_CONSTANT( int, EAIBadFlags = 2 );				//The flags had an invalid value. 
	__QCMP_STATIC_CONSTANT( int, EAIFail = 3 );				//A non-recoverable error occurred. 
	__QCMP_STATIC_CONSTANT( int, EAIFamily = 4 );				//The address family was not recognized or the address length was invalid for the specified family. 
	__QCMP_STATIC_CONSTANT( int, EAIMemory = 5 );				//There was a memory allocation failure. 
	__QCMP_STATIC_CONSTANT( int, EAINoName = 6 );				//The name does not resolve for the supplied parameters. NI_NAMEREQD is set and the host's name cannot be located, or both nodename and servname were null.
	__QCMP_STATIC_CONSTANT( int, EAIService = 7 );				//The service passed was not recognized for the specified socket type. 
	__QCMP_STATIC_CONSTANT( int, EAISockType = 8 );				//The intended socket type was not recognized. 
	__QCMP_STATIC_CONSTANT( int, EAISystem = 9 );				//A system error occurred. The error code can be found in errno. 
	__QCMP_STATIC_CONSTANT( int, EAIOverflow = 10 );				//An argument buffer overflowed. 

																	/*
																	#   ifndef _PATH_HEQUIV
																	#       define	_PATH_HEQUIV	"/etc/hosts.equiv"
																	#   endif
																	#   define	_PATH_HOSTS         "/etc/hosts"
																	#   define	_PATH_NETWORKS      "/etc/networks"
																	#   define	_PATH_PROTOCOLS     "/etc/protocols"
																	#   define	_PATH_SERVICES      "/etc/services"

																	extern int h_errno;

																	#define IPPORT_RESERVED         1024
																	*/
																	//#define OS_EXPORTS_NETDB_HOSTENT 1
																	//#define OS_EXPORTS_NETDB_NETENT 1
																	//#define OS_EXPORTS_NETDB_PROTOENT 1
																	//#define OS_EXPORTS_NETDB_SOCKADDR 1

																	//--------------------------------------------------------------------------------
	struct  protoent
	{
		char* p_name;				// official protocol name
		char** p_aliases;			// alias list 
		short p_proto;				// protocol # 
	};

	//--------------------------------------------------------------------------------
	struct netent
	{
		char* n_name;				// official name of net 
		char** n_aliases;			// alias list 
		short n_addrtype;			// net address type 
		unsigned long n_net;		// network # 
	};

	//--------------------------------------------------------------------------------
	/*defined in sys/socket_types.h
	struct sockaddr
	{
	unsigned short sa_family;	// address family
	char sa_data[ 14 ];			// up to 14 bytes of direct address
	};
	*/
	//--------------------------------------------------------------------------------
	struct servent
	{
		char* s_name;				// official service name 
		char** s_aliases;			// alias list
#ifdef _WIN64
		char* s_proto;				// protocol to use
		short   s_port;				// port #
#else
		short   s_port;				// port # 
		char* s_proto;				// protocol to use
#endif
	};

	//--------------------------------------------------------------------------------
	struct  hostent
	{
		char* h_name;				// official name of host
		char** h_aliases;			// alias list
		short   h_addrtype;         // host address type
		short   h_length;			// length of address 
		char** h_addr_list;			// list of addresses
									//#	define h_addr  h_addr_list[ 0 ]          /* address, for backward compat */
	};

	//--------------------------------------------------------------------------------
	struct addrinfo
	{
	};

	typedef long socklen_t;

	//--------------------------------------------------------------------------------
	struct rpcent
	{
		char* r_name;       // name of server for this rpc program
		char** r_aliases;   // alias list
		int r_number;       // rpc program number
	};

	// Error return codes from gethostbyname() and gethostbyaddr() (left in h_errno).

#   define	NETDB_INTERNAL	-1	/* see errno */
#   define	NETDB_SUCCESS	0	/* no problem */
#   define HOST_NOT_FOUND   WSAHOST_NOT_FOUND   /* Authoritative Answer Host not found */
#   define	TRY_AGAIN	WSATRY_AGAIN       /* Non-Authoritative Host not found, or SERVERFAIL */
#   define	NO_RECOVERY	WSANO_RECOVERY       /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
#   define	NO_DATA		WSANO_DATA       /* Valid name, no data record of requested type */
#   define	NO_ADDRESS	WSANO_ADDRESS	/* no address, look for MX record */

#   define OS_EXPORTS_NETDB_GETSERVBYPORT 1
#   define OS_EXPORTS_NETDB_GETSERVBYNAME 1
#   define OS_EXPORTS_NETDB_GETPROTOBYNUMBER 1
#   define OS_EXPORTS_NETDB_GETPROTOBYNAME 1
#   define OS_EXPORTS_NETDB_GETHOSTBYNAME 1
#   define OS_EXPORTS_NETDB_GETHOSTBYADDR 1

#   define DBM_RDONLY	O_RDONLY

	__QCMP_STATIC_CONSTANT( int, DBMInsert = 0 );
	__QCMP_STATIC_CONSTANT( int, DBMReplace = 1 );

	// The db(3) support for ndbm(3) always appends this suffix to the
	// file name to avoid overwriting the user's original database.
#   define	DBM_SUFFIX	".db"

	//--------------------------------------------------------------------------------
	typedef struct
	{
		void* dptr;
		size_t dsize;
	} datum;

	//--------------------------------------------------------------------------------
	typedef struct
	{
		char __opaque[ sizeof( int ) + 8 * sizeof( void* ) ];
	} DBM;


#   define	dbm_pagfno( a ) DBM_PAGFNO_NOT_AVAILABLE

	typedef unsigned long mqd_t;

	//--------------------------------------------------------------------------------
	struct mq_attr
	{
		long mq_flags;      //Message queue flags
		long mq_maxmsg;     //Maximum number of messages
		long mq_msgsize;    //Maximum message size
		long mq_currmsgs;   //Number of messages currently queued
	};

	static const union
	{
		unsigned long __i[ 1 ];
		float __d;
	} __Nanf = { 0x7FC00000 };

#if __QCMP_SUPPORTS( __QCMP_FEATURE_64BIT_CONSTANTS )
	__QCMP_STATIC_CONSTANT( unsigned long long, __gcs_ullHuge = ( 0x7ff0000000000000 ) );
#else
	__QCMP_STATIC_CONSTANT( unsigned long long, __gcs_ullHuge = ( 0x7ff00000 ) );
#endif
	__QCMP_STATIC_CONSTANT( int, FpNAN = 0 );
	__QCMP_STATIC_CONSTANT( int, FpInfinite = 1 );
	__QCMP_STATIC_CONSTANT( int, FpZero = 2 );
	__QCMP_STATIC_CONSTANT( int, FpSubNormal = 3 );
	__QCMP_STATIC_CONSTANT( int, FpNormal = 4 );

	// Constant definitions for the exception type passed in the _exception struct

	__QCMP_STATIC_CONSTANT( int, _DOMAIN = 1 );			//argument domain error
	__QCMP_STATIC_CONSTANT( int, _SING = 2 );			//argument singularity
	__QCMP_STATIC_CONSTANT( int, _OVERFLOW = 3 );			//overflow range error
	__QCMP_STATIC_CONSTANT( int, _UNDERFLOW = 4 );			//underflow range error
	__QCMP_STATIC_CONSTANT( int, _TLOSS = 5 );			//total loss of precision
	__QCMP_STATIC_CONSTANT( int, _PLOSS = 6 );			//partial loss of precision
#if __QCMP_SUPPORTS( __QCMP_FEATURE_64BIT_CONSTANTS )
	__QCMP_STATIC_CONSTANT( double, HugeValue = ASSIGN_HUGE_VAL );
	__QCMP_STATIC_CONSTANT( float, HugeValueF = ASSIGN_HUGE_VALF );
	__QCMP_STATIC_CONSTANT( long double, HugeValueLL = ASSIGN_HUGE_VALL );
	__QCMP_STATIC_CONSTANT( float, NaN = ( __Nanf.__d ) );
#else
	__QCMP_STATIC_CONSTANT( double, HugeValue = ( 0x7ff00000 ) );
	__QCMP_STATIC_CONSTANT( float, HugeValueF = ( 0x7ff00000 ) );
	__QCMP_STATIC_CONSTANT( long double, HugeValueLL = ( 0x7ff00000 ) );
	__QCMP_STATIC_CONSTANT( float, NaN = ( 0x7FC00000 ) );
#endif

	//--------------------------------------------------------------------------------
	// Definition of _exception struct - this struct is passed to the matherr routine when a floating point exception is detected
	struct _exception
	{
		int type;       // exception type - see below 
		char *name;     // name of function where error occured 
		double arg1;    // first argument to function 
		double arg2;    // second argument (if any) to function 
		double retval;  // value to be returned by function 
	};


	// Definition of a _complex struct to be used by those who use cabs and want type checking on their argument

	struct _complex
	{
		double x, y; /* real and imaginary parts */
	};

#	define complex _complex

	__QCMP_STARTLINKAGE_CPP

		template<class _Ty> inline _Ty _Pow_int( _Ty _X, int _Y )
	{
		unsigned int _N;
		if( _Y >= 0 )
			_N = (unsigned int)_Y;
		else
			_N = (unsigned int)( -_Y );
		for( _Ty _Z = _Ty( 1 ); ; _X *= _X )
		{
			if( ( _N & 1 ) != 0 )
				_Z *= _X;
			if( ( _N >>= 1 ) == 0 )
				return ( _Y < 0 ? _Ty( 1 ) / _Z : _Z );
		}
	}

	__QCMP_ENDLINKAGE_CPP


		//--------------------------------------------------------------------------------
		typedef struct tagLC_ID
	{
		unsigned short wLanguage;
		unsigned short wCountry;
		unsigned short wCodePage;
	} LC_ID, *LPLC_ID;

	// Locale categories
	__QCMP_STATIC_CONSTANT( int, LocaleCategoryAll = 0/*CLocale::LCALL*/ );
	__QCMP_STATIC_CONSTANT( int, LocaleCategoryCollate = 1/*CLocale::LCCOLLATE*/ );
	__QCMP_STATIC_CONSTANT( int, LocaleCategoryCType = 2/*CLocale::LCCTYPE*/ );
	__QCMP_STATIC_CONSTANT( int, LocaleCategoryMessages = 3/*CLocale::LCMESSAGES*/ );
	__QCMP_STATIC_CONSTANT( int, LocaleCategoryMonetary = 4/*CLocale::LCMONETARY*/ );
	__QCMP_STATIC_CONSTANT( int, LocaleCategoryNumeric = 5/*CLocale::LCNUMERIC*/ );
	__QCMP_STATIC_CONSTANT( int, LocaleCategoryTime = 6/*CLocale::LCTIME*/ );
	__QCMP_STATIC_CONSTANT( int, LocaleCategoryMin = 0/*LocaleCategoryAll*/ );
	__QCMP_STATIC_CONSTANT( int, LocaleCategoryMax = 6/*LocaleCategoryTime*/ );

	__QCMP_STATIC_CONSTANT( int, LocaleCategoryCollateMask = 0x0001 );
	__QCMP_STATIC_CONSTANT( int, LocaleCategoryCTypeMask = 0x0002 );
	__QCMP_STATIC_CONSTANT( int, LocaleCategoryMessagesMask = 0x0004 );
	__QCMP_STATIC_CONSTANT( int, LocaleCategoryMonetaryMask = 0x0008 );
	__QCMP_STATIC_CONSTANT( int, LocaleCategoryNumericMask = 0x0010 );
	__QCMP_STATIC_CONSTANT( int, LocaleCategoryTimeMask = 0x0020 );
	__QCMP_STATIC_CONSTANT( int, LocaleCategoryAllMask = 0x003F );

	//--------------------------------------------------------------------------------
	struct lconv
	{
		char *decimal_point;
		char *thousands_sep;
		char *grouping;
		char *int_curr_symbol;
		char *currency_symbol;
		char *mon_decimal_point;
		char *mon_thousands_sep;
		char *mon_grouping;
		char *positive_sign;
		char *negative_sign;
		char int_frac_digits;
		char frac_digits;
		char p_cs_precedes;
		char p_sep_by_space;
		char n_cs_precedes;
		char n_sep_by_space;
		char p_sign_posn;
		char n_sign_posn;
	};

	struct threadlocaleinfostruct;
	struct threadmbcinfostruct;
	typedef struct threadlocaleinfostruct * pthreadlocinfo;
	typedef struct threadmbcinfostruct * pthreadmbcinfo;
	struct __lc_time_data;

	//--------------------------------------------------------------------------------
	typedef struct localeinfo_struct
	{
		pthreadlocinfo locinfo;
		pthreadmbcinfo mbcinfo;
	} _locale_tstruct, *_locale_t;

	typedef localeinfo_struct* locale_t;

	//--------------------------------------------------------------------------------
	__QOR_INTERFACE( __QSYS )  int MBCurMax( void );
	__QOR_INTERFACE( __QSYS )  int MBCurMax_l( locale_t );

#ifndef _CHAR_UNSIGNED
	__QCMP_STATIC_CONSTANT( int, CharMin = -128 );							//mimimum char value
	__QCMP_STATIC_CONSTANT( int, CharMax = 127 );							//maximum char value
#else
	__QCMP_STATIC_CONSTANT( int, CharMin = 0 );							//mimimum char value
	__QCMP_STATIC_CONSTANT( int, CharMax = 255 );							//maximum char value
#endif  /* _CHAR_UNSIGNED */

	__QCMP_STATIC_CONSTANT( int, LongMax = 2147483647L );					// maximum (signed) long value 
	__QCMP_STATIC_CONSTANT( int, LongMin = ( -2147483647L - 1 ) );			// minimum (signed) long value 

	__QCMP_STATIC_CONSTANT( int, MBLenMax = 5 );							// max. # bytes in multibyte char 
	__QCMP_STATIC_CONSTANT( short, ShortMin = ( -32768 ) );						// minimum (signed) short value 
	__QCMP_STATIC_CONSTANT( short, ShortMax = 32767 );						// maximum (signed) short value 
	__QCMP_STATIC_CONSTANT( unsigned short, UShortMax = 0xffff );						// maximum unsigned short value 
	__QCMP_STATIC_CONSTANT( int, IntMin = ( -2147483647 - 1 ) );			// minimum (signed) int value 
	__QCMP_STATIC_CONSTANT( int, IntMax = 2147483647 );					// maximum (signed) int value 
	__QCMP_STATIC_CONSTANT( unsigned int, UIntMax = 0xffffffff );					// maximum unsigned int value 
	__QCMP_STATIC_CONSTANT( unsigned long, ULongMax = 0xffffffffUL );					// maximum unsigned long value
#if __QCMP_SUPPORTS( __QCMP_FEATURE_64BIT_CONSTANTS )
	__QCMP_STATIC_CONSTANT( Cmp_unsigned__int64, UInt64Max = __QCMP_ui64_SUFFIX( 0xffffffffffffffff ) );		//maximum unsigned 64 bit value
	__QCMP_STATIC_CONSTANT( Cmp_signed__int64, Int64Min = ( __QCMP_i64_SUFFIX( -9223372036854775807 ) - 1 ) );//minimum signed 64 bit value
	__QCMP_STATIC_CONSTANT( Cmp_signed__int64, Int64Max = __QCMP_i64_SUFFIX( 9223372036854775807 ) );		//maximum signed 64 bit value
#endif
	__QCMP_STATIC_CONSTANT( int, NLArgMax = 100 );							//Maximum value of n in conversion specifications using the "%n$" sequence in calls to the printf() and scanf() families of functions.
	__QCMP_STATIC_CONSTANT( int, FloatMaxExp = 128 );
	__QCMP_STATIC_CONSTANT( int, DoubleMaxExp = 1024 );							// max binary exponent
	__QCMP_STATIC_CONSTANT( int, LongDoubleMaxExp = DoubleMaxExp );

	__QCMP_STATIC_CONSTANT( int, PathMax = 1024 );

#ifdef	_WIN64 
	__QCMP_STATIC_CONSTANT( Cmp_unsigned__int64, Size_Max = UInt64Max );
#else
	__QCMP_STATIC_CONSTANT( unsigned int, Size_Max = UIntMax );
#endif//_WIN64 

	__QCMP_STATIC_CONSTANT( nl_item, CodeSet = 1 );			//Codeset name.

															// The ISO C99 standard specifies that these macros must only be defined if explicitly requested.
#if !defined __cplusplus || defined __STDC_FORMAT_MACROS

# if __WORDSIZE == 64
#  define __PRI64_PREFIX	"l"
#  define __PRIPTR_PREFIX	"l"
# else
#  define __PRI64_PREFIX	"ll"
#  define __PRIPTR_PREFIX
# endif

															// Macros for printing format specifiers.

															// Decimal notation.
# define PRId8		"d"
# define PRId16		"d"
# define PRId32		"d"
# define PRId64		__PRI64_PREFIX "d"

# define PRIdLEAST8	"d"
# define PRIdLEAST16	"d"
# define PRIdLEAST32	"d"
# define PRIdLEAST64	__PRI64_PREFIX "d"

# define PRIdFAST8	"d"
# define PRIdFAST16	__PRIPTR_PREFIX "d"
# define PRIdFAST32	__PRIPTR_PREFIX "d"
# define PRIdFAST64	__PRI64_PREFIX "d"


# define PRIi8		"i"
# define PRIi16		"i"
# define PRIi32		"i"
# define PRIi64		__PRI64_PREFIX "i"

# define PRIiLEAST8	"i"
# define PRIiLEAST16	"i"
# define PRIiLEAST32	"i"
# define PRIiLEAST64	__PRI64_PREFIX "i"

# define PRIiFAST8	"i"
# define PRIiFAST16	__PRIPTR_PREFIX "i"
# define PRIiFAST32	__PRIPTR_PREFIX "i"
# define PRIiFAST64	__PRI64_PREFIX "i"

															// Octal notation.
# define PRIo8		"o"
# define PRIo16		"o"
# define PRIo32		"o"
# define PRIo64		__PRI64_PREFIX "o"

# define PRIoLEAST8	"o"
# define PRIoLEAST16	"o"
# define PRIoLEAST32	"o"
# define PRIoLEAST64	__PRI64_PREFIX "o"

# define PRIoFAST8	"o"
# define PRIoFAST16	__PRIPTR_PREFIX "o"
# define PRIoFAST32	__PRIPTR_PREFIX "o"
# define PRIoFAST64	__PRI64_PREFIX "o"

															// Unsigned integers.
# define PRIu8		"u"
# define PRIu16		"u"
# define PRIu32		"u"
# define PRIu64		__PRI64_PREFIX "u"

# define PRIuLEAST8	"u"
# define PRIuLEAST16	"u"
# define PRIuLEAST32	"u"
# define PRIuLEAST64	__PRI64_PREFIX "u"

# define PRIuFAST8	"u"
# define PRIuFAST16	__PRIPTR_PREFIX "u"
# define PRIuFAST32	__PRIPTR_PREFIX "u"
# define PRIuFAST64	__PRI64_PREFIX "u"

															// lowercase hexadecimal notation.
# define PRIx8		"x"
# define PRIx16		"x"
# define PRIx32		"x"
# define PRIx64		__PRI64_PREFIX "x"

# define PRIxLEAST8	"x"
# define PRIxLEAST16	"x"
# define PRIxLEAST32	"x"
# define PRIxLEAST64	__PRI64_PREFIX "x"

# define PRIxFAST8	"x"
# define PRIxFAST16	__PRIPTR_PREFIX "x"
# define PRIxFAST32	__PRIPTR_PREFIX "x"
# define PRIxFAST64	__PRI64_PREFIX "x"

															// UPPERCASE hexadecimal notation.
# define PRIX8		"X"
# define PRIX16		"X"
# define PRIX32		"X"
# define PRIX64		__PRI64_PREFIX "X"

# define PRIXLEAST8	"X"
# define PRIXLEAST16	"X"
# define PRIXLEAST32	"X"
# define PRIXLEAST64	__PRI64_PREFIX "X"

# define PRIXFAST8	"X"
# define PRIXFAST16	__PRIPTR_PREFIX "X"
# define PRIXFAST32	__PRIPTR_PREFIX "X"
# define PRIXFAST64	__PRI64_PREFIX "X"


															// Macros for printing `intmax_t' and `uintmax_t'.
# define PRIdMAX	__PRI64_PREFIX "d"
# define PRIiMAX	__PRI64_PREFIX "i"
# define PRIoMAX	__PRI64_PREFIX "o"
# define PRIuMAX	__PRI64_PREFIX "u"
# define PRIxMAX	__PRI64_PREFIX "x"
# define PRIXMAX	__PRI64_PREFIX "X"


															// Macros for printing `intptr_t' and `uintptr_t'.
# define PRIdPTR	__PRIPTR_PREFIX "d"
# define PRIiPTR	__PRIPTR_PREFIX "i"
# define PRIoPTR	__PRIPTR_PREFIX "o"
# define PRIuPTR	__PRIPTR_PREFIX "u"
# define PRIxPTR	__PRIPTR_PREFIX "x"
# define PRIXPTR	__PRIPTR_PREFIX "X"


															// Macros for scanning format specifiers.

															// Signed decimal notation.
# define SCNd8		"hhd"
# define SCNd16		"hd"
# define SCNd32		"d"
# define SCNd64		__PRI64_PREFIX "d"

# define SCNdLEAST8	"hhd"
# define SCNdLEAST16	"hd"
# define SCNdLEAST32	"d"
# define SCNdLEAST64	__PRI64_PREFIX "d"

# define SCNdFAST8	"hhd"
# define SCNdFAST16	__PRIPTR_PREFIX "d"
# define SCNdFAST32	__PRIPTR_PREFIX "d"
# define SCNdFAST64	__PRI64_PREFIX "d"

															// Signed decimal notation.
# define SCNi8		"hhi"
# define SCNi16		"hi"
# define SCNi32		"i"
# define SCNi64		__PRI64_PREFIX "i"

# define SCNiLEAST8	"hhi"
# define SCNiLEAST16	"hi"
# define SCNiLEAST32	"i"
# define SCNiLEAST64	__PRI64_PREFIX "i"

# define SCNiFAST8	"hhi"
# define SCNiFAST16	__PRIPTR_PREFIX "i"
# define SCNiFAST32	__PRIPTR_PREFIX "i"
# define SCNiFAST64	__PRI64_PREFIX "i"

															// Unsigned decimal notation.
# define SCNu8		"hhu"
# define SCNu16		"hu"
# define SCNu32		"u"
# define SCNu64		__PRI64_PREFIX "u"

# define SCNuLEAST8	"hhu"
# define SCNuLEAST16	"hu"
# define SCNuLEAST32	"u"
# define SCNuLEAST64	__PRI64_PREFIX "u"

# define SCNuFAST8	"hhu"
# define SCNuFAST16	__PRIPTR_PREFIX "u"
# define SCNuFAST32	__PRIPTR_PREFIX "u"
# define SCNuFAST64	__PRI64_PREFIX "u"

															// Octal notation.
# define SCNo8		"hho"
# define SCNo16		"ho"
# define SCNo32		"o"
# define SCNo64		__PRI64_PREFIX "o"

# define SCNoLEAST8	"hho"
# define SCNoLEAST16	"ho"
# define SCNoLEAST32	"o"
# define SCNoLEAST64	__PRI64_PREFIX "o"

# define SCNoFAST8	"hho"
# define SCNoFAST16	__PRIPTR_PREFIX "o"
# define SCNoFAST32	__PRIPTR_PREFIX "o"
# define SCNoFAST64	__PRI64_PREFIX "o"

															// Hexadecimal notation.
# define SCNx8		"hhx"
# define SCNx16		"hx"
# define SCNx32		"x"
# define SCNx64		__PRI64_PREFIX "x"

# define SCNxLEAST8	"hhx"
# define SCNxLEAST16	"hx"
# define SCNxLEAST32	"x"
# define SCNxLEAST64	__PRI64_PREFIX "x"

# define SCNxFAST8	"hhx"
# define SCNxFAST16	__PRIPTR_PREFIX "x"
# define SCNxFAST32	__PRIPTR_PREFIX "x"
# define SCNxFAST64	__PRI64_PREFIX "x"


															// Macros for scanning `intmax_t' and `uintmax_t'.
# define SCNdMAX	__PRI64_PREFIX "d"
# define SCNiMAX	__PRI64_PREFIX "i"
# define SCNoMAX	__PRI64_PREFIX "o"
# define SCNuMAX	__PRI64_PREFIX "u"
# define SCNxMAX	__PRI64_PREFIX "x"

															// Macros for scaning `intptr_t' and `uintptr_t'.
# define SCNdPTR	__PRIPTR_PREFIX "d"
# define SCNiPTR	__PRIPTR_PREFIX "i"
# define SCNoPTR	__PRIPTR_PREFIX "o"
# define SCNuPTR	__PRIPTR_PREFIX "u"
# define SCNxPTR	__PRIPTR_PREFIX "x"

#endif	// C++ && format macros

#if QOR_ARCH_WORDSIZE == 64

															// We have to define the `uintmax_t' type using `ldiv_t'.
	typedef struct
	{
		long int quot;		// Quotient.
		long int rem;		// Remainder.
	} imaxdiv_t;

#else

															// We have to define the `uintmax_t' type using `lldiv_t'.
	typedef struct
	{
		Cmp_long_long quot;		// Quotient.
		Cmp_long_long rem;		// Remainder.
	} imaxdiv_t;

#endif


	typedef void* iconv_t;

	__QCMP_STATIC_CONSTANT( int, GlobAppend = 0x0001 );			//Append to output from previous call.
	__QCMP_STATIC_CONSTANT( int, GlobDoOffset = 0x0002 );			//Use gl_offs.
	__QCMP_STATIC_CONSTANT( int, GlobError = 0x0004 );			//Return on error.
	__QCMP_STATIC_CONSTANT( int, GlobMark = 0x0008 );			//Append / to matching directories.
	__QCMP_STATIC_CONSTANT( int, GlobNoCheck = 0x0010 );			//Return pattern itself if nothing matches.
	__QCMP_STATIC_CONSTANT( int, GlobNoEscape = 0x2000 );			//Disable backslash escaping.
	__QCMP_STATIC_CONSTANT( int, GlobNoSort = 0x0020 );			//Don't sort.

	__QCMP_STATIC_CONSTANT( int, GlobAborted = -2 );				//Unignored error.
	__QCMP_STATIC_CONSTANT( int, GlobNoMatch = -3 );				//No match and GLOB_NOCHECK was not set.
	__QCMP_STATIC_CONSTANT( int, GlobNoSpace = -1 );				//Malloc call failed.
	__QCMP_STATIC_CONSTANT( int, GlobNoSys = -4 );				//Obselete compat only

																//--------------------------------------------------------------------------------
	struct sstat
	{
		unsigned int st_dev;
		unsigned short     st_ino;
		unsigned short st_mode;
		short      st_nlink;
		short      st_uid;
		short      st_gid;
		unsigned int     st_rdev;
		long     st_size;
		time_t st_atime;
		time_t st_mtime;
		time_t st_ctime;
	};

	//--------------------------------------------------------------------------------
	struct _stat64
	{
		unsigned int     st_dev;
		unsigned short     st_ino;
		unsigned short st_mode;
		short      st_nlink;
		short      st_uid;
		short      st_gid;
		unsigned int     st_rdev;
		Cmp_signed__int64    st_size;
		__time64_t st_atime;
		__time64_t st_mtime;
		__time64_t st_ctime;
	};

	typedef _stat64 sstat64;

	//--------------------------------------------------------------------------------
	struct sstati64
	{
		unsigned int     st_dev;
		unsigned short     st_ino;
		unsigned short st_mode;
		short      st_nlink;
		short      st_uid;
		short      st_gid;
		unsigned int     st_rdev;
		Cmp__int64    st_size;
		__time32_t st_atime;
		__time32_t st_mtime;
		__time32_t st_ctime;
	};

	//--------------------------------------------------------------------------------
	struct _stat32
	{
		unsigned int     st_dev;
		unsigned short     st_ino;
		unsigned short st_mode;
		short      st_nlink;
		short      st_uid;
		short      st_gid;
		unsigned int     st_rdev;
		long     st_size;
		__time32_t st_atime;
		__time32_t st_mtime;
		__time32_t st_ctime;
	};

	//--------------------------------------------------------------------------------
	struct file_stat
	{
		unsigned int     st_dev;
		unsigned short     st_ino;
		unsigned short st_mode;
		short      st_nlink;
		short      st_uid;
		short      st_gid;
		unsigned int     st_rdev;
		long     st_size;
		time_t st_atim;
		time_t st_mtim;
		time_t st_ctim;
		unsigned long  st_blksize;
		Cmp_unsigned__int64  st_blocks;
	};
	
	//--------------------------------------------------------------------------------
	struct _stat32i64
	{
		unsigned int     st_dev;
		unsigned short     st_ino;
		unsigned short st_mode;
		short      st_nlink;
		short      st_uid;
		short      st_gid;
		unsigned int     st_rdev;
		Cmp_signed__int64    st_size;
		__time32_t st_atime;
		__time32_t st_mtime;
		__time32_t st_ctime;
	};

	//--------------------------------------------------------------------------------
	struct _stat64i32
	{
		unsigned int     st_dev;
		unsigned short     st_ino;
		unsigned short st_mode;
		short      st_nlink;
		short      st_uid;
		short      st_gid;
		unsigned int     st_rdev;
		long     st_size;
		__time64_t st_atime;
		__time64_t st_mtime;
		__time64_t st_ctime;
	};

	__QCMP_STATIC_CONSTANT( unsigned long, UTimeNow = 0x3fffffff );
	__QCMP_STATIC_CONSTANT( unsigned long, UTimeOmit = 0x3ffffffe );

	//--------------------------------------------------------------------------------
	typedef struct
	{
		size_t gl_pathc;	// Count of total paths so far.
		int gl_matchc;		// Count of paths matching pattern.
		size_t gl_offs;		// Reserved at beginning of gl_pathv.
		int gl_flags;		// Copy of flags parameter to glob.
		char **gl_pathv;	// List of paths matching pattern.

		int( *gl_errfunc )( const char *, int );// Copy of errfunc parameter to glob.

												// Alternate filesystem access methods for glob; replacement
												// versions of closedir(3), readdir(3), opendir(3), stat(2) and lstat(2).
		void( *gl_closedir )( void * );
		struct dirent *( *gl_readdir )( void * );
		void *( *gl_opendir )( const char * );
		int( *gl_lstat )( const char *, file_stat* );
		int( *gl_stat )( const char *, file_stat* );
	} glob_t;

	/*
	//#   define	GLOB_ALTDIRFUNC	0x0040	// Use alternately specified directory funcs.
	//#   define	GLOB_BRACE	0x0080      // Expand braces ala csh
	//#   define	GLOB_MAGCHAR	0x0100	// Pattern had globbing characters.
	//#   define	GLOB_NOMAGIC	0x0200	// GLOB_NOCHECK without magic chars (csh).
	#   define	GLOB_QUOTE	0x0400      // Quote special chars with \.
	//#   define	GLOB_TILDE	0x0800      // Expand tilde names from the passwd file.
	#   define	GLOB_LIMIT	0x1000      // limit number of returned paths

	#   define	GLOB_PERIOD     (1 << 7) // Leading `.' can be matched by metachars.
	#   define GLOB_MAGCHAR     (1 << 8) // Set in gl_flags if any metachars seen.
	#   define GLOB_ALTDIRFUNC  (1 << 9) // Use gl_opendir et al functions.
	#   define GLOB_BRACE       (1 << 10)// Expand "{a,b}" to "a" "b".
	#   define GLOB_NOMAGIC     (1 << 11)// If no magic chars, return the pattern.
	#   define GLOB_TILDE       (1 << 12)// Expand ~user and ~ to home directories.
	#   define GLOB_ONLYDIR     (1 << 13)// Match only directories.
	#   define GLOB_TILDE_CHECK (1 << 14)// Like GLOB_TILDE but return an error

	// source compatibility, these are the old names
	#   define GLOB_MAXPATH     GLOB_LIMIT
	#   define GLOB_ABEND       GLOB_ABORTED

	#   define __GLOB_FLAGS	( GLOB_ERR|GLOB_MARK|GLOB_NOSORT|GLOB_DOOFFS| \
	GLOB_NOESCAPE|GLOB_NOCHECK|GLOB_APPEND|     \
	GLOB_PERIOD|GLOB_ALTDIRFUNC|GLOB_BRACE|     \
	GLOB_NOMAGIC|GLOB_TILDE|GLOB_ONLYDIR|GLOB_TILDE_CHECK )
	*/

	__QCMP_STATIC_CONSTANT( int, FTWFile = 0 );				//File. 
	__QCMP_STATIC_CONSTANT( int, FTWDirectory = 1 );		//Directory. 
	__QCMP_STATIC_CONSTANT( int, FTWDirNoRead = 2 );		//Directory without read permission. 
	__QCMP_STATIC_CONSTANT( int, FTWDirSubdirVisit = 3 );	//Directory with subdirectories visited. 
	__QCMP_STATIC_CONSTANT( int, FTWUnknown = 4 );			//Unknown type; stat() failed. 
	__QCMP_STATIC_CONSTANT( int, FTWSymLink = 5 );			//Symbolic link. 
	__QCMP_STATIC_CONSTANT( int, FTWSymLinkNoFile = 6 );	//Symbolic link that names a nonexistent file.

															// Flags for use as the 4th argument to nftw(3).  These may be ORed together
	__QCMP_STATIC_CONSTANT( int, FTWPhysicalWalk = 0x01 );	//Physical walk, does not follow symbolic links. Otherwise, nftw() follows links but does not walk down any path that crosses itself. 
	__QCMP_STATIC_CONSTANT( int, FTWMountX = 0x02 );		//The walk does not cross a mount point. 
	__QCMP_STATIC_CONSTANT( int, FTWDepth = 0x04 );			//All subdirectories are visited before the directory itself. 
	__QCMP_STATIC_CONSTANT( int, FTWChDir = 0x08 );			//The walk changes to each directory before reading it. 

															//--------------------------------------------------------------------------------
	struct FTW
	{
		int base;
		int level;
	};

	__QCMP_STATIC_CONSTANT( int, FNMNoMatch = 0x00000001 );			//The string does not match the specified pattern. 
	__QCMP_STATIC_CONSTANT( int, FNMPathName = 0x00000002 );			//<slash> in string only matches <slash> in pattern. 
	__QCMP_STATIC_CONSTANT( int, FNMPeriod = 0x00000004 );			//Leading <period> in string must be exactly matched by <period> in pattern. 
	__QCMP_STATIC_CONSTANT( int, FNMNoEscape = 0x00000008 );			//Disable backslash escaping. 

	__QCMP_STATIC_CONSTANT( int, MMHard = 0x00000001 );		//Source of the condition is hardware. 
	__QCMP_STATIC_CONSTANT( int, MMSoft = 0x00000002 );		//Source of the condition is software. 
	__QCMP_STATIC_CONSTANT( int, MMFirm = 0x00000004 );		//Source of the condition is firmware. 
	__QCMP_STATIC_CONSTANT( int, MMApplication = 0x00000010 );		//Condition detected by application. 
	__QCMP_STATIC_CONSTANT( int, MMUtility = 0x00000020 );		//Condition detected by utility. 
	__QCMP_STATIC_CONSTANT( int, MMOpSys = 0x00000040 );		//Condition detected by operating system. 
	__QCMP_STATIC_CONSTANT( int, MMRecoverable = 0x00000100 );		//Recoverable error. 
	__QCMP_STATIC_CONSTANT( int, MMNotRecoverable = 0x00000200 );		//Non-recoverable error. 
	__QCMP_STATIC_CONSTANT( int, MMHalt = 0x00001000 );		//Error causing application to halt. 
	__QCMP_STATIC_CONSTANT( int, MMError = 0x00002000 );		//Application has encountered a non-fatal fault. 
	__QCMP_STATIC_CONSTANT( int, MMWarning = 0x00004000 );		//Application has detected unusual non-error condition. 
	__QCMP_STATIC_CONSTANT( int, MMInfo = 0x00008000 );		//Informative message. 
	__QCMP_STATIC_CONSTANT( int, MMNoSeverity = 0x00010000 );		//No severity level provided for the message. 
	__QCMP_STATIC_CONSTANT( int, MMPrint = 0x00100000 );		//Display message on standard error. 
	__QCMP_STATIC_CONSTANT( int, MMConsole = 0x00200000 );		//Display message on system console. 

	__QCMP_STATIC_CONSTANT( int, MMOK = 0 );				//The function succeeded. 
	__QCMP_STATIC_CONSTANT( int, MMNotOK = 1 );				//The function failed completely. 
	__QCMP_STATIC_CONSTANT( int, MMNoMsg = 2 );				//The function was unable to generate a message on standard error, but otherwise succeeded. 
	__QCMP_STATIC_CONSTANT( int, MMNoConsole = 3 );				//The function was unable to generate a console message, but otherwise succeeded. 

#	define _CRT_ALIGN(x) __declspec(align(x))

	typedef float           _FP32;
	typedef double          _FP64;
	typedef short           _I16;
	typedef int             _I32;
	typedef unsigned short  _U16;
	typedef unsigned int    _U32;
	typedef __int64         _Q64;

	//--------------------------------------------------------------------------------
	typedef struct
#if defined(_M_IA64)
		_CRT_ALIGN( 16 )
#endif
	{
		unsigned short W[ 5 ];
	} _FP80;

	//--------------------------------------------------------------------------------
	typedef struct _CRT_ALIGN( 16 )
	{
		unsigned long W[ 4 ];
	} _FP128;

	//--------------------------------------------------------------------------------
	typedef struct _CRT_ALIGN( 8 )
	{
		unsigned long W[ 2 ];
	} _I64;

	//--------------------------------------------------------------------------------
	typedef struct _CRT_ALIGN( 8 )
	{
		unsigned long W[ 2 ];
	} _U64;

	//--------------------------------------------------------------------------------
	typedef struct
#if defined(_M_IA64)
		_CRT_ALIGN( 16 )
#endif
	{
		unsigned short W[ 5 ];
	} _BCD80;

	//--------------------------------------------------------------------------------
	typedef struct _CRT_ALIGN( 16 )
	{
		_Q64 W[ 2 ];
	} _FPQ64;

	__QCMP_WARNING_PUSH
		__QCMP_WARNING_DISABLE( __QCMP_WARN_STRUCTURE_PADDED_DUE_TO_ALIGN, _QCMP_TXT("Noise") );
	//--------------------------------------------------------------------------------
	typedef struct
	{
		union
		{
			_FP32        Fp32Value;
			_FP64        Fp64Value;
			_FP80        Fp80Value;
			_FP128       Fp128Value;
			_I16         I16Value;
			_I32         I32Value;
			_I64         I64Value;
			_U16         U16Value;
			_U32         U32Value;
			_U64         U64Value;
			_BCD80       Bcd80Value;
			char         *StringValue;
			int          CompareValue;
			_Q64         Q64Value;
			_FPQ64       Fpq64Value;
		} Value;

		unsigned int OperandValid : 1;
		unsigned int Format : 4;

	} _FPIEEE_VALUE;

	__QCMP_WARNING_POP

		//--------------------------------------------------------------------------------
		typedef struct
	{
		unsigned int Inexact : 1;
		unsigned int Underflow : 1;
		unsigned int Overflow : 1;
		unsigned int ZeroDivide : 1;
		unsigned int InvalidOperation : 1;
	} _FPIEEE_EXCEPTION_FLAGS;

	//--------------------------------------------------------------------------------
	typedef struct
	{
		unsigned int RoundingMode : 2;
		unsigned int Precision : 3;
		unsigned int Operation : 12;
		_FPIEEE_EXCEPTION_FLAGS Cause;
		_FPIEEE_EXCEPTION_FLAGS Enable;
		_FPIEEE_EXCEPTION_FLAGS Status;
		_FPIEEE_VALUE Operand1;
		_FPIEEE_VALUE Operand2;
		_FPIEEE_VALUE Result;
#if defined(_M_IA64)
		_FPIEEE_VALUE Operand3;
#endif
	} _FPIEEE_RECORD, *_PFPIEEE_RECORD;

	__QCMP_STATIC_CONSTANT( Cmp_int, FloatRadix = 2 );						//exponent radix
	__QCMP_STATIC_CONSTANT( Cmp_int, FloatMantDigits = 24 );						//# of bits in mantissa
	__QCMP_STATIC_CONSTANT( Cmp_int, DoubleMantDigits = 53 );						//# of bits in mantissa
	__QCMP_STATIC_CONSTANT( Cmp_int, LongDoubleMantDigits = DoubleMantDigits );			//# of bits in mantissa
	__QCMP_STATIC_CONSTANT( Cmp_int, FloatDigits = 6 );						//# of decimal digits of precision
	__QCMP_STATIC_CONSTANT( Cmp_int, DoubleDigits = 15 );						//# of decimal digits of precision
	__QCMP_STATIC_CONSTANT( Cmp_int, LongDoubleDigits = DoubleDigits );				//# of decimal digits of precision
	__QCMP_STATIC_CONSTANT( Cmp_int, DecimalDigits = DoubleDigits );				//Number of decimal digits, n, such that any floating-point number in the widest supported floating type with pmax radix b digits can be rounded to a floating-point number with n decimal digits and back again without change to the value.
	__QCMP_STATIC_CONSTANT( Cmp_int, FloatMinExponent = -125 );						//min binary exponent
	__QCMP_STATIC_CONSTANT( Cmp_int, DoubleMinExponent = -1021 );					//min binary exponent
	__QCMP_STATIC_CONSTANT( Cmp_int, LongDoubleMinExponent = DoubleMinExponent );		//min binary exponent
	__QCMP_STATIC_CONSTANT( Cmp_int, FloatMin10Exponent = -37 );						//min decimal exponent
	__QCMP_STATIC_CONSTANT( Cmp_int, DoubleMin10Exponent = -307 );						//min decimal exponent
	__QCMP_STATIC_CONSTANT( Cmp_int, LongDoubleMin10Exponent = DoubleMin10Exponent );	//min decimal exponent
	__QCMP_STATIC_CONSTANT( Cmp_int, FloatMax10Exponent = 38 );						//max decimal exponent
	__QCMP_STATIC_CONSTANT( Cmp_int, DoubleMax10Exponent = 308 );						//max decimal exponent
	__QCMP_STATIC_CONSTANT( Cmp_int, LongDoubleMax10Exponent = DoubleMax10Exponent );	//max decimal exponent

	__QCMP_STATIC_CONSTANT( Cmp_float, FloatMax = 3.402823466e+38F );			//max value
	__QCMP_STATIC_CONSTANT( Cmp_double, DoubleMax = 1.7976931348623158e+308 );	//max value
	__QCMP_STATIC_CONSTANT( Cmp_long_double, LongDoubleMax = DoubleMax );				//max value
	__QCMP_STATIC_CONSTANT( Cmp_float, FloatEpsilon = 1.192092896e-07F );			//smallest such that 1.0+FLT_EPSILON != 1.0
	__QCMP_STATIC_CONSTANT( Cmp_double, DoubleEpsilon = 2.2204460492503131e-016 );	//smallest such that 1.0+DBL_EPSILON != 1.0
	__QCMP_STATIC_CONSTANT( Cmp_long_double, LongDoubleEpsilon = DoubleEpsilon );			//smallest such that 1.0+LDBL_EPSILON != 1.0
	__QCMP_STATIC_CONSTANT( Cmp_float, FloatMin = 1.175494351e-38F );			//min positive value
	__QCMP_STATIC_CONSTANT( Cmp_double, DoubleMin = 2.2250738585072014e-308 );	//min positive value
	__QCMP_STATIC_CONSTANT( Cmp_long_double, LongDoubleMin = DoubleMin );				//min positive value


																						//TODO: Assumes x86
	typedef nsArch::nsx86::C387FPU::fenv_t fenv_t;
	typedef nsArch::nsx86::C387FPU::fexcept_t fexcept_t;

	/*
	typedef unsigned int fexcept_t;

	//--------------------------------------------------------------------------------
	typedef struct
	{
	fexcept_t __excepts;
	} fenv_t;
	*/
	//typedef nsArch::CFloatingPointUnit::fexcept_t fexcept_t;
	//typedef nsArch::CFloatingPointUnit::fenv_t fenv_t;										// Type representing floating-point environment.
	__QCMP_STATIC_CONSTANT( fenv_t*, FE_DFL_ENV = ( (const fenv_t*)-1l ) );	// If the default argument is used we use this value.

	__QCMP_STATIC_CONSTANT( int, FDuplicateFD = 0 );
	__QCMP_STATIC_CONSTANT( int, FDuplicateFDCloseOnExec = 1030 );
	__QCMP_STATIC_CONSTANT( int, FGetDescriptorFlags = 1 );
	__QCMP_STATIC_CONSTANT( int, FSetDescriptorFlags = 2 );
	__QCMP_STATIC_CONSTANT( int, FGetFlags = 3 );
	__QCMP_STATIC_CONSTANT( int, FSetFlags = 4 );
	__QCMP_STATIC_CONSTANT( int, FGetLock = 5 );
	__QCMP_STATIC_CONSTANT( int, FSetLock = 6 );
	__QCMP_STATIC_CONSTANT( int, FSetLockWait = 7 );
	__QCMP_STATIC_CONSTANT( int, FSetOwn = 8 );
	__QCMP_STATIC_CONSTANT( int, FGetOwn = 9 );

	__QCMP_STATIC_CONSTANT( int, OReadOnly = 0x00000 );			//open for reading only
	__QCMP_STATIC_CONSTANT( int, OWriteOnly = 0x00001 );			//open for writing only
	__QCMP_STATIC_CONSTANT( int, OReadWrite = 0x00002 );			//open for reading and writing
	__QCMP_STATIC_CONSTANT( int, OAppend = 0x00008 );			//writes done at eof
	__QCMP_STATIC_CONSTANT( int, OCreate = 0x00100 );			//create and open file
	__QCMP_STATIC_CONSTANT( int, OTruncate = 0x00200 );			//open and truncate
	__QCMP_STATIC_CONSTANT( int, OExclusive = 0x00400 );			//open only if file doesn't already exist

	__QCMP_STATIC_CONSTANT( int, OText = 0x04000 );			//file mode is text (translated). OText files have <cr><lf> sequences translated to <lf> on read()'s, and <lf> sequences translated to <cr><lf> on write()'s
	__QCMP_STATIC_CONSTANT( int, OBinary = 0x08000 );			//file mode is binary (untranslated)
	__QCMP_STATIC_CONSTANT( int, OWText = 0x10000 );			//file mode is UTF16 (translated)
	__QCMP_STATIC_CONSTANT( int, OU16Text = 0x20000 );			//file mode is UTF16 no BOM (translated)
	__QCMP_STATIC_CONSTANT( int, OU8Text = 0x40000 );			//file mode is UTF8  no BOM (translated)

	__QCMP_STATIC_CONSTANT( int, PosixFAdvNormal = 0 );
	__QCMP_STATIC_CONSTANT( int, PosixFAdvSequential = 1 );
	__QCMP_STATIC_CONSTANT( int, PosixFAdvRandom = 2 );
	__QCMP_STATIC_CONSTANT( int, PosixFAdvWillNeed = 3 );
	__QCMP_STATIC_CONSTANT( int, PosixFAdvDontNeed = 4 );
	__QCMP_STATIC_CONSTANT( int, PosixFAdvNoReuse = 5 );

	__QCMP_STATIC_CONSTANT( int, ORaw = OBinary );			//file mode is binary (untranslated)
	__QCMP_STATIC_CONSTANT( int, ONoInherit = 0x0080 );			//child process doesn't inherit file // Open handle inherit bit
	__QCMP_STATIC_CONSTANT( int, OTemporary = 0x0040 );			//temporary file bit// Temporary file bit - file is deleted when last handle is closed 
	__QCMP_STATIC_CONSTANT( int, OShortLived = 0x1000 );			//temporary storage file, try not to flush// temporary access hint
	__QCMP_STATIC_CONSTANT( int, OSequential = 0x0020 );			//file access is primarily sequential sequential/random access hints
	__QCMP_STATIC_CONSTANT( int, ORandom = 0x0010 );			//file access is primarily random 

	__QCMP_STATIC_CONSTANT( int, OCloseOnExec = 1 );

	__QCMP_STATIC_CONSTANT( int, ONonBlocking = 0 );			//Non-blocking mode. 

	typedef int mode_t;

	//--------------------------------------------------------------------------------
	struct flock
	{
		short int l_type;
		short int l_whence;
		long l_start;
		long l_len;
		pid_t l_pid;
	};

	//--------------------------------------------------------------------------------
	struct _diskfree_t
	{
		unsigned total_clusters;
		unsigned avail_clusters;
		unsigned sectors_per_cluster;
		unsigned bytes_per_sector;
	};

	//--------------------------------------------------------------------------------
	// structure describing an open directory.
	struct DIR
	{
		int	__dd_fd;	// file descriptor associated with directory
		long __dd_loc;	// offset in current buffer
		long __dd_size;	// amount of data returned
		char* __dd_buf;	// data buffer
		int	__dd_len;	// size of data buffer
	};

	//--------------------------------------------------------------------------------
	struct dirent
	{
		ino_t d_ino;
		char d_name[ nsWin32::Max_Path ];
	};

	typedef unsigned short wint_t;
	__QCMP_STATIC_CONSTANT( wint_t, WEoF = 0xFFFF );
	typedef wchar_t wctype_t;

	__QCMP_STATIC_CONSTANT( int, Upper = 0x1 );				//Upper case letter
	__QCMP_STATIC_CONSTANT( int, Lower = 0x2 );				//Lower case letter
	__QCMP_STATIC_CONSTANT( int, Digit = 0x4 );				//digit[0-9]
	__QCMP_STATIC_CONSTANT( int, Space = 0x8 );				//tab, carriage return, newline,
	__QCMP_STATIC_CONSTANT( int, Punct = 0x10 );				//punctuation character
	__QCMP_STATIC_CONSTANT( int, Control = 0x20 );				//control character
	__QCMP_STATIC_CONSTANT( int, Blank = 0x40 );				//space char
	__QCMP_STATIC_CONSTANT( int, Hex = 0x80 );				//hexidecimal digit
	__QCMP_STATIC_CONSTANT( int, LeadByte = 0x8000 );			//hexidecimal digit
	__QCMP_STATIC_CONSTANT( int, Alpha = 0x0100 | Upper | Lower );		//alphabetic character

																		
	//--------------------------------------------------------------------------------
	struct aiocb
	{
		int aio_fildes;						//File descriptor
		off_t aio_offset;					//File offset
		volatile void* aio_buf;				//Location of buffer
		size_t aio_nbytes;					//Length of transfer
		int aio_reqprio;					//Request priority offset
		sigevent aio_sigevent;				//Signal number and value
		int aio_lio_opcode;					//Operation to be performed
		nsWin32::OVERLAPPED Overlapped;		//Win32 async data
	};

	__QCMP_STATIC_CONSTANT( int, AIOAllDone = 0x1 );
	__QCMP_STATIC_CONSTANT( int, AIOCancelled = 0x2 );
	__QCMP_STATIC_CONSTANT( int, AIONotCancelled = 0x4 );

	__QCMP_STATIC_CONSTANT( int, LIONoOp = 0x0 );
	__QCMP_STATIC_CONSTANT( int, LIONoWait = 0x1 );
	__QCMP_STATIC_CONSTANT( int, LIORead = 0x1 );
	__QCMP_STATIC_CONSTANT( int, LIOWait = 0x2 );
	__QCMP_STATIC_CONSTANT( int, LIOWrite = 0x2 );


#ifdef __CQOR_COMPLEXTYPE_SUPPORTED

#	define _Complex_I	( __extension__ 1.0iF )
#	define _Imaginary_I ( __extension__ 1.0iF )
#	define I _Imaginary_I
#	define _Complex __complex__
#	define float_complex float __complex__
#	define double_complex double __complex__
#	define long_double_complex long double __complex__

#else

#	define _Complex_I ( (const float_complex){ 0, 1 } )
#	define I _Complex_I
#ifdef __MINGW32__
#	define __CQOR_REAL_( _X ) _X.real
#	define __CQOR_IMAG_( _X ) _X.imag
#else
#	define __CQOR_REAL_( _X ) _X##.real
#	define __CQOR_IMAG_( _X ) _X##.imag
#endif

	//--------------------------------------------------------------------------------
	struct float_complex
	{
		float real;
		float imag;

		//--------------------------------------------------------------------------------
		void _init( void )
		{
			real = 0;
			imag = 0;
		}

		//--------------------------------------------------------------------------------
		float_complex operator * ( const float_complex& x1 )
		{
			float_complex Result;

			Result.real = ( real * x1.real ) + ( imag * x1.imag );
			Result.imag = ( real * x1.imag ) + ( imag * x1.real );

			return Result;
		}

		//--------------------------------------------------------------------------------
		void operator *= ( const float_complex& x ) { *this = *this * x; }

		//--------------------------------------------------------------------------------
		float_complex operator / ( const float_complex& x1 )
		{
			float_complex Result;
			Result._init();
			float_complex Denom;
			Denom.real = x1.real;
			Denom.imag = -x1.imag;
			float_complex Numer = *this * Denom;
			Denom *= x1;

			if( Denom.imag == 0 )
			{
				Result.real = Numer.real / Denom.real;
				Result.imag = Numer.imag / Denom.real;
			}

			return Result;
		}

	protected:

	};

	//--------------------------------------------------------------------------------
	struct double_complex
	{
		double real;
		double imag;

		//--------------------------------------------------------------------------------
		void _init( void )
		{
			real = 0;
			imag = 0;
		}

		//--------------------------------------------------------------------------------
		double_complex operator * ( const double_complex& x1 )
		{
			double_complex Result;

			Result.real = ( real * x1.real ) + ( imag * x1.imag );
			Result.imag = ( real * x1.imag ) + ( imag * x1.real );

			return Result;
		}

		//--------------------------------------------------------------------------------
		void operator *= ( const double_complex& x ) { *this = *this * x; }

		//--------------------------------------------------------------------------------
		double_complex operator / ( const double_complex& x1 )
		{
			double_complex Result;
			Result._init();
			double_complex Denom;
			Denom.real = x1.real;
			Denom.imag = -x1.imag;
			double_complex Numer = *this * Denom;
			Denom *= x1;

			if( Denom.imag == 0 )
			{
				Result.real = Numer.real / Denom.real;
				Result.imag = Numer.imag / Denom.real;
			}

			return Result;
		}

	};

	//--------------------------------------------------------------------------------
	struct long_double_complex
	{
		long double real;
		long double imag;

		//--------------------------------------------------------------------------------
		void _init( void )
		{
			real = 0;
			imag = 0;
		}

		//--------------------------------------------------------------------------------
		long_double_complex operator * ( const long_double_complex& x1 )
		{
			long_double_complex Result;

			Result.real = ( real * x1.real ) + ( imag * x1.imag );
			Result.imag = ( real * x1.imag ) + ( imag * x1.real );

			return Result;
		}

		//--------------------------------------------------------------------------------
		void operator *= ( const long_double_complex& x ) { *this = *this * x; }

		//--------------------------------------------------------------------------------
		long_double_complex operator / ( const long_double_complex& x1 )
		{
			long_double_complex Result;
			Result._init();
			long_double_complex Denom;
			Denom.real = x1.real;
			Denom.imag = -x1.imag;
			long_double_complex Numer = *this * Denom;
			Denom *= x1;

			if( Denom.imag == 0 )
			{
				Result.real = Numer.real / Denom.real;
				Result.imag = Numer.imag / Denom.real;
			}

			return Result;
		}

	};

#endif


	//--------------------------------------------------------------------------------
	__QCMP_STATIC_CONSTANT( int, SemaphoreMaxValue = IntMax );

}//nsWin32


 /*
 #define DBL_MAX_EXP     1024                    // max binary exponent
 #define _DBL_RADIX      2                       // exponent radix
 #define _DBL_ROUNDS     1                       // addition rounding: near
 #define FLT_GUARD       0
 #define FLT_MAX_EXP     128                     // max binary exponent
 #define FLT_NORMALIZE   0
 #define FLT_ROUNDS      1                       // addition rounding: near
 #define LDBL_MAX_EXP    DBL_MAX_EXP             // max binary exponent
 #define _LDBL_RADIX     DBL_RADIX               // exponent radix
 #define _LDBL_ROUNDS    DBL_ROUNDS              // addition rounding: near
 #define _clear87        _clearfp
 #define _status87       _statusfp

 //Abstract User Status Word bit definitions

 #define _SW_INEXACT     0x00000001              // inexact (precision)
 #define _SW_UNDERFLOW   0x00000002              // underflow
 #define _SW_OVERFLOW    0x00000004              // overflow
 #define _SW_ZERODIVIDE  0x00000008              // zero divide
 #define _SW_INVALID     0x00000010              // invalid
 #define _SW_DENORMAL    0x00080000              // denormal status bit

 //New Control Bit that specifies the ambiguity in control word.

 #define _EM_AMBIGUIOUS  0x80000000                              // for backwards compatibility old spelling
 #define _EM_AMBIGUOUS   0x80000000

 //Abstract User Control Word Mask and bit definitions

 #define _MCW_EM         0x0008001f              // interrupt Exception Masks
 #define _EM_INEXACT     0x00000001              //   inexact (precision)
 #define _EM_UNDERFLOW   0x00000002              //   underflow
 #define _EM_OVERFLOW    0x00000004              //   overflow
 #define _EM_ZERODIVIDE  0x00000008              //   zero divide
 #define _EM_INVALID     0x00000010              //   invalid
 #define _EM_DENORMAL    0x00080000              // denormal exception mask (_control87 only)

 #define _MCW_RC         0x00000300              // Rounding Control
 #define _RC_NEAR        0x00000000              //   near
 #define _RC_DOWN        0x00000100              //   down
 #define _RC_UP          0x00000200              //   up
 #define _RC_CHOP        0x00000300              //   chop

 //i386 specific definitions

 #define _MCW_PC         0x00030000              // Precision Control
 #define _PC_64          0x00000000              //    64 bits
 #define _PC_53          0x00010000              //    53 bits
 #define _PC_24          0x00020000              //    24 bits

 #define _MCW_IC         0x00040000              // Infinity Control
 #define _IC_AFFINE      0x00040000              //   affine
 #define _IC_PROJECTIVE  0x00000000              //   projective

 //RISC specific definitions

 #define _MCW_DN         0x03000000              // Denormal Control
 #define _DN_SAVE        0x00000000              //   save denormal results and operands
 #define _DN_FLUSH       0x01000000              //   flush denormal results and operands to zero
 #define _DN_FLUSH_OPERANDS_SAVE_RESULTS 0x02000000  //   flush operands to zero and save results
 #define _DN_SAVE_OPERANDS_FLUSH_RESULTS 0x03000000  //   save operands and flush results to zero

 // initial Control Word value

 #if defined (_M_IX86)
 #define _CW_DEFAULT ( _RC_NEAR + _PC_53 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)
 #elif defined (_M_IA64)
 #define _CW_DEFAULT ( _RC_NEAR + _PC_64 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)
 #elif defined (_M_AMD64)
 #define _CW_DEFAULT ( _RC_NEAR + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)
 #endif  //defined (_M_AMD64)

 #define _fpecode        (*__fpecode())

 // invalid subconditions (_SW_INVALID also set)

 #define _SW_UNEMULATED          0x0040  // unemulated instruction
 #define _SW_SQRTNEG             0x0080  // square root of a neg number
 #define _SW_STACKOVERFLOW       0x0200  // FP stack overflow
 #define _SW_STACKUNDERFLOW      0x0400  // FP stack underflow
 */
 //  Floating point error signals and return codes

#define _FPE_INVALID            0x81
#define _FPE_DENORMAL           0x82
#define _FPE_ZERODIVIDE         0x83
#define _FPE_OVERFLOW           0x84
#define _FPE_UNDERFLOW          0x85
#define _FPE_INEXACT            0x86

#define _FPE_UNEMULATED         0x87
#define _FPE_SQRTNEG            0x88
#define _FPE_STACKOVERFLOW      0x8a
#define _FPE_STACKUNDERFLOW     0x8b

#define _FPE_EXPLICITGEN        0x8c    // raise( SIGFPE );

#define _FPCLASS_SNAN   0x0001  // signaling NaN 
#define _FPCLASS_QNAN   0x0002  // quiet NaN 
#define _FPCLASS_NINF   0x0004  // negative infinity 
#define _FPCLASS_NN     0x0008  // negative normal 
#define _FPCLASS_ND     0x0010  // negative denormal 
#define _FPCLASS_NZ     0x0020  // -0 
#define _FPCLASS_PZ     0x0040  // +0 
#define _FPCLASS_PD     0x0080  // positive denormal
#define _FPCLASS_PN     0x0100  // positive normal 
#define _FPCLASS_PINF   0x0200  // positive infinity
 /*
 #if !__STDC__

 // Non-ANSI names for compatibility

 #define clear87         _clear87
 #define status87        _status87
 #define control87       _control87

 #define DBL_RADIX               _DBL_RADIX
 #define DBL_ROUNDS              _DBL_ROUNDS

 #define LDBL_RADIX              _LDBL_RADIX
 #define LDBL_ROUNDS             _LDBL_ROUNDS

 #define EM_AMBIGUIOUS           _EM_AMBIGUOUS           // for backwards compatibility old spelling
 #define EM_AMBIGUOUS            _EM_AMBIGUOUS

 #define MCW_EM                  _MCW_EM
 #define EM_INVALID              _EM_INVALID
 #define EM_DENORMAL             _EM_DENORMAL
 #define EM_ZERODIVIDE           _EM_ZERODIVIDE
 #define EM_OVERFLOW             _EM_OVERFLOW
 #define EM_UNDERFLOW            _EM_UNDERFLOW
 #define EM_INEXACT              _EM_INEXACT

 #define MCW_IC                  _MCW_IC
 #define IC_AFFINE               _IC_AFFINE
 #define IC_PROJECTIVE           _IC_PROJECTIVE

 #define MCW_RC                  _MCW_RC
 #define RC_CHOP                 _RC_CHOP
 #define RC_UP                   _RC_UP
 #define RC_DOWN                 _RC_DOWN
 #define RC_NEAR                 _RC_NEAR

 #define MCW_PC                  _MCW_PC
 #define PC_24                   _PC_24
 #define PC_53                   _PC_53
 #define PC_64                   _PC_64

 #define CW_DEFAULT              _CW_DEFAULT

 #define SW_INVALID              _SW_INVALID
 #define SW_DENORMAL             _SW_DENORMAL
 #define SW_ZERODIVIDE           _SW_ZERODIVIDE
 #define SW_OVERFLOW             _SW_OVERFLOW
 #define SW_UNDERFLOW            _SW_UNDERFLOW
 #define SW_INEXACT              _SW_INEXACT

 #define SW_UNEMULATED           _SW_UNEMULATED
 #define SW_SQRTNEG              _SW_SQRTNEG
 #define SW_STACKOVERFLOW        _SW_STACKOVERFLOW
 #define SW_STACKUNDERFLOW       _SW_STACKUNDERFLOW

 #define FPE_INVALID             _FPE_INVALID
 #define FPE_DENORMAL            _FPE_DENORMAL
 #define FPE_ZERODIVIDE          _FPE_ZERODIVIDE
 #define FPE_OVERFLOW            _FPE_OVERFLOW
 #define FPE_UNDERFLOW           _FPE_UNDERFLOW
 #define FPE_INEXACT             _FPE_INEXACT

 #define FPE_UNEMULATED          _FPE_UNEMULATED
 #define FPE_SQRTNEG             _FPE_SQRTNEG
 #define FPE_STACKOVERFLOW       _FPE_STACKOVERFLOW
 #define FPE_STACKUNDERFLOW      _FPE_STACKUNDERFLOW

 #define FPE_EXPLICITGEN         _FPE_EXPLICITGEN

 #endif
 */

#define __WINPTHREADS_VERSION_MAJOR			0
#define __WINPTHREADS_VERSION_MINOR			5
#define __WINPTHREADS_VERSION_PATCHLEVEL	0

// MSB 8-bit major version, 8-bit minor version, 16-bit patch level.
#define __WINPTHREADS_VERSION 0x00050000

#define PTHREAD_BARRIER_SERIAL_THREAD	1
#define PTHREAD_CANCEL_ASYNCHRONOUS		0x02
#define PTHREAD_CANCEL_ENABLE			0x01
#define PTHREAD_CANCEL_DEFERRED			0
#define PTHREAD_CANCEL_DISABLE			0
#define PTHREAD_CANCELED				((void *) (Cmp_int_ptr) 0xDEADBEEF)
#define PTHREAD_CREATE_DETACHED			0x04
#define PTHREAD_CREATE_JOINABLE			0
#define PTHREAD_MUTEX_DEFAULT			PTHREAD_MUTEX_NORMAL
#define PTHREAD_MUTEX_ERRORCHECK		1
#define PTHREAD_MUTEX_NORMAL			0
#define PTHREAD_MUTEX_RECURSIVE			2
#define PTHREAD_MUTEX_ROBUST			//TODO
#define PTHREAD_MUTEX_STALLED			//TODO
#define PTHREAD_ONCE_INIT				0
#define PTHREAD_PROCESS_SHARED			1
#define PTHREAD_PROCESS_PRIVATE			0


//[TPS]
#define PTHREAD_EXPLICIT_SCHED			0
#define PTHREAD_INHERIT_SCHED			0x08
#define PTHREAD_SCOPE_PROCESS			0
#define PTHREAD_SCOPE_SYSTEM			0x10


//[RPI|TPI] 
#define PTHREAD_PRIO_INHERIT			8


//[MC1] 
#define PTHREAD_PRIO_NONE				0


//[RPP|TPP]
#define PTHREAD_PRIO_PROTECT			16

#define PTHREAD_COND_INITIALIZER			(::pthread_cond_t*)GENERIC_INITIALIZER
#define PTHREAD_MUTEX_INITIALIZER			(::pthread_mutex_t*)GENERIC_INITIALIZER
#define PTHREAD_RWLOCK_INITIALIZER			(::pthread_rwlock_t*)GENERIC_INITIALIZER

// Compatibility stuff:-----------------------------------------------------------

namespace nsWin32
{
	__QCMP_STATIC_CONSTANT( int, PThreadDestructorIterations = 256 );
	__QCMP_STATIC_CONSTANT( int, PThreadKeysMax = ( 1 << 20 ) );
	__QCMP_STATIC_CONSTANT( int, SemaphoresMax = 1024 );
	__QCMP_STATIC_CONSTANT( int, PThreadThreadsMax = 2019 );
};//namespace nsWin32

#define RWLS_PER_THREAD						8

#define PTHREAD_DEFAULT_ATTR				(PTHREAD_CANCEL_ENABLE)
#define _PTHREAD_NULL_THREAD				((::pthread_t) 0)

#define PTHREAD_MUTEX_SHARED				1
#define PTHREAD_MUTEX_PRIVATE				0
#define PTHREAD_PRIO_MULT					32

#define PTHREAD_MUTEX_FAST_NP				PTHREAD_MUTEX_NORMAL
#define PTHREAD_MUTEX_TIMED_NP				PTHREAD_MUTEX_FAST_NP
#define PTHREAD_MUTEX_ADAPTIVE_NP			PTHREAD_MUTEX_FAST_NP
#define PTHREAD_MUTEX_ERRORCHECK_NP			PTHREAD_MUTEX_ERRORCHECK
#define PTHREAD_MUTEX_RECURSIVE_NP			PTHREAD_MUTEX_RECURSIVE

#define	MAX_READ_LOCKS						(INT_MAX - 1)// maximum number of times a read lock may be obtained

  // Some POSIX realtime extensions, mostly stubbed 

#define PTHREAD_MUTEX_ERRORCHECK			1
#define PTHREAD_MUTEX_RECURSIVE				2

#define GENERIC_INITIALIZER					((void *) (size_t) -1)
#define GENERIC_ERRORCHECK_INITIALIZER		((void *) (size_t) -2)
#define GENERIC_RECURSIVE_INITIALIZER		((void *) (size_t) -3)
#define GENERIC_NORMAL_INITIALIZER			((void *) (size_t) -1)

#define PTHREAD_RECURSIVE_MUTEX_INITIALIZER		(pthread_mutex_t *)GENERIC_RECURSIVE_INITIALIZER
#define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER	(pthread_mutex_t *)GENERIC_ERRORCHECK_INITIALIZER
#define PTHREAD_NORMAL_MUTEX_INITIALIZER		(pthread_mutex_t *)GENERIC_NORMAL_INITIALIZER
#define PTHREAD_DEFAULT_MUTEX_INITIALIZER		PTHREAD_NORMAL_MUTEX_INITIALIZER
#define PTHREAD_SPINLOCK_INITIALIZER			(pthread_spinlock_t *)GENERIC_INITIALIZER

  //#define pthread_sigmask(H, S1, S2)				0

  //#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS     PTHREAD_DESTRUCTOR_ITERATIONS
  //#define _POSIX_THREAD_KEYS_MAX                  PTHREAD_KEYS_MAX
#define _POSIX_SEM_NSEMS_MAX                    256

#define PTHREAD_BARRIER_SERIAL_THREAD			1
#define PTHREAD_MUTEX_NORMAL					0
#define PTHREAD_MUTEX_ERRORCHECK				1
#define PTHREAD_MUTEX_RECURSIVE					2

#define GENERIC_INITIALIZER						((void *) (size_t) -1)
#define GENERIC_ERRORCHECK_INITIALIZER			((void *) (size_t) -2)
#define GENERIC_RECURSIVE_INITIALIZER			((void *) (size_t) -3)
#define GENERIC_NORMAL_INITIALIZER				((void *) (size_t) -1)
#define PTHREAD_NORMAL_MUTEX_INITIALIZER		(pthread_mutex_t *)GENERIC_NORMAL_INITIALIZER
#define PTHREAD_DEFAULT_MUTEX_INITIALIZER		PTHREAD_NORMAL_MUTEX_INITIALIZER

#define PTHREAD_PRIO_NONE						0
#define PTHREAD_PRIO_INHERIT					8
#define PTHREAD_PRIO_PROTECT					16
#define PTHREAD_PRIO_MULT						32
#define PTHREAD_PROCESS_SHARED					1
#define PTHREAD_PROCESS_PRIVATE					0
  /*
  #define SCHED_OTHER								0
  #define SCHED_FIFO								1
  #define SCHED_RR								2
  #define SCHED_MIN								SCHED_OTHER
  #define SCHED_MAX								SCHED_RR
  */
#define LIFE_THREAD								0xBAB1F00D
#define DEAD_THREAD								0xDEADBEEF

  //#define sched_rr_get_interval( _p, _i )			( errno = ENOTSUP, (int) -1 )

  //#define _POSIX_THREADS							200112L
  //#define _POSIX_READER_WRITER_LOCKS				200112L
  //#define _POSIX_SPIN_LOCKS						200112L
  //#define _POSIX_BARRIERS							200112L
  //#define _POSIX_THREAD_SAFE_FUNCTIONS			200112L
  //#define _POSIX_TIMEOUTS							200112L
  //#define _POSIX_CLOCK_SELECTION					200112
  //#define _POSIX_SEMAPHORES						200112
  //#define _POSIX_TIMERS							200809L
  //#define _POSIX_MONOTONIC_CLOCK					200809L
  //#define _POSIX_CPUTIME							200809L
  //#define _POSIX_THREAD_CPUTIME					200809L

  //--------------------------------------------------------------------------------
namespace nsWin32
{
	__QCMP_STATIC_CONSTANT( int, ClockRealtime = 0 );
	__QCMP_STATIC_CONSTANT( int, ClockMonotonic = 1 );
	__QCMP_STATIC_CONSTANT( int, ClockProcessCPUTimeID = 2 );
	__QCMP_STATIC_CONSTANT( int, ClockThreadCPUTimeID = 3 );

	__QCMP_STATIC_CONSTANT( int, TimerAbsTime = 1 );

	//--------------------------------------------------------------------------------
	struct pthread_attr_t
	{
		unsigned p_state;
		void *stack;
		size_t s_size;
		sched_param param;
	};

	typedef void*			pthread_barrier_t;
	typedef void*			pthread_barrierattr_t;
	typedef void*			pthread_cond_t;
	typedef int				pthread_condattr_t;
	typedef unsigned		pthread_key_t;
	typedef void*			pthread_mutex_t;
	typedef unsigned		pthread_mutexattr_t;
	typedef long			pthread_once_t;
	typedef void*			pthread_rwlock_t;
	typedef int				pthread_rwlockattr_t;
	typedef void*			pthread_spinlock_t;
	typedef Cmp_uint_ptr	pthread_t;

	//--------------------------------------------------------------------------------
	struct posix_trace_event_info
	{
		trace_event_id_t	posix_event_id;
		pid_t				posix_pid;
		void*				posix_prog_address;
		pthread_t			posix_thread_id;
		timespec			posix_timestamp;
		int					posix_truncation_status;
	};

	//--------------------------------------------------------------------------------
	struct _pthread_cleanup
	{
		void( *func )( void * );
		void* arg;
		_pthread_cleanup* next;
	};

	//--------------------------------------------------------------------------------
	struct spin_t
	{
		unsigned long owner;
		unsigned int valid;
		long l;
	};

	//--------------------------------------------------------------------------------
	struct _pthread_v
	{
		unsigned int valid;
		void *ret_arg;
		void *( *func )( void* );
		_pthread_cleanup* clean;
		int nobreak;
		nsWin32::CThread* h;
		nsWin32::CEvent* evStart;
		pthread_mutex_t p_clock;
		int cancelled : 2;
		int in_cancel : 2;
		int thread_noposix : 2;
		unsigned int p_state;
		unsigned int keymax;
		void** keyval;
		unsigned char* keyval_set;
		spin_t spin_keys;
		unsigned long tid;
		int rwlc;
		pthread_rwlock_t rwlq[ RWLS_PER_THREAD ];
		int sched_pol;
		int ended;
		sched_param sched;
		jmp_buf jb;
		_pthread_v* next;
		pthread_t x; // Internal posix handle.
	};

	//--------------------------------------------------------------------------------
	typedef struct __pthread_idlist
	{
		_pthread_v *ptr;
		pthread_t id;
	} __pthread_idlist;

}//nsWin32

#if defined(_M_X64)
__QCMP_STARTLINKAGE_C
extern void __cdecl __va_start( nsWin32::va_list *, ... );
__QCMP_ENDLINKAGE_C
#endif

__QCMP_STARTLINKAGE_C


#define cleanup_push(F, A)\
{\
    const _pthread_cleanup _pthread_cup = {(F), (A), *Cpthread::getclean()};\
    _ReadWriteBarrier();\
    *Cpthread::getclean() = (_pthread_cleanup *) &_pthread_cup;\
    _ReadWriteBarrier()


// Note that if async cancelling is used, then there is a race here 
#define cleanup_pop( E ) ( *Cpthread::getclean() = _pthread_cup.next, ( E ? _pthread_cup.func( (pthread_once_t*)_pthread_cup.arg ) : 0 ) ); }

///* Windows doesn't have this, so declare it ourselves. */
//#ifndef _TIMESPEC_DEFINED
//#define _TIMESPEC_DEFINED
//struct timespec {
//  time_t  tv_sec;   /* Seconds */
//  long    tv_nsec;  /* Nanoseconds */
//};

//struct itimerspec {
//  struct timespec  it_interval;  /* Timer period */
//  struct timespec  it_value;     /* Timer expiration */
//};
//#endif


//TODO: define in the right place


// Recursive API emulation. 
/*
#undef localtime_r
#define localtime_r(_Time, _Tm)	({ struct tm *___tmp_tm;		\
pthread_testcancel();	\
___tmp_tm = localtime((_Time));\
if (___tmp_tm) {	\
*(_Tm) = *___tmp_tm;	\
___tmp_tm = (_Tm);	\
}			\
___tmp_tm;	})

#undef gmtime_r
#define gmtime_r(_Time,_Tm)	({ struct tm *___tmp_tm;		\
pthread_testcancel();	\
___tmp_tm = gmtime((_Time)); \
if (___tmp_tm) {	\
*(_Tm) = *___tmp_tm;	\
___tmp_tm = (_Tm);	\
}			\
___tmp_tm;	})

#undef ctime_r
#define ctime_r(_Time,_Str)	({ char *___tmp_tm;			\
pthread_testcancel();	\
___tmp_tm = ctime((_Time));  \
if (___tmp_tm)		\
___tmp_tm =		\
strcpy((_Str),___tmp_tm); \
___tmp_tm;	})

//use interface function version instead
#undef asctime_r
#define asctime_r(_Tm, _Buf)	({ char *___tmp_tm;			\
pthread_testcancel();	\
___tmp_tm = asctime((_Tm)); \
if (___tmp_tm)		\
___tmp_tm =		\
strcpy((_Buf),___tmp_tm);\
___tmp_tm;	})
*/

//TODO: #include <pthread_unistd.h>


/* Wrap cancellation points.  */
#ifdef __WINPTRHEAD_ENABLE_WRAP_API
#define accept(...) (pthread_testcancel(), accept(__VA_ARGS__))
#define aio_suspend(...) (pthread_testcancel(), aio_suspend(__VA_ARGS__))
#define clock_nanosleep(...) (pthread_testcancel(), clock_nanosleep(__VA_ARGS__))
#define close(...) (pthread_testcancel(), close(__VA_ARGS__))
#define connect(...) (pthread_testcancel(), connect(__VA_ARGS__))
#define creat(...) (pthread_testcancel(), creat(__VA_ARGS__))
#define fcntl(...) (pthread_testcancel(), fcntl(__VA_ARGS__))
#define fdatasync(...) (pthread_testcancel(), fdatasync(__VA_ARGS__))
#define fsync(...) (pthread_testcancel(), fsync(__VA_ARGS__))
#define getmsg(...) (pthread_testcancel(), getmsg(__VA_ARGS__))
#define getpmsg(...) (pthread_testcancel(), getpmsg(__VA_ARGS__))
#define lockf(...) (pthread_testcancel(), lockf(__VA_ARGS__))
#define mg_receive(...) (pthread_testcancel(), mg_receive(__VA_ARGS__))
#define mg_send(...) (pthread_testcancel(), mg_send(__VA_ARGS__))
#define mg_timedreceive(...) (pthread_testcancel(), mg_timedreceive(__VA_ARGS__))
#define mg_timessend(...) (pthread_testcancel(), mg_timedsend(__VA_ARGS__))
#define msgrcv(...) (pthread_testcancel(), msgrecv(__VA_ARGS__))
#define msgsnd(...) (pthread_testcancel(), msgsnd(__VA_ARGS__))
#define msync(...) (pthread_testcancel(), msync(__VA_ARGS__))
#define nanosleep(...) (pthread_testcancel(), nanosleep(__VA_ARGS__))
#define open(...) (pthread_testcancel(), open(__VA_ARGS__))
#define pause(...) (pthread_testcancel(), pause(__VA_ARGS__))
#define poll(...) (pthread_testcancel(), poll(__VA_ARGS__))
#define pread(...) (pthread_testcancel(), pread(__VA_ARGS__))
#define pselect(...) (pthread_testcancel(), pselect(__VA_ARGS__))
#define putmsg(...) (pthread_testcancel(), putmsg(__VA_ARGS__))
#define putpmsg(...) (pthread_testcancel(), putpmsg(__VA_ARGS__))
#define pwrite(...) (pthread_testcancel(), pwrite(__VA_ARGS__))
#define read(...) (pthread_testcancel(), read(__VA_ARGS__))
#define readv(...) (pthread_testcancel(), readv(__VA_ARGS__))
#define recv(...) (pthread_testcancel(), recv(__VA_ARGS__))
#define recvfrom(...) (pthread_testcancel(), recvfrom(__VA_ARGS__))
#define recvmsg(...) (pthread_testcancel(), recvmsg(__VA_ARGS__))
#define select(...) (pthread_testcancel(), select(__VA_ARGS__))
#define sem_timedwait(...) (pthread_testcancel(), sem_timedwait(__VA_ARGS__))
#define sem_wait(...) (pthread_testcancel(), sem_wait(__VA_ARGS__))
#define send(...) (pthread_testcancel(), send(__VA_ARGS__))
#define sendmsg(...) (pthread_testcancel(), sendmsg(__VA_ARGS__))
#define sendto(...) (pthread_testcancel(), sendto(__VA_ARGS__))
#define sigpause(...) (pthread_testcancel(), sigpause(__VA_ARGS__))
#define sigsuspend(...) (pthread_testcancel(), sigsuspend(__VA_ARGS__))
#define sigwait(...) (pthread_testcancel(), sigwait(__VA_ARGS__))
#define sigwaitinfo(...) (pthread_testcancel(), sigwaitinfo(__VA_ARGS__))
#define sleep(...) (pthread_testcancel(), sleep(__VA_ARGS__))
//#define Sleep(...) (pthread_testcancel(), Sleep(__VA_ARGS__))
#define system(...) (pthread_testcancel(), system(__VA_ARGS__))
#define access(...) (pthread_testcancel(), access(__VA_ARGS__))
#define asctime(...) (pthread_testcancel(), asctime(__VA_ARGS__))
#define catclose(...) (pthread_testcancel(), catclose(__VA_ARGS__))
#define catgets(...) (pthread_testcancel(), catgets(__VA_ARGS__))
#define catopen(...) (pthread_testcancel(), catopen(__VA_ARGS__))
#define closedir(...) (pthread_testcancel(), closedir(__VA_ARGS__))
#define closelog(...) (pthread_testcancel(), closelog(__VA_ARGS__))
#define ctermid(...) (pthread_testcancel(), ctermid(__VA_ARGS__))
#define ctime(...) (pthread_testcancel(), ctime(__VA_ARGS__))
#define dbm_close(...) (pthread_testcancel(), dbm_close(__VA_ARGS__))
#define dbm_delete(...) (pthread_testcancel(), dbm_delete(__VA_ARGS__))
#define dbm_fetch(...) (pthread_testcancel(), dbm_fetch(__VA_ARGS__))
#define dbm_nextkey(...) (pthread_testcancel(), dbm_nextkey(__VA_ARGS__))
#define dbm_open(...) (pthread_testcancel(), dbm_open(__VA_ARGS__))
#define dbm_store(...) (pthread_testcancel(), dbm_store(__VA_ARGS__))
#define dlclose(...) (pthread_testcancel(), dlclose(__VA_ARGS__))
#define dlopen(...) (pthread_testcancel(), dlopen(__VA_ARGS__))
#define endgrent(...) (pthread_testcancel(), endgrent(__VA_ARGS__))
#define endhostent(...) (pthread_testcancel(), endhostent(__VA_ARGS__))
#define endnetent(...) (pthread_testcancel(), endnetent(__VA_ARGS__))
#define endprotoent(...) (pthread_testcancel(), endprotoend(__VA_ARGS__))
#define endpwent(...) (pthread_testcancel(), endpwent(__VA_ARGS__))
#define endservent(...) (pthread_testcancel(), endservent(__VA_ARGS__))
#define endutxent(...) (pthread_testcancel(), endutxent(__VA_ARGS__))
#define fclose(...) (pthread_testcancel(), fclose(__VA_ARGS__))
#define fflush(...) (pthread_testcancel(), fflush(__VA_ARGS__))
#define fgetc(...) (pthread_testcancel(), fgetc(__VA_ARGS__))
#define fgetpos(...) (pthread_testcancel(), fgetpos(__VA_ARGS__))
#define fgets(...) (pthread_testcancel(), fgets(__VA_ARGS__))
#define fgetwc(...) (pthread_testcancel(), fgetwc(__VA_ARGS__))
#define fgetws(...) (pthread_testcancel(), fgetws(__VA_ARGS__))
#define fmtmsg(...) (pthread_testcancel(), fmtmsg(__VA_ARGS__))
#define fopen(...) (pthread_testcancel(), fopen(__VA_ARGS__))
#define fpathconf(...) (pthread_testcancel(), fpathconf(__VA_ARGS__))
#define fprintf(...) (pthread_testcancel(), fprintf(__VA_ARGS__))
#define fputc(...) (pthread_testcancel(), fputc(__VA_ARGS__))
#define fputs(...) (pthread_testcancel(), fputs(__VA_ARGS__))
#define fputwc(...) (pthread_testcancel(), fputwc(__VA_ARGS__))
#define fputws(...) (pthread_testcancel(), fputws(__VA_ARGS__))
#define fread(...) (pthread_testcancel(), fread(__VA_ARGS__))
#define freopen(...) (pthread_testcancel(), freopen(__VA_ARGS__))
#define fscanf(...) (pthread_testcancel(), fscanf(__VA_ARGS__))
#define fseek(...) (pthread_testcancel(), fseek(__VA_ARGS__))
#define fseeko(...) (pthread_testcancel(), fseeko(__VA_ARGS__))
#define fsetpos(...) (pthread_testcancel(), fsetpos(__VA_ARGS__))
#define fstat(...) (pthread_testcancel(), fstat(__VA_ARGS__))
#define ftell(...) (pthread_testcancel(), ftell(__VA_ARGS__))
#define ftello(...) (pthread_testcancel(), ftello(__VA_ARGS__))
#define ftw(...) (pthread_testcancel(), ftw(__VA_ARGS__))
#define fwprintf(...) (pthread_testcancel(), fwprintf(__VA_ARGS__))
#define fwrite(...) (pthread_testcancel(), fwrite(__VA_ARGS__))
#define fwscanf(...) (pthread_testcancel(), fwscanf(__VA_ARGS__))
#define getaddrinfo(...) (pthread_testcancel(), getaddrinfo(__VA_ARGS__))
#define getc(...) (pthread_testcancel(), getc(__VA_ARGS__))
#define getc_unlocked(...) (pthread_testcancel(), getc_unlocked(__VA_ARGS__))
#define getchar(...) (pthread_testcancel(), getchar(__VA_ARGS__))
#define getchar_unlocked(...) (pthread_testcancel(), getchar_unlocked(__VA_ARGS__))
#define getcwd(...) (pthread_testcancel(), getcwd(__VA_ARGS__))
#define getdate(...) (pthread_testcancel(), getdate(__VA_ARGS__))
#define getgrent(...) (pthread_testcancel(), getgrent(__VA_ARGS__))
#define getgrgid(...) (pthread_testcancel(), getgrgid(__VA_ARGS__))
#define getgrgid_r(...) (pthread_testcancel(), getgrgid_r(__VA_ARGS__))
#define gergrnam(...) (pthread_testcancel(), getgrnam(__VA_ARGS__))
#define getgrnam_r(...) (pthread_testcancel(), getgrnam_r(__VA_ARGS__))
#define gethostbyaddr(...) (pthread_testcancel(), gethostbyaddr(__VA_ARGS__))
#define gethostbyname(...) (pthread_testcancel(), gethostbyname(__VA_ARGS__))
#define gethostent(...) (pthread_testcancel(), gethostent(__VA_ARGS__))
#define gethostid(...) (pthread_testcancel(), gethostid(__VA_ARGS__))
#define gethostname(...) (pthread_testcancel(), gethostname(__VA_ARGS__))
#define getlogin(...) (pthread_testcancel(), getlogin(__VA_ARGS__))
#define getlogin_r(...) (pthread_testcancel(), getlogin_r(__VA_ARGS__))
#define getnameinfo(...) (pthread_testcancel(), getnameinfo(__VA_ARGS__))
#define getnetbyaddr(...) (pthread_testcancel(), getnetbyaddr(__VA_ARGS__))
#define getnetbyname(...) (pthread_testcancel(), getnetbyname(__VA_ARGS__))
#define getnetent(...) (pthread_testcancel(), getnetent(__VA_ARGS__))
#define getopt(...) (pthread_testcancel(), getopt(__VA_ARGS__))
#define getprotobyname(...) (pthread_testcancel(), getprotobyname(__VA_ARGS__))
#define getprotobynumber(...) (pthread_testcancel(), getprotobynumber(__VA_ARGS__))
#define getprotoent(...) (pthread_testcancel(), getprotoent(__VA_ARGS__))
#define getpwent(...) (pthread_testcancel(), getpwent(__VA_ARGS__))
#define getpwnam(...) (pthread_testcancel(), getpwnam(__VA_ARGS__))
#define getpwnam_r(...) (pthread_testcancel(), getpwnam_r(__VA_ARGS__))
#define getpwuid(...) (pthread_testcancel(), getpwuid(__VA_ARGS__))
#define getpwuid_r(...) (pthread_testcancel(), getpwuid_r(__VA_ARGS__))
#define gets(...) (pthread_testcancel(), gets(__VA_ARGS__))
#define getservbyname(...) (pthread_testcancel(), getservbyname(__VA_ARGS__))
#define getservbyport(...) (pthread_testcancel(), getservbyport(__VA_ARGS__))
#define getservent(...) (pthread_testcancel(), getservent(__VA_ARGS__))
#define getutxent(...) (pthread_testcancel(), getutxent(__VA_ARGS__))
#define getutxid(...) (pthread_testcancel(), getutxid(__VA_ARGS__))
#define getutxline(...) (pthread_testcancel(), getutxline(__VA_ARGS__))
#undef getwc
#define getwc(...) (pthread_testcancel(), getwc(__VA_ARGS__))
#undef getwchar
#define getwchar(...) (pthread_testcancel(), getwchar(__VA_ARGS__))
#define getwd(...) (pthread_testcancel(), getwd(__VA_ARGS__))
#define glob(...) (pthread_testcancel(), glob(__VA_ARGS__))
#define iconv_close(...) (pthread_testcancel(), iconv_close(__VA_ARGS__))
#define iconv_open(...) (pthread_testcancel(), iconv_open(__VA_ARGS__))
#define ioctl(...) (pthread_testcancel(), ioctl(__VA_ARGS__))
#define link(...) (pthread_testcancel(), link(__VA_ARGS__))
#define localtime(...) (pthread_testcancel(), localtime(__VA_ARGS__))
#define lseek(...) (pthread_testcancel(), lseek(__VA_ARGS__))
#define lstat(...) (pthread_testcancel(), lstat(__VA_ARGS__))
#define mkstemp(...) (pthread_testcancel(), mkstemp(__VA_ARGS__))
#define nftw(...) (pthread_testcancel(), nftw(__VA_ARGS__))
#define opendir(...) (pthread_testcancel(), opendir(__VA_ARGS__))
#define openlog(...) (pthread_testcancel(), openlog(__VA_ARGS__))
#define pathconf(...) (pthread_testcancel(), pathconf(__VA_ARGS__))
#define pclose(...) (pthread_testcancel(), pclose(__VA_ARGS__))
#define perror(...) (pthread_testcancel(), perror(__VA_ARGS__))
#define popen(...) (pthread_testcancel(), popen(__VA_ARGS__))
#define posix_fadvise(...) (pthread_testcancel(), posix_fadvise(__VA_ARGS__))
#define posix_fallocate(...) (pthread_testcancel(), posix_fallocate(__VA_ARGS__))
#define posix_madvise(...) (pthread_testcancel(), posix_madvise(__VA_ARGS__))
#define posix_openpt(...) (pthread_testcancel(), posix_openpt(__VA_ARGS__))
#define posix_spawn(...) (pthread_testcancel(), posix_spawn(__VA_ARGS__))
#define posix_spawnp(...) (pthread_testcancel(), posix_spawnp(__VA_ARGS__))
#define posix_trace_clear(...) (pthread_testcancel(), posix_trace_clear(__VA_ARGS__))
#define posix_trace_close(...) (pthread_testcancel(), posix_trace_close(__VA_ARGS__))
#define posix_trace_create(...) (pthread_testcancel(), posix_trace_create(__VA_ARGS__))
#define posix_trace_create_withlog(...) (pthread_testcancel(), posix_trace_create_withlog(__VA_ARGS__))
#define posix_trace_eventtypelist_getne(...) (pthread_testcancel(), posix_trace_eventtypelist_getne(__VA_ARGS__))
#define posix_trace_eventtypelist_rewin(...) (pthread_testcancel(), posix_trace_eventtypelist_rewin(__VA_ARGS__))
#define posix_trace_flush(...) (pthread_testcancel(), posix_trace_flush(__VA_ARGS__))
#define posix_trace_get_attr(...) (pthread_testcancel(), posix_trace_get_attr(__VA_ARGS__))
#define posix_trace_get_filter(...) (pthread_testcancel(), posix_trace_get_filter(__VA_ARGS__))
#define posix_trace_get_status(...) (pthread_testcancel(), posix_trace_get_status(__VA_ARGS__))
#define posix_trace_getnext_event(...) (pthread_testcancel(), posix_trace_getnext_event(__VA_ARGS__))
#define posix_trace_open(...) (pthread_testcancel(), posix_trace_open(__VA_ARGS__))
#define posix_trace_rewind(...) (pthread_testcancel(), posix_trace_rewind(__VA_ARGS__))
#define posix_trace_setfilter(...) (pthread_testcancel(), posix_trace_setfilter(__VA_ARGS__))
#define posix_trace_shutdown(...) (pthread_testcancel(), posix_trace_shutdown(__VA_ARGS__))
#define posix_trace_timedgetnext_event(...) (pthread_testcancel(), posix_trace_timedgetnext_event(__VA_ARGS__))
#define posix_typed_mem_open(...) (pthread_testcancel(), posix_typed_mem_open(__VA_ARGS__))
#define printf(...) (pthread_testcancel(), printf(__VA_ARGS__))
#define putc(...) (pthread_testcancel(), putc(__VA_ARGS__))
#define putc_unlocked(...) (pthread_testcancel(), putc_unlocked(__VA_ARGS__))
#define putchar(...) (pthread_testcancel(), putchar(__VA_ARGS__))
#define putchar_unlocked(...) (pthread_testcancel(), putchar_unlocked(__VA_ARGS__))
#define puts(...) (pthread_testcancel(), puts(__VA_ARGS__))
#define pututxline(...) (pthread_testcancel(), pututxline(__VA_ARGS__))
#undef putwc
#define putwc(...) (pthread_testcancel(), putwc(__VA_ARGS__))
#undef putwchar
#define putwchar(...) (pthread_testcancel(), putwchar(__VA_ARGS__))
#define readdir(...) (pthread_testcancel(), readdir(__VA_ARSG__))
#define readdir_r(...) (pthread_testcancel(), readdir_r(__VA_ARGS__))
#define remove(...) (pthread_testcancel(), remove(__VA_ARGS__))
#define rename(...) (pthread_testcancel(), rename(__VA_ARGS__))
#define rewind(...) (pthread_testcancel(), rewind(__VA_ARGS__))
#define rewinddir(...) (pthread_testcancel(), rewinddir(__VA_ARGS__))
#define scanf(...) (pthread_testcancel(), scanf(__VA_ARGS__))
#define seekdir(...) (pthread_testcancel(), seekdir(__VA_ARGS__))
#define semop(...) (pthread_testcancel(), semop(__VA_ARGS__))
#define setgrent(...) (pthread_testcancel(), setgrent(__VA_ARGS__))
#define sethostent(...) (pthread_testcancel(), sethostemt(__VA_ARGS__))
#define setnetent(...) (pthread_testcancel(), setnetent(__VA_ARGS__))
#define setprotoent(...) (pthread_testcancel(), setprotoent(__VA_ARGS__))
#define setpwent(...) (pthread_testcancel(), setpwent(__VA_ARGS__))
#define setservent(...) (pthread_testcancel(), setservent(__VA_ARGS__))
#define setutxent(...) (pthread_testcancel(), setutxent(__VA_ARGS__))
#define stat(...) (pthread_testcancel(), stat(__VA_ARGS__))
#define strerror(...) (pthread_testcancel(), strerror(__VA_ARGS__))
#define strerror_r(...) (pthread_testcancel(), strerror_r(__VA_ARGS__))
#define strftime(...) (pthread_testcancel(), strftime(__VA_ARGS__))
#define symlink(...) (pthread_testcancel(), symlink(__VA_ARGS__))
#define sync(...) (pthread_testcancel(), sync(__VA_ARGS__))
#define syslog(...) (pthread_testcancel(), syslog(__VA_ARGS__))
#define tmpfile(...) (pthread_testcancel(), tmpfile(__VA_ARGS__))
#define tmpnam(...) (pthread_testcancel(), tmpnam(__VA_ARGS__))
#define ttyname(...) (pthread_testcancel(), ttyname(__VA_ARGS__))
#define ttyname_r(...) (pthread_testcancel(), ttyname_r(__VA_ARGS__))
#define tzset(...) (pthread_testcancel(), tzset(__VA_ARGS__))
#define ungetc(...) (pthread_testcancel(), ungetc(__VA_ARGS__))
#define ungetwc(...) (pthread_testcancel(), ungetwc(__VA_ARGS__))
#define unlink(...) (pthread_testcancel(), unlink(__VA_ARGS__))
#define vfprintf(...) (pthread_testcancel(), vfprintf(__VA_ARGS__))
#define vfwprintf(...) (pthread_testcancel(), vfwprintf(__VA_ARGS__))
#define vprintf(...) (pthread_testcancel(), vprintf(__VA_ARGS__))
#define vwprintf(...) (pthread_testcancel(), vwprintf(__VA_ARGS__))
#define wcsftime(...) (pthread_testcancel(), wcsftime(__VA_ARGS__))
#define wordexp(...) (pthread_testcancel(), wordexp(__VA_ARGS__))
#define wprintf(...) (pthread_testcancel(), wprintf(__VA_ARGS__))
#define wscanf(...) (pthread_testcancel(), wscanf(__VA_ARGS__))
#endif

__QCMP_ENDLINKAGE_C

#endif//WIN32_SYS_TYPES_H
