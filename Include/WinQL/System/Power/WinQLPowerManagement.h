//WinQLPowerManagement.h

// Copyright Querysoft Limited 2015, 2017
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef WINQL_SYSTEM_POWER_H_3
#define WINQL_SYSTEM_POWER_H_3

#include "CompilerQOR.h"

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "CodeQOR/DataTypes/GUID.h"
#include "WinQL/Definitions/Data.h"
#include "WinQL/Definitions/Security.h"
#include "WinQL/System/FileSystem/WinQLFile.h"
#include "WinQL/CodeServices/Handles/WinQLRAIISessionHandle.h"
#include "WinQL/CodeServices/WinQLSharedRef.h"
#include "WinQL/System/Devices/Instances/WinQLDeviceInstance.h"

//--------------------------------------------------------------------------------
namespace nsWinQAPI
{
	class __QOR_INTERFACE( __WINQAPI ) CUser32;
	class __QOR_INTERFACE( __WINQAPI ) CPowerProf;
}

//--------------------------------------------------------------------------------
namespace nsWin32
{
	//--------------------------------------------------------------------------------
	struct SystemPowerStatus 
	{
		unsigned char ACLineStatus;
		unsigned char BatteryFlag;
		unsigned char BatteryLifePercent;
		unsigned char Reserved1;
		unsigned long BatteryLifeTime;
		unsigned long BatteryFullLifeTime;
	};

	//--------------------------------------------------------------------------------
	typedef enum 
	{
		LTDontCare,
		LTLowestLatency
	} eLatency_Time;

	//--------------------------------------------------------------------------------
	enum ePowerPlatformRole
	{
		PlatformRoleUnspecified = 0,
		PlatformRoleDesktop,
		PlatformRoleMobile,
		PlatformRoleWorkstation,
		PlatformRoleEnterpriseServer,
		PlatformRoleSOHOServer,
		PlatformRoleAppliancePC,
		PlatformRolePerformanceServer,
		PlatformRoleMaximum
	};

	//--------------------------------------------------------------------------------
	enum ePowerAction
	{
		PowerActionNone = 0,
		PowerActionReserved,
		PowerActionSleep,
		PowerActionHibernate,
		PowerActionShutdown,
		PowerActionShutdownReset,
		PowerActionShutdownOff,
		PowerActionWarmEject
	};

	//--------------------------------------------------------------------------------
	struct Power_Action_Policy
	{
		ePowerAction    Action;
		unsigned long	Flags;
		unsigned long	EventCode;
	};

	//--------------------------------------------------------------------------------
	struct User_Power_Policy
	{
		unsigned long			Revision;       // 1

		// "system idle" detection
		Power_Action_Policy		IdleAc;
		Power_Action_Policy		IdleDc;
		unsigned long			IdleTimeoutAc;
		unsigned long			IdleTimeoutDc;
		unsigned char			IdleSensitivityAc;
		unsigned char			IdleSensitivityDc;
    
		// Throttling Policy
		unsigned char			ThrottlePolicyAc;
		unsigned char			ThrottlePolicyDc;

		// meaning of power action "sleep"
		eSystem_Power_State		MaxSleepAc;
		eSystem_Power_State		MaxSleepDc;

		// For future use
		unsigned long			Reserved[2];

		// video policies
		unsigned long			VideoTimeoutAc;
		unsigned long			VideoTimeoutDc;

		// hard disk policies
		unsigned long			SpindownTimeoutAc;
		unsigned long			SpindownTimeoutDc;

		// processor policies
		byte					OptimizeForPowerAc;
		byte					OptimizeForPowerDc;
		unsigned char			FanThrottleToleranceAc;
		unsigned char			FanThrottleToleranceDc;
		unsigned char			ForcedThrottleAc;
		unsigned char			ForcedThrottleDc;
    
	};

	//--------------------------------------------------------------------------------
	struct Machine_Power_Policy
	{
		unsigned long			Revision;       // 1

		// meaning of power action "sleep"
		eSystem_Power_State      MinSleepAc;
		eSystem_Power_State      MinSleepDc;
		eSystem_Power_State      ReducedLatencySleepAc;
		eSystem_Power_State      ReducedLatencySleepDc;

		// parameters for dozing
		unsigned long			DozeTimeoutAc;
		unsigned long			DozeTimeoutDc;
		unsigned long			DozeS4TimeoutAc;
		unsigned long			DozeS4TimeoutDc;

		// processor policies
		unsigned char			MinThrottleAc;
		unsigned char			MinThrottleDc;
		unsigned char			pad1[2];
		Power_Action_Policy		OverThrottledAc;
		Power_Action_Policy		OverThrottledDc;

	};

	//--------------------------------------------------------------------------------
	struct Processor_Power_Policy_Info
	{
		// Time based information (will be converted to kernel units)
		unsigned long			TimeCheck;                      // in US
		unsigned long			DemoteLimit;                    // in US
		unsigned long			PromoteLimit;                   // in US

		// Percentage based information
		byte					DemotePercent;
		byte					PromotePercent;
		byte					Spare[2];

		// Flags
		unsigned long			AllowDemotion:1;
		unsigned long			AllowPromotion:1;
		unsigned long			Reserved:30;
	};

	//--------------------------------------------------------------------------------
	struct Processor_Power_Policy
	{
		unsigned long				Revision;

		// Dynamic Throttling Policy
		byte						DynamicThrottle;
		byte						Spare[3];

		// Flags
		unsigned long				DisableCStates:1;
		unsigned long				Reserved:31;

		// System policy information
		// The Array is last, in case it needs to be grown and the structure
		// revision incremented.
		unsigned long				PolicyCount;
		Processor_Power_Policy_Info Policy[3];
	};

	//--------------------------------------------------------------------------------
	struct Machine_Processor_Power_Policy
	{
		unsigned long			Revision;       // 1
    
		Processor_Power_Policy	ProcessorPolicyAc;    
		Processor_Power_Policy  ProcessorPolicyDc;    

	};

	//--------------------------------------------------------------------------------
	struct Power_Policy
	{
		User_Power_Policy		user;
		Machine_Power_Policy    mach;
	};

	//--------------------------------------------------------------------------------
	struct Battery_Reporting_Scale
	{
		unsigned long		Granularity;
		unsigned long		Capacity;
	};

	//--------------------------------------------------------------------------------
	struct System_Power_Capabilities
	{
		// Misc supported system features
		byte				PowerButtonPresent;
		byte				SleepButtonPresent;
		byte				LidPresent;
		byte				SystemS1;
		byte				SystemS2;
		byte				SystemS3;
		byte				SystemS4;           // hibernate
		byte				SystemS5;           // off
		byte				HiberFilePresent;
		byte				FullWake;
		byte				VideoDimPresent;
		byte				ApmPresent;
		byte				UpsPresent;

		// Processors
		byte				ThermalControl;
		byte				ProcessorThrottle;
		byte				ProcessorMinThrottle;

	#if (NTDDI_VERSION < NTDDI_WINXP)
		byte				ProcessorThrottleScale;
		byte				spare2[4];
	#else
		byte				ProcessorMaxThrottle;
		byte				FastSystemS4;
		byte				spare2[3];
	#endif // (NTDDI_VERSION < NTDDI_WINXP)

		// Disk
		byte				DiskSpinDown;
		byte				spare3[8];

		// System Battery
		byte				SystemBatteriesPresent;
		byte				BatteriesAreShortTerm;
		Battery_Reporting_Scale BatteryScale[3];

		// Wake
		eSystem_Power_State	AcOnLineWake;
		eSystem_Power_State	SoftLidWake;
		eSystem_Power_State	RtcWake;
		eSystem_Power_State	MinDeviceWakeState; // note this may change on driver load
		eSystem_Power_State	DefaultLowLatencyWake;
	};

	//--------------------------------------------------------------------------------
	struct System_Power_Level
	{
		byte					Enable;
		byte					Spare[3];
		unsigned long			BatteryLevel;
		Power_Action_Policy		PowerPolicy;
		eSystem_Power_State		MinSystemState;
	};

#	define Num_Discharge_Policies		4
#	define Discharge_Policy_Critical	0
#	define Discharge_Policy_Low			1

	//--------------------------------------------------------------------------------
	struct Global_User_Power_Policy
	{
		unsigned long			Revision;
		Power_Action_Policy		PowerButtonAc;
		Power_Action_Policy		PowerButtonDc;
		Power_Action_Policy		SleepButtonAc;
		Power_Action_Policy		SleepButtonDc;
		Power_Action_Policy		LidCloseAc;
		Power_Action_Policy		LidCloseDc;
		System_Power_Level		DischargePolicy[ Num_Discharge_Policies ];
		unsigned long			GlobalFlags;
	};

	//--------------------------------------------------------------------------------
	struct Global_Machine_Power_Policy
	{
		unsigned long		Revision;
		eSystem_Power_State	LidOpenWakeAc;
		eSystem_Power_State	LidOpenWakeDc;
		unsigned long		BroadcastCapacityResolution;
	};

	//--------------------------------------------------------------------------------
	struct Global_Power_Policy
	{
		Global_User_Power_Policy	user;
		Global_Machine_Power_Policy mach;
	};

	//--------------------------------------------------------------------------------
	enum ePower_Information_Level
	{
		SystemPowerPolicyAc,
		SystemPowerPolicyDc,
		VerifySystemPolicyAc,
		VerifySystemPolicyDc,
		SystemPowerCapabilities,
		SystemBatteryState,
		SystemPowerStateHandler,
		ProcessorStateHandler,
		SystemPowerPolicyCurrent,
		AdministratorPowerPolicy,
		SystemReserveHiberFile,
		ProcessorInformation,
		SystemPowerInformation,
		ProcessorStateHandler2,
		LastWakeTime,                                   // Compare with KeQueryInterruptTime()
		LastSleepTime,                                  // Compare with KeQueryInterruptTime()
		SystemExecutionState,
		SystemPowerStateNotifyHandler,
		ProcessorPowerPolicyAc,
		ProcessorPowerPolicyDc,
		VerifyProcessorPowerPolicyAc,
		VerifyProcessorPowerPolicyDc,
		ProcessorPowerPolicyCurrent,
		SystemPowerStateLogging,
		SystemPowerLoggingEntry,
		SetPowerSettingValue,
		NotifyUserPowerSetting,
		PowerInformationLevelUnused0,
		PowerInformationLevelUnused1,
		SystemVideoState,
		TraceApplicationPowerMessage,
		TraceApplicationPowerMessageEnd,
		ProcessorPerfStates,
		ProcessorIdleStates,
		ProcessorCap,
		SystemWakeSource,
		SystemHiberFileInformation,
		TraceServicePowerMessage,
		ProcessorLoad,
		PowerShutdownNotification,
		MonitorCapabilities,
		SessionPowerInit,
		SessionDisplayState,
		PowerRequestCreate,
		PowerRequestAction,
		GetPowerRequestList,
		ProcessorInformationEx,
		NotifyUserModeLegacyPowerEvent,
		GroupPark,
		ProcessorIdleDomains,
		WakeTimerList,
		SystemHiberFileSize,
		PowerInformationLevelMaximum
	};

	//--------------------------------------------------------------------------------
	struct Reason_Context
	{
		//--------------------------------------------------------------------------------
		struct Detail
		{
			void* LocalizedReasonModule;
			unsigned long LocalizedReasonId;
			unsigned long ReasonStringCount;
			wchar_t** ReasonStrings;

		};

		unsigned long Version;
		unsigned long Flags;

		//--------------------------------------------------------------------------------
		union 
		{
			Detail Detailed;
			wchar_t* SimpleReasonString;
		} Reason;
	};


	//--------------------------------------------------------------------------------
	enum ePower_Request_Type
	{
		PowerRequestDisplayRequired,
		PowerRequestSystemRequired,
		PowerRequestAwayModeRequired,
		PowerRequestExecutionRequired,
	};

	//--------------------------------------------------------------------------------
	enum ePower_Data_Accessor
	{
		Access_AC_Power_Setting_Index   = 0,
		Access_DC_Power_Setting_Index   = 1,
		Access_Scheme                   = 16,
		Access_SubGroup                 = 17,
		Access_Individual_Setting       = 18,
		Access_Active_Scheme            = 19,
		Access_Create_Scheme            = 20 
	};

	//--------------------------------------------------------------------------------
	//Session class for Power Setting Change Notifications
	class __QOR_INTERFACE( __WINQL ) CPowerSettingNotification
	{
	public:

		__QOR_DECLARE_OCLASS_ID( CPowerSettingNotification );

		CPowerSettingNotification( void* hRecipient, const nsWin32::GUID* PowerSettingGuid, unsigned long Flags );
		virtual ~CPowerSettingNotification();

	protected:
			
		nsWinQAPI::CUser32& m_Library;
		CRAIISessionHandle m_Handle;

		__QCS_DECLARE_NONCOPYABLE( CPowerSettingNotification );
	};

	//--------------------------------------------------------------------------------
	//Stateless helper class for Power management
	class __QOR_INTERFACE( __WINQL ) CPowerHelper
	{
	public:

		__QOR_DECLARE_OCLASS_ID( CPowerHelper );

		CPowerHelper();
		CPowerHelper( const CPowerHelper& );
		CPowerHelper& operator = ( const CPowerHelper& );
		virtual ~CPowerHelper();
		bool GetDevicePowerState( CDeviceHandle::ref_type hDevice, int& fOn );
		bool CancelDeviceWakeupRequest( CDeviceHandle::ref_type hDevice );
		bool GetSystemPowerStatus( SystemPowerStatus& SystemPowerStatus );
		bool IsSystemResumeAutomatic( void );
		bool RequestWakeupLatency( eLatency_Time latency );
		unsigned long SetThreadExecutionState( unsigned long esFlags );
		bool SetSystemPowerState( bool fSuspend, bool fForce );
		bool SetMessageWaitingIndicator( CDeviceHandle::ref_type hIndicator, unsigned long cmsg );
	};

	//--------------------------------------------------------------------------------
	//Advanced Power Management helper
	class __QOR_INTERFACE( __WINQL ) CAdvancedPowerHelper
	{
	public:

		__QOR_DECLARE_OCLASS_ID( CAdvancedPowerHelper );

		CAdvancedPowerHelper();
		CAdvancedPowerHelper( const CAdvancedPowerHelper& );
		CAdvancedPowerHelper& operator = ( const CAdvancedPowerHelper& );
		virtual ~CAdvancedPowerHelper();

		long CallNtPowerInformation( ePower_Information_Level InformationLevel, void* lpInputBuffer, unsigned long nInputBufferSize, void* lpOutputBuffer, unsigned long nOutputBufferSize );
		bool CanUserWriteAPowerScheme( void );
		bool GetCurrentPowerPolicies( Global_Power_Policy* pGlobalPowerPolicy, Power_Policy* pPowerPolicy );
		bool GetPwrCapabilities( System_Power_Capabilities* lpSystemPowerCapabilities );
		bool GetDiskSpindownRange( unsigned int* pRangeMax, unsigned int* pRangeMin );
		ePowerPlatformRole GetPlatformRole( void );		
		bool IsHibernateAllowed( void );
		bool IsShutdownAllowed( void );
		bool IsSuspendAllowed( void );
		bool IsSystemResumeAutomatic( void );
		bool CanRestoreIndividualDefaultPowerScheme( const nsCodeQOR::mxGUID* SchemeGuid );

	private:

		nsWinQAPI::CPowerProf& m_Library;
	};

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CPowerRequest
	{
	public:

		//--------------------------------------------------------------------------------
		enum eRequestLevel
		{
			Simple = 1,
			Detailed
		};

		__QOR_DECLARE_OCLASS_ID( CPowerRequest );

		CPowerRequest( wchar_t* wszReason );
		CPowerRequest( Reason_Context::Detail Reason );
		CPowerRequest( const CPowerRequest& );
		CPowerRequest& operator = ( const CPowerRequest& );
		virtual ~CPowerRequest();

		bool Clear( ePower_Request_Type RequestType );
		bool Set( ePower_Request_Type RequestType );

	private:

		Reason_Context m_Reason_Context;
		nsWinQAPI::CPowerProf& m_Library;
		CHandle m_Handle;
	};

	class __QOR_INTERFACE( __WINQL ) CPowerSettingCollection;

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CPowerSetting
	{
	public:

		__QOR_DECLARE_OCLASS_ID( CPowerSetting );

		CPowerSetting();
		CPowerSetting( CPowerSettingCollection* pParent, nsCodeQOR::mxGUID guid );
		CPowerSetting( const CPowerSetting& );
		CPowerSetting& operator = ( const CPowerSetting& );
		virtual ~CPowerSetting();

		nsCodeQOR::mxGUID& GetGUID( void ) const;
		
		bool Delete( void );
		void Duplicate( void );

		CWString ReadDescription( void );
		CWString ReadFriendlyName( void );
		nsCodeQOR::CTLRef< byte > ReadIconResourceSpecifier( void );

		unsigned long ReadDCValueIndex( void );
		unsigned long ReadDCDefaultIndex( void );
		nsCodeQOR::CTLRef< byte > ReadDCValue( unsigned long& ulType, unsigned long& ulBufferSize );

		unsigned long ReadACValueIndex( void );
		unsigned long ReadACDefaultIndex( void );
		nsCodeQOR::CTLRef< byte > ReadACValue( unsigned long& ulType, unsigned long& ulBufferSize );

	protected:

		CPowerSettingCollection* m_pParent;
		nsCodeQOR::__mxGUID m_GUID;
	};

	class __QOR_INTERFACE( __WINQL ) CPowerScenario;

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CPowerSettingCollection : public nsCodeQOR::CTArray< CPowerSetting, CWinQLPolicy >
	{
		friend class CPowerSetting;

	public:

		__QOR_DECLARE_OCLASS_ID( CPowerSettingCollection );

		CPowerSettingCollection();		
		CPowerSettingCollection( const CPowerSettingCollection& );
		CPowerSettingCollection& operator = ( const CPowerSettingCollection& );
		virtual ~CPowerSettingCollection();

		void Init( CPowerScenario* pParent, int iSubGroupID, nsCodeQOR::mxGUID guid );
		
		nsCodeQOR::mxGUID& GetGUID( void ) const;

	protected:

		int m_iSubGroup;
		CPowerScenario* m_pParent;
		nsCodeQOR::__mxGUID m_GUID;
		nsWinQAPI::CPowerProf& m_Library;

	};


	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CPowerScenario
	{
	public:

		__QOR_DECLARE_REF_TYPE(CPowerScenario);

		//--------------------------------------------------------------------------------
		enum eSubGroup
		{
			No_SubGroup = 0,
			Disk,
			System_Button,
			Processor_Settings,
			Video,
			Battery,
			Sleep,
			PCIExpress,
			Count_of_SubGroups
		};

		__QOR_DECLARE_OCLASS_ID( CPowerScenario );

		CPowerScenario();
		CPowerScenario( nsCodeQOR::mxGUID guid );
		CPowerScenario( const CPowerScenario& );
		CPowerScenario& operator = ( const CPowerScenario& );
		virtual ~CPowerScenario();

		nsCodeQOR::mxGUID& GetGUID( void ) const;

		bool CanRestoreIndividualDefault( void );		
		bool Delete( void );
		ref_type Duplicate();
		unsigned long ReadACDefaultIndex( eSubGroup SubGroup, nsCodeQOR::mxGUID* pPowerSettingGuid );
		nsCodeQOR::CTLRef< byte > ReadACValue( eSubGroup SubGroup, nsCodeQOR::mxGUID* pPowerSettingGuid, unsigned long& ulType, unsigned long& ulBufferSize );
		unsigned long ReadACValueIndex( eSubGroup SubGroup, nsCodeQOR::mxGUID* PowerSettingGuid );
		unsigned long ReadDCDefaultIndex( eSubGroup SubGroup, nsCodeQOR::mxGUID* pPowerSettingGuid  );
		nsCodeQOR::CTLRef< byte > ReadDCValue( CPowerScenario::eSubGroup SubGroup, nsCodeQOR::mxGUID* PowerSettingGuid, unsigned long& ulType, unsigned long& ulBufferSize );
		unsigned long ReadDCValueIndex( eSubGroup SubGroup, nsCodeQOR::mxGUID* PowerSettingGuid );
		CAString ReadDescription( eSubGroup SubGroup, nsCodeQOR::mxGUID* PowerSettingGuid );
		CAString ReadFriendlyName( eSubGroup SubGroup, nsCodeQOR::mxGUID* PowerSettingGuid );
		nsCodeQOR::CTLRef< byte > ReadIconResourceSpecifier( eSubGroup SubGroup, nsCodeQOR::mxGUID* PowerSettingGuid );

		nsCodeQOR::CTLRef< CPowerSettingCollection > SubGroup( eSubGroup );

	protected:

		nsCodeQOR::CSTMember< CPowerSettingCollection > m_SubGroups[ Count_of_SubGroups ];
		static nsCodeQOR::mxGUID SubGroupOfPowerSettingsGuids[ Count_of_SubGroups ];
		nsCodeQOR::__mxGUID m_GUID;
		nsWinQAPI::CPowerProf& m_Library;
	};

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CPowerScheme
	{
	public:

		__QOR_DECLARE_OCLASS_ID( CPowerScheme );

		CPowerScheme();
		CPowerScheme( unsigned int uiIndex, CWString strName, CWString strDescription, Power_Policy& Policy );
		CPowerScheme( const CPowerScheme& );
		CPowerScheme& operator = ( const CPowerScheme& );
		virtual ~CPowerScheme();

		unsigned int GetIndex( void );
		CWString GetName( void );
		CWString GetDescription( void );
		Power_Policy& GetPolicy( void );

		bool Write( void );

	protected:

		unsigned int m_uiIndex;
		CWString m_strName;
		CWString m_strDescription;
		Power_Policy m_Policy;

	private:
	};

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CPowerScenarioCollection : public nsCodeQOR::CTArray< CPowerScenario*, CWinQLPolicy >
	{
	public:

		__QOR_DECLARE_OCLASS_ID( CPowerScenarioCollection );

		CPowerScenarioCollection();
		CPowerScenarioCollection( const CPowerScenarioCollection& src );
		CPowerScenarioCollection& operator = ( const CPowerScenarioCollection& src );
		virtual ~CPowerScenarioCollection();

		unsigned long CreatePossibleSetting( nsCodeQOR::mxGUID* SubGroupOfPowerSettingsGuid, nsCodeQOR::mxGUID* PowerSettingGuid, unsigned long PossibleSettingIndex );
		unsigned long CreateSetting( nsCodeQOR::mxGUID* SubGroupOfPowerSettingsGuid, nsCodeQOR::mxGUID* PowerSettingGuid );
		CPowerScenario::ref_type GetActiveScenario( void );
		unsigned long ImportScenario( const CWString ImportFileNamePath );

		unsigned long ReadPossibleDescription( const GUID* SubGroupOfPowerSettingsGuid, const GUID* PowerSettingGuid, unsigned long PossibleSettingIndex, unsigned char* Buffer, unsigned long* BufferSize );
		unsigned long PowerReadPossibleFriendlyName( const GUID* SubGroupOfPowerSettingsGuid, const GUID* PowerSettingGuid, unsigned long PossibleSettingIndex, unsigned char* Buffer, unsigned long* BufferSize );

	private:

		nsWinQAPI::CPowerProf& m_Library;
	};

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CPowerSchemeCollection : public nsCodeQOR::CTArray< CPowerScheme*, CWinQLPolicy >
	{
	public:

		__QOR_DECLARE_OCLASS_ID( CPowerSchemeCollection );

		CPowerSchemeCollection();
		CPowerSchemeCollection( const CPowerSchemeCollection& );
		CPowerSchemeCollection& operator = ( const CPowerSchemeCollection& );
		virtual ~CPowerSchemeCollection();

		unsigned int ActiveScheme( void );
		bool DeleteScheme( unsigned int uiIndex );

	private:

		byte EnumSchemeProc( unsigned int Index, unsigned long NameSize, wchar_t* wszName, unsigned long ulDescriptionSize, wchar_t* wszDescription, Power_Policy* pPolicy );
		static byte __QCMP_STDCALLCONVENTION StaticEnumProcV2( unsigned int Index, unsigned long NameSize, wchar_t* Name, unsigned long DescriptionSize, wchar_t* Description, Power_Policy* Policy, Cmp_long_ptr Context );
		static byte __QCMP_STDCALLCONVENTION StaticEnumProcV1( unsigned int Index, unsigned long NameSize, wchar_t* Name, unsigned long DescriptionSize, TCHAR* Description, Power_Policy* Policy, Cmp_long_ptr Context );

		nsWinQAPI::CPowerProf& m_Library;
	};

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CPowerDevice
	{
	public:

		__QOR_DECLARE_OCLASS_ID( CPowerDevice );

		CPowerDevice();
		CPowerDevice( const CPowerDevice& );
		CPowerDevice& operator = ( const CPowerDevice& );
		virtual ~CPowerDevice();

		void SetID( const CWString& strID );
		void SetPowerData( nsCodeQOR::CTLRef< CM_Power_Data > Ref );
		void SetName( const CWString& strName );
		void SetDevice( CDeviceInstance* pDevice );
		nsCodeQOR::CTLRef< CDeviceInstance > Instance( void );

		bool Control( unsigned long dwIoControlCode, void* lpInBuffer, unsigned long nInBufferSize, void* lpOutBuffer, unsigned long nOutBufferSize, unsigned long* lpBytesReturned, nsWin32::LPOVERLAPPED lpOverlapped );
		bool GetState( int& fOn );
		bool CancelWakeupRequest( void );

		eDevice_Power_State GetMostRecentPowerState( void );
		eDevice_Power_State GetPowerStateMapping( eSystem_Power_State PowerState );
		eSystem_Power_State GetDeepestSystemWake( void );
		unsigned long GetD1Latency( void );
		unsigned long GetD2Latency( void );
		unsigned long GetD3Latency( void );
		unsigned long Capabilities( void );
		bool D0_Supported( void );
		bool D1_Supported( void );
		bool D2_Supported( void );
		bool D3_Supported( void );
		bool Wake_From_D0_Supported( void );
		bool Wake_From_D1_Supported( void );
		bool Wake_From_D2_Supported( void );
		bool Wake_From_D3_Supported( void );
		bool Warm_Eject_Supported( void );

	protected:

		CDeviceInstance* m_pDevice;

	private:

		nsCodeQOR::CTLRef< CM_Power_Data > m_PowerRef;
		CWString m_strID;
		CWString m_strName;
		nsWinQAPI::CPowerProf& m_Library;
	};

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CPowerDeviceCollection : public nsCodeQOR::CTArray< CPowerDevice*, CWinQLPolicy >
	{
	public:

		__QOR_DECLARE_OCLASS_ID( CPowerDeviceCollection );

		CPowerDeviceCollection();
		CPowerDeviceCollection( const CPowerDeviceCollection& );
		CPowerDeviceCollection& operator = ( const CPowerDeviceCollection& );
		virtual ~CPowerDeviceCollection();

	private:

		bool m_bValid;
		nsWinQAPI::CPowerProf& m_Library;
	};

	//--------------------------------------------------------------------------------

    typedef nsCodeQOR::CTLRef< nsWin32::CPowerSettingNotification > CPowerSettingNotifyRef;

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CMessageWaitingIndicator
	{
	public:

		CMessageWaitingIndicator();
		~CMessageWaitingIndicator();
		bool Set( unsigned long cmsg );

	protected:

		nsWin32::CPowerHelper m_Win32PowerHelper;
		nsWin32::CFile m_MessageWaitingDevice;
	};

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CPowerManager
	{
	public:

		__QOR_DECLARE_OCLASS_ID( CPowerManager );

		CPowerManager();
		virtual ~CPowerManager();
		bool IsResumeAutomatic(void);
		bool GetPowerStatus( nsWin32::SystemPowerStatus& SystemPowerStatus );
		bool SetPowerStatus( bool fSuspend, bool fForce );
		CPowerSettingNotifyRef CreateNotification( void* hRecipient, const nsWin32::GUID* PowerSettingGuid, unsigned long Flags );
		unsigned long SetCurrentThreadPowerStateRequirements( unsigned long esFlags );
		CMessageWaitingIndicator& MessageWaitingIndicator();
		bool RequestWakeupLatency( nsWin32::eLatency_Time latency );

		nsCodeQOR::CTLRef< Global_Power_Policy > CurrentGlobalPowerPolicy( void );
		nsCodeQOR::CTLRef< Power_Policy > CurrentPowerPolicy( void );
		
		ePowerPlatformRole GetPlatformRole( void );												//Get the kind of Computer this is in terms of power usage, mobile, desktop, server...
		bool CanUserWriteAPowerScheme();														//Does the current user have sufficient permissions to write a power management scheme

		nsCodeQOR::CSTMember< CPowerSchemeCollection > PowerSchemes;							//An array of the power schemes on this computer
		nsCodeQOR::CSTMember< CPowerScenarioCollection > PowerScenarios;						//An array of the power scenarios on this computer
		nsCodeQOR::CSTMember< CPowerDeviceCollection > Devices;									//An array of power managed devices

	protected:

		CPowerHelper m_Win32PowerHelper;
		nsCodeQOR::CSTMember< CAdvancedPowerHelper > m_AdvancedPowerHelper;
		CMessageWaitingIndicator* m_pMessageWaitingIndicator;

	private:

		CPowerManager( const CPowerManager& );
		CPowerManager& operator = ( const CPowerManager& );
	};

}//nsWin32

#endif //WINQL_SYSTEM_POWER_H_3
