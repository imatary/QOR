//BfBuffer.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Bluefoot buffer class

#ifndef BLUEFOOT_BUFFER_H_3
#define BLUEFOOT_BUFFER_H_3

#include "CompilerQOR.h"
#include "CodeQOR/MemoryManagement/DefaultAllocator.h"
#include "CodeQOR/DataStructures/TLRef.h"
#include <string.h>

//------------------------------------------------------------------------------
namespace nsBluefoot
{
	//------------------------------------------------------------------------------
	class __QOR_INTERFACE( __BLUEFOOTQOR ) CBuffer
	{
	public:

		CBuffer( unsigned long ulUnitSize = 1, unsigned long ulItemCount = 0 );
		CBuffer( const CBuffer& src );
		virtual ~CBuffer();
		CBuffer& operator = ( const CBuffer& src );

		virtual unsigned long WriteCapacity( void ) = 0;
		virtual unsigned long ReadCapacity( void ) = 0;
		virtual byte* WriteRequest( unsigned long& ulItemCount ) = 0;
		virtual byte* ReadRequest( unsigned long& ulItemCount ) = 0;
		
		virtual void SetCapacity( unsigned long ulItemCount );
		unsigned long Capacity( void ) const;
		unsigned long ReadAcknowledge( unsigned long& ulItemCount );
		unsigned long ReadReject( unsigned long& ulItemCount );
		unsigned long WriteAcknowledge( unsigned long& ulItemCount );
		unsigned long GetUnitSize( void );

	protected:

		//------------------------------------------------------------------------------
		void SetUnitSize( unsigned long ulUnitSize )
		{
			m_ulUnitSize = ulUnitSize;
		}

		unsigned long m_ulAllocationCount;
		unsigned long m_ulUnitSize;
		Cmp_unsigned__int64 m_uiReadBegin;
		Cmp_unsigned__int64 m_uiReadEnd;
		Cmp_unsigned__int64 m_uiWriteBegin;
		Cmp_unsigned__int64 m_uiWriteEnd;

	};

	//------------------------------------------------------------------------------
	template< class pod_t >
	class CPODStreamBuffer : public CBuffer
	{
	public:

		typedef nsCodeQOR::CTLRef< CPODStreamBuffer< pod_t > > ref_type;

		//------------------------------------------------------------------------------
		CPODStreamBuffer( unsigned long ulItemCount = 0 ) : CBuffer( sizeof( pod_t ), ulItemCount )
		,	m_pAllocation( 0 )
		{
			SetCapacity( ulItemCount );
		}

		//------------------------------------------------------------------------------
		CPODStreamBuffer( const CPODStreamBuffer& src )
		{
			*this = src;
		}

		//------------------------------------------------------------------------------
		~CPODStreamBuffer()
		{
		}

		//------------------------------------------------------------------------------
		CPODStreamBuffer& operator = ( const CPODStreamBuffer& src )
		{
			if( &src != this )
			{
				CBuffer::operator = ( src );				
				memcpy( m_pAllocation, src.m_pAllocation, sizeof( pod_t ) * m_ulAllocationCount );
			}
			return *this;
		}

		//------------------------------------------------------------------------------
		CPODStreamBuffer& operator << ( pod_t& item )
		{
			unsigned long ulCount = 1;
			pod_t* pWrite = reinterpret_cast< pod_t* >( WriteRequest( ulCount ) );
			if( pWrite && ulCount == 1 )
			{
				memcpy( pWrite, &item, sizeof( pod_t ) );
			}
			WriteAcknowledge( ulCount );
			return *this;
		}

		//------------------------------------------------------------------------------
		CPODStreamBuffer& operator >> ( pod_t& item )
		{
			unsigned long ulCount = 1;
			pod_t* pRead = reinterpret_cast< pod_t* >( ReadRequest( ulCount ) );
			if( pRead && ulCount == 1 )
			{
				memcpy( &item, pRead, sizeof( pod_t ) );
			}
			ReadAcknowledge( ulCount );
			return *this;
		}

		//------------------------------------------------------------------------------
		unsigned long WriteCapacity( void )
		{
			unsigned long ulResult = m_ulAllocationCount - static_cast< unsigned long >( m_uiWriteEnd - m_uiReadBegin );
			if( AddressOf( m_uiWriteEnd ) + ulResult > EndOfBuffer() )
			{
				ulResult = EndOfBuffer() - AddressOf( m_uiWriteEnd );
			}
			return ulResult;
		}

		//------------------------------------------------------------------------------
		unsigned long ReadCapacity( void )
		{
			unsigned long ulResult = static_cast< unsigned long >( m_uiWriteBegin - m_uiReadEnd );
			if( AddressOf( m_uiReadEnd ) + ulResult > EndOfBuffer() )
			{
				ulResult = EndOfBuffer() - AddressOf( m_uiReadEnd );
			}
			return ulResult;
		}

		//------------------------------------------------------------------------------
		byte* WriteRequest( unsigned long& ulItemCount )
		{
			pod_t* pResult = 0;
			if( ulItemCount > WriteCapacity() )
			{
				ulItemCount = WriteCapacity();
			}

			if( ulItemCount > 0 )
			{
				pResult = AddressOf( m_uiWriteEnd );
				m_uiWriteEnd += ulItemCount;
			}
			return reinterpret_cast< byte* >( pResult );
		}

		//------------------------------------------------------------------------------
		byte* ReadRequest( unsigned long& ulItemCount )
		{
			pod_t* pResult = AddressOf( m_uiReadEnd );
			if( ulItemCount > ReadCapacity() )
			{
				ulItemCount = ReadCapacity();
			}
			m_uiReadEnd += ulItemCount;
			return reinterpret_cast< byte* >( pResult );
		}

		//------------------------------------------------------------------------------
		virtual void SetCapacity( unsigned long ulItemCount )
		{
			delete [] m_pAllocation;
			m_pAllocation = ( ulItemCount > 0 ) ? new pod_t[ ulItemCount ] : 0;

			CBuffer::SetCapacity( ulItemCount );
		}

		//------------------------------------------------------------------------------
		ref_type Ref(void)
		{
			return ref_type( this );
		}

	private:

		//------------------------------------------------------------------------------
		pod_t* EndOfBuffer( void )
		{
			pod_t* pResult = 0;
			if( m_ulAllocationCount > 0 )
			{
				pResult = m_pAllocation + m_ulAllocationCount;
			}
			return pResult;
		}

		//------------------------------------------------------------------------------
		pod_t* AddressOf( Cmp_unsigned__int64 uiIndex )
		{
			pod_t* pResult = 0;
			if( m_ulAllocationCount > 0 )
			{
				pResult = m_pAllocation + ( uiIndex % m_ulAllocationCount );
			}
			return pResult;
		}

		pod_t* m_pAllocation;
	};

	typedef CPODStreamBuffer< byte > CByteStreamBuffer;

}//nsBluefoot

#endif//BLUEFOOT_BUFFER_H_3
