//WinQLPipe.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/Application/Comms/IPC/Pipe/WinQLPipe.h"
#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include <assert.h>
#include "WinQAPI/Kernel32.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	using namespace nsWinQAPI;

	__QOR_IMPLEMENT_OCLASS_LUID( CPipe );

	//--------------------------------------------------------------------------------
	bool CPipe::Instance( void** hReadPipe, void** hWritePipe, nsWin32::LPSECURITY_ATTRIBUTES lpPipeAttributes, unsigned long nSize )
	{
		_WINQ_SFCONTEXT( "CPipeHelper::Instance" );
		bool bResult = false;
		bResult = CKernel32::Instance().CreatePipe( hReadPipe, hWritePipe, reinterpret_cast< ::LPSECURITY_ATTRIBUTES >( lpPipeAttributes ), nSize ) ? true : false;
		return bResult;
	}

	//--------------------------------------------------------------------------------
	CPipe::CPipe() : CDeviceFile()
	{
		_WINQ_FCONTEXT( "CPipe::CPipe" );
	}

	//--------------------------------------------------------------------------------
	CPipe::CPipe( CDeviceHandle& hExisting ) : CDeviceFile( hExisting )
	{
	}

	//--------------------------------------------------------------------------------
	CPipe::~CPipe()
	{
		_WINQ_FCONTEXT( "CPipe::~CPipe" );
		Close();
	}

	//--------------------------------------------------------------------------------
	bool CPipe::IsOpen( void )
	{
		_WINQ_FCONTEXT( "CPipe::IsOpen" );
		return ( !Handle()->IsNull() && !Handle()->IsInvalid() );
	}

	//--------------------------------------------------------------------------------
	bool CPipe::Create( const TCHAR* lpszName, unsigned long OpenMode, unsigned long PipeMode, unsigned long nMaxInstances, unsigned long nOutBufferSize, unsigned long nInBufferSize, unsigned long nDefaultTimeout, SECURITY_ATTRIBUTES* pSecurityAttributes )
	{
		_WINQ_FCONTEXT( "CPipe::Create" );
		bool bResult = false;

		__QOR_PROTECT
		{
			assert( !IsOpen() );
			CTString strName( lpszName );
			CTString strPipeName = _TXT( "\\\\.\\pipe\\" );
			strPipeName.Append( strName );
			m_Handle = CKernel32::CreateNamedPipe( strPipeName.GetBuffer(), OpenMode, PipeMode, nMaxInstances, nOutBufferSize, nInBufferSize, nDefaultTimeout, reinterpret_cast< ::LPSECURITY_ATTRIBUTES >( pSecurityAttributes ) );
			strPipeName.ReleaseBuffer();

			bResult = m_Handle.Use() != Invalid_Handle_Value ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::Open( const TCHAR* lpszServerName, const TCHAR* lpszPipeName, unsigned long DesiredAccess, unsigned long ShareMode, SECURITY_ATTRIBUTES* pSecurityAttributes, unsigned long FlagsAndAttributes )
	{
		_WINQ_FCONTEXT( "CPipe::Open" );
		bool bResult = false;

		__QOR_PROTECT
		{
			assert( !IsOpen() );

			//Construct the canonical pipe name
			CTString strPipeName = _TXT( "\\\\" );
			CTString strServerName( lpszServerName ? lpszServerName : _TXT( "." ) );
			CTString strPipe = _TXT( "\\PIPE\\" );
			CTString strName( lpszPipeName );
			strPipeName.Append( strServerName );
			strPipeName.Append( strPipe );
			strPipeName.Append( strName );
			
			m_Handle = CKernel32::CreateFile( strPipeName.GetBuffer(), DesiredAccess, ShareMode, reinterpret_cast< ::LPSECURITY_ATTRIBUTES >( pSecurityAttributes ), Open_Existing, FlagsAndAttributes, 0 );
			strPipeName.ReleaseBuffer();
			bResult = m_Handle.Use() != Invalid_Handle_Value ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::Attach( void* hPipe )
	{
		_WINQ_FCONTEXT( "CPipe::Attach" );
		__QOR_PROTECT
		{
			if( m_Handle.Use() != hPipe )
			{
				Close();
			}

			m_Handle = hPipe;
		}__QOR_ENDPROTECT
		return true;
	}

	//--------------------------------------------------------------------------------
	void* CPipe::Detach()
	{
		_WINQ_FCONTEXT( "CPipe::Detach" );
		void* pReturn = const_cast< void* >( Invalid_Handle_Value );
		__QOR_PROTECT
		{
			pReturn = m_Handle.Detach();
		}__QOR_ENDPROTECT
		return pReturn;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::Close()
	{
		_WINQ_FCONTEXT( "CPipe::Close" );
		bool bSuccess = false;
		__QOR_PROTECT
		{
			if( m_Handle.Use() != 0 )
			{
				m_Handle.Close();
			}
			bSuccess = true;
		}__QOR_ENDPROTECT
		return bSuccess;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::Call( const TCHAR* lpszServerName, const TCHAR* lpszPipeName, void* pInBuffer, unsigned long nInBuffer, void* pOutBuffer, unsigned long nOutBuffer, unsigned long& BytesRead, unsigned long nTimeout )
	{
		_WINQ_FCONTEXT( "CPipe::Call" );
		bool bResult = false;
		__QOR_PROTECT
		{
			//Construct the canonical pipe name
			//Construct the canonical pipe name
			CTString strPipeName = _TXT( "\\\\" );
			CTString strServerName( lpszServerName );
			CTString strPipe = _TXT( "\\PIPE\\" );
			CTString strName( lpszPipeName );
			strPipeName.Append( strServerName );
			strPipeName.Append( strPipe );
			strPipeName.Append( strName );
			bResult = CKernel32::CallNamedPipe( strPipeName.GetBuffer(), pInBuffer, nInBuffer, pOutBuffer, nOutBuffer, &BytesRead, nTimeout ) ? true : false;
			strPipeName.ReleaseBuffer();
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::ConnectClient( OVERLAPPED* pOverlapped )
	{
		_WINQ_FCONTEXT( "CPipe::ConnectClient" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bool bServerPipe;
			assert( IsServer( bServerPipe ) );
			assert( bServerPipe );//Must be called from the server side

			bResult = CKernel32::ConnectNamedPipe( m_Handle.Use(), reinterpret_cast< ::LPOVERLAPPED >( pOverlapped ) ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::DisconnectClient()
	{
		_WINQ_FCONTEXT( "CPipe::DisconnectClient" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bool bServerPipe;
			assert( IsServer( bServerPipe ) );
			assert( bServerPipe );//Must be called from the server side

			bResult = CKernel32::DisconnectNamedPipe( m_Handle.Use() ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::Flush()
	{
		_WINQ_FCONTEXT( "CPipe::Flush" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );

			bResult = CKernel32::FlushFileBuffers( m_Handle.Use() ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::IsBlocking( bool& bIsBlocking ) const
	{
		_WINQ_FCONTEXT( "CPipe::IsBlocking" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			unsigned long State = 0;
			bResult = CKernel32::GetNamedPipeHandleState( m_Handle.Use(), &State, 0, 0, 0, 0, 0 ) ? true : false;
			if( bResult )
			{
				bIsBlocking = ( ( State & Pipe_NoWait ) == 0 );
			}
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::IsClient( bool& bIsClient ) const
	{
		_WINQ_FCONTEXT( "CPipe::IsClient" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			unsigned long Flags = 0;
			bResult = CKernel32::GetNamedPipeInfo( m_Handle.Use(), &Flags, 0, 0, 0 ) ? true : false;
			if( bResult )
			{
				bIsClient = ( ( Flags & Pipe_Client_End ) != 0 );
			}
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::IsServer( bool& bIsServer ) const
	{
		_WINQ_FCONTEXT( "CPipe::IsServer" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			unsigned long Flags = 0;
			bResult = CKernel32::GetNamedPipeInfo( m_Handle.Use(), &Flags, 0, 0, 0 ) ? true : false;
			if( bResult )
			{
				bIsServer = ( ( Flags & Pipe_Server_End ) != 0 );
			}
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::IsMessaging( bool& bIsMessaging ) const 
	{
		_WINQ_FCONTEXT( "CPipe::IsMessaging" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			unsigned long State = 0;
			bResult = CKernel32::GetNamedPipeHandleState( m_Handle.Use(), &State, 0, 0, 0, 0, 0 ) ? true : false;
			if( bResult )
			{
				bIsMessaging = ( ( ( State & Pipe_ReadMode_Message ) != 0 ) );
			}
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::GetCurrentInstances( unsigned long& CurrentInstances ) const
	{
		_WINQ_FCONTEXT( "CPipe::GetCurrentInstance" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bResult = CKernel32::GetNamedPipeHandleState( m_Handle.Use(), 0, &CurrentInstances, 0, 0, 0, 0 ) ? true : false;

		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::GetMaxCollectionCount( unsigned long& MaxCollectionCount ) const
	{
		_WINQ_FCONTEXT( "CPipe::GetMaxCollectionCount" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bool bClientPipe = false;
			assert( IsClient( bClientPipe ) );
			assert( bClientPipe );//Must be called from the client side
			bResult = CKernel32::GetNamedPipeHandleState( m_Handle.Use(), 0, 0, &MaxCollectionCount, 0, 0, 0 ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::GetCollectionTimeout( unsigned long& CollectDataTimeout ) const
	{
		_WINQ_FCONTEXT( "CPipe::GetCollectionTimeout" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bool bClientPipe = false;
			assert( IsClient( bClientPipe ) );
			assert( bClientPipe );//Must be called from the client side
			bResult = CKernel32::GetNamedPipeHandleState( m_Handle.Use(), 0, 0, 0, &CollectDataTimeout, 0, 0 ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::GetOutboundBufferSize( unsigned long& OutboundBufferSize ) const
	{
		_WINQ_FCONTEXT( "CPipe::GetOutboundBufferSize" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bResult = CKernel32::GetNamedPipeInfo( m_Handle.Use(), 0, &OutboundBufferSize, 0, 0 ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::GetInboundBufferSize( unsigned long& InboundBufferSize ) const
	{
		_WINQ_FCONTEXT( "CPipe::GetInboundBufferSize" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bResult = CKernel32::GetNamedPipeInfo( m_Handle.Use(), 0, 0, &InboundBufferSize, 0 ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::GetClientComputerName( TCHAR* ClientComputerName, unsigned long ClientComputerNameLength )
	{
		_WINQ_FCONTEXT( "CPipe::GetClientComputerName" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bResult = CKernel32::GetNamedPipeClientComputerName( m_Handle.Use(), ClientComputerName, ClientComputerNameLength ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::GetClientProcessId( unsigned long& ClientProcessId )
	{
		_WINQ_FCONTEXT( "CPipe::GetClientProcessId" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bResult = CKernel32::GetNamedPipeClientProcessId( m_Handle.Use(), &ClientProcessId ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::GetClientSessionId( unsigned long& ClientSessionId )
	{
		_WINQ_FCONTEXT( "CPipe::GetClientSessionId" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bResult = CKernel32::GetNamedPipeClientSessionId( m_Handle.Use(), &ClientSessionId ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::GetClientUserName( CTString& strUserName )
	{
		_WINQ_FCONTEXT( "CPipe::GetClientUserName" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bool bServerPipe = false;
			assert( IsServer( bServerPipe ) );
			assert( bServerPipe );//Must be called from the server side

			bResult = CKernel32::GetNamedPipeHandleState( m_Handle.Use(), 0, 0, 0, 0, strUserName.GetBufferSetLength( Max_Path ), Max_Path ) ? true : false;
			if( bResult )
			{
				strUserName.ValidateBuffer( Max_Path );
			}
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::GetMaxInstances( unsigned long& MaxInstances ) const
	{
		_WINQ_FCONTEXT( "CPipe::GetMaxInstances" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bResult = CKernel32::GetNamedPipeInfo( m_Handle.Use(), 0, 0, 0, &MaxInstances ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::SetMode( bool bByteMode, bool bBlockingMode )
	{
		_WINQ_FCONTEXT( "CPipe::SetMode" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );

			unsigned long Mode = bByteMode ? Pipe_ReadMode_Byte : Pipe_ReadMode_Message;
			Mode |= ( bBlockingMode ? Pipe_Wait : Pipe_NoWait );

			bResult = CKernel32::SetNamedPipeHandleState( m_Handle.Use(), &Mode, 0, 0 ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::SetMaxCollectionCount( unsigned long CollectionCount )
	{
		_WINQ_FCONTEXT( "CPipe::SetMaxCollectionCount" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bool bClientPipe = false;
			assert( IsClient( bClientPipe ) );
			assert( bClientPipe ); //Must be called from the client side

			bResult = CKernel32::SetNamedPipeHandleState( m_Handle.Use(), 0, &CollectionCount, 0 ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::SetCollectionTimeout( unsigned long DataTimeout )
	{
		_WINQ_FCONTEXT( "CPipe::SetCollectionTimeout" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bool bClientPipe = false;
			assert( IsClient( bClientPipe ) );
			assert( bClientPipe ); //Must be called from the client side

			bResult = CKernel32::SetNamedPipeHandleState( m_Handle.Use(), 0, 0, &DataTimeout ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::ServerAvailable( const TCHAR* lpszServerName, const TCHAR* lpszPipeName, unsigned long Timeout )
	{
		_WINQ_FCONTEXT( "CPipe::ServerAvailable" );
		bool bResult = false;
		__QOR_PROTECT
		{
			//Construct the canonical pipe name
			CTString strPipeName = _TXT( "\\\\" );
			CTString strServerName( lpszServerName );
			CTString strName( lpszPipeName );
			CTString strPipe = _TXT( "\\PIPE\\" );
			strPipeName.Append( strServerName );
			strPipeName.Append( strPipe );
			strPipeName.Append( strName );

			bResult = CKernel32::WaitNamedPipe( strPipeName.GetBuffer(), Timeout ) ? true : false;
			strPipeName.ReleaseBuffer();

		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::GetHandleState( unsigned long* pState, unsigned long* pCurInstances, unsigned long* pMaxCollectionCount, unsigned long* pCollectDataTimeout, TCHAR* UserName, unsigned long nMaxUserNameSize )
	{
		_WINQ_FCONTEXT( "CPipe::GetHandleState" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetNamedPipeHandleState( m_Handle.Use(), pState, pCurInstances, pMaxCollectionCount, pCollectDataTimeout, UserName, nMaxUserNameSize ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::GetInfo( unsigned long* pFlags, unsigned long* pOutBufferSize, unsigned long* pInBufferSize, unsigned long* pMaxInstances )
	{
		_WINQ_FCONTEXT( "CPipe::GetInfo" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetNamedPipeInfo( m_Handle.Use(), pFlags, pOutBufferSize, pInBufferSize, pMaxInstances ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::GetServerProcessId( unsigned long& ServerProcessId )
	{
		_WINQ_FCONTEXT( "CPipe::GetServerProcessId" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetNamedPipeServerProcessId( m_Handle.Use(), &ServerProcessId ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::GetServerSessionId( unsigned long& ServerSessionId )
	{
		_WINQ_FCONTEXT( "CPipe::GetServerSessionId" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetNamedPipeServerSessionId( m_Handle.Use(), &ServerSessionId ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::Peek( void* pBuffer, unsigned long nBufferSize, unsigned long& BytesRead, unsigned long& TotalBytesAvail, unsigned long& BytesLeftThisMessage )
	{
		_WINQ_FCONTEXT( "CPipe::Peek" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bResult = CKernel32::PeekNamedPipe( m_Handle.Use(), pBuffer, nBufferSize, &BytesRead, &TotalBytesAvail, &BytesLeftThisMessage ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::SetHandleState( unsigned long* pMode, unsigned long* pMaxCollectionCount, unsigned long* pCollectDataTimeout )
	{
		_WINQ_FCONTEXT( "CPipe::SetHandleState" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bResult = CKernel32::SetNamedPipeHandleState( m_Handle.Use(), pMode, pMaxCollectionCount, pCollectDataTimeout ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}
		
	//--------------------------------------------------------------------------------
	bool CPipe::Transact( void* pBuffer, unsigned long nInBufferSize, void* pOutBuffer, unsigned long nOutBufferSize, unsigned long& BytesRead, OVERLAPPED* pOverlapped )
	{
		_WINQ_FCONTEXT( "CPipe::Transact" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bResult = CKernel32::TransactNamedPipe( m_Handle.Use(), pBuffer, nInBufferSize, pOutBuffer, nOutBufferSize, &BytesRead, reinterpret_cast< ::LPOVERLAPPED >( pOverlapped ) ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::Write( const void* pBuffer, unsigned long NumberOfBytesToWrite, unsigned long& NumberOfBytesWritten, OVERLAPPED* pOverlapped )
	{
		_WINQ_FCONTEXT( "CPipe::Write" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bResult = CKernel32::WriteFile( m_Handle.Use(), pBuffer, NumberOfBytesToWrite, &NumberOfBytesWritten, reinterpret_cast< ::LPOVERLAPPED >( pOverlapped ) ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::Write( const void* pBuffer, unsigned long NumberOfBytesToWrite, OVERLAPPED* pOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE pCompletionRoutine )
	{
		_WINQ_FCONTEXT( "CPipe::Write" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bResult = CKernel32::WriteFileEx( m_Handle.Use(), pBuffer, NumberOfBytesToWrite, reinterpret_cast< ::LPOVERLAPPED >( pOverlapped ), reinterpret_cast< ::LPOVERLAPPED_COMPLETION_ROUTINE >( pCompletionRoutine ) ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::Read( void* pBuffer, unsigned long NumberOfBytesToRead, unsigned long& NumberOfBytesRead, OVERLAPPED* pOverlapped )
	{
		_WINQ_FCONTEXT( "CPipe::Read" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bResult = CKernel32::ReadFile( m_Handle.Use(), pBuffer, NumberOfBytesToRead, &NumberOfBytesRead, reinterpret_cast< ::LPOVERLAPPED >( pOverlapped ) ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::Read( void* pBuffer, unsigned long NumberOfBytesToRead, OVERLAPPED* pOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE pCompletionRoutine )
	{
		_WINQ_FCONTEXT( "CPipe::Read" );
		bool bResult = false;
		__QOR_PROTECT
		{
			assert( !m_Handle.IsNull() && !m_Handle.IsInvalid() );
			bResult = CKernel32::ReadFileEx( Handle()->Use(), pBuffer, NumberOfBytesToRead, reinterpret_cast< ::LPOVERLAPPED >( pOverlapped ), reinterpret_cast< ::LPOVERLAPPED_COMPLETION_ROUTINE >( pCompletionRoutine ) ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CPipe::GetOverlappedResult( OVERLAPPED& Overlapped, unsigned long& ulNumberOfBytesTransferred, bool bWait )
	{
		_WINQ_FCONTEXT( "CPipe::GetOverlappedResult" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::Instance().GetOverlappedResult( Handle()->Use(), reinterpret_cast< ::OVERLAPPED* >( &Overlapped ), &ulNumberOfBytesTransferred, bWait ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

}//nsWin32

