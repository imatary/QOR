//WinQLRenderingController.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "CompilerQOR.h"
__QCMP_WARNING_PUSH
__QCMP_WARNING_DISABLE( __QCMP_WARN_THIS_USED_IN_BASE_INIT_LIST, "Safe usage: stored in member for later use" )
#include "WinQL/GUI/Controllers/Parts/RenderingController.h"
#include "WinQL/GUI/Window.h"
__QCMP_WARNING_POP
#include "WinQL/GUI/Views/WindowView.h"
#include "WinQAPI/Kernel32.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	using namespace nsWinQAPI;

	__QOR_IMPLEMENT_OCLASS_LUID( CRenderingController );

	//--------------------------------------------------------------------------------
	CRenderingController::CRenderingController( nsMammut::CModel* pModelItem, nsQOR::CController::ref_type Parent ) : CBaseWindowPartController( pModelItem, Parent )
	{
		_WINQ_FCONTEXT( "CRenderingController::CRenderingController" );
	}

	//--------------------------------------------------------------------------------
	CRenderingController::~CRenderingController()
	{
		_WINQ_FCONTEXT( "CRenderingController::~CRenderingController" );
	}

	//--------------------------------------------------------------------------------
	bool CRenderingController::ProcessMessage( COSWindow& Window, Cmp_long_ptr& lResult, unsigned int uMsg, Cmp_uint_ptr wParam, Cmp_long_ptr lParam )
	{
		_WINQ_FCONTEXT( "CRenderingController::ProcessMessage" );

		bool bProcessed = ProcessHook( Window, lResult, uMsg, wParam, lParam );

        if( bProcessed )
        {
            return true;
        }

		//this->GetView()->pWindow->m_View().QueryInterface( CRenderedWindowView::IID_IRenderedWindowView, (void**)&m_pView );

		switch ( uMsg )
		{
		case COSWindow::wmPaint:
			{
				OnPaint( Window );
				lResult = 0;
				bProcessed = true;
			}
			break;
		case COSWindow::wmSetRedraw:
			{
				bool bRedraw = ( ( wParam == 1 ) ? true : false );
				OnSetRedraw( Window, bRedraw );
				lResult = 0;
				bProcessed = true;
			}
			break;
		case COSWindow::wmEraseBackground:
			{
				CDeviceContext::refType refDC = CDeviceContext::FromHandle( CDCHandle( 0, (void*)( wParam ) ).Ref() );
				lResult = OnEraseBackground( Window, refDC );
				bProcessed = true;
			}
			break;
		case COSWindow::wmSysColorChange:
			{
				OnSysColourChange( Window );//Forward to all children and regen all SysColour Brushes
				bProcessed = true;
			}
			break;
		case COSWindow::wmShowWindow:
			{
				bool bShow = wParam ? true : false;
				OnShow( Window, bShow, lParam );
				lResult = 0;
				bProcessed = true;
			}
			break;
		case COSWindow::wmGetMinMaxInfo:
			{
				MINMAXINFO* pMinMaxInfo = reinterpret_cast< MINMAXINFO* >( lParam );
				OnGetMinMaxInfo( Window, pMinMaxInfo );
				lResult = 0;
				bProcessed = true;
			}
			break;
		case COSWindow::wmWindowPosChanging:
			{
				WindowPos* pWindowPos = reinterpret_cast< WindowPos* >( lParam );
				OnWindowPosChanging( Window, pWindowPos );
				lResult = 0;
				bProcessed = true;
			}
			break;
		case COSWindow::wmWindowPosChanged:
			{
				WindowPos* pWindowPos = reinterpret_cast< WindowPos* >( lParam );
				OnWindowPosChanged( Window, pWindowPos );
				lResult = 0;
				bProcessed = true;
			}
			break;
		case COSWindow::wmDisplayChange:
			{
				unsigned short wBitsPP = static_cast< unsigned short >( wParam );
				unsigned short hRes = LoWord( lParam );
				unsigned short vRes = HiWord( lParam );
				OnDisplayChange( Window, wBitsPP, hRes, vRes );
				bProcessed = true;
			}
			break;
		case COSWindow::wmGetIcon:
			{
				lResult = OnGetIcon( Window, wParam );
				bProcessed = true;
			}
			break;
		case COSWindow::wmSetIcon:
			{
				CIcon::refType refIcon = CIcon::FromHandle( CIconHandle( 0, (void*)( lParam ) ).Ref() );
				lResult = OnSetIcon( Window, wParam, refIcon );
				bProcessed = true;
			}
			break;
		case COSWindow::wmSyncPaint:
			{
				OnSyncPaint( Window );
				lResult = 0;
				bProcessed = true;
			}
			break;
		case COSWindow::wmSizing:
			{
				RECT* pRect = reinterpret_cast< RECT* >( lParam );
				OnSizing( Window, wParam, pRect );
				lResult = 1;
				bProcessed = true;
			}
			break;
		case COSWindow::wmMoving:
			{
				RECT* pRect = reinterpret_cast< RECT* >( lParam );
				OnMoving( Window, pRect );
				lResult = 1;
				bProcessed = true;
			}
			break;
		case COSWindow::wmQueryNewPalette:
			{
				lResult = OnQueryNewPalette( Window );
				bProcessed = true;
			}
			break;
		case COSWindow::wmPaletteIsChanging:
			{
				COSWindow::refType refWindow = COSWindow::FromHandle( CWindowHandle( 0, (void*)(wParam) ).Ref() );
				OnPaletteChanging( refWindow );
				lResult = 0;
				bProcessed = true;
			}
			break;
		case COSWindow::wmPaletteChanged:
			{
				COSWindow::refType refWindow = COSWindow::FromHandle( CWindowHandle( 0, (void*)(wParam) ).Ref() );
				OnPaletteChanged( refWindow );					
				bProcessed = true;
			}
			break;
		case COSWindow::wmPrint:
			{
				CDeviceContext::refType refDC = CDeviceContext::FromHandle( CDCHandle( 0, (void*)(wParam) ).Ref() );
				OnPrint( Window, refDC, lParam );
				bProcessed = true;
			}
			break;
		case COSWindow::wmPrintClient:
			{
				CDeviceContext::refType refDC = CDeviceContext::FromHandle( CDCHandle( 0, (void*)(wParam) ).Ref() );
				OnPrintClient( Window, refDC, lParam );
				bProcessed = true;
			}
			break;
		case COSWindow::wmSize:
			{
				OnSize( Window, wParam, lParam );
				lResult = 0;
				bProcessed = true;
			}
			break;
		case COSWindow::wmMove:
			{
				OnMove( Window, LoWord( lParam ), HiWord( lParam ) );
				lResult = 0;
				bProcessed = true;
			}
			break;
		}

		return bProcessed;
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnSize( COSWindow& Window, Cmp_uint_ptr wParam, Cmp_long_ptr lParam )
	{
		Window.DefProc( COSWindow::wmSize, wParam, lParam );
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnMove( COSWindow& Window, unsigned short wXPos, unsigned short wYPos )
	{
		Window.DefProc( COSWindow::wmMove, 0, MakeLong( wXPos, wYPos ) );
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnPaint( COSWindow& Window )
	{
		Window.DefProc( COSWindow::wmPaint, 0, 0 );
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnSetRedraw( COSWindow& Window, bool bRedraw )
	{
		Window.DefProc( COSWindow::wmSetRedraw, static_cast< Cmp_uint_ptr >( bRedraw ? 1 : 0 ), 0 );
	}

	//--------------------------------------------------------------------------------
	long CRenderingController::OnEraseBackground( COSWindow& Window, CDeviceContext::refType refDC )
	{
        long lResult = 0;/*m_pView ? m_pView->OnEraseBackground( Window, refDC ) :
            Window.DefProc( COSWindow::wmEraseBackground, reinterpret_cast< Cmp_uint_ptr >( refDC->Handle()->Use() ), 0 );*/
           
		return lResult;
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnSysColourChange( COSWindow& Window )
	{
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnShow( COSWindow& Window, bool bShow, Cmp_long_ptr lParam )
	{
		Window.DefProc( COSWindow::wmShowWindow, static_cast< Cmp_uint_ptr >( bShow ), lParam );
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnGetMinMaxInfo( COSWindow& Window, MINMAXINFO* pMinMaxInfo )
	{
		Window.DefProc( COSWindow::wmGetMinMaxInfo, 0, (Cmp_long_ptr)pMinMaxInfo );
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnWindowPosChanging( COSWindow& Window, WindowPos* pWindowPos )
	{
		::WINDOWPOS WP;
		Window.DefProc( COSWindow::wmWindowPosChanging, 0, reinterpret_cast< Cmp_long_ptr >( &WP ) );
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnWindowPosChanged( COSWindow& Window, WindowPos* pWindowPos )
	{
		::WINDOWPOS WP;
		
		Window.DefProc( COSWindow::wmWindowPosChanged, 0, reinterpret_cast< Cmp_long_ptr >( &WP ) );
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnDisplayChange( COSWindow& Window, unsigned short wBitsPP, unsigned short hRes, unsigned short vRes )
	{
	}

	//--------------------------------------------------------------------------------
	long CRenderingController::OnGetIcon( COSWindow& Window, Cmp_uint_ptr wParam )
	{
		long lResult = 0;//IconHandle of relevent icon
		return lResult;
	}

	//--------------------------------------------------------------------------------
	long CRenderingController::OnSetIcon( COSWindow& Window, Cmp_uint_ptr wParam, CIcon::refType Icon )
	{
		long lResult = 0;//Must be previous icon handle
		return lResult;
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnSyncPaint( COSWindow& Window )
	{
		Window.DefProc( COSWindow::wmSyncPaint, 0, 0 );
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnSizing( COSWindow& Window, Cmp_uint_ptr wParam, RECT* pRect )
	{
		Window.DefProc( COSWindow::wmSizing, 0, reinterpret_cast< Cmp_long_ptr >( pRect ) );
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnMoving( COSWindow& Window, RECT* pRect )
	{
		Window.DefProc( COSWindow::wmMoving, 0, reinterpret_cast< Cmp_long_ptr >( pRect ) );
	}

	//--------------------------------------------------------------------------------
	long CRenderingController::OnQueryNewPalette( COSWindow& Window )
	{
		/*The WM_QUERYNEWPALETTE message informs a window that it is about to receive 
		the keyboard focus, giving the window the opportunity to realize its logical 
		palette when it receives the focus. */

		/*If the window realizes its logical palette, it must return TRUE; otherwise, 
		it must return FALSE.*/

		long lResult = 0;
		return lResult;
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnPaletteChanging( COSWindow::refType Window )
	{
		/*The WM_PALETTEISCHANGING message informs applications that an application 
		is going to realize its logical palette.*/
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnPaletteChanged( COSWindow::refType Window )
	{
		/*The WM_PALETTECHANGED message is sent to all top-level and overlapped 
		windows after the window with the keyboard focus has realized its logical 
		palette, thereby changing the system palette. This message enables a window 
		that uses a color palette but does not have the keyboard focus to realize 
		its logical palette and update its client area.*/
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnPrint( COSWindow& Window, CDeviceContext::refType DC, Cmp_long_ptr lParam )
	{
		Window.DefProc( COSWindow::wmPrint, (Cmp_uint_ptr)( DC->Handle()->Use() ), lParam );
	}

	//--------------------------------------------------------------------------------
	void CRenderingController::OnPrintClient( COSWindow& Window, CDeviceContext::refType DC, Cmp_long_ptr lParam )
	{
		//The WM_PRINTCLIENT message is sent to a window to request 
		//that it draw its client area in the specified device context, 
		//most commonly in a printer device context.
	}

}//nsWin32
