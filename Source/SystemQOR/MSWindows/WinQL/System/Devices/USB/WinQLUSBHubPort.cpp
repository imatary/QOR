//WinQLUSBHubPort.cpp

// Copyright Querysoft Limited 2013, 2017
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/CodeServices/WinQLPolicy.h"
#include "WinQL/Application/Threading/WinQLCriticalSection.h"
#include "WinQL/Definitions/Constants.h"
#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "WinQL/CodeServices/Text/WinString.h"
#include "WinQL/System/Devices/USB/WinQLUSBHub.h"
#include "WinQL/System/Devices/Interfaces/WinQLDeviceInterfaceClass.h"
#include "WinQL/System/WinQLSystem.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{

	//--------------------------------------------------------------------------------
	CUSBHub::CPortConnection::CPortConnection() : m_pHub( 0 ), m_ulConnectionIndex( 0 ), m_bInfo( false ), m_bInfoEx( false ), m_bInfoExV2( false ), m_bProperties( false ), m_bAttributes( false )
	{
	}

	//--------------------------------------------------------------------------------
	CUSBHub::CPortConnection::CPortConnection( CUSBHub* pHub, unsigned long ulConnectionIndex ) : m_pHub( pHub ), m_ulConnectionIndex( ulConnectionIndex ), m_bInfo( false ), m_bInfoEx( false ), m_bInfoExV2( false ), m_bProperties( false ), m_bAttributes( false )
	{

	}

	//--------------------------------------------------------------------------------
	CUSBHub::CPortConnection::CPortConnection( const CPortConnection& src ) : m_pHub( src.m_pHub ), m_ulConnectionIndex( src.m_ulConnectionIndex ), m_bInfo( src.m_bInfo ), m_bInfoEx( src.m_bInfoEx ), m_bInfoExV2( src.m_bInfoExV2 ), m_bProperties( src.m_bProperties ), m_bAttributes( src.m_bAttributes )
	{
		Info = src.Info;
		Pipes = src.Pipes;
		ConnectorProperties = src.ConnectorProperties;
		InfoEx = src.InfoEx;
		InfoExV2 = src.InfoExV2;
		strName = src.strName;
		strDriverKeyName = src.strDriverKeyName;
		Attributes = src.Attributes;
	}
	
	//--------------------------------------------------------------------------------
	CUSBHub::CPortConnection::~CPortConnection()
	{
	}

	//--------------------------------------------------------------------------------
	void CUSBHub::CPortConnection::Setup( CUSBHub* pHub, unsigned long ulConnectionIndex )
	{
		if( m_pHub == 0 && m_ulConnectionIndex == 0 )
		{
			m_pHub = pHub;
			m_ulConnectionIndex = ulConnectionIndex;
		}
	}

	//--------------------------------------------------------------------------------
	bool CUSBHub::CPortConnection::ValidateProperties()
	{
		if( !m_bProperties )
		{
			m_bProperties = GetProperties();
		}
		return m_bProperties;
	}

	//--------------------------------------------------------------------------------
	bool CUSBHub::CPortConnection::GetProperties()
	{
		auto Session = m_pHub->Open(Generic_Write, File_Share_Write, Open_Existing);
		unsigned long nBytes = 0;
		memset( &ConnectorProperties, 0, sizeof( USB_PORT_CONNECTOR_PROPERTIES ) );
		ConnectorProperties.ConnectionIndex = m_ulConnectionIndex;
        bool bSuccess = Session->Control( 
			__WINQL_DEVICE_CONTROL_CODE( File_Device_USB, USB_GET_PORT_CONNECTOR_PROPERTIES, Method_Buffered, File_Any_Access ), &ConnectorProperties, sizeof(USB_PORT_CONNECTOR_PROPERTIES), &ConnectorProperties, sizeof(USB_PORT_CONNECTOR_PROPERTIES), &nBytes, NULL );
		return bSuccess;
	}

	//--------------------------------------------------------------------------------
	CWString CUSBHub::CPortConnection::GetName()
	{
		auto Session = m_pHub->Open(Generic_Write, File_Share_Write, Open_Existing);
		bool success = 0;
		unsigned long nBytes = 0;
		USB_NODE_CONNECTION_NAME    extHubName;
		USB_NODE_CONNECTION_NAME*   extHubNameW = NULL;
		CWString strNodeConnectionName;

		// Get the length of the name of the external hub attached to the specified port.
		memset( &extHubName, 0, sizeof( USB_NODE_CONNECTION_NAME ) );
		extHubName.ConnectionIndex = m_ulConnectionIndex;
		success = Session->Control(
			__WINQL_DEVICE_CONTROL_CODE( File_Device_USB, USB_GET_NODE_CONNECTION_NAME, Method_Buffered, File_Any_Access ), &extHubName, sizeof( extHubName ), &extHubName, sizeof( extHubName ), &nBytes, NULL );

		if( success )
		{
			nBytes = extHubName.ActualLength;
			nsCodeQOR::CTLRef< byte > Buffer( new byte[ nBytes ], true );
			extHubNameW = reinterpret_cast< USB_NODE_CONNECTION_NAME* >( Buffer.operator byte *() );

			// Get the name of the external hub attached to the specified port
    
			extHubNameW->ConnectionIndex = m_ulConnectionIndex;
			success = Session->Control(
				__WINQL_DEVICE_CONTROL_CODE( File_Device_USB, USB_GET_NODE_CONNECTION_NAME, Method_Buffered, File_Any_Access ), extHubNameW, nBytes, extHubNameW, nBytes, &nBytes, NULL);

			memcpy( strNodeConnectionName.GetBufferSetLength( static_cast< unsigned short >( nBytes / sizeof( wchar_t ) ) ), extHubNameW->NodeName, nBytes );
			strNodeConnectionName.ValidateBuffer( static_cast< unsigned short >( nBytes / sizeof( wchar_t ) ) );
		
			strName = strNodeConnectionName;
		}
		return strNodeConnectionName;
	}

	//--------------------------------------------------------------------------------
	bool CUSBHub::CPortConnection::GetInformation()
	{
		auto Session = m_pHub->Open(Generic_Write, File_Share_Write, Open_Existing);
		unsigned long nBytes = sizeof( USB_NODE_CONNECTION_INFORMATION ) + sizeof( USB_PIPE_INFO ) * 30;

		nsCodeQOR::CTLRef< byte > Buffer( new byte[ nBytes ], true );
		memset( Buffer.operator byte *(), 0, sizeof( USB_NODE_CONNECTION_INFORMATION ) );
		USB_NODE_CONNECTION_INFORMATION* pConnectionInfo = reinterpret_cast< USB_NODE_CONNECTION_INFORMATION* >( Buffer.operator byte *() );
		pConnectionInfo->ConnectionIndex = m_ulConnectionIndex;
		bool bSuccess = Session->Control( 
			__WINQL_DEVICE_CONTROL_CODE( File_Device_USB, USB_GET_NODE_CONNECTION_INFORMATION, Method_Buffered, File_Any_Access ), pConnectionInfo, nBytes, pConnectionInfo, nBytes, &nBytes, NULL );

		if( bSuccess )
		{
			memcpy( &Info, pConnectionInfo, sizeof( USB_NODE_CONNECTION_INFORMATION ) );

			Pipes.erase( Pipes.begin(), Pipes.end() );

			for( unsigned int uiPipe = 0; uiPipe < pConnectionInfo->NumberOfOpenPipes; uiPipe++ )
			{
				Pipes.push_back( (reinterpret_cast< USB_PIPE_INFO* >( pConnectionInfo + 1 ) )[ uiPipe ] );
			}
		}

		return bSuccess;
	}

	//--------------------------------------------------------------------------------
	bool CUSBHub::CPortConnection::ValidateInfoEx( void )
	{
		if( !m_bInfoEx )
		{
			m_bInfoEx = GetInformationEx();
		}
		return m_bInfoEx;
	}

	//--------------------------------------------------------------------------------
	bool CUSBHub::CPortConnection::GetInformationEx()
	{
		auto Session = m_pHub->Open(Generic_Write, File_Share_Write, Open_Existing);
		unsigned long nBytesEx = sizeof( USB_NODE_CONNECTION_INFORMATION_EX ) + ( sizeof( USB_PIPE_INFO ) * 30 );

		nsCodeQOR::CTLRef< byte > Buffer( new byte[ nBytesEx ], true );
		memset( Buffer.operator byte *(), 0, sizeof( USB_NODE_CONNECTION_INFORMATION_EX ) );
		USB_NODE_CONNECTION_INFORMATION_EX* pConnectionInfo = reinterpret_cast< USB_NODE_CONNECTION_INFORMATION_EX* >( Buffer.operator byte *() );
		pConnectionInfo->ConnectionIndex = m_ulConnectionIndex;
        bool bSuccess = Session->Control( 
			__WINQL_DEVICE_CONTROL_CODE( File_Device_USB, USB_GET_NODE_CONNECTION_INFORMATION_EX, Method_Buffered, File_Any_Access ), pConnectionInfo, nBytesEx, pConnectionInfo, nBytesEx, &nBytesEx, NULL );

		if( bSuccess )
		{
			memcpy( &InfoEx, pConnectionInfo, sizeof( USB_NODE_CONNECTION_INFORMATION_EX ) );

			Pipes.erase( Pipes.begin(), Pipes.end() );

			for( unsigned int uiPipe = 0; uiPipe < pConnectionInfo->NumberOfOpenPipes; uiPipe++ )
			{
				Pipes.push_back( (reinterpret_cast< USB_PIPE_INFO* >( pConnectionInfo + 1 ) )[ uiPipe ] );
			}

		}
		return bSuccess;
	}

	//--------------------------------------------------------------------------------
	bool CUSBHub::CPortConnection::ValidateInfoExV2()
	{
		if( !m_bInfoExV2 )
		{
			m_bInfoExV2 = GetInformationExV2();
		}
		return m_bInfoExV2;
	}

	//--------------------------------------------------------------------------------
	bool CUSBHub::CPortConnection::GetInformationExV2()
	{
		auto Session = m_pHub->Open(Generic_Write, File_Share_Write, Open_Existing);
		unsigned long nBytes = 0;

		memset( &InfoExV2, 0, sizeof( USB_NODE_CONNECTION_INFORMATION_EX_V2 ) );
		InfoExV2.ConnectionIndex = m_ulConnectionIndex;
        bool bSuccess = Session->Control( 
			__WINQL_DEVICE_CONTROL_CODE( File_Device_USB, USB_GET_NODE_CONNECTION_INFORMATION_EX_V2, Method_Buffered, File_Any_Access ), 
			&InfoExV2, sizeof( USB_NODE_CONNECTION_INFORMATION_EX_V2 ), &InfoExV2, sizeof( USB_NODE_CONNECTION_INFORMATION_EX_V2 ), &nBytes, NULL );

		return bSuccess;
	}

	//--------------------------------------------------------------------------------
	bool CUSBHub::CPortConnection::ValidateAttributes( void )
	{
		if( !m_bAttributes )
		{
			m_bAttributes = GetAttributes();
		}
		return m_bAttributes;
	}

	//--------------------------------------------------------------------------------
	bool CUSBHub::CPortConnection::GetAttributes()
	{
		auto Session = m_pHub->Open(Generic_Write, File_Share_Write, Open_Existing);
		unsigned long nBytes = 0;
		memset( &Attributes, 0, sizeof( USB_NODE_CONNECTION_ATTRIBUTES ) );
		Attributes.ConnectionIndex = m_ulConnectionIndex;

		bool bSuccess = Session->Control(
			__WINQL_DEVICE_CONTROL_CODE( File_Device_USB, USB_GET_NODE_CONNECTION_ATTRIBUTES, Method_Buffered, File_Any_Access ), 
			&Attributes, sizeof( USB_NODE_CONNECTION_ATTRIBUTES ), 
			&Attributes, sizeof( USB_NODE_CONNECTION_ATTRIBUTES ), &nBytes, NULL );

		return bSuccess;
	}

	//--------------------------------------------------------------------------------
	CWString CUSBHub::CPortConnection::GetDriverKeyName()
	{
		auto Session = m_pHub->Open(Generic_Write, File_Share_Write, Open_Existing);
		bool success = 0;
		unsigned long nBytes = 0;
		USB_NODE_CONNECTION_DRIVERKEY_NAME  driverKeyName;
		USB_NODE_CONNECTION_DRIVERKEY_NAME* driverKeyNameW = 0;

		// Get the length of the name of the driver key of the device attached to the specified port.
    
		memset( &driverKeyName, 0, sizeof( USB_NODE_CONNECTION_DRIVERKEY_NAME ) );
		driverKeyName.ConnectionIndex = m_ulConnectionIndex;

		success = Session->Control(
			__WINQL_DEVICE_CONTROL_CODE( File_Device_USB, USB_GET_NODE_CONNECTION_DRIVERKEY_NAME, Method_Buffered, File_Any_Access ), &driverKeyName, sizeof( driverKeyName ), &driverKeyName, sizeof( driverKeyName ), &nBytes, NULL );

		if( success )
		{
			// Allocate space to hold the driver key name
			nBytes = driverKeyName.ActualLength;
			nsCodeQOR::CTLRef< byte > Buffer( new byte[ nBytes ], true );
			driverKeyNameW = reinterpret_cast< USB_NODE_CONNECTION_DRIVERKEY_NAME* >( Buffer.operator byte *() );

			// Get the name of the driver key of the device attached to the specified port.
    
			driverKeyNameW->ConnectionIndex = m_ulConnectionIndex;

			success = Session->Control(
				__WINQL_DEVICE_CONTROL_CODE( File_Device_USB, USB_GET_NODE_CONNECTION_DRIVERKEY_NAME, Method_Buffered, File_Any_Access ), driverKeyNameW, nBytes, driverKeyNameW, nBytes, &nBytes, NULL );

			memcpy( strDriverKeyName.GetBufferSetLength( static_cast< unsigned short >( nBytes / sizeof( wchar_t ) ) ), driverKeyNameW->DriverKeyName, nBytes );

			strDriverKeyName.ValidateBuffer( static_cast< unsigned short >( nBytes / sizeof( wchar_t ) ) );
		}
		return strDriverKeyName;

	}

	//--------------------------------------------------------------------------------
	bool CUSBHub::CPortConnection::ValidateInfo()
	{
		if( !m_bInfo )
		{
			m_bInfo = GetInformation();
		}
		return m_bInfo;
	}

	//--------------------------------------------------------------------------------
	byte CUSBHub::CPortConnection::GetDeviceClass()
	{
		byte Result = 0;
		if( ValidateInfo() )
		{
			Result = Info.DeviceDescriptor.bDeviceClass;
		}
		return Result;
	}
	
	//--------------------------------------------------------------------------------
	byte CUSBHub::CPortConnection::GetDeviceSubClass()
	{
		byte Result = 0;
		if( ValidateInfo() )
		{
			Result = Info.DeviceDescriptor.bDeviceSubClass;
		}
		return Result;
	}

	//--------------------------------------------------------------------------------
	byte CUSBHub::CPortConnection::GetDeviceProtocol()
	{
		byte Result = 0;
		if( ValidateInfo() )
		{
			Result = Info.DeviceDescriptor.bDeviceProtocol;
		}
		return Result;
	}

	//--------------------------------------------------------------------------------
	byte CUSBHub::CPortConnection::GetMaxPacketSize()
	{
		byte Result = 0;
		if( ValidateInfo() )
		{
			Result = Info.DeviceDescriptor.bMaxPacketSize0;
		}
		return Result;
	}

	//--------------------------------------------------------------------------------
	unsigned short CUSBHub::CPortConnection::GetVendorID()
	{
		unsigned short usResult = 0;
		if( ValidateInfo() )
		{
			usResult = Info.DeviceDescriptor.idVendor;
		}
		return usResult;
	}

	//--------------------------------------------------------------------------------
	unsigned short CUSBHub::CPortConnection::GetProductID()
	{
		unsigned short usResult = 0;
		if( ValidateInfo() )
		{
			usResult = Info.DeviceDescriptor.idProduct;
		}
		return usResult;
	}

	//--------------------------------------------------------------------------------
	unsigned short CUSBHub::CPortConnection::GetBCDDevice()
	{
		unsigned short usResult = 0;
		if( ValidateInfo() )
		{
			usResult = Info.DeviceDescriptor.bcdDevice;
		}
		return usResult;
	}

	//--------------------------------------------------------------------------------
	byte CUSBHub::CPortConnection::GetManufacturer()
	{
		byte Result = 0;
		if( ValidateInfo() )
		{
			Result = Info.DeviceDescriptor.iManufacturer;
		}
		return Result;
	}

	//--------------------------------------------------------------------------------
	byte CUSBHub::CPortConnection::GetProduct()
	{
		byte Result = 0;
		if( ValidateInfo() )
		{
			Result = Info.DeviceDescriptor.iProduct;
		}
		return Result;
	}

	//--------------------------------------------------------------------------------
	byte CUSBHub::CPortConnection::GetSerialNumber()
	{
		byte Result = 0;
		if( ValidateInfo() )
		{
			Result = Info.DeviceDescriptor.iSerialNumber;
		}
		return Result;
	}

	//--------------------------------------------------------------------------------
	byte CUSBHub::CPortConnection::GetNumberOfConfigurations()
	{
		byte Result = 0;
		if( ValidateInfo() )
		{
			Result = Info.DeviceDescriptor.bNumConfigurations;
		}
		return Result;
	}

	//--------------------------------------------------------------------------------
	byte CUSBHub::CPortConnection::GetCurrentConfiguration()
	{
		byte Result = 0;
		if( ValidateInfo() )
		{
			Result = Info.CurrentConfigurationValue;
		}
		return Result;
	}

	//--------------------------------------------------------------------------------
	byte CUSBHub::CPortConnection::GetLowSpeed()
	{
		byte Result = 0;
		if( ValidateInfo() )
		{
			Result = Info.LowSpeed;
		}
		return Result;
	}

	//--------------------------------------------------------------------------------
	bool CUSBHub::CPortConnection::IsHub()
	{
		bool bResult = false;
		if( ValidateInfo() )
		{
			bResult = Info.DeviceIsHub ? true : false;
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	unsigned short CUSBHub::CPortConnection::GetDeviceAddress()
	{
		unsigned short usResult = 0;
		if( ValidateInfo() )
		{
			usResult = Info.DeviceAddress;
		}
		return usResult;
	}

	//--------------------------------------------------------------------------------
	unsigned long CUSBHub::CPortConnection::GetNumberOfOpenPipes()
	{
		unsigned long ulResult = 0;
		if( ValidateInfo() )
		{
			ulResult = Info.NumberOfOpenPipes;
		}
		return ulResult;
	}

	//--------------------------------------------------------------------------------
	CUSBHub::USB_CONNECTION_STATUS CUSBHub::CPortConnection::GetConnectionStatus()
	{
		USB_CONNECTION_STATUS Result = NoDeviceConnected;
		if( ValidateAttributes() )
		{
			Result = Attributes.ConnectionStatus;
		}
		return Result;
	}

	//--------------------------------------------------------------------------------
	byte CUSBHub::CPortConnection::GetSpeed()
	{
		byte Result = 0;
		if( ValidateInfoEx() )
		{
			Result = InfoEx.Speed;
		}
		return Result;
	}

	//--------------------------------------------------------------------------------
	CUSBHub::USB_PROTOCOLS CUSBHub::CPortConnection::GetSupportedUsbProtocols( void )
	{
		CUSBHub::USB_PROTOCOLS Result;
		Result.ul = 0;
		if( ValidateInfoExV2() )
		{
			Result.ul = InfoExV2.SupportedUsbProtocols.ul;
		}
		return Result;
	}

	//--------------------------------------------------------------------------------
	bool CUSBHub::CPortConnection::IsDeviceOperatingAtSuperSpeedOrHigher( void )
	{
		bool bResult = false;
		if( ValidateInfoExV2() )
		{
			bResult = InfoExV2.Flags.DeviceIsOperatingAtSuperSpeedOrHigher ? true : false;
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CUSBHub::CPortConnection::IsDeviceSuperSpeedCapableOrHigher( void )
	{
		bool bResult = false;
		if( ValidateInfoExV2() )
		{
			bResult = InfoExV2.Flags.DeviceIsSuperSpeedCapableOrHigher ? true : false;
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CUSBHub::CPortConnection::IsPortUserConnectable( void )
	{
		bool bResult = false;
		if( ValidateProperties() )
		{
			bResult = ConnectorProperties.UsbPortProperties.PortIsUserConnectable ? true : false;
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CUSBHub::CPortConnection::IsPortDebugCapable( void )
	{
		bool bResult = false;
		if( ValidateProperties() )
		{
			bResult = ConnectorProperties.UsbPortProperties.PortIsDebugCapable ? true : false;
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	unsigned short CUSBHub::CPortConnection::GetCompanionIndex( void )
	{
		unsigned short usResult = 0;
		if( ValidateProperties() )
		{
			usResult = ConnectorProperties.CompanionIndex;
		}
		return usResult;
	}

	//--------------------------------------------------------------------------------
	unsigned short CUSBHub::CPortConnection::GetCompanionPortNumber( void )
	{
		unsigned short usResult = 0;
		if( ValidateProperties() )
		{
			usResult = ConnectorProperties.CompanionPortNumber;
		}
		return usResult;
	}

	//--------------------------------------------------------------------------------
	CWString CUSBHub::CPortConnection::GetCompanionHubSymbolicLinkName( void )
	{
		CWString strResult;
		if( ValidateProperties() )
		{
			strResult = CWString( ConnectorProperties.CompanionHubSymbolicLinkName );
		}
		return strResult;
	}

}//nsWin32
