//WinQLStreamFormatter.cpp

// Copyright Querysoft Limited 2017
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <errno.h>
#include <wchar.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include "WinQL/System/FileSystem/WinQLStream.h"
#include "WinQL/System/FileSystem/WinQLStreamFormatter.h"
#include "WinQL/Application/Console/WinQLConsole.h"
#include "WinQAPI/Kernel32.h"


#define FIND_CHAR_CLASS(lookuptbl, c)      \
        ((c) < L' ' || (c) > L'x' ? \
            CH_OTHER            \
            :               \
        (enum CHARTYPE)(lookuptbl[(c)-L' '] & 0xF))

#define FIND_NEXT_STATE(lookuptbl, class, state)   \
        (enum STATE)(lookuptbl[(class) * NUMSTATES + (state)] >> 4)

//extern const unsigned char __lookuptable_s[];
//extern const char __lookuptable[];

//------------------------------------------------------------------------------


//--------------------------------------------------------------------------------
namespace nsWin32
{
	using namespace nsWinQAPI;

	char* CStreamFormatter::__nullstring = "(null)";  // string to print on null ptr
	wchar_t* CStreamFormatter::__wnullstring = L"(null)";// string to print on null ptr
														 
	const char CStreamFormatter::__lookuptable[] =
	{
		/* ' ' */  0x06,
		/* '!' */  0x00,
		/* '"' */  0x00,
		/* '#' */  0x06,
		/* '$' */  0x00,
		/* '%' */  0x01,
		/* '&' */  0x00,
		/* ''' */  0x00,
		/* '(' */  0x10,
		/* ')' */  0x00,
		/* '*' */  0x03,
		/* '+' */  0x06,
		/* ',' */  0x00,
		/* '-' */  0x06,
		/* '.' */  0x02,
		/* '/' */  0x10,
		/* '0' */  0x04,
		/* '1' */  0x45,
		/* '2' */  0x45,
		/* '3' */  0x45,
		/* '4' */  0x05,
		/* '5' */  0x05,
		/* '6' */  0x05,
		/* '7' */  0x05,
		/* '8' */  0x05,
		/* '9' */  0x35,
		/* ':' */  0x30,
		/* ';' */  0x00,
		/* '<' */  0x50,
		/* '=' */  0x00,
		/* '>' */  0x00,
		/* '?' */  0x00,
		/* '@' */  0x00,
#if defined (_SAFECRT_IMPL)
		/* 'A' */  0x20,       // Disable %A format
#else  /* defined (_SAFECRT_IMPL) */
		/* 'A' */  0x28,
#endif  /* defined (_SAFECRT_IMPL) */
		/* 'B' */  0x20,
		/* 'C' */  0x38,
		/* 'D' */  0x50,
		/* 'E' */  0x58,
		/* 'F' */  0x07,
		/* 'G' */  0x08,
		/* 'H' */  0x00,
		/* 'I' */  0x37,
		/* 'J' */  0x30,
		/* 'K' */  0x30,
		/* 'L' */  0x57,
		/* 'M' */  0x50,
		/* 'N' */  0x07,
		/* 'O' */  0x00,
		/* 'P' */  0x00,
		/* 'Q' */  0x20,
		/* 'R' */  0x20,
		/* 'S' */  0x08,
		/* 'T' */  0x00,
		/* 'U' */  0x00,
		/* 'V' */  0x00,
		/* 'W' */  0x00,
		/* 'X' */  0x08,
		/* 'Y' */  0x60,
		/* 'Z' */  0x68,
		/* '[' */  0x60,
		/* '\' */  0x60,
		/* ']' */  0x60,
		/* '^' */  0x60,
		/* '_' */  0x00,
		/* '`' */  0x00,
#if defined (_SAFECRT_IMPL)
		/* 'a' */  0x70,       // Disable %a format
#else  /* defined (_SAFECRT_IMPL) */
		/* 'a' */  0x78,
#endif  /* defined (_SAFECRT_IMPL) */
		/* 'b' */  0x70,
		/* 'c' */  0x78,
		/* 'd' */  0x78,
		/* 'e' */  0x78,
		/* 'f' */  0x78,
		/* 'g' */  0x08,
		/* 'h' */  0x07,
		/* 'i' */  0x08,
		/* 'j' */  0x00,
		/* 'k' */  0x00,
		/* 'l' */  0x07,
		/* 'm' */  0x00,
#if defined (_SAFECRT_IMPL)
		/* 'n' */  0x00,       // Disable %n format
#else  /* defined (_SAFECRT_IMPL) */
		/* 'n' */  0x08,
#endif  /* defined (_SAFECRT_IMPL) */
		/* 'o' */  0x08,
		/* 'p' */  0x08,
		/* 'q' */  0x00,
		/* 'r' */  0x00,
		/* 's' */  0x08,
		/* 't' */  0x00,
		/* 'u' */  0x08,
		/* 'v' */  0x00,
		/* 'w' */  0x07,
		/* 'x' */  0x08
	};

	const unsigned char CStreamFormatter::__lookuptable_s[] =
	{
		/* ' ' */  0x06,
		/* '!' */  0x80,
		/* '"' */  0x80,
		/* '#' */  0x86,
		/* '$' */  0x80,
		/* '%' */  0x81,
		/* '&' */  0x80,
		/* ''' */  0x00,
		/* '(' */  0x00,
		/* ')' */  0x10,
		/* '*' */  0x03,
		/* '+' */  0x86,
		/* ',' */  0x80,
		/* '-' */  0x86,
		/* '.' */  0x82,
		/* '/' */  0x80,
		/* '0' */  0x14,
		/* '1' */  0x05,
		/* '2' */  0x05,
		/* '3' */  0x45,
		/* '4' */  0x45,
		/* '5' */  0x45,
		/* '6' */  0x85,
		/* '7' */  0x85,
		/* '8' */  0x85,
		/* '9' */  0x05,
		/* ':' */  0x00,
		/* ';' */  0x00,
		/* '<' */  0x30,
		/* '=' */  0x30,
		/* '>' */  0x80,
		/* '?' */  0x50,
		/* '@' */  0x80,
#if defined (_SAFECRT_IMPL)
		/* 'A' */  0x80,       // Disable %A format
#else  /* defined (_SAFECRT_IMPL) */
		/* 'A' */  0x88,
#endif  /* defined (_SAFECRT_IMPL) */
		/* 'B' */  0x00,
		/* 'C' */  0x08,
		/* 'D' */  0x00,
		/* 'E' */  0x28,
		/* 'F' */  0x27,
		/* 'G' */  0x38,
		/* 'H' */  0x50,
		/* 'I' */  0x57,
		/* 'J' */  0x80,
		/* 'K' */  0x00,
		/* 'L' */  0x07,
		/* 'M' */  0x00,
		/* 'N' */  0x37,
		/* 'O' */  0x30,
		/* 'P' */  0x30,
		/* 'Q' */  0x50,
		/* 'R' */  0x50,
		/* 'S' */  0x88,
		/* 'T' */  0x00,
		/* 'U' */  0x00,
		/* 'V' */  0x00,
		/* 'W' */  0x20,
		/* 'X' */  0x28,
		/* 'Y' */  0x80,
		/* 'Z' */  0x88,
		/* '[' */  0x80,
		/* '\' */  0x80,
		/* ']' */  0x00,
		/* '^' */  0x00,
		/* '_' */  0x00,
		/* '`' */  0x60,
#if defined (_SAFECRT_IMPL)
		/* 'a' */  0x60,       // Disable %a format
#else  /* defined (_SAFECRT_IMPL) */
		/* 'a' */  0x68,
#endif  /* defined (_SAFECRT_IMPL) */
		/* 'b' */  0x60,
		/* 'c' */  0x68,
		/* 'd' */  0x68,
		/* 'e' */  0x68,
		/* 'f' */  0x08,
		/* 'g' */  0x08,
		/* 'h' */  0x07,
		/* 'i' */  0x78,
		/* 'j' */  0x70,
		/* 'k' */  0x70,
		/* 'l' */  0x77,
		/* 'm' */  0x70,
		/* 'n' */  0x70,
		/* 'o' */  0x08,
		/* 'p' */  0x08,
		/* 'q' */  0x00,
		/* 'r' */  0x00,
		/* 's' */  0x08,
		/* 't' */  0x00,
		/* 'u' */  0x08,
		/* 'v' */  0x00,
		/* 'w' */  0x07,
		/* 'x' */  0x08
	};

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputA_State_ST_FLAG()
	{
		// set flag based on which flag character
		switch (chA)
		{
		case '-':
			flags |= FL_LEFT;		// '-' => left justify
			break;
		case '+':
			flags |= FL_SIGN;		// '+' => force sign indicator
			break;
		case ' ':
			flags |= FL_SIGNSP;		// ' ' => force sign or space
			break;
		case '#':
			flags |= FL_ALTERNATE;  // '#' => alternate form
			break;
		case '0':
			flags |= FL_LEADZERO;   // '0' => pad with leading zeros
			break;
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputW_State_ST_FLAG()
	{
		// set flag based on which flag character
		switch (chW)
		{
		case L'-':
			flags |= FL_LEFT;		// '-' => left justify
			break;
		case L'+':
			flags |= FL_SIGN;		// '+' => force sign indicator
			break;
		case L' ':
			flags |= FL_SIGNSP;		// ' ' => force sign or space
			break;
		case L'#':
			flags |= FL_ALTERNATE;  // '#' => alternate form
			break;
		case L'0':
			flags |= FL_LEADZERO;   // '0' => pad with leading zeros
			break;
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::Output_State_ST_PERCENT()
	{
		// set default value of conversion parameters
		prefixlen = fldwidth = no_output = capexp = 0;
		flags = 0;
		precision = -1;
		bufferiswide = 0;   // default
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputA_p_State_ST_NORMAL_2()
	{
		write_charA(chA, m_pStream, &charsout);
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputW_p_State_ST_NORMAL_2()
	{
		// normal state -- just write character
		bufferiswide = 1;
		write_charW(chW, m_pStream, &charsout);
	}

	//--------------------------------------------------------------------------------
	bool CStreamFormatter::Output_p_State_ST_NORMAL_1()
	{
		bool bResult = false;
		if (((pass == FORMAT_POSSCAN_PASS) && (format_type == FMT_TYPE_POSITIONAL)) || ((pass == FORMAT_OUTPUT_PASS) && (format_type == FMT_TYPE_NOTSET)))
		{
			/* Do not output in the 1st pass, if we have already come across
			a positional format specifier. All chars before the first format
			specifier get output in the first pass itself. Hence we need to
			check the format_type to make sure that they don't get output
			again in the 2nd pass */
			bResult = true;
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputA_p_State_ST_WIDTH(const char* format, va_list& argptr)
	{
		// update width value
		if (chA == '*')
		{
			// get width from arg list
			if (format_type == FMT_TYPE_NONPOSITIONAL)
			{
				fldwidth = get_int_arg(&argptr);
			}
			else
			{
				width_pos = 1;//TODO:strtol( format, &end_posA, 10 ) - 1;
				format = end_posA + 1;

				if (pass == FORMAT_POSSCAN_PASS)
				{
					// Update max_pos with the current maximum pos argument
					max_pos = width_pos > max_pos ? width_pos : max_pos;

					STORE_ARGPTRA(&pos_value[0], e_int_arg, width_pos, chA, flags);
					return;
				}
				else
				{
					// get width from arg list
					{
						va_list lst = pos_value[width_pos].arg_ptr;
						fldwidth = get_int_arg(&lst);
					}
				}
			}

			if (fldwidth < 0)
			{
				// ANSI says neg fld width means '-' flag and pos width
				flags |= FL_LEFT;
				fldwidth = -fldwidth;
			}
		}
		else
		{
			// add digit to current field width
			fldwidth = fldwidth * 10 + (chA - '0');
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputW_p_State_ST_WIDTH(const wchar_t* format, va_list& argptr)
	{
		// update width value
		if (chW == L'*')
		{
			// get width from arg list
			if (format_type == FMT_TYPE_NONPOSITIONAL)
			{
				fldwidth = get_int_arg(&argptr);
			}
			else
			{
				width_pos = 2;//TODO: wcstol( format, &end_posW, 10 ) - 1;
				format = end_posW + 1;

				if (pass == FORMAT_POSSCAN_PASS)
				{
					//_VALIDATE_RETURN(((width_pos >= 0) && (*end_pos == L'$') && (type_pos < NL_ARGMAX)), EINVAL, -1);

					// Update max_pos with the current maximum pos argument
					max_pos = width_pos > max_pos ? width_pos : max_pos;

					STORE_ARGPTR(&pos_value[0], e_int_arg, width_pos, chW, flags);
					return;
				}
				else
				{
					// get width from arg list
					{
						va_list lst = pos_value[width_pos].arg_ptr;
						fldwidth = get_int_arg(&lst);
					}
				}
			}

			if (fldwidth < 0)
			{
				// ANSI says neg fld width means '-' flag and pos width
				flags |= FL_LEFT;
				fldwidth = -fldwidth;
			}
		}
		else
		{
			// add digit to current field width
			fldwidth = fldwidth * 10 + (chW - L'0');
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputA_p_State_ST_PRECIS(const char* format, va_list argptr)
	{
		// update precison value
		if (chA == '*')
		{
			// get precision from arg list

			if (format_type == FMT_TYPE_NONPOSITIONAL)
			{
				precision = get_int_arg(&argptr);
			}
			else
			{
				precis_pos = 1;//TODO:strtol( format, &end_posA, 10 ) - 1;
				format = end_posA + 1;

				if (pass == FORMAT_POSSCAN_PASS)
				{
					//_VALIDATE_RETURN(((precis_pos >= 0) && (*end_pos == L'$') && (type_pos < NL_ARGMAX)), EINVAL, -1);

					// Update max_pos with the current maximum pos argument
					max_pos = precis_pos > max_pos ? precis_pos : max_pos;

					STORE_ARGPTRA(pos_value, e_int_arg, precis_pos, chA, flags);
					return;
				}
				else
				{
					// get width from arg list
					{
						va_list lst = pos_value[precis_pos].arg_ptr;
						precision = get_int_arg(&lst);
					}
				}
			}

			if (precision < 0)
			{
				precision = -1; // neg precision means default
			}
		}
		else
		{
			// add digit to current precision
			precision = precision * 10 + (chA - '0');
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputW_p_State_ST_PRECIS(const wchar_t* format, va_list argptr)
	{
		// update precison value
		if (chW == L'*')
		{
			// get precision from arg list

			if (format_type == FMT_TYPE_NONPOSITIONAL)
			{
				precision = get_int_arg(&argptr);
			}
			else
			{
				precis_pos = 2;//TODO: wcstol( format, &end_posW, 10 ) - 1;
				format = end_posW + 1;

				if (pass == FORMAT_POSSCAN_PASS)
				{
					//_VALIDATE_RETURN(((precis_pos >= 0) && (*end_pos == L'$') && (type_pos < NL_ARGMAX)), EINVAL, -1);

					// Update max_pos with the current maximum pos argument
					max_pos = precis_pos > max_pos ? precis_pos : max_pos;

					STORE_ARGPTR(pos_value, e_int_arg, precis_pos, chW, flags);
					return;
				}
				else
				{
					// get width from arg list
					{
						va_list lst = pos_value[precis_pos].arg_ptr;
						precision = get_int_arg(&lst);
					}
				}
			}

			if (precision < 0)
			{
				precision = -1; // neg precision means default
			}
		}
		else
		{
			// add digit to current precision
			precision = precision * 10 + (chW - L'0');
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputA_p_State_ST_SIZE(const char* format)
	{
		// just read a size specifier, set the flags based on it
		switch (chA)
		{
		case 'l':
		{
			if (*format == 'l')
			{
				++format;
				flags |= FL_LONGLONG;   /* 'll' => long long */
			}
			else
			{
				flags |= FL_LONG;   /* 'l' => long int or wchar_t */
			}
		}
		break;

		case 'I':
			/*In order to handle the I, I32, and I64 size modifiers, we
			* depart from the simple deterministic state machine. The
			* code below scans for characters following the 'I',
			* and defaults to 64 bit on WIN64 and 32 bit on WIN32
			*/
#if PTR_IS_INT64
			flags |= FL_I64;    // 'I' => __int64 on WIN64 systems */
#endif  /* PTR_IS_INT64 */
			if ((*format == '6') && (*(format + 1) == '4'))
			{
				format += 2;
				flags |= FL_I64;    // I64 => __int64
			}
			else if ((*format == '3') && (*(format + 1) == '2'))
			{
				format += 2;
				flags &= ~FL_I64;   // I32 => __int32
			}
			else if ((*format == 'd') ||
				(*format == 'i') ||
				(*format == 'o') ||
				(*format == 'u') ||
				(*format == 'x') ||
				(*format == 'X'))
			{
				// %I without 32/64 is platform dependent. We set FL_PTRSIZE to indicate this - this is used in the positional parameter reuse validation
				flags |= FL_PTRSIZE;
			}
			else
			{
				state = ST_NORMAL;
				OutputA_p_State_ST_NORMAL_2();
			}
			break;

		case 'h':
			flags |= FL_SHORT;  // 'h' => short int or char
			break;

		case 'w':
			flags |= FL_WIDECHAR;  // 'w' => wide character
			break;

		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputW_p_State_ST_SIZE(const wchar_t* format)
	{
		// just read a size specifier, set the flags based on it
		switch (chW)
		{
		case L'l':
		{
			if (*format == L'l')
			{
				++format;
				flags |= FL_LONGLONG;   /* 'll' => long long */
			}
			else
			{
				flags |= FL_LONG;   /* 'l' => long int or wchar_t */
			}
		}
		break;

		case L'I':
			/*In order to handle the I, I32, and I64 size modifiers, we
			* depart from the simple deterministic state machine. The
			* code below scans for characters following the 'I',
			* and defaults to 64 bit on WIN64 and 32 bit on WIN32
			*/
#if PTR_IS_INT64
			flags |= FL_I64;    /* 'I' => __int64 on WIN64 systems */
#endif  /* PTR_IS_INT64 */
			if ((*format == L'6') && (*(format + 1) == L'4'))
			{
				format += 2;
				flags |= FL_I64;    /* I64 => __int64 */
			}
			else if ((*format == L'3') && (*(format + 1) == L'2'))
			{
				format += 2;
				flags &= ~FL_I64;   /* I32 => __int32 */
			}
			else if ((*format == L'd') ||
				(*format == L'i') ||
				(*format == L'o') ||
				(*format == L'u') ||
				(*format == L'x') ||
				(*format == L'X'))
			{
				// %I without 32/64 is platform dependent. We set FL_PTRSIZE to indicate this - this is used in the positional parameter reuse validation
				flags |= FL_PTRSIZE;
			}
			else
			{
				state = ST_NORMAL;
				OutputW_p_State_ST_NORMAL_2();
			}
			break;

		case L'h':
			flags |= FL_SHORT;  /* 'h' => short int or char */
			break;

		case L'w':
			flags |= FL_WIDECHAR;  /* 'w' => wide character */
			break;

		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::Output_State_ST_TYPE_C()
	{
		if (!(flags & (FL_SHORT | FL_LONG | FL_WIDECHAR)))
		{
			flags |= FL_SHORT;
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputA_p_l_State_ST_TYPE_c( /*nsWin32::CLocaleUpdate& _loc_update,*/ va_list argptr)
	{
		// print a single character specified by int argument

		if (format_type == FMT_TYPE_NONPOSITIONAL)
		{
			achar = (char)get_int_arg(&argptr);
		}
		else
		{
			//_VALIDATE_RETURN( ( ( type_pos >= 0 ) && ( type_pos < NL_ARGMAX ) ), EINVAL, -1 );

			if (pass == FORMAT_POSSCAN_PASS)
			{
				STORE_ARGPTRA(pos_value, e_int_arg, type_pos, chA, flags);
				return;
			}
			else
			{
				va_list lst = pos_value[type_pos].arg_ptr;
				achar = (char)get_int_arg(&lst);
			}
		}

		/*
		if( flags & FL_SHORT )
		{
		// format multibyte character, this is an extension of ANSI
		char tempchar[ 2 ];
		{
		tempchar[ 0 ] = achar;
		tempchar[ 1 ] = '\0';
		}

		if( _mbtowc_l( buffer.sz, tempchar, _loc_update.GetLocaleT()->LocaleInfoPtr()->MBCurMax(), _loc_update.GetLocaleT() ) < 0 )
		{
		// ignore if conversion was unsuccessful
		no_output = 1;
		}
		}
		else */
		{
			buffer.sz[0] = achar;
		}

		text.sz = buffer.sz;
		textlen = 1;    // print just a single character
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputW_p_l_State_ST_TYPE_c( /*nsWin32::CLocaleUpdate& _loc_update,*/ va_list argptr)
	{
		// print a single character specified by int argument
		bufferiswide = 1;

		if (format_type == FMT_TYPE_NONPOSITIONAL)
		{
			wchar = (wchar_t)get_int_arg(&argptr);
		}
		else
		{
			//_VALIDATE_RETURN( ( ( type_pos >= 0 ) && ( type_pos < NL_ARGMAX ) ), EINVAL, -1 );

			if (pass == FORMAT_POSSCAN_PASS)
			{
				STORE_ARGPTR(pos_value, e_int_arg, type_pos, chW, flags);
				return;
			}
			else
			{
				va_list lst = pos_value[type_pos].arg_ptr;
				wchar = (wchar_t)get_int_arg(&lst);
			}
		}

		if (flags & FL_SHORT)
		{
			// format multibyte character, this is an extension of ANSI
			char tempchar[2];
			{
				tempchar[0] = (char)(wchar & 0x00ff);
				tempchar[1] = '\0';
			}

			//if( _mbtowc_l( buffer.wz, tempchar, _loc_update.GetLocaleT()->LocaleInfoPtr()->MBCurMax(), _loc_update.GetLocaleT() ) < 0 )
			{
				// ignore if conversion was unsuccessful
				no_output = 1;
			}
		}
		else
		{
			buffer.wz[0] = wchar;
		}

		text.wz = buffer.wz;
		textlen = 1;    // print just a single character
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputA_p_State_ST_TYPE_Z(va_list& argptr)
	{
		// print a Counted String

		struct _count_string
		{
			short Length;
			short MaximumLength;
			char *Buffer;
		} *pstr;

		if (format_type == FMT_TYPE_NONPOSITIONAL)
		{
			pstr = (_count_string*)get_ptr_arg(&argptr);
		}
		else
		{
			//_VALIDATE_RETURN( ( ( type_pos >= 0 ) && ( type_pos < NL_ARGMAX ) ), EINVAL, -1 );

			if (pass == FORMAT_POSSCAN_PASS)
			{
				STORE_ARGPTRA(pos_value, e_ptr_arg, type_pos, chA, flags);
				return;
			}
			else
			{
				va_list lst = pos_value[type_pos].arg_ptr;
				pstr = (_count_string*)get_ptr_arg(&lst);
			}
		}

		if (pstr == NULL || pstr->Buffer == 0)
		{
			// null ptr passed, use special string
			text.sz = __nullstring;
			textlen = (int)strlen(text.sz);
		}
		else
		{
			if (flags & FL_WIDECHAR)
			{
				text.wz = (wchar_t*)pstr->Buffer;
				textlen = pstr->Length / (int)sizeof(wchar_t);
				bufferiswide = 1;
			}
			else
			{
				bufferiswide = 0;
				text.sz = pstr->Buffer;
				textlen = pstr->Length;
			}
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputW_p_State_ST_TYPE_Z(va_list& argptr)
	{
		// print a Counted String

		struct _count_string
		{
			short Length;
			short MaximumLength;
			char *Buffer;
		} *pstr;

		if (format_type == FMT_TYPE_NONPOSITIONAL)
		{
			pstr = (_count_string*)get_ptr_arg(&argptr);
		}
		else
		{
			//_VALIDATE_RETURN( ( ( type_pos >= 0 ) && ( type_pos < NL_ARGMAX ) ), EINVAL, -1 );

			if (pass == FORMAT_POSSCAN_PASS)
			{
				STORE_ARGPTR(pos_value, e_ptr_arg, type_pos, chW, flags);
				return;
			}
			else
			{
				va_list lst = pos_value[type_pos].arg_ptr;
				pstr = (_count_string*)get_ptr_arg(&lst);
			}
		}

		if (pstr == NULL || pstr->Buffer == 0)
		{
			// null ptr passed, use special string
			text.sz = __nullstring;
			textlen = (int)strlen(text.sz);
		}
		else
		{
			if (flags & FL_WIDECHAR)
			{
				text.wz = (wchar_t*)pstr->Buffer;
				textlen = pstr->Length / (int)sizeof(wchar_t);
				bufferiswide = 1;
			}
			else
			{
				bufferiswide = 0;
				text.sz = pstr->Buffer;
				textlen = pstr->Length;
			}
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputA_p_l_State_ST_TYPE_s( /*nsWin32::CLocaleUpdate& _loc_update,*/ va_list& argptr)
	{
		// print a string --
		// ANSI rules on how much of string to print:
		//   all if precision is default,
		//   min(precision, length) if precision given.
		// prints '(null)' if a null string is passed

		int i;
		char* p;
		char* pch;

		// At this point it is tempting to use strlen(), but
		// if a precision is specified, we're not allowed to
		// scan past there, because there might be no null
		// at all.  Thus, we must do our own scan.

		i = (precision == -1) ? 2147483647/*INT_MAX*/ : precision;

		if (format_type == FMT_TYPE_NONPOSITIONAL)
		{
			text.sz = (char*)get_ptr_arg(&argptr);
		}
		else
		{
			//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);
			if (pass == FORMAT_POSSCAN_PASS)
			{
				STORE_ARGPTRA(pos_value, e_ptr_arg, type_pos, chA, flags);
				return;
			}
			else
			{
				va_list lst = pos_value[type_pos].arg_ptr;
				text.sz = (char*)get_ptr_arg(&lst);
			}
		}

		// scan for null upto i characters
		if (flags & FL_SHORT)
		{
			if (text.sz == NULL) // NULL passed, use special string
			{
				text.sz = __nullstring;
			}
			p = text.sz;
			for (textlen = 0; textlen < i && *p; textlen++)
			{
				/*TODO:
				if( SBUChar(*p).isleadbyte( _loc_update.GetLocaleT() ) )
				{
				++p;
				}
				*/
				++p;
			}
			// textlen now contains length in multibyte chars
		}
		else
		{
			if (text.sz == 0) // NULL passed, use special string */
			{
				text.sz = __nullstring;
			}

			pch = text.sz;
			while (i-- && *pch)
			{
				++pch;
			}
			textlen = (int)(pch - text.sz);       // in char(s)
												  // textlen now contains length in chars
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputW_p_l_State_ST_TYPE_s( /*nsWin32::CLocaleUpdate& _loc_update,*/ va_list& argptr)
	{
		// print a string --
		// ANSI rules on how much of string to print:
		//   all if precision is default,
		//   min(precision, length) if precision given.
		// prints '(null)' if a null string is passed

		int i;
		char* p;
		wchar_t *pwch;

		// At this point it is tempting to use strlen(), but
		// if a precision is specified, we're not allowed to
		// scan past there, because there might be no null
		// at all.  Thus, we must do our own scan.

		i = (precision == -1) ? 2147483647/*INT_MAX*/ : precision;

		if (format_type == FMT_TYPE_NONPOSITIONAL)
		{
			text.wz = (wchar_t*)get_ptr_arg(&argptr);
		}
		else
		{
			//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);
			if (pass == FORMAT_POSSCAN_PASS)
			{
				STORE_ARGPTR(pos_value, e_ptr_arg, type_pos, chW, flags);
				return;
			}
			else
			{
				va_list lst = pos_value[type_pos].arg_ptr;
				text.wz = (wchar_t*)get_ptr_arg(&lst);
			}
		}

		// scan for null upto i characters
		if (flags & FL_SHORT)
		{
			if (text.wz == 0) // NULL passed, use special string
			{
				text.wz = __wnullstring;
			}
			p = text.sz;
			for (textlen = 0; textlen < i && *p; textlen++)
			{
				/*TODO:
				if( SBUChar(*p).isleadbyte( _loc_update.GetLocaleT() ) )
				{
				++p;
				}
				*/
				++p;
			}
			// textlen now contains length in multibyte chars
		}
		else
		{
			if (text.wz == 0) // NULL passed, use special string
			{
				text.wz = __wnullstring;
			}
			bufferiswide = 1;
			pwch = text.wz;
			while (i-- && *pwch)
			{
				++pwch;
			}
			textlen = (int)(pwch - text.wz);       // in wchar_ts
												   // textlen now contains length in wide chars
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputA_p_l_State_ST_TYPE_n(va_list& argptr)
	{
		// write count of characters seen so far into short/int/long thru ptr read from args
		void* p;

		if (format_type == FMT_TYPE_NONPOSITIONAL)
		{
			p = get_ptr_arg(&argptr);
		}
		else
		{
			//_VALIDATE_RETURN( ( ( type_pos >= 0 ) && ( type_pos < NL_ARGMAX ) ), EINVAL, -1 );

			if (pass == FORMAT_POSSCAN_PASS)
			{
				STORE_ARGPTRA(pos_value, e_ptr_arg, type_pos, chA, flags);
				return;
			}
			else
			{
				va_list lst = pos_value[type_pos].arg_ptr;
				p = get_ptr_arg(&lst);
			}
		}

		// if %n is disabled, we skip an arg and print 'n'
		//		if( !_get_printf_count_output() )
		//		{
		//			//_VALIDATE_RETURN(("'n' format specifier disabled", 0), EINVAL, -1);
		////			break;
		//			return;
		//		}

		// store chars out into short/long/int depending on flags
		if (flags & FL_SHORT)
		{
			*(short *)p = (short)charsout;
		}
		else
		{
			*(int *)p = charsout;
		}

		no_output = 1;              // force no output
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputW_p_l_State_ST_TYPE_n(va_list& argptr)
	{
		// write count of characters seen so far into
		// short/int/long thru ptr read from args
		void* p;

		if (format_type == FMT_TYPE_NONPOSITIONAL)
		{
			p = get_ptr_arg(&argptr);
		}
		else
		{
			//_VALIDATE_RETURN( ( ( type_pos >= 0 ) && ( type_pos < NL_ARGMAX ) ), EINVAL, -1 );

			if (pass == FORMAT_POSSCAN_PASS)
			{
				STORE_ARGPTR(pos_value, e_ptr_arg, type_pos, chW, flags);
				return;
			}
			else
			{
				va_list lst = pos_value[type_pos].arg_ptr;
				p = get_ptr_arg(&lst);
			}
		}

		// if %n is disabled, we skip an arg and print 'n'
		//		if( !_get_printf_count_output() )
		//		{
		//			//_VALIDATE_RETURN(("'n' format specifier disabled", 0), EINVAL, -1);
		////			break;
		//			return;
		//		}

		// store chars out into short/long/int depending on flags
		if (flags & FL_SHORT)
		{
			*(short *)p = (short)charsout;
		}
		else
		{
			*(int *)p = charsout;
		}

		no_output = 1;              /* force no output */
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputA_p_l_State_ST_TYPE_a( /*nsWin32::CLocaleUpdate& _loc_update,*/ va_list& argptr)
	{
		// floating point conversion -- we call cfltcvt routines to do the work for us.
		flags |= FL_SIGNED;         // floating point is signed conversion

		if ((format_type == FMT_TYPE_POSITIONAL) && (pass == FORMAT_POSSCAN_PASS))
		{
			//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);
			STORE_ARGPTRA(pos_value, e_double_arg, type_pos, chA, flags);
			return;
		}

		text.sz = buffer.sz;        // put result in buffer
		buffersize = BUFFERSIZE;

		// compute the precision value
		if (precision < 0)
		{
			precision = 6;          // default precision: 6
		}
		else if (precision == 0 && chA == 'g')
		{
			precision = 1;          // ANSI specified
		}
		else if (precision > MAXPRECISION)
		{
			precision = MAXPRECISION;
		}

		if (precision > BUFFERSIZE - _CVTBUFSIZE)
		{
			// conversion will potentially overflow local buffer so we need to use a heap-allocated buffer.
			heapbuf = (char *)malloc(_CVTBUFSIZE + precision);
			if (heapbuf != NULL)
			{
				text.sz = heapbuf;
				buffersize = _CVTBUFSIZE + precision;
			}
			else
			{
				// malloc failed, cap precision further
				precision = BUFFERSIZE - _CVTBUFSIZE;
			}
		}

		double tmp;
		if (format_type == FMT_TYPE_NONPOSITIONAL)
		{
			tmp = va_arg(argptr, double);
		}
		else
		{
			// Will get here only for pass == FORMAT_OUTPUT_PASS because pass == FORMAT_POSSCAN_PASS has a break Above
			va_list tmp_arg;

			//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);
			//_ASSERTE(pass == FORMAT_OUTPUT_PASS);

			tmp_arg = pos_value[type_pos].arg_ptr;
			tmp = va_arg(tmp_arg, double);
		}
		// Note: assumes ch is in ASCII range
		// In safecrt, we provide a special version of _cfltcvt which internally calls printf (see safecrt_output_s.c)
		cfltcvt/*_l*/( /*&*/tmp/*.x*/, text.sz/*, buffersize*/, (char)chA, precision, capexp/*, _loc_update.GetLocaleT()*/);

		// For safecrt, this is done already in _safecrt_cfltcvt

		// '#' and precision == 0 means force a decimal point
		if ((flags & FL_ALTERNATE) && precision == 0)
		{
			forcdecpt/*_l*/(text.sz/*, _loc_update.GetLocaleT()*/);
		}

		// 'g' format means crop zero unless '#' given
		if (chA == 'g' && !(flags & FL_ALTERNATE))
		{
			cropzeros/*_l*/(text.sz/*, _loc_update.GetLocaleT() */);
		}

		// check if result was negative, save '-' for later
		// and point to positive part (this is for '0' padding)
		if (*text.sz == '-')
		{
			flags |= FL_NEGATIVE;
			++text.sz;
		}

		textlen = (int)strlen(text.sz);     // compute length of text
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputW_p_l_State_ST_TYPE_a( /*nsWin32::CLocaleUpdate& _loc_update,*/ va_list& argptr)
	{
		// floating point conversion -- we call cfltcvt routines
		// to do the work for us.
		flags |= FL_SIGNED;         // floating point is signed conversion

		if ((format_type == FMT_TYPE_POSITIONAL) && (pass == FORMAT_POSSCAN_PASS))
		{
			//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);
			STORE_ARGPTR(pos_value, e_double_arg, type_pos, chW, flags);
			return;
		}

		text.sz = buffer.sz;        // put result in buffer
		buffersize = BUFFERSIZE;

		// compute the precision value
		if (precision < 0)
		{
			precision = 6;          // default precision: 6
		}
		else if (precision == 0 && chW == L'g')
		{
			precision = 1;          // ANSI specified
		}
		else if (precision > MAXPRECISION)
		{
			precision = MAXPRECISION;
		}

		if (precision > BUFFERSIZE - _CVTBUFSIZE)
		{
			// conversion will potentially overflow local buffer so we need to use a heap-allocated buffer.
			heapbuf = (char *)malloc(_CVTBUFSIZE + precision);
			if (heapbuf != NULL)
			{
				text.sz = heapbuf;
				buffersize = _CVTBUFSIZE + precision;
			}
			else
			{
				// malloc failed, cap precision further
				precision = BUFFERSIZE - _CVTBUFSIZE;
			}
		}

		double tmp;
		if (format_type == FMT_TYPE_NONPOSITIONAL)
		{
			tmp = va_arg(argptr, double);
		}
		else
		{
			// Will get here only for pass == FORMAT_OUTPUT_PASS because pass == FORMAT_POSSCAN_PASS has a break Above
			va_list tmp_arg;

			//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);
			//_ASSERTE(pass == FORMAT_OUTPUT_PASS);

			tmp_arg = pos_value[type_pos].arg_ptr;
			tmp = va_arg(tmp_arg, double);
		}
		// Note: assumes ch is in ASCII range
		// In safecrt, we provide a special version of _cfltcvt which internally calls printf (see safecrt_output_s.c)
		cfltcvt/*_l*/( /*&*/tmp/*.x*/, text.sz/*, buffersize*/, (char)chW, precision, capexp/*, _loc_update.GetLocaleT()*/);

		// For safecrt, this is done already in _safecrt_cfltcvt

		// '#' and precision == 0 means force a decimal point
		if ((flags & FL_ALTERNATE) && precision == 0)
		{
			forcdecpt/*_l*/(text.sz/*, _loc_update.GetLocaleT()*/);
		}

		// 'g' format means crop zero unless '#' given
		if (chW == L'g' && !(flags & FL_ALTERNATE))
		{
			cropzeros/*_l*/(text.sz/*, _loc_update.GetLocaleT() */);
		}

		// check if result was negative, save '-' for later
		// and point to positive part (this is for '0' padding)
		if (*text.sz == '-')
		{
			flags |= FL_NEGATIVE;
			++text.sz;
		}

		textlen = (int)strlen(text.sz);     // compute length of text
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputA_p_l_State_ST_TYPE_COMMON_INT(va_list& argptr)
	{
		// This is the general integer formatting routine.
		// Basically, we get an argument, make it positive
		// if necessary, and convert it according to the
		// correct radix, setting text and textlen
		// appropriately.

#if _INTEGRAL_MAX_BITS >= 64
		Cmp_unsigned__int64 number;    // number to convert
		int digit;              // ascii value of digit
		Cmp__int64 l;              // temp long value
#else  // _INTEGRAL_MAX_BITS >= 64
		unsigned long number;   // number to convert
		int digit;              // ascii value of digit
		long l;                 // temp long value
#endif  // _INTEGRAL_MAX_BITS >= 64

								// 1. read argument into l, sign extend as needed
#if _INTEGRAL_MAX_BITS >= 64

		if (flags & FL_I64)
		{
			if (format_type == FMT_TYPE_NONPOSITIONAL)
			{
				l = get_int64_arg(&argptr);
			}
			else
			{
				//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);

				if (pass == FORMAT_POSSCAN_PASS)
				{
					STORE_ARGPTRA(pos_value, e_int64_arg, type_pos, chA, flags);
					return;
				}
				else
				{
					va_list lst = pos_value[type_pos].arg_ptr;
					l = get_int64_arg(&lst);
				}
			}
		}
		else
#endif  /* _INTEGRAL_MAX_BITS >= 64        */
			if (flags & FL_LONGLONG)
			{
				if (format_type == FMT_TYPE_NONPOSITIONAL)
				{
					l = get_long_long_arg(&argptr);
				}
				else
				{
					//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);

					if (pass == FORMAT_POSSCAN_PASS)
					{
						STORE_ARGPTRA(pos_value, e_long_long_arg, type_pos, chA, flags);
						return;
					}
					else
					{
						va_list lst = pos_value[type_pos].arg_ptr;
						l = get_long_long_arg(&lst);
					}
				}
			}
			else if (flags & FL_SHORT)
			{
				if (flags & FL_SIGNED)
				{
					if (format_type == FMT_TYPE_NONPOSITIONAL)
					{
						l = (short)get_int_arg(&argptr); /* sign extend */
					}
					else
					{
						//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);

						if (pass == FORMAT_POSSCAN_PASS)
						{
							STORE_ARGPTRA(pos_value, e_int_arg, type_pos, chA, flags);
							return;
						}
						else
						{
							va_list lst = pos_value[type_pos].arg_ptr;
							l = (short)get_int_arg(&lst);
						}
					}
				}
				else
				{
					if (format_type == FMT_TYPE_NONPOSITIONAL)
					{
						l = (unsigned short)get_int_arg(&argptr);    // zero-extend
					}
					else
					{
						//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);

						if (pass == FORMAT_POSSCAN_PASS)
						{
							STORE_ARGPTRA(pos_value, e_int_arg, type_pos, chA, flags);
							return;
						}
						else
						{
							va_list lst = pos_value[type_pos].arg_ptr;
							l = (short)get_int_arg(&lst);
						}
					}
				}

			}
			else

			{
				if (flags & FL_SIGNED)
				{
					if (format_type == FMT_TYPE_NONPOSITIONAL)
					{
						l = get_int_arg(&argptr); // sign extend
					}
					else
					{
						//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);

						if (pass == FORMAT_POSSCAN_PASS)
						{
							STORE_ARGPTRA(pos_value, e_int_arg, type_pos, chA, flags);
							return;
						}
						else
						{
							va_list lst = pos_value[type_pos].arg_ptr;
							l = (short)get_int_arg(&lst);
						}
					}
				}
				else
				{
					if (format_type == FMT_TYPE_NONPOSITIONAL)
					{
						l = (unsigned int)get_int_arg(&argptr);    // zero-extend
					}
					else
					{
						//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);

						if (pass == FORMAT_POSSCAN_PASS)
						{
							STORE_ARGPTRA(pos_value, e_int_arg, type_pos, chA, flags);
							return;
						}
						else
						{
							va_list lst = pos_value[type_pos].arg_ptr;
							l = (unsigned int)get_int_arg(&lst);
						}
					}
				}
			}

		// 2. check for negative; copy into number
		if ((flags & FL_SIGNED) && l < 0)
		{
			number = -l;
			flags |= FL_NEGATIVE;   // remember negative sign
		}
		else
		{
			number = l;
		}

#if	_INTEGRAL_MAX_BITS >= 64
		if ((flags & FL_I64) == 0 && (flags & FL_LONGLONG) == 0)
		{
			/*Unless printing a full 64-bit value, insure values here are not in cananical longword
			format to prevent the sign extended upper 32-bits from being printed. */
			number &= 0xffffffff;
		}
#endif  /* _INTEGRAL_MAX_BITS >= 64        */

		/* 3. check precision value for default; non-default */
		/*    turns off 0 flag, according to ANSI. */
		if (precision < 0)
		{
			precision = 1;  // default precision
		}
		else
		{
			flags &= ~FL_LEADZERO;
			if (precision > MAXPRECISION)
			{
				precision = MAXPRECISION;
			}
		}

		/* 4. Check if data is 0; if so, turn off hex prefix */
		if (number == 0)
		{
			prefixlen = 0;
		}

		// 5. Convert data to ASCII -- note if precision is zero
		//    and number is zero, we get no digits at all.

		text.sz = &buffer.sz[BUFFERSIZE - 1];    // last digit at end of buffer

		while (precision-- > 0 || number != 0)
		{
			digit = (int)(number % radix) + '0';
			number /= radix;                // reduce number
			if (digit > '9')
			{
				// a hex digit, make it a letter
				digit += hexadd;
			}
			*text.sz-- = (char)digit;       // store the digit
		}

		textlen = (int)((char *)&buffer.sz[BUFFERSIZE - 1] - text.sz); // compute length of number
		++text.sz;          // text points to first digit now

							// 6. Force a leading zero if FORCEOCTAL flag set
		if ((flags & FL_FORCEOCTAL) && (textlen == 0 || text.sz[0] != '0'))
		{
			*--text.sz = '0';
			++textlen;      /* add a zero */
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputW_p_l_State_ST_TYPE_COMMON_INT(va_list& argptr)
	{
		// This is the general integer formatting routine.
		// Basically, we get an argument, make it positive
		// if necessary, and convert it according to the
		// correct radix, setting text and textlen
		// appropriately.

#if _INTEGRAL_MAX_BITS >= 64
		Cmp_unsigned__int64 number;    // number to convert
		int digit;              // ascii value of digit
		Cmp__int64 l;              // temp long value
#else  // _INTEGRAL_MAX_BITS >= 64
		unsigned long number;   // number to convert
		int digit;              // ascii value of digit
		long l;                 // temp long value
#endif  // _INTEGRAL_MAX_BITS >= 64

								// 1. read argument into l, sign extend as needed
#if _INTEGRAL_MAX_BITS >= 64
		if (flags & FL_I64)
		{
			if (format_type == FMT_TYPE_NONPOSITIONAL)
			{
				l = get_int64_arg(&argptr);
			}
			else
			{
				//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);

				if (pass == FORMAT_POSSCAN_PASS)
				{
					STORE_ARGPTR(pos_value, e_int64_arg, type_pos, chW, flags);
					return;
				}
				else
				{
					va_list lst = pos_value[type_pos].arg_ptr;
					l = get_int64_arg(&lst);
				}
			}
		}
		else
#endif  /* _INTEGRAL_MAX_BITS >= 64        */
			if (flags & FL_LONGLONG)
			{
				if (format_type == FMT_TYPE_NONPOSITIONAL)
				{
					l = get_long_long_arg(&argptr);
				}
				else
				{
					//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);

					if (pass == FORMAT_POSSCAN_PASS)
					{
						STORE_ARGPTR(pos_value, e_long_long_arg, type_pos, chW, flags);
						return;
					}
					else
					{
						va_list lst = pos_value[type_pos].arg_ptr;
						l = get_long_long_arg(&lst);
					}
				}
			}
			else if (flags & FL_SHORT)
			{
				if (flags & FL_SIGNED)
				{
					if (format_type == FMT_TYPE_NONPOSITIONAL)
					{
						l = (short)get_int_arg(&argptr); /* sign extend */
					}
					else
					{
						//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);

						if (pass == FORMAT_POSSCAN_PASS)
						{
							STORE_ARGPTR(pos_value, e_int_arg, type_pos, chW, flags);
							return;
						}
						else
						{
							va_list lst = pos_value[type_pos].arg_ptr;
							l = (short)get_int_arg(&lst);
						}
					}
				}
				else
				{
					if (format_type == FMT_TYPE_NONPOSITIONAL)
					{
						l = (unsigned short)get_int_arg(&argptr);    // zero-extend
					}
					else
					{
						//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);

						if (pass == FORMAT_POSSCAN_PASS)
						{
							STORE_ARGPTR(pos_value, e_int_arg, type_pos, chW, flags);
							return;
						}
						else
						{
							va_list lst = pos_value[type_pos].arg_ptr;
							l = (short)get_int_arg(&lst);
						}
					}
				}

			}
			else

			{
				if (flags & FL_SIGNED)
				{
					if (format_type == FMT_TYPE_NONPOSITIONAL)
					{
						l = get_int_arg(&argptr); // sign extend
					}
					else
					{
						//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);

						if (pass == FORMAT_POSSCAN_PASS)
						{
							STORE_ARGPTR(pos_value, e_int_arg, type_pos, chW, flags);
							return;
						}
						else
						{
							{
								va_list lst = pos_value[type_pos].arg_ptr;
								l = (short)get_int_arg(&lst);
							}
						}
					}
				}
				else
				{
					if (format_type == FMT_TYPE_NONPOSITIONAL)
					{
						l = (unsigned int)get_int_arg(&argptr);    // zero-extend
					}
					else
					{
						//_VALIDATE_RETURN(((type_pos>=0) && (type_pos<NL_ARGMAX)), EINVAL, -1);

						if (pass == FORMAT_POSSCAN_PASS)
						{
							STORE_ARGPTR(pos_value, e_int_arg, type_pos, chW, flags);
							return;
						}
						else
						{
							va_list lst = pos_value[type_pos].arg_ptr;
							l = (unsigned int)get_int_arg(&lst);
						}
					}
				}
			}

		// 2. check for negative; copy into number
		if ((flags & FL_SIGNED) && l < 0)
		{
			number = -l;
			flags |= FL_NEGATIVE;   // remember negative sign
		}
		else
		{
			number = l;
		}

#if	_INTEGRAL_MAX_BITS >= 64
		if ((flags & FL_I64) == 0 && (flags & FL_LONGLONG) == 0)
		{
			/*Unless printing a full 64-bit value, insure values
			* here are not in cananical longword format to prevent
			* the sign extended upper 32-bits from being printed.
			*/
			number &= 0xffffffff;
		}
#endif  /* _INTEGRAL_MAX_BITS >= 64        */

		/* 3. check precision value for default; non-default */
		/*    turns off 0 flag, according to ANSI. */
		if (precision < 0)
		{
			precision = 1;  // default precision
		}
		else
		{
			flags &= ~FL_LEADZERO;
			if (precision > MAXPRECISION)
			{
				precision = MAXPRECISION;
			}
		}

		/* 4. Check if data is 0; if so, turn off hex prefix */
		if (number == 0)
		{
			prefixlen = 0;
		}

		// 5. Convert data to ASCII -- note if precision is zero
		//    and number is zero, we get no digits at all.

		text.sz = &buffer.sz[BUFFERSIZE - 1];    // last digit at end of buffer

		while (precision-- > 0 || number != 0)
		{
			digit = (int)(number % radix) + '0';
			number /= radix;                // reduce number
			if (digit > '9')
			{
				// a hex digit, make it a letter
				digit += hexadd;
			}
			*text.sz-- = (char)digit;       // store the digit
		}

		textlen = (int)((char *)&buffer.sz[BUFFERSIZE - 1] - text.sz); // compute length of number
		++text.sz;          // text points to first digit now

							// 6. Force a leading zero if FORCEOCTAL flag set
		if ((flags & FL_FORCEOCTAL) && (textlen == 0 || text.sz[0] != '0'))
		{
			*--text.sz = '0';
			++textlen;      // add a zero
		}

	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputA_p_l_State_ST_TYPE( /*nsWin32::CLocaleUpdate& _loc_update,*/ va_list& argptr)
	{
		//Now format and "print" the output.  We use a big switch statement that sets
		//'text' to point to the text that should be printed, and 'textlen' to the
		//length of this text. Common code later on takes care of justifying it and
		//other miscellaneous chores.  Note that cases share code, in particular, all
		//integer formatting is done in one place.

		switch (chA)
		{
		case 'C':   // ISO wide character
		{
			Output_State_ST_TYPE_C();
		}
		// fall into 'c' case
		case 'c':
		{
			OutputA_p_l_State_ST_TYPE_c( /*_loc_update,*/ argptr);
		}
		break;

		case 'Z':
		{
			OutputA_p_State_ST_TYPE_Z(argptr);
		}
		break;

		case 'S':   // ISO wide character string
		{
			if (!(flags & (FL_SHORT | FL_LONG | FL_WIDECHAR)))
			{
				flags |= FL_SHORT;
			}
		}
		// fall into 's' case
		case 's':
		{
			OutputA_p_l_State_ST_TYPE_s( /*_loc_update,*/ argptr);
		}
		break;

		case 'n':
		{
			OutputA_p_l_State_ST_TYPE_n(argptr);
		}
		break;

		case 'E':// fall through
		case 'G':// fall through
		case 'A':// fall through
			capexp = 1;                 // capitalize exponent
			chW += 'a' - 'A';			// convert format char to lower
										// fall through
		case 'e':// fall through
		case 'f':// fall through
		case 'g':// fall through
		case 'a':
		{
			OutputA_p_l_State_ST_TYPE_a( /*_loc_update,*/ argptr);
		}
		break;

		case 'd':// fall through
		case 'i':
		{
			// signed decimal output
			flags |= FL_SIGNED;
			radix = 10;
			OutputA_p_l_State_ST_TYPE_COMMON_INT(argptr);
			break;
		}
		case 'u':
		{
			radix = 10;

			OutputA_p_l_State_ST_TYPE_COMMON_INT(argptr);
			break;
		}
		case 'p':
			// write a pointer -- this is like an integer or long
			// except we force precision to pad with zeros and
			// output in big hex.

			precision = 2 * sizeof(void *);     // number of hex digits needed
#if PTR_IS_INT64
			flags |= FL_I64;                    // assume we're converting an int64
#elif !PTR_IS_INT
			flags |= FL_LONG;                   // assume we're converting a long
#endif  /* !PTR_IS_INT */

												//fall through to hex formatting
		case 'X':
		{
			// unsigned upper hex output
			hexadd = 'A' - '9' - 1;     // set hexadd for uppercase hex
			goto COMMON_HEX;
		}

		case 'x':
			// unsigned lower hex output
			hexadd = 'a' - '9' - 1;     // set hexadd for lowercase hex

		COMMON_HEX:

			radix = 16;
			if (flags & FL_ALTERNATE)
			{
				// alternate form means '0x' prefix
				prefixA[0] = '0';
				prefixA[1] = (char)('x' - 'a' + '9' + 1 + hexadd);  /* 'x' or 'X' */
				prefixlen = 2;
			}

			OutputA_p_l_State_ST_TYPE_COMMON_INT(argptr);

			break;

		case 'o':

			// unsigned octal output
			radix = 8;
			if (flags & FL_ALTERNATE)
			{
				// alternate form means force a leading 0
				flags |= FL_FORCEOCTAL;
			}

			//			COMMON_INT:
			OutputA_p_l_State_ST_TYPE_COMMON_INT(argptr);

			break;
		}

		if ((format_type == FMT_TYPE_POSITIONAL) && (pass == FORMAT_POSSCAN_PASS))
		{
			return;
		}

		// At this point, we have done the specific conversion, and
		// 'text' points to text to print; 'textlen' is length.  Now we
		// justify it, put on prefixes, leading zeros, and then
		// print it.

		if (!no_output)
		{
			int padding;    // amount of padding, negative means zero

			if (flags & FL_SIGNED)
			{
				if (flags & FL_NEGATIVE)
				{
					// prefix is a '-'
					prefixA[0] = '-';
					prefixlen = 1;
				}
				else if (flags & FL_SIGN)
				{
					// prefix is '+'
					prefixA[0] = '+';
					prefixlen = 1;
				}
				else if (flags & FL_SIGNSP)
				{
					// prefix is ' '
					prefixA[0] = ' ';
					prefixlen = 1;
				}
			}

			// calculate amount of padding -- might be negative,
			// but this will just mean zero
			padding = fldwidth - textlen - prefixlen;

			// put out the padding, prefix, and text, in the correct order

			if (!(flags & (FL_LEFT | FL_LEADZERO)))
			{
				// pad on left with blanks
				write_multi_charA(' ', padding, m_pStream, &charsout);
			}

			// write prefix
			write_stringA(prefixA, prefixlen, m_pStream, &charsout);

			if ((flags & FL_LEADZERO) && !(flags & FL_LEFT))
			{
				// write leading zeros
				write_multi_charA('0', padding, m_pStream, &charsout);
			}

			// write text
			write_stringA(text.sz, textlen, m_pStream, &charsout);

			if (charsout >= 0 && (flags & FL_LEFT))
			{
				// pad on right with blanks
				write_multi_charA(' ', padding, m_pStream, &charsout);
			}
		}

		if (heapbuf)
		{
			free(heapbuf);
			heapbuf = 0;
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputW_p_l_State_ST_TYPE( /*nsWin32::CLocaleUpdate& _loc_update,*/ va_list& argptr)
	{
		// we have finally read the actual type character, so we
		// now format and "print" the output.  We use a big switch
		// statement that sets 'text' to point to the text that should
		// be printed, and 'textlen' to the length of this text.
		// Common code later on takes care of justifying it and
		// other miscellaneous chores.  Note that cases share code,
		// in particular, all integer formatting is done in one place.
		// Look at those funky goto statements!

		switch (chW)
		{
		case L'C':   // ISO wide character
		{
			Output_State_ST_TYPE_C();
		}
		// fall into 'c' case
		case L'c':
		{
			OutputW_p_l_State_ST_TYPE_c( /*_loc_update,*/ argptr);
		}
		break;

		case L'Z':
		{
			OutputW_p_State_ST_TYPE_Z(argptr);
		}
		break;

		case L'S':   // ISO wide character string
		{
			if (!(flags & (FL_SHORT | FL_LONG | FL_WIDECHAR)))
			{
				flags |= FL_SHORT;
			}
		}
		// fall into 's' case
		case L's':
		{
			OutputW_p_l_State_ST_TYPE_s( /*_loc_update,*/ argptr);
		}
		break;

		case L'n':
		{
			OutputW_p_l_State_ST_TYPE_n(argptr);
		}
		break;

		case L'E':// fall through
		case L'G':// fall through
		case L'A':// fall through
			capexp = 1;                 // capitalize exponent
			chW += L'a' - L'A';			// convert format char to lower
										// fall through
		case L'e':// fall through
		case L'f':// fall through
		case L'g':// fall through
		case L'a':
		{
			OutputW_p_l_State_ST_TYPE_a( /*_loc_update,*/ argptr);
		}
		break;

		case L'd':// fall through
		case L'i':
		{
			// signed decimal output
			flags |= FL_SIGNED;
			radix = 10;
			OutputW_p_l_State_ST_TYPE_COMMON_INT(argptr);

			break;
		}
		case L'u':
		{
			radix = 10;
			OutputW_p_l_State_ST_TYPE_COMMON_INT(argptr);

			break;
		}
		case L'p':
			// write a pointer -- this is like an integer or long
			// except we force precision to pad with zeros and
			// output in big hex.

			precision = 2 * sizeof(void *);     // number of hex digits needed
#if PTR_IS_INT64
			flags |= FL_I64;                    // assume we're converting an int64
#elif !PTR_IS_INT
			flags |= FL_LONG;                   // assume we're converting a long
#endif  /* !PTR_IS_INT */

												//fall through to hex formatting
		case L'X':
		{
			// unsigned upper hex output
			hexadd = L'A' - L'9' - 1;     // set hexadd for uppercase hex
			goto COMMON_HEX;
		}

		case L'x':
			// unsigned lower hex output
			hexadd = L'a' - L'9' - 1;     // set hexadd for lowercase hex

		COMMON_HEX:

			radix = 16;
			if (flags & FL_ALTERNATE)
			{
				// alternate form means '0x' prefix
				prefixW[0] = L'0';
				prefixW[1] = (wchar_t)(L'x' - L'a' + L'9' + 1 + hexadd);  /* 'x' or 'X' */
				prefixlen = 2;
			}
			OutputW_p_l_State_ST_TYPE_COMMON_INT(argptr);

			break;


		case L'o':

			// unsigned octal output
			radix = 8;
			if (flags & FL_ALTERNATE)
			{
				// alternate form means force a leading 0
				flags |= FL_FORCEOCTAL;
			}

			//COMMON_INT:
			OutputW_p_l_State_ST_TYPE_COMMON_INT(argptr);

			break;
		}

		if ((format_type == FMT_TYPE_POSITIONAL) && (pass == FORMAT_POSSCAN_PASS))
		{
			return;
		}

		// At this point, we have done the specific conversion, and
		// 'text' points to text to print; 'textlen' is length.  Now we
		// justify it, put on prefixes, leading zeros, and then
		// print it.

		if (!no_output)
		{
			int padding;    /* amount of padding, negative means zero */

			if (flags & FL_SIGNED)
			{
				if (flags & FL_NEGATIVE)
				{
					// prefix is a '-'
					prefixW[0] = L'-';
					prefixlen = 1;
				}
				else if (flags & FL_SIGN)
				{
					// prefix is '+'
					prefixW[0] = L'+';
					prefixlen = 1;
				}
				else if (flags & FL_SIGNSP)
				{
					// prefix is ' '
					prefixW[0] = L' ';
					prefixlen = 1;
				}
			}

			// calculate amount of padding -- might be negative,
			// but this will just mean zero
			padding = fldwidth - textlen - prefixlen;

			// put out the padding, prefix, and text, in the correct order

			if (!(flags & (FL_LEFT | FL_LEADZERO)))
			{
				// pad on left with blanks
				write_multi_charW(L' ', padding, m_pStream, &charsout);
			}

			// write prefix
			write_stringW(prefixW, prefixlen, m_pStream, &charsout);

			if ((flags & FL_LEADZERO) && !(flags & FL_LEFT))
			{
				// write leading zeros
				write_multi_charW(L'0', padding, m_pStream, &charsout);
			}

			// write text
			if (!bufferiswide && textlen > 0)
			{
				char* p;
				int retval, count;

				p = text.sz;
				count = textlen;
				while (count-- > 0)
				{
					//retval = _mbtowc_l( &wchar, p, _loc_update.GetLocaleT()->LocaleInfoPtr()->MBCurMax(), _loc_update.GetLocaleT() );
					retval = mbtowc(&wchar, p, 1);
					if (retval <= 0)
					{
						charsout = -1;
						break;
					}
					write_charW(wchar, m_pStream, &charsout);
					p += retval;
				}
			}
			else
			{
				write_stringW(text.wz, textlen, m_pStream, &charsout);
			}

			if (charsout >= 0 && (flags & FL_LEFT))
			{
				// pad on right with blanks
				write_multi_charW(L' ', padding, &charsout);
			}

			// we're done!
		}

		if (heapbuf)
		{
			free(heapbuf);
			heapbuf = 0;
		}
	}

	//--------------------------------------------------------------------------------
	int CStreamFormatter::OutputA_l_State( /*nsWin32::CLocaleUpdate& _loc_update,*/ const char* format/*, CLocaleThreadData* plocinfo*/, bool bSecure, bool bPositionalParams, va_list& argptr)
	{
		int iResult = 0;

		switch (state)
		{

		case ST_NORMAL:

			if (Output_p_State_ST_NORMAL_1())
			{
				break;
			}

			OutputA_p_State_ST_NORMAL_2();
			break;

		case ST_PERCENT:

			Output_State_ST_PERCENT();
			break;

		case ST_FLAG:

			OutputA_State_ST_FLAG();

			break;

		case ST_WIDTH:

			OutputA_p_State_ST_WIDTH(format, argptr);
			break;

		case ST_DOT:

			precision = 0;// zero the precision, since dot with no number means 0 not default, according to ANSI
			break;

		case ST_PRECIS:

			OutputA_p_State_ST_PRECIS(format, argptr);
			break;

		case ST_SIZE:

			OutputA_p_State_ST_SIZE(format);
			break;

		case ST_TYPE:

			OutputA_p_l_State_ST_TYPE( /*_loc_update,*/ argptr);
			break;
		}

		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CStreamFormatter::OutputW_p_l_State( /*nsWin32::CLocaleUpdate& _loc_update,*/ const wchar_t* format/*, CLocaleThreadData* plocinfo*/, bool bSecure, bool bPositionalParams, va_list& argptr)
	{
		int iResult = 0;

		switch (state)
		{

		case ST_NORMAL:

			if (Output_p_State_ST_NORMAL_1())
			{
				break;
			}
			//NORMAL_STATE:
			OutputW_p_State_ST_NORMAL_2();
			break;

		case ST_PERCENT:

			Output_State_ST_PERCENT();
			break;

		case ST_FLAG:

			OutputW_State_ST_FLAG();

			break;

		case ST_WIDTH:

			OutputW_p_State_ST_WIDTH(format, argptr);
			break;

		case ST_DOT:
			// zero the precision, since dot with no number means 0 not default, according to ANSI
			precision = 0;
			break;

		case ST_PRECIS:

			OutputW_p_State_ST_PRECIS(format, argptr);
			break;

		case ST_SIZE:

			OutputW_p_State_ST_SIZE(format);
			break;

		case ST_TYPE:

			OutputW_p_l_State_ST_TYPE( /*_loc_update,*/ argptr);
			break;
		}

		return iResult;
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputA_l_Main( /*nsWin32::CLocaleUpdate& _loc_update,*/ const char* format/*, CLocaleThreadData* plocinfo*/, va_list argptr)
	{
		// main loop -- loop while format character exist and no I/O errors
		while ((chA = *format++) != '\0' && charsout >= 0)
		{
			chclass = (CHARTYPE)FIND_CHAR_CLASS(__lookuptable_s, chA);  // find character class
			state = FIND_NEXT_STATE(__lookuptable_s, chclass, state);	// find next state

			if ((state == ST_PERCENT) && (*format != '%'))
			{
				if (format_type == FMT_TYPE_NOTSET)
				{
					// We set the value of format_type when we hit the first type specifier
					if ( /*strtol( format, &end_posA, 10 ) > 0 */ false && (*end_posA == '$'))
					{
						if (pass == FORMAT_POSSCAN_PASS)
						{
							memset(pos_value, 0, sizeof(pos_value));
						}
						format_type = FMT_TYPE_POSITIONAL;
					}
					else
					{
						format_type = FMT_TYPE_NONPOSITIONAL;
					}
				}

				if (format_type == FMT_TYPE_POSITIONAL)
				{
					type_pos = 1;//TODO:strtol( format, &end_posA, 10 ) - 1;
					format = end_posA + 1;

					if (pass == FORMAT_POSSCAN_PASS)
					{
						// We don't redo the validations in the 2nd pass
						//_VALIDATE_RETURN( ( ( type_pos >= 0 ) && ( *end_pos == L'$' ) && ( type_pos < NL_ARGMAX ) ), EINVAL, -1 );

						// Update max_pos with the current maximum pos argument */
						max_pos = type_pos > max_pos ? type_pos : max_pos;
					}
				}
			}
			else
			{
				// If state is ST_INVALID, that means an invalid format specifier
				if (state == ST_INVALID)
				{
					//_VALIDATE_RETURN(("Incorrect format specifier", 0), EINVAL, -1);
					return;
				}
			}

			// execute code for each state
			OutputA_l_State( /*_loc_update,*/ format/*, plocinfo*/, false, false, argptr);
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::OutputW_l_Main( /*nsWin32::CLocaleUpdate& _loc_update,*/ const wchar_t* format/*, CLocaleThreadData* plocinfo*/, va_list argptr)
	{
		// main loop -- loop while format character exist and no I/O errors
		while ((chW = *format++) != L'\0' && charsout >= 0)
		{
			chclass = (CHARTYPE)FIND_CHAR_CLASS(__lookuptable_s, chW);  // find character class
			state = FIND_NEXT_STATE(__lookuptable_s, chclass, state);	// find next state

			if ((state == ST_PERCENT) && (*format != L'%'))
			{
				if (format_type == FMT_TYPE_NOTSET)
				{
					// We set the value of format_type when we hit the first type specifier
					if (wcstol(format, &end_posW, 10) > 0 && (*end_posW == L'$'))
					{
						if (pass == FORMAT_POSSCAN_PASS)
						{
							memset(pos_value, 0, sizeof(pos_value));
						}
						format_type = FMT_TYPE_POSITIONAL;
					}
					else
					{
						format_type = FMT_TYPE_NONPOSITIONAL;
					}
				}

				if (format_type == FMT_TYPE_POSITIONAL)
				{
					type_pos = wcstol(format, &end_posW, 10) - 1;
					format = end_posW + 1;

					if (pass == FORMAT_POSSCAN_PASS)
					{
						// We don't redo the validations in the 2nd pass
						//_VALIDATE_RETURN( ( ( type_pos >= 0 ) && ( *end_pos == L'$' ) && ( type_pos < NL_ARGMAX ) ), EINVAL, -1 );

						// Update max_pos with the current maximum pos argument */
						max_pos = type_pos > max_pos ? type_pos : max_pos;
					}
				}
			}
			else
			{
				// If state is ST_INVALID, that means an invalid format specifier
				if (state == ST_INVALID)
				{
					//_VALIDATE_RETURN(("Incorrect format specifier", 0), EINVAL, -1);
				}
			}

			// execute code for each state
			OutputW_p_l_State( /*_loc_update,*/ format/*, plocinfo*/, false, false, argptr);
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::Output_Positonal(va_list argptr)
	{
		/* At the end of the 1st pass, we have the types filled into the
		arg_type member of the struct. We now need to get argument pointer on
		the stack & store it into the arg_ptr member */
		for (type_pos = 0; type_pos <= max_pos; ++type_pos)
		{
			switch (pos_value[type_pos].arg_type)
			{
			case e_int_arg:
				pos_value[type_pos].arg_ptr = argptr;
				get_int_arg(&argptr);
				break;

			case e_ptr_arg:
				pos_value[type_pos].arg_ptr = argptr;
				get_ptr_arg(&argptr);
				break;

			case e_int64_arg:
				pos_value[type_pos].arg_ptr = argptr;
				get_int64_arg(&argptr);
				break;

			case e_long_long_arg:
				pos_value[type_pos].arg_ptr = argptr;
				get_long_long_arg(&argptr);
				break;

			case e_long_arg:
				pos_value[type_pos].arg_ptr = argptr;
				get_long_arg(&argptr);
				break;

			case e_double_arg:
				pos_value[type_pos].arg_ptr = argptr;
				get_crtdouble_arg(&argptr);
				break;

			default:
				// Should never get here
				//_VALIDATE_RETURN(("Missing position in the format string", 0), EINVAL, -1);
				break;
			}
		}
	}

	//--------------------------------------------------------------------------------
	int CStreamFormatter::OutputA_l(const char* format/*, CLocaleThreadData* plocinfo*/, va_list argptr)
	{
		//nsWin32::CLocaleUpdate _loc_update( plocinfo );
		charsout = 0;
		saved_formatA = format;
		for (pass = 0; pass < 2; ++pass)
		{
			if ((pass == FORMAT_OUTPUT_PASS) && (format_type == FMT_TYPE_NONPOSITIONAL))
			{
				// If in pass2, we still have format_type isn't positional, it means that we do not need a 2nd pass
				break;
			}

			textlen = 0;        // no text yet
			heapbuf = 0;		// not using heap-allocated buffer
			buffersize = 0;
			max_pos = -1;
			fldwidth = 0;
			precision = 0;
			format = saved_formatA;
			type_pos = -1;
			width_pos = -1;
			precis_pos = -1;

			/* All chars before the first format specifier get output in the first
			pass itself. Hence we have to reset format_type to FMT_TYPE_NOTSET to ensure
			that they do not get output again in the 2nd pass */
			format_type = FMT_TYPE_NOTSET;

			OutputA_l_Main( /*_loc_update,*/ format/*, plocinfo*/, argptr);

			if ((format_type == FMT_TYPE_POSITIONAL) && (pass == FORMAT_POSSCAN_PASS))
			{
				Output_Positonal(argptr);
			}

		}

		return charsout;
	}

	//--------------------------------------------------------------------------------
	int CStreamFormatter::OutputW_l(const wchar_t* format/*, CLocaleThreadData* plocinfo*/, va_list argptr)
	{
		//nsWin32::CLocaleUpdate _loc_update( plocinfo );

		charsout = 0;						// no characters written yet
		saved_formatW = format;

		for (pass = 0; pass < 2; ++pass)
		{
			if ((pass == FORMAT_OUTPUT_PASS) && (format_type == FMT_TYPE_NONPOSITIONAL))
			{
				// If in pass2, we still have format_type isn't positional, it means that we do not need a 2nd pass
				break;
			}

			textlen = 0;        // no text yet
			heapbuf = NULL;     // not using heap-allocated buffer
			buffersize = 0;
			max_pos = -1;
			fldwidth = 0;
			precision = 0;
			format = saved_formatW;
			type_pos = -1;
			width_pos = -1;
			precis_pos = -1;

			/* All chars before the first format specifier get output in the first
			pass itself. Hence we have to reset format_type to FMT_TYPE_NOTSET to ensure
			that they do not get output again in the 2nd pass */
			format_type = FMT_TYPE_NOTSET;

			OutputW_l_Main( /*_loc_update,*/ format/*, plocinfo*/, argptr);

			/* The format string shouldn't be incomplete - i.e. when we are finished
			with the format string, the last thing we should have encountered
			should have been a regular char to be output or a type specifier. Else
			the format string was incomplete */
			//_VALIDATE_RETURN(((state == ST_NORMAL) || (state == ST_TYPE)), EINVAL, -1);

			if ((format_type == FMT_TYPE_POSITIONAL) && (pass == FORMAT_POSSCAN_PASS))
			{
				Output_Positonal(argptr);
			}
		}

		return charsout;        // return value = number of characters written
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::cfltcvt(double value, char* buffer, char fmt, int precision, int capexp)
	{
		int decpt, sign, exp, pos;
		char* digits = NULL;
		char cvtbuf[80];
		int magnitude;

		if (fmt == 'g')
		{
			digits = ecvtbuf(value, precision, &decpt, &sign, cvtbuf);
			magnitude = decpt - 1;
			if (magnitude < -4 || magnitude > precision - 1)
			{
				fmt = 'e';
				precision -= 1;
			}
			else
			{
				fmt = 'f';
				precision -= decpt;
			}
		}

		if (fmt == 'e')
		{
			digits = ecvtbuf(value, precision + 1, &decpt, &sign, cvtbuf);

			if (sign)
			{
				*buffer++ = '-';
			}
			*buffer++ = *digits;
			if (precision > 0)
			{
				*buffer++ = '.';
			}
			memcpy(buffer, digits + 1, precision);
			buffer += precision;
			*buffer++ = capexp ? 'E' : 'e';

			if (decpt == 0)
			{
				if (value == 0.0)
				{
					exp = 0;
				}
				else
				{
					exp = -1;
				}
			}
			else
			{
				exp = decpt - 1;
			}

			if (exp < 0)
			{
				*buffer++ = '-';
				exp = -exp;
			}
			else
			{
				*buffer++ = '+';
			}

			buffer[2] = (exp % 10) + '0';
			exp = exp / 10;
			buffer[1] = (exp % 10) + '0';
			exp = exp / 10;
			buffer[0] = (exp % 10) + '0';
			buffer += 3;
		}
		else if (fmt == 'f')
		{
			digits = fcvtbuf(value, precision, &decpt, &sign, cvtbuf);
			if (sign)
			{
				*buffer++ = '-';
			}

			if (*digits)
			{
				if (decpt <= 0)
				{
					*buffer++ = '0';
					*buffer++ = '.';
					for (pos = 0; pos < -decpt; pos++)
					{
						*buffer++ = '0';
					}

					while (*digits)
					{
						*buffer++ = *digits++;
					}
				}
				else
				{
					pos = 0;
					while (*digits)
					{
						if (pos++ == decpt)
						{
							*buffer++ = '.';
						}
						*buffer++ = *digits++;
					}
				}
			}
			else
			{
				*buffer++ = '0';
				if (precision > 0)
				{
					*buffer++ = '.';
					for (pos = 0; pos < precision; pos++)
					{
						*buffer++ = '0';
					}
				}
			}
		}

		*buffer = '\0';
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::forcdecpt(char* buffer)
	{
		while (*buffer)
		{
			if (*buffer == '.')
			{
				return;
			}

			if (*buffer == 'e' || *buffer == 'E')
			{
				break;
			}
			buffer++;
		}

		if (*buffer)
		{
			int n = strlen(buffer);
			while (n > 0)
			{
				buffer[n + 1] = buffer[n];
				n--;
			}
			*buffer = '.';
		}
		else
		{
			*buffer++ = '.';
			*buffer = '\0';
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::cropzeros(char* buffer)
	{
		char* stop;

		while (*buffer && *buffer != '.') buffer++;

		if (*buffer++)
		{
			while (*buffer && *buffer != 'e' && *buffer != 'E') buffer++;

			stop = buffer--;

			while (*buffer == '0') buffer--;

			if (*buffer == '.')
			{
				buffer--;
			}

			while (*++buffer = *stop++);
		}
	}

	//--------------------------------------------------------------------------------
	char* CStreamFormatter::cvt(double arg, int ndigits, int* decpt, int* sign, char* buf, int eflag)
	{
		int r2;
		double fi, fj;
		char* p, *p1;

		if (ndigits < 0)
		{
			ndigits = 0;
		}

		if (ndigits >= _CVTBUFSIZE - 1)
		{
			ndigits = _CVTBUFSIZE - 2;
		}
		r2 = 0;
		*sign = 0;
		p = &buf[0];
		if (arg < 0)
		{
			*sign = 1;
			arg = -arg;
		}
		arg = modf(arg, &fi);
		p1 = &buf[_CVTBUFSIZE];

		if (fi != 0)
		{
			p1 = &buf[_CVTBUFSIZE];
			while (fi != 0)
			{
				fj = modf(fi / 10, &fi);
				*--p1 = (char)(int)((fj + .03) * 10) + '0';
				r2++;
			}
			while (p1 < &buf[_CVTBUFSIZE])
			{
				*p++ = *p1++;
			}
		}
		else if (arg > 0)
		{
			while ((fj = arg * 10) < 1)
			{
				arg = fj;
				r2--;
			}
		}
		p1 = &buf[ndigits];
		if (eflag == 0)
		{
			p1 += r2;
		}
		*decpt = r2;
		if (p1 < &buf[0])
		{
			buf[0] = '\0';
			return buf;
		}
		while (p <= p1 && p < &buf[_CVTBUFSIZE])
		{
			arg *= 10;
			arg = modf(arg, &fj);
			*p++ = (char)(int)fj + '0';
		}
		if (p1 >= &buf[_CVTBUFSIZE])
		{
			buf[_CVTBUFSIZE - 1] = '\0';
			return buf;
		}
		p = p1;
		*p1 += 5;
		while (*p1 > '9')
		{
			*p1 = '0';
			if (p1 > buf)
			{
				++*--p1;
			}
			else
			{
				*p1 = '1';
				(*decpt)++;
				if (eflag == 0)
				{
					if (p > buf)
					{
						*p = '0';
					}
					p++;
				}
			}
		}
		*p = '\0';
		return buf;
	}

	//--------------------------------------------------------------------------------
	char* CStreamFormatter::ecvt(double arg, int ndigits, int* decpt, int* sign)
	{
		return cvt(arg, ndigits, decpt, sign, t_pCurrentWin32Thread->Data().CVTBuffer(), 1);
	}

	//--------------------------------------------------------------------------------
	char* CStreamFormatter::ecvtbuf(double arg, int ndigits, int* decpt, int* sign, char* buf)
	{
		return cvt(arg, ndigits, decpt, sign, buf, 1);
	}

	//--------------------------------------------------------------------------------
	char* CStreamFormatter::fcvt(double arg, int ndigits, int* decpt, int* sign)
	{
		return cvt(arg, ndigits, decpt, sign, t_pCurrentWin32Thread->Data().CVTBuffer(), 0);
	}

	//--------------------------------------------------------------------------------
	char* CStreamFormatter::fcvtbuf(double arg, int ndigits, int* decpt, int* sign, char* buf)
	{
		return cvt(arg, ndigits, decpt, sign, buf, 0);
	}


	//--------------------------------------------------------------------------------
	void CStreamFormatter::write_charA(char ch, int* pnumwritten)
	{
		if (_putch_nolock(ch) == -1/*EOF*/)
		{
			*pnumwritten = -1;
		}
		else
		{
			++(*pnumwritten);
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::write_charW(wchar_t ch, int* pnumwritten)
	{
		if (_putwch_nolock(ch) == WEOF)
		{
			*pnumwritten = -1;
		}
		else
		{
			++(*pnumwritten);
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::write_charA(char ch, CStream* , int* pnumwritten)
	{

		if ((m_pStream->IsBufferString() ) && m_pStream->IsUnBuffered() )
		{
			++(*pnumwritten);
			return;
		}

		if (m_pStream->putc_unlocked(ch) == -1/*EOF*/)
		{
			*pnumwritten = -1;
		}
		else
		{
			++(*pnumwritten);
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::write_charW(wchar_t ch, CStream* f, int* pnumwritten)
	{
		if ((m_pStream->IsBufferString()) && m_pStream->IsUnBuffered())
		{
			++(*pnumwritten);
			return;
		}

		if (m_pStream->putc_unlocked(ch) == WEOF)
		{
			*pnumwritten = -1;
		}
		else
		{
			++(*pnumwritten);
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::write_multi_charA(char ch, int num, int* pnumwritten)
	{
		while (num-- > 0)
		{
			write_charA(ch, pnumwritten);
			if (*pnumwritten == -1)
			{
				break;
			}
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::write_multi_charW(wchar_t ch, int num, int* pnumwritten)
	{
		while (num-- > 0)
		{
			write_charW(ch, pnumwritten);
			if (*pnumwritten == -1)
			{
				break;
			}
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::write_multi_charA(char ch, int num, CStream *f, int *pnumwritten)
	{
		while (num-- > 0)
		{
			write_charA(ch, f, pnumwritten);
			if (*pnumwritten == -1)
			{
				break;
			}
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::write_multi_charW(wchar_t ch, int num, CStream *f, int *pnumwritten)
	{
		while (num-- > 0)
		{
			write_charW(ch, f, pnumwritten);
			if (*pnumwritten == -1)
			{
				break;
			}
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::write_stringA(char* string, int len, int* pnumwritten)
	{
		while (len-- > 0)
		{
			write_charA(*string++, pnumwritten);
			if (*pnumwritten == -1)
			{
				if ((*nsBaseCRT::CCRTErrorDomain::ErrNo()) == EILSEQ)
				{
					write_charA(L'?', pnumwritten);
				}
				else
				{
					break;
				}
			}
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::write_stringW(wchar_t* string, int len, int* pnumwritten)
	{
		while (len-- > 0)
		{
			write_charW(*string++, pnumwritten);
			if (*pnumwritten == -1)
			{
				if ((*nsBaseCRT::CCRTErrorDomain::ErrNo()) == EILSEQ)
				{
					write_charW(L'?', pnumwritten);
				}
				else
				{
					break;
				}
			}
		}
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::write_stringA(char* string, int len, CStream* f, int* pnumwritten)
	{
		if( m_pStream->IsBufferString() && m_pStream->IsUnBuffered() )
		{
			(*pnumwritten) += len;
		}
		else
		{
			while (len-- > 0)
			{
				write_charA(*string++, f, pnumwritten);
				if (*pnumwritten == -1)
				{
					if ((*nsBaseCRT::CCRTErrorDomain::ErrNo()) == EILSEQ)
					{
						write_charA(L'?', f, pnumwritten);
					}
					else
					{
						break;
					}
				}
			}
		}
		return;
	}

	//--------------------------------------------------------------------------------
	void CStreamFormatter::write_stringW(wchar_t* string, int len, CStream* f, int* pnumwritten)
	{
		if (m_pStream->IsBufferString() && m_pStream->IsUnBuffered())
		{
			(*pnumwritten) += len;
		}
		else
		{
			while (len-- > 0)
			{
				write_charW(*string++, f, pnumwritten);
				if (*pnumwritten == -1)
				{
					if ((*nsBaseCRT::CCRTErrorDomain::ErrNo()) == EILSEQ)
					{
						write_charW(L'?', f, pnumwritten);
					}
					else
					{
						break;
					}
				}
			}
		}
		return;
	}

	//--------------------------------------------------------------------------------
	//int CStreamFormatter::_mbtowc_l( wchar_t* pwc, const char* s, size_t n, CLocaleThreadData* plocinfo )
	//{
	//	if( !s || n == 0 )
	//	{
	//		// indicate do not have state-dependent encodings, handle zero length string
	//		return 0;
	//	}

	//	if( !*s )
	//	{
	//		// handle NULL char
	//		if( pwc )
	//		{
	//			*pwc = 0;
	//		}
	//		return 0;
	//	}

	//	//CLocaleUpdate _loc_update( plocinfo );

	//	if( _loc_update.GetLocaleT()->LocaleInfoPtr()->Handles()[ CLocale::LCCTYPE ] == CLocale::_CLOCALEHANDLE )
	//	{
	//		if( pwc )
	//		{
	//			*pwc = (wchar_t)(unsigned char)*s;
	//		}
	//		return sizeof(char);
	//	}

	//	if( SBUChar(*s).isleadbyte( _loc_update.GetLocaleT() ) )
	//	{
	//		// multi-byte char

	//		if( ( _loc_update.GetLocaleT()->LocaleInfoPtr()->MBCurMax() <= 1 ) || ( (int)n < _loc_update.GetLocaleT()->LocaleInfoPtr()->MBCurMax() ) || (  _loc_update.GetLocaleT()->LocaleInfoPtr()->CodePage().MultiByteToWideChar( MB_Precomposed | MB_Err_Invalid_Chars, s, _loc_update.GetLocaleT()->LocaleInfoPtr()->MBCurMax(), pwc, ( pwc ) ? 1 : 0 ) == 0 ) )
	//		{
	//			// validate high byte of mbcs char
	//			if( (n < (size_t)_loc_update.GetLocaleT()->LocaleInfoPtr()->MBCurMax() ) || ( !*( s + 1 ) ) )
	//			{
	//				errno = EILSEQ;
	//				return -1;
	//			}
	//		}
	//		return _loc_update.GetLocaleT()->LocaleInfoPtr()->MBCurMax();
	//	}
	//	else
	//	{
	//		// single byte char
	//		if( _loc_update.GetLocaleT()->LocaleInfoPtr()->CodePage().MultiByteToWideChar( MB_Precomposed | MB_Err_Invalid_Chars, s, 1, pwc, (pwc) ? 1 : 0 ) == 0 )
	//		{
	//			errno = EILSEQ;
	//			return -1;
	//		}
	//		return sizeof(char);
	//	}
	//}

	//--------------------------------------------------------------------------------
	wint_t CStreamFormatter::_putwch_nolock(wchar_t ch)
	{
		/*
		int size, num_written;
		static int use_w = 2;
		char mbc[ 5//MB_LEN_MAX// + 1 ];
		if( use_w )
		{
		if( CConsole::ConsoleOutputFile() == (nsWin32::CCRTFile*)(-2) )
		{
		CConsole::__initconout();
		}

		// write character to console file handle

		if( CConsole::ConsoleOutputFile() == (nsWin32::CCRTFile*)(-1) )
		{
		return WEOF;
		}
		else if( !nsWin32::CKernel32::WriteConsoleW( CConsole::ConsoleOutputFile()->Handle(), (void*)&ch, 1, (unsigned long*)&num_written, 0 ) )
		{
		if( use_w == 2 && nsWin32::CKernel32::GetLastError() == ERROR_CALL_NOT_IMPLEMENTED )
		{
		use_w = 0;
		}
		else
		{
		return WEOF;
		}
		}
		else
		{
		use_w = 1;
		}
		}

		if( use_w == 0)
		{
		size = CKernel32::WideCharToMultiByte( CKernel32::GetConsoleOutputCP(), 0, (wchar_t*)&ch, 1, mbc, 5//MB_LEN_MAX//, 0, 0 );
		if( ( CConsole::ConsoleOutputFile() == (nsWin32::CCRTFile*)(-1) ) || !CKernel32::WriteConsole( (void*)CConsole::ConsoleOutputFile(), (void*)mbc, size, (unsigned long*)&num_written, 0 ) )
		{
		// return error indicator
		return WEOF;
		}
		}
		*/
		return ch;
	}

	//--------------------------------------------------------------------------------
	int CStreamFormatter::_putch_nolock(int c)
	{
		unsigned char* ch_buf = _con_ch_buf;
		unsigned short* pch_buf_used = &(_ch_buf_used);

		// can't use ch directly unless sure we have a big-endian machine
		unsigned char ch = (unsigned char)c;
		//wchar_t wchar;

		/*Why are we using putwch to write to Console when we could have
		* written straight away to Console? The problem we have in writing to
		* Console is that CRT codepage is different from Console codepage and
		* thus to write to console, we will need to convert the codepage. Here
		* we can use unicode version of these routines and this way we will
		* only have to do one conversion and rest will be handled by putwch.
		*/

		/*
		* The usual way people call putch is character by character. Also
		* there is noway we can convert partial MBCS to unicode character. To
		* address this issue, we buffer all the lead bytes and combine them
		* with trail bytes and then do the conversion.
		*/
		if (*pch_buf_used == 1)
		{
			//assert( isleadbyte( ch_buf[ 0 ] ) != 0 );

			ch_buf[1] = ch;
		}
		else
		{
			ch_buf[0] = ch;
		}

		if (false)//TODO: *pch_buf_used == 0 && isleadbyte( ch_buf[ 0 ] ) )
		{
			//We still need trail byte, wait for it.
			*pch_buf_used = 1;
		}
		else
		{
			//if( mbtowc( &wchar, const_cast< const char* >( reinterpret_cast< char* >( ch_buf ) ), ( *pch_buf_used ) + 1 ) == -1 || _putwch_nolock( wchar ) == WEOF )
			{
				ch = (unsigned char)(-1);/*EOF*/
			}

			//Since we have processed full MBCS character, we should reset ch_buf_used.

			(*pch_buf_used) = 0;
		}

		return ch;
	}

}//nsWin32

