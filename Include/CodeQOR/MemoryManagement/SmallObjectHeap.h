//SmallObjectHeap.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//A heap manager optimized for many 'small' i.e. < 64K allocations

//Only to be used from a single thread as no locking is performed.

/*On Windows a CSmallObjectHeap will outperform the system allocator on allocation
for heaps of > 1000 and < 100000 small items.
Allocation performance is better the smaller the items but typically twice that
of the system allocator for < 100000 items and 1/2 that of the system allocator
for larger heaps
Deallocation performance is typical 10 * that of the system allocator rising to
 ~16 * as the number of items increases.

 Allocation space efficiency is generally lower than the system heap. The larger the
 items stored the lower the efficiency. typically an SO Heap will be 125% to 150% of the
 system heap with identical allocations
*/

#ifndef CODEQOR_SMALLOBJECTHEAP_H_2
#define CODEQOR_SMALLOBJECTHEAP_H_2

#include "CompilerQOR.h"

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "CodeQOR/MemoryManagement/SmallObjectBucket.h"

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
	template< typename T > class TBox;
	template< typename T > class TPointer;
	template< typename T > struct __QOR_INTERFACE( __CODEQOR ) TTHFunctor;

	//--------------------------------------------------------------------------------
	template< typename T > T* FastNew( Cmp_uint_ptr uiCount, unsigned int uiLine, char* pFile );
	template< typename T > void FastFree( T* pT, Cmp_uint_ptr uiCount );

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __CODEQOR ) CSmallObjectHeap
	{

	public:

		__QCMP_STATIC_CONSTANT( unsigned int, suiRootBuckets = ( sizeof( Cmp_uint_ptr ) * 8 ) / 2 );// power of 4 buckets up to the memory space size

		CSmallObjectHeap();
		~CSmallObjectHeap();

		//--------------------------------------------------------------------------------
		//Allocated 1 or more typed objects ( unmanaged ) from the SO Heap
		template< typename T >
		T* AllocateUnboxed( Cmp_uint_ptr uiCount = 1 )
		{
			return TTHFunctor< T >::Allocate( *this, uiCount );
		}

		//--------------------------------------------------------------------------------
		//Free 1 or more typed objects ( unmanaged ) from the SO Heap
		template< typename T >
		void FreeUnboxed( T* pT, Cmp_uint_ptr uiCount )
		{
			TTHFunctor< T >::Free( *this, pT, uiCount );
		}

		//--------------------------------------------------------------------------------
		template< typename T >
		bool TestUnboxed( T* pT, Cmp_uint_ptr uiCount )
		{
			return TTHFunctor< T >::Test( *this, pT, uiCount );
		}

		//--------------------------------------------------------------------------------
		//Allocate 1 or more managed objects from the SO Heap
		template< typename T >
		TPointer< T > AllocateBoxed( Cmp_uint_ptr uiCount = 1 )
		{
			byte* pBoxMem = 0;
			int iBucket = Bucket( sizeof( TBox< T > ) );												//index of the bucket in which to allocate
			CSmallObjectBucket* pBucket = Page( iBucket );												//Get the bucket
			if( pBucket )
			{
				pBoxMem = reinterpret_cast< byte* >( pBucket->Allocate( sizeof( TBox< T > ) ) );		//Allocate raw memory from the bucket
				TPointer< T > Result( new( pBoxMem ) TBox< T >( uiCount ) );							//Construct the Box in the memory
				m_uiTotalAlloc += pBucket->UnitSize();													//Count the raw memory allocated
				if( m_uiTotalAlloc > m_uiMaxAlloc )
				{
					m_uiMaxAlloc = m_uiTotalAlloc;														//Keep account of the maximum heap size
				}
				return Result;
			}
			else
			{
#ifdef __QOR_CPP_EXCEPTIONS
				throw "Small Object Heap, failure to get a bucket to allocate in.";
#endif
			}
		}

		//--------------------------------------------------------------------------------
		//Free a managed 'box'
		template< typename T >
		void FreeBox( TBox< T >* pBox )
		{
			pBox->~TBox< T >();									//deconstruct the box
			int iBucket = Bucket( sizeof( TBox< T > ) );		//Get the bucket index from the size to be deallocated
			CSmallObjectBucket* pBucket = Page( iBucket );		//Get the bucket object
			if( pBucket )
			{
				pBucket->Free( pBox, sizeof( TBox< T > ) );		//Free the memory
				m_uiTotalAlloc -= pBucket->UnitSize();			//reduce the count of the allocation
			}
		}

		byte* DeferToFastAllocator( Cmp_uint_ptr uiSize );
		void DeferToFastFree( void* pMem, Cmp_uint_ptr uiCount  );
		void FreeBucket( int iBucket, CSmallObjectBucket* pBucket );

		void ReportTotalAllocation( Cmp_uint_ptr& uiTotalAlloc );
		void ReportMaxAllocation( Cmp_uint_ptr& uiMaxAlloc );
		int Bucket( Cmp_uint_ptr uiAllocSize );					//Get the bucket index from the size of allocation
		CSmallObjectBucket* Page( int iBucket );				//Get the bucket from the index

		void Analyse( void(*pTrace)( char* ) );

		CSmallObjectBucket* m_Buckets[ suiRootBuckets ];		//Array of buckets to contain allocations
		Cmp_uint_ptr m_uiTotalAlloc;							//The total allocated bytes
		Cmp_uint_ptr m_uiMaxAlloc;								//The highest total allocated bytes
	};

	//--------------------------------------------------------------------------------
	//template to manage allocation and deletion
	template< typename T > struct TTHFunctor
	{
		//--------------------------------------------------------------------------------
		static T* Allocate( CSmallObjectHeap& Heap, Cmp_uint_ptr uiCount = 1 )
		{
			byte* pMemory = 0;
			Cmp_uint_ptr uiSize = sizeof( T ) * uiCount;

			if( uiSize > ( 1024 * 64 ) )														//Divert allocations > 64K to the Fast Heap
			{
				pMemory = reinterpret_cast< byte* >( FastNew< void >( uiSize, __LINE__, __FILE__ ) );
				Heap.m_uiTotalAlloc += ( uiSize );
			}
			else
			{
				CSmallObjectBucket* pBucket = Heap.Page( Heap.Bucket( uiSize ) );				//Get the bucket to allocate from
				if( pBucket )
				{
					pMemory = reinterpret_cast< byte* >( pBucket->Allocate( uiSize ) );//Allocate from the bucket
					Heap.m_uiTotalAlloc += pBucket->UnitSize();									//Count the allocation
				}
			}

			if( pMemory )
			{
				for( unsigned int uiItem = 0; uiItem < uiCount; uiItem++ )						//Initialise the allocated objects
				{
					new( pMemory + ( sizeof( T ) * uiItem ) ) T;
				}

				if( Heap.m_uiTotalAlloc > Heap.m_uiMaxAlloc )
				{
					Heap.m_uiMaxAlloc = Heap.m_uiTotalAlloc;									//Track the maximum heap size
				}
			}
			else
			{
#ifdef __QOR_CPP_EXCEPTIONS
				throw( "Small Object Heap out of memory!" );
#endif
			}

			return reinterpret_cast< T* >( pMemory );											//Return the new object(s)
		}

		//--------------------------------------------------------------------------------
		static void Free( CSmallObjectHeap& Heap, T* pT, Cmp_uint_ptr uiCount )
		{
			for( unsigned int uiItem = 0; uiItem < uiCount; uiItem++ )							//Destruct the object(s)
			{
				( pT + uiItem )->~T();
			}

			Cmp_uint_ptr uiSize = sizeof( T ) * uiCount;										//Work out the size to delete from the object type and count

			if( uiSize > ( 1024 * 64 ) )														//If the allocation is > 64k
			{
				FastFree< T >( pT, uiCount );													//Divert to the Fast heap
			}
			else
			{
				int iBucket = Heap.Bucket( uiSize );											//Get the bucket index from the size
				CSmallObjectBucket* pBucket = Heap.Page( iBucket );								//Get the bucket
				if( pBucket && pBucket->Free( pT, uiSize ) )									//Free within the bucket
				{
					Heap.m_uiTotalAlloc -= pBucket->UnitSize();									//decrease the allocation

					if( pBucket->IsEmpty() )													//If the bucket is now empty
					{
						Heap.FreeBucket( iBucket, pBucket );									//Free the bucket memory
					}
				}
				else
				{
#ifdef __QOR_CPP_EXCEPTIONS
					throw( "Small Object Heap failed to find memory to free!" );
#endif
				}
			}
		}

	};

	//--------------------------------------------------------------------------------
	template<> struct TTHFunctor< void >
	{
		//--------------------------------------------------------------------------------
		static void* Allocate( CSmallObjectHeap& Heap, Cmp_uint_ptr uiCount = 1 )
		{
			byte* pMemory = 0;
			Cmp_uint_ptr uiSize = uiCount;

			if( uiSize > ( 1024 * 64 ) )
			{
				pMemory = Heap.DeferToFastAllocator( uiSize );
				Heap.m_uiTotalAlloc += uiSize;
			}
			else
			{
				CSmallObjectBucket* pBucket = Heap.Page( Heap.Bucket( uiSize ) );
				if( pBucket )
				{
					pMemory = reinterpret_cast< byte* >( pBucket->Allocate( uiSize ) );
					Heap.m_uiTotalAlloc += pBucket->UnitSize();
				}
			}

			if( pMemory )
			{
				if( Heap.m_uiTotalAlloc > Heap.m_uiMaxAlloc )
				{
					Heap.m_uiMaxAlloc = Heap.m_uiTotalAlloc;
				}
			}
			else
			{
			    //abort();
				//throw( "Small Object Heap out of memory!" );
			}

			return pMemory;
		}

		//--------------------------------------------------------------------------------
		static void Free( CSmallObjectHeap& Heap, void* pMem, Cmp_uint_ptr uiCount )
		{
			Cmp_uint_ptr uiSize = uiCount;

			if( uiSize > ( 1024 * 64 ) )
			{
				Heap.DeferToFastFree( pMem, uiCount );
			}
			else
			{
				int iBucket = Heap.Bucket( uiSize );
				CSmallObjectBucket* pBucket = Heap.Page( iBucket );
				if( pBucket && pBucket->Free( pMem, uiSize ) )
				{
					Heap.m_uiTotalAlloc -= pBucket->UnitSize();

					if( pBucket->IsEmpty() )
					{
						Heap.FreeBucket( iBucket, pBucket );
					}
				}
				else
				{
					//throw( "Small Object Heap failed to find memory to free!" );
				}
			}
		}

		//--------------------------------------------------------------------------------
		static bool Test( CSmallObjectHeap& Heap, void* pMem, Cmp_uint_ptr uiCount )
		{
			Cmp_uint_ptr uiSize = uiCount;

			if( uiSize > ( 1024 * 64 ) )
			{
				return false;
			}
			else
			{
				CSmallObjectBucket* pBucket = Heap.Page( Heap.Bucket( uiSize ) );
				if( pBucket )
				{
					return pBucket->Test( pMem, uiSize );
				}
				else
				{
					return false;
				}
			}
		}
	};

}//nsCodeQOR

#endif//CODEQOR_SMALLOBJECTHEAP_H_2
