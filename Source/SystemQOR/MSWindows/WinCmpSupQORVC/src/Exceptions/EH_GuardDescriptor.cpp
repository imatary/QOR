//EH_GuardDescriptor.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "AppocritaQOR/SubSystems/Threading.h"
#include "WinQL/WinQL.h"
#include "SystemQOR.h"
#include "WinQL/Application/Threading/WinQLCriticalSection.h"
#include "../Source/SystemQOR/MSWindows/WinCmpSupQORVC/include/Exceptions/EH_Context.h"
#include "../Source/SystemQOR/MSWindows/WinCmpSupQORVC/include/Exceptions/EH_GuardDescriptor.h"
#include "CodeQOR/Modules/ProcessBase.h"
#include "../Source/SystemQOR/MSWindows/WinCmpSupQORVC/include/Exceptions/SEH/excpt.h"
#include "CodeQOR/Threading/ThreadContext.h"

//--------------------------------------------------------------------------------
namespace nsCompiler
{
#ifndef _WIN64		//This doesn't apply t 64bit Windows

	void CallMemberFunction( void* pObject, void* pfn, ... );
	void JumpToFunction( void* target, void* targetStack, void* targetEBP );
	void* __stdcall CallOnFrame0( void* addr, void* new_frame, void* temp1 = 0, void* temp2 = 0 );
	void* __stdcall CallOnFrame2( void* addr, void* new_frame, void* arg1, void* arg2, void* temp1 = 0, void* temp2 = 0 );

	namespace EH
	{
		//--------------------------------------------------------------------------------
		nsWin32::EXCEPTION_DISPOSITION CxxFrameHandler( ExceptionContext& context, GuardDescriptor& guard, BasicRegistrationNode* pMarkerRN, bool recursive );

		//--------------------------------------------------------------------------------
		GuardDescriptor::FrameInfo::FrameInfo( const ThrownObject& object ): m_pThrownObject( &object )
		{			
			FrameInfo*& pChain = reinterpret_cast< FrameInfo*& >( nsCodeQOR::CProcessBase::ThisProcess()->ThreadContext()->ExceptionContext()->FrameInfoChain() );
			m_pNext = pChain;
			pChain = this;
		}

		//--------------------------------------------------------------------------------
		GuardDescriptor::FrameInfo::~FrameInfo()
		{			
			FrameInfo*& pChain = reinterpret_cast< FrameInfo*& >( nsCodeQOR::CProcessBase::ThisProcess()->ThreadContext()->ExceptionContext()->FrameInfoChain() );
			if ( pChain == this )
			{
				pChain = m_pNext;
				return;
			}
			
			if (pChain)
			{
				FrameInfo* pInfo = 0;
				for (pInfo = pChain; !pInfo || pInfo->m_pNext != this; pInfo = pInfo ? pInfo->m_pNext : 0)
				{
					if (pInfo->m_pNext == 0)
					{
						inconsistency();
					}
				}
				pInfo->m_pNext = m_pNext;
			}
		}

		//--------------------------------------------------------------------------------	
		const TryBlockMapEntry* GuardDescriptor::GetRangeOfTrysToCheck( unsigned int* pStart, unsigned int* pEnd ) const
		{
			if( m_pFuncInfo->pTryBlockMap == 0 )
			{
				return 0;
			}

			const int curState = m_pRN->state;
			int CatchDepth = m_CatchDepth;
			unsigned start = m_pFuncInfo->nTryBlocks;
			unsigned temp = start;                                             
			unsigned end = start; 
			while ( CatchDepth >= 0 )
			{
				if ( start-- == -1 )
				{
					inconsistency();
				}

				const TryBlockMapEntry* const pEntry = m_pFuncInfo->pTryBlockMap + start;
				if ( ( pEntry->tryHigh >= curState || curState > pEntry->catchHigh ) && start != -1 )//Modified
				{
					end = temp;
					temp = start;
					--CatchDepth;
				}
			}
			*pStart = /*++*/start;                                          
			*pEnd = end;
			if ( end > m_pFuncInfo->nTryBlocks || start > end )//Modified
			{
				inconsistency();
			}
			return m_pFuncInfo->pTryBlockMap + start;
		}

		//--------------------------------------------------------------------------------
		int GuardDescriptor::FrameUnwindFilter( nsWin32::EXCEPTION_POINTERS* pExPtrs )
		{
			if ( pExPtrs->ExceptionRecord->ExceptionCode == CPP_EXCEPTION )
			{
				nsQOR::IThreading* pThreading = TheApplication()->GetRole()->GetSubSystem( nsQOR::IThread::ClassID() ).As< nsQOR::IThreading >();
				pThreading->GetCurrent()->ExceptionContext()->ProcessingThrow() = 0;
				std::terminate();
			}
			return nsWin32::Exception_Continue_Search;
		}

		//--------------------------------------------------------------------------------
		void GuardDescriptor::FrameUnwindToState( int targetState )
		{
			int curState = m_pRN->state;			
			int& ProcessingThrow = GetThreadContext()->ExceptionContext()->ProcessingThrow();
			++ProcessingThrow;
			__try 
			{
				while ( curState != targetState )
				{
					if ( curState <= -1 || curState >= m_pFuncInfo->maxState )
					{
						inconsistency();
					}
					int nxtState = m_pFuncInfo->pUnwindMap[curState].toState;
					__try
					{
						if ( m_pFuncInfo->pUnwindMap[curState].action != 0 )
						{
							m_pRN->state = nxtState;
							CallOnFrame0( reinterpret_cast< void* >( m_pFuncInfo->pUnwindMap[curState].action ), m_pRN->GetStackFrame() );
						}
					}
					__except( FrameUnwindFilter( (nsWin32::EXCEPTION_POINTERS*)_exception_info() ) )
					{
						
					}
					curState = nxtState;
				}
			}
			__finally
			{
				if ( ProcessingThrow > 0 )
				{
					--ProcessingThrow;
				}
			}
			
			if ( curState != targetState )
			{
				inconsistency();
			}
			m_pRN->state = curState;
		}

		//--------------------------------------------------------------------------------
		nsWin32::EXCEPTION_DISPOSITION GuardDescriptor::CatchGuardHandler( ExceptionRecord* pExcept, CatchGuardRN* pRN, nsWin32::CONTEXT* pContext, void* /*pDC*/ )
		{
			ExceptionContext context( pExcept, pContext, 0 );
			return CxxFrameHandler( context, pRN->StoredValue(), pRN, false );
		}

		//--------------------------------------------------------------------------------
		void* GuardDescriptor::CallCatchBlock2( void* handlerAddress )
		{
			CatchGuardRN CGRN( m_pRN, m_pFuncInfo, reinterpret_cast< void* >( CatchGuardHandler ), m_CatchDepth + 1 );
			CGRN.SetCurrent();

			void* continuationAddress = CallOnFrame0( handlerAddress, m_pRN->GetStackFrame() );
			CGRN.Remove();
			return continuationAddress;
		}

		//--------------------------------------------------------------------------------
		int GuardDescriptor::ExFilterRethrow( nsWin32::EXCEPTION_POINTERS* pExPtrs )
		{
			const ExceptionRecord* pExcept = ( const ExceptionRecord* )( pExPtrs->ExceptionRecord );
			if ( !pExcept->IsCpp() || pExcept->Object().IsValid() != 0 )
			{
				return nsWin32::Exception_Continue_Search;
			}
			return nsWin32::Exception_Execute_Handler;
		}

		//--------------------------------------------------------------------------------
		nsQOR::IThread* GuardDescriptor::GetThreadContext()
		{
			nsQOR::IThread* ThreadContext = nsCodeQOR::CProcessBase::ThisProcess()->ThreadContext().Detach();
			return ThreadContext;
		}

		//--------------------------------------------------------------------------------
		void* GuardDescriptor::CallCatchBlock( ExceptionContext& context, void* handlerAddress )
		{			
			nsQOR::IThread* ThreadContext = GetThreadContext();
			void* continuationAddress = handlerAddress;
			bool ExceptionObjectDestroyed = false;
			
			void* const saveESP = m_pRN->GetStack();
			const ExceptionContext SavedContext = ThreadContext->ExceptionContext()->CurrentException();                                         

			ThreadContext->ExceptionContext()->CurrentException() = reinterpret_cast< ExceptData& >( context );

			__try
			{
				__try
				{
					continuationAddress = CallCatchBlock2(handlerAddress);
				}
				__except( ExFilterRethrow( ( nsWin32::EXCEPTION_POINTERS* )_exception_info() ) )
				{
					const UnwindMapEntry* pUnwindMap = m_pFuncInfo->pUnwindMap;
					int cState = m_pRN->state;                                                                      
					const TryBlockMapEntry* pTryBlockMap = m_pFuncInfo->pTryBlockMap;
					for( unsigned i = 0; i < m_pFuncInfo->nTryBlocks; ++i )
					{
						if ( cState <= pTryBlockMap[i].tryHigh || cState > pTryBlockMap[i].catchHigh )
						{
							continue;
						}

						cState = pTryBlockMap[i].tryHigh + 1;                                                         
						cState = pUnwindMap[cState].toState;
					}
					FrameUnwindToState(cState);                                                
					continuationAddress = 0;
				}
			}
			__finally
			{
				m_pRN->SetStack( saveESP );				
				ThreadContext->ExceptionContext()->CurrentException() = *( reinterpret_cast< const ExceptData* >( &SavedContext ) );
				if ( context.IsCppException() && !ExceptionObjectDestroyed && continuationAddress != 0 && IsToBeDestroyed( context.ExceptionObject() ) )
				{
					context.ExceptionObject().Destruct( _abnormal_termination() != 0 );
				}
				
			}
			return continuationAddress;
		}
 	
		//--------------------------------------------------------------------------------
		void GuardDescriptor::Catch( ExceptionContext& context, const HandlerType* pCatch, const CatchableType* pConv, const TryBlockMapEntry* pEntry, BasicRegistrationNode* pMarkerRN )
		{
			if ( pConv != 0 )
			{
				context.CopyExceptionObject( m_pRN, pCatch, pConv ); 
			}
			
			context.UnwindNestedFrames( pMarkerRN != 0 ? pMarkerRN : m_pRN );
			
			FrameUnwindToState( pEntry->tryLow );

			m_pRN->state = pEntry->tryHigh + 1;

			void* continuationAddress = 0;

			{
				FrameInfo aFrameInfo( context.ExceptionObject() );
				continuationAddress = CallCatchBlock( context, pCatch->addressOfHandler );				
			}

			if ( continuationAddress )
			{
				JumpToContinuation( continuationAddress ); 
			}
		}

		//--------------------------------------------------------------------------------
		void __stdcall GuardDescriptor::JumpToContinuation( void* target )
		{
			( reinterpret_cast< CExceptionFrame* >( RegistrationNode::GetCurrent() ) )->Remove();
			void* const targetEBP = m_pRN->GetStackFrame();
			void* const targetStack = m_pRN->GetStack();
			JumpToFunction( target, targetStack, targetEBP );
		}

		//--------------------------------------------------------------------------------
		bool GuardDescriptor::IsToBeDestroyed( const ThrownObject& object ) const
		{			
			nsQOR::IThreading* pThreading = TheApplication()->GetRole()->GetSubSystem( nsQOR::IThread::ClassID() ).As< nsQOR::IThreading >();
			for( const FrameInfo* pInfo = reinterpret_cast< const FrameInfo* >( pThreading->GetCurrent()->ExceptionContext()->FrameInfoChain() ); pInfo != 0; pInfo = pInfo->Next() )
			{
				if( pInfo->Object() == object )
				{
					return false;
				}
			}
			return true;
		}

	}//EH
#endif
}//nsCompiler

