//WinQLStreamFormatter.h

// Copyright Querysoft Limited 2017
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//WinQL stream formatter

#ifndef WINQL_FILE_STREAMFORMATTER_H_2
#define WINQL_FILE_STREAMFORMATTER_H_2

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma __QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "WinQL/System/FileSystem/WinQLCRTFile.h"
//#include "WinQL/CodeServices/Locale/Locale.h"
//#include "WinQL/CodeServices/Locale/LocaleUpdate.h"
//#include <limits.h>

//--------------------------------------------------------------------------------
namespace nsWin32
{

	__QCMP_STATIC_CONSTANT(int, LONG_IS_INT = (sizeof(long) == sizeof(int)) ? 1 : 0);
	__QCMP_STATIC_CONSTANT(int, SHORT_IS_INT = (sizeof(short) == sizeof(int)) ? 1 : 0);
	__QCMP_STATIC_CONSTANT(int, LONGDOUBLE_IS_DOUBLE = (sizeof(Cmp_long_double) == sizeof(double)) ? 1 : 0);
	__QCMP_STATIC_CONSTANT(int, LONGLONG_IS_INT64 = (sizeof(Cmp_long_long) == sizeof(Cmp__int64)) ? 1 : 0);

	__QCMP_STATIC_CONSTANT(int, PTR_IS_INT = (sizeof(int*) == sizeof(int)) ? 1 : 0);
	__QCMP_STATIC_CONSTANT(int, PTR_IS_LONG = (sizeof(int*) == sizeof(long)) ? 1 : 0);
	__QCMP_STATIC_CONSTANT(int, PTR_IS_INT64 = (sizeof(int*) == sizeof(Cmp__int64)) ? 1 : 0);

#define get_long_long_arg(x) (long long)get_int64_arg(x)
#define get_long_arg(x) (long)get_int_arg(x)

	//#if PTR_IS_INT
	//#	define get_ptr_arg(x) (void *)(intptr_t)get_int_arg(x)
	//#elif PTR_IS_LONG
	//#	define get_ptr_arg(x) (void *)(intptr_t)get_long_arg(x)
	//#elif PTR_IS_INT64
	//#	define get_ptr_arg(x) (void *)get_int64_arg(x)
	//#else  /* PTR_IS_INT64 */
	//#	error Size of pointer must be same as size of int or long
	//#endif  /* PTR_IS_INT64 */

#define POSITION_CHAR _T('$')

	class __QOR_INTERFACE(__WINQL) CStream;

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE(__WINQL) CStreamFormatter
	{
	public:

		//--------------------------------------------------------------------------------
		enum STATE
		{
			ST_NORMAL,          // normal state; outputting literal chars
			ST_PERCENT,         // just read '%'
			ST_FLAG,            // just read flag character
			ST_WIDTH,           // just read width specifier
			ST_DOT,             // just read '.'
			ST_PRECIS,          // just read precision specifier
			ST_SIZE,            // just read size specifier
			ST_TYPE,            // just read type specifier
			ST_INVALID          // Invalid format
		};

		//--------------------------------------------------------------------------------
		enum ARG_TYPE
		{
			eblank,
			e_int_arg,
#ifndef _UNICODE
			e_short_arg,
#endif
			e_ptr_arg,
			e_int64_arg,
			e_long_long_arg,
			e_long_arg,
			e_longdouble_arg,
			e_double_arg
		};

		//--------------------------------------------------------------------------------
		struct positional_param
		{
			enum ARG_TYPE arg_type;
			va_list arg_ptr;
			union
			{
				char cType;
				wchar_t wType;
			}type;
			int flags;
		};

		//--------------------------------------------------------------------------------
		// character type values
		enum CHARTYPE
		{
			CH_OTHER,           // character with no special meaning
			CH_PERCENT,         // '%'
			CH_DOT,             // '.'
			CH_STAR,            // '*'
			CH_ZERO,            // '0'
			CH_DIGIT,           // '1'..'9'
			CH_FLAG,            // ' ', '+', '-', '#'
			CH_SIZE,            // 'h', 'l', 'L', 'N', 'F', 'w'
			CH_TYPE             // type specifying character
		};

		// flag definitions
		__QCMP_STATIC_CONSTANT(unsigned int, FL_SIGN = 0x00001);  // put plus or minus in front
		__QCMP_STATIC_CONSTANT(unsigned int, FL_SIGNSP = 0x00002);  // put space or minus in front
		__QCMP_STATIC_CONSTANT(unsigned int, FL_LEFT = 0x00004);  // left justify
		__QCMP_STATIC_CONSTANT(unsigned int, FL_LEADZERO = 0x00008);  // pad with leading zeros
		__QCMP_STATIC_CONSTANT(unsigned int, FL_LONG = 0x00010);  // long value given
		__QCMP_STATIC_CONSTANT(unsigned int, FL_SHORT = 0x00020);  // short value given
		__QCMP_STATIC_CONSTANT(unsigned int, FL_SIGNED = 0x00040);  // signed data given
		__QCMP_STATIC_CONSTANT(unsigned int, FL_ALTERNATE = 0x00080);  // alternate form requested
		__QCMP_STATIC_CONSTANT(unsigned int, FL_NEGATIVE = 0x00100);  // value is negative
		__QCMP_STATIC_CONSTANT(unsigned int, FL_FORCEOCTAL = 0x00200);  // force leading '0' for octals
		__QCMP_STATIC_CONSTANT(unsigned int, FL_LONGDOUBLE = 0x00400);  // long double value given
		__QCMP_STATIC_CONSTANT(unsigned int, FL_WIDECHAR = 0x00800);  // wide characters
		__QCMP_STATIC_CONSTANT(unsigned int, FL_LONGLONG = 0x01000);  // long long value given
		__QCMP_STATIC_CONSTANT(unsigned int, FL_I64 = 0x08000);  // __int64 value given
																 // We set this flag if %I is passed without I32 or I64
		__QCMP_STATIC_CONSTANT(unsigned int, FL_PTRSIZE = 0x10000);   // platform dependent number
		__QCMP_STATIC_CONSTANT(unsigned int, BUFFERSIZE = 512);
		__QCMP_STATIC_CONSTANT(unsigned int, MAXPRECISION = BUFFERSIZE);
		__QCMP_STATIC_CONSTANT(unsigned int, _CVTBUFSIZE = (309 + 40));
		__QCMP_STATIC_CONSTANT(int, FMT_TYPE_NOTSET = -1);
		__QCMP_STATIC_CONSTANT(int, FMT_TYPE_NONPOSITIONAL = 0);
		__QCMP_STATIC_CONSTANT(int, FMT_TYPE_POSITIONAL = 1);
		__QCMP_STATIC_CONSTANT(int, FORMAT_POSSCAN_PASS = 0);
		__QCMP_STATIC_CONSTANT(int, FORMAT_OUTPUT_PASS = 1);
		__QCMP_STATIC_CONSTANT(int, NUMSTATES = ST_INVALID + 1);

		static char* __nullstring;// = "(null)";  // string to print on null ptr
		static wchar_t* __wnullstring;// = L"(null)";// string to print on null ptr

		static const unsigned char __lookuptable_s[];
		static const char __lookuptable[];

		//--------------------------------------------------------------------------------
		typedef union
		{
			double value;
			struct
			{
				Cmp_unsigned__int32 lsw;
				Cmp_unsigned__int32 msw;
			} parts;
		} ieee_double_shape_type;

		//--------------------------------------------------------------------------------
		typedef union
		{
			float value;
			Cmp_unsigned__int32 word;
		} ieee_float_shape_type;

		//------------------------------------------------------------------------------
		// Get two 32 bit ints from a double.
		template< typename t1, typename t2, typename t3 >
		void extract_words(t1& ix0, t2& ix1, t3 d)
		{
			ieee_double_shape_type ew_u;
			ew_u.value = d;
			ix0 = ew_u.parts.msw;
			ix1 = ew_u.parts.lsw;
		}

		//------------------------------------------------------------------------------
		// Get the more significant 32 bit int from a double.
		template< typename t1, typename t2 >
		void get_high_word(t1& i, t2 d)
		{
			ieee_double_shape_type gh_u;
			gh_u.value = d;
			i = gh_u.parts.msw;
		}

		//------------------------------------------------------------------------------
		// Get the less significant 32 bit int from a double.
		template< typename t1, typename t2 >
		void get_low_word(t1& i, t2 d)
		{
			ieee_double_shape_type gl_u;
			gl_u.value = d;
			i = gl_u.parts.lsw;
		}

		//------------------------------------------------------------------------------
		// Set a double from two 32 bit ints.
		template< typename t1 >
		void insert_words(t1& d, Cmp_unsigned__int32 ix0, Cmp_unsigned__int32 ix1)
		{
			ieee_double_shape_type iw_u;
			iw_u.parts.msw = ix0;
			iw_u.parts.lsw = ix1;
			d = iw_u.value;
		}

		//------------------------------------------------------------------------------
		// Set the more significant 32 bits of a double from an int.
		template< typename t1, typename t2 >
		void set_high_word(t1& d, t2 v)
		{
			ieee_double_shape_type sh_u;
			sh_u.value = d;
			sh_u.parts.msw = v;
			d = sh_u.value;
		}

		//------------------------------------------------------------------------------
		// Set the less significant 32 bits of a double from an int.
		template< typename t1, typename t2 >
		void set_low_word(t1& d, t2 v)
		{
			ieee_double_shape_type sl_u;
			sl_u.value = d;
			sl_u.parts.lsw = v;
			d = sl_u.value;
		}

		//------------------------------------------------------------------------------
		// Get a 32 bit int from a float.
		template< typename t1, typename t2 >
		void get_float_word(t1& i, t2 d)
		{
			ieee_float_shape_type gf_u;
			gf_u.value = d;
			i = gf_u.word;
		}

		//------------------------------------------------------------------------------
		// Set a float from a 32 bit int.
		template< typename t1, typename t2 >
		void set_float_word(t1& d, t2 i)
		{
			ieee_float_shape_type sf_u;
			sf_u.word = i;
			d = sf_u.value;
		}

		//------------------------------------------------------------------------------
		double modf(double x, double* iptr)
		{
			static const double one = 1.0;

			Cmp_signed__int32 i0, i1, j0;
			Cmp_unsigned__int32 i;
			extract_words(i0, i1, x);
			j0 = ((i0 >> 20) & 0x7ff) - 0x3ff;	// exponent of x
			if (j0 < 20)
			{
				// integer part in high x
				if (j0 < 0)
				{
					// |x|<1
					insert_words(*iptr, i0 & 0x80000000, 0);	// *iptr = +-0
					return x;
				}
				else
				{
					i = (0x000fffff) >> j0;
					if (((i0 & i) | i1) == 0)
					{
						// x is integral */
						Cmp_unsigned__int32 high;
						*iptr = x;
						get_high_word(high, x);
						insert_words(x, high & 0x80000000, 0);	// return +-0
						return x;
					}
					else
					{
						insert_words(*iptr, i0 & (~i), 0);
						return x - *iptr;
					}
				}
			}
			else if (j0 > 51)
			{
				// no fraction part
				Cmp_unsigned__int32 high;
				*iptr = x*one;
				get_high_word(high, x);
				insert_words(x, high & 0x80000000, 0);	// return +-0
				return x;
			}
			else
			{
				// fraction part in low x
				i = ((Cmp_unsigned__int32)(0xffffffff)) >> (j0 - 20);
				if ((i1 & i) == 0)
				{
					// x is integral
					Cmp_unsigned__int32 high;
					*iptr = x;
					get_high_word(high, x);
					insert_words(x, high & 0x80000000, 0); // return +-0
					return x;
				}
				else
				{
					insert_words(*iptr, i0, i1 & (~i));
					return x - *iptr;
				}
			}
		}

		//--------------------------------------------------------------------------------
		inline float modf(float _X, float *_Y)
		{
			double _Di, _Df = modf((double)_X, &_Di);
			*_Y = (float)_Di;
			return ((float)_Df);
		}

		//--------------------------------------------------------------------------------
		CStreamFormatter(CStream* pStream) :
			hexadd(0),
			chW(0),
			chA(0),
			radix(0),
			charsout(0),
			fldwidth(0),
			precision(0),
			prefixlen(0),
			capexp(0),
			no_output(0),
			textlen(0),
			wchar(0),
			achar(0),
			buffersize(0),
			bufferiswide(0),
			saved_formatW(0),
			saved_formatA(0),
			pass(0),							// Ctr for scanning the format string in diff passes
			noofpasses(0),					// Set to 2 for positional formats, otherwise 1
			max_pos(-1),						// Keeping track of the current max positional arg
			type_pos(-1),						// position of an arg denoting a type
			width_pos(-1),					// position of an arg denoting width
			precis_pos(-1),					// position of an arg denoting precision
			format_type(FMT_TYPE_NOTSET),		// type of format string
			heapbuf(0),						// non-zero = test.sz using heap buffer to be freed		
			state(ST_NORMAL),					// starting state
			end_posW(0),
			end_posA(0),
			flags(0),							// flag word -- see above for flag values		
			_ch_buf_used(0)
		{
			m_pStream = pStream;
		}

		void OutputA_State_ST_FLAG(/* char& ch, int& flags */);
		void OutputW_State_ST_FLAG(/* wchar_t& ch, int& flags */);
		void Output_State_ST_PERCENT();
		void OutputA_p_State_ST_NORMAL_2();
		void OutputW_p_State_ST_NORMAL_2();
		bool Output_p_State_ST_NORMAL_1();
		void OutputA_p_State_ST_WIDTH(const char* format, va_list& argptr);
		void OutputW_p_State_ST_WIDTH(const wchar_t* format, va_list& argptr);
		void OutputA_p_State_ST_PRECIS(const char* format, va_list argptr);
		void OutputW_p_State_ST_PRECIS(const wchar_t* format, va_list argptr);
		void OutputA_p_State_ST_SIZE(const char* format);
		void OutputW_p_State_ST_SIZE(const wchar_t* format);
		void OutputA_p_l_State_ST_TYPE( /*nsWin32::CLocaleUpdate& _loc_update,*/ va_list& argptr);
		void OutputW_p_l_State_ST_TYPE( /*nsWin32::CLocaleUpdate& _loc_update,*/ va_list& argptr);

		void Output_State_ST_TYPE_C();
		void OutputA_p_l_State_ST_TYPE_c( /*nsWin32::CLocaleUpdate& _loc_update,*/ va_list argptr);
		void OutputW_p_l_State_ST_TYPE_c( /*nsWin32::CLocaleUpdate& _loc_update,*/ va_list argptr);
		void OutputA_p_State_ST_TYPE_Z(va_list& argptr);
		void OutputW_p_State_ST_TYPE_Z(va_list& argptr);
		void OutputA_p_l_State_ST_TYPE_s( /*nsWin32::CLocaleUpdate& _loc_update,*/ va_list& argptr);
		void OutputW_p_l_State_ST_TYPE_s( /*nsWin32::CLocaleUpdate& _loc_update,*/ va_list& argptr);
		void OutputA_p_l_State_ST_TYPE_n(va_list& argptr);
		void OutputW_p_l_State_ST_TYPE_n(va_list& argptr);
		void OutputA_p_l_State_ST_TYPE_a( /*nsWin32::CLocaleUpdate& _loc_update,*/ va_list& argptr);
		void OutputW_p_l_State_ST_TYPE_a( /*nsWin32::CLocaleUpdate& _loc_update,*/ va_list& argptr);
		void OutputA_p_l_State_ST_TYPE_COMMON_INT(va_list& argptr);
		void OutputW_p_l_State_ST_TYPE_COMMON_INT(va_list& argptr);

		int OutputA_l_State( /*nsWin32::CLocaleUpdate& _loc_update,*/ const char* format/*, CLocaleThreadData* plocinfo*/, bool bSecure, bool bPositionalParams, va_list& argptr);
		int OutputW_p_l_State( /*nsWin32::CLocaleUpdate& _loc_update,*/ const wchar_t* format/*, CLocaleThreadData* plocinfo*/, bool bSecure, bool bPositionalParams, va_list& argptr);
		void OutputA_l_Main( /*nsWin32::CLocaleUpdate& _loc_update,*/ const char* format/*, CLocaleThreadData* plocinfo*/, va_list argptr);
		void OutputW_l_Main( /*nsWin32::CLocaleUpdate& _loc_update,*/ const wchar_t* format/*, CLocaleThreadData* plocinfo*/, va_list argptr);
		void Output_Positonal(va_list argptr);
		int OutputA_l(const char* format/*, CLocaleThreadData* plocinfo*/, va_list argptr);
		int OutputW_l(const wchar_t* format/*, CLocaleThreadData* plocinfo*/, va_list argptr);

		//--------------------------------------------------------------------------------
		void STORE_ARGPTR(positional_param* pos_struct, ARG_TYPE get_fn_type, int& pos, wchar_t& cur_type, int& cur_flags)
		{
			if (pos_struct[pos].arg_type == eblank)
			{
				pos_struct[pos].arg_type = get_fn_type;
				pos_struct[pos].type.wType = cur_type;
				pos_struct[pos].flags = cur_flags;
			}
			else
			{
				//_VALIDATE_RETURN(_tvalidate_param_reuse(&pos_struct[pos], get_fn_type, cur_type, cur_flags), EINVAL, -1);
			}
		}

		//--------------------------------------------------------------------------------
		void STORE_ARGPTRA(positional_param* pos_struct, ARG_TYPE get_fn_type, int& pos, char& cur_type, int& cur_flags)
		{
			if (pos_struct[pos].arg_type == eblank)
			{
				pos_struct[pos].arg_type = get_fn_type;
				pos_struct[pos].type.cType = cur_type;
				pos_struct[pos].flags = cur_flags;
			}
			else
			{
				//_VALIDATE_RETURN(_tvalidate_param_reuse(&pos_struct[pos], get_fn_type, cur_type, cur_flags), EINVAL, -1);
			}
		}

		//--------------------------------------------------------------------------------
		template< typename T > void* get_ptr_arg(T x)
		{
			return PTR_IS_INT ? ((void*)get_int_arg(x)) : (PTR_IS_LONG ? (void*)get_long_arg(x) : (PTR_IS_INT64 ? (void*)get_int64_arg(x) : (void*)-1));
		}

		//--------------------------------------------------------------------------------
		int get_int_arg(va_list* pargptr)
		{
			return va_arg(*pargptr, int);
		}

		//--------------------------------------------------------------------------------
		//#if _INTEGRAL_MAX_BITS >= 64   
		Cmp__int64 get_int64_arg(va_list* pargptr)
		{
			return va_arg(*pargptr, Cmp__int64);
		}
		//#endif  /* _INTEGRAL_MAX_BITS >= 64    */

		//--------------------------------------------------------------------------------
		double get_crtdouble_arg(va_list* pargptr)
		{
			return va_arg(*pargptr, double/*_CRT_DOUBLE*/);
		}

		//void GET_ARG( ARG_TYPE& get_fn_type, va_list& arg_ptr, int lhs/*, type*/)
		//{ 
		//	va_list lst = arg_ptr ;
		//	lhs = /*type*/ get_fn_type( &lst );
		//}

		char* cvt(double arg, int ndigits, int* decpt, int* sign, char* buf, int eflag);
		char* ecvt(double arg, int ndigits, int* decpt, int* sign);
		char* ecvtbuf(double arg, int ndigits, int* decpt, int* sign, char* buf);
		char* fcvt(double arg, int ndigits, int* decpt, int* sign);
		char* fcvtbuf(double arg, int ndigits, int* decpt, int* sign, char* buf);
		void cfltcvt(double value, char* buffer, char fmt, int precision, int capexp);
		void forcdecpt(char* buffer);
		void cropzeros(char* buffer);

		void write_charA(char ch, int* pnumwritten);
		void write_charW(wchar_t ch, int* pnumwritten);
		void write_charA(char ch, CStream* f, int* pnumwritten);
		void write_charW(wchar_t ch, CStream* f, int* pnumwritten);
		void write_multi_charA(char ch, int num, int* pnumwritten);
		void write_multi_charW(wchar_t ch, int num, int* pnumwritten);
		void write_multi_charA(char ch, int num, CStream *f, int *pnumwritten);
		void write_multi_charW(wchar_t ch, int num, CStream *f, int *pnumwritten);
		void write_stringA(char* string, int len, int* pnumwritten);
		void write_stringW(wchar_t* string, int len, int* pnumwritten);
		void write_stringA(char* string, int len, CStream* f, int* pnumwritten);
		void write_stringW(wchar_t* string, int len, CStream* f, int* pnumwritten);

		//int _mbtowc_l( wchar_t* pwc, const char* s, size_t n, CLocaleThreadData* plocinfo );
		wint_t _putwch_nolock(wchar_t ch);
		int _putch_nolock(int c);

		enum CHARTYPE chclass;	// class of current character
		enum STATE state;		// starting state
		wchar_t* end_posW;
		char* end_posA;
		int flags;				// flag word -- see above for flag values		

		int hexadd;				// offset to add to number to get 'a'..'f'
		wchar_t chW;			// character just read		
		char chA;
		int radix;				// current conversion radix
		int charsout;			// characters currently written so far, -1 = IO error
		int fldwidth;			// selected field width -- 0 means default
		int precision;			// selected precision  -- -1 means default
		wchar_t prefixW[2];	// numeric prefix -- up to two characters
		char prefixA[2];		// numeric prefix -- up to two characters
		int prefixlen;			// length of prefix -- 0 means no prefix
		int capexp;				// non-zero = 'E' exponent signifient, zero = 'e'
		int no_output;			// non-zero = prodcue no output for this specifier

		union
		{
			char* sz;			// pointer text to be printed, not zero terminated
			wchar_t* wz;
		} text;

		int textlen;			/* length of the text in bytes/wchars to be printed.
								textlen is in multibyte or wide chars if _UNICODE */
		union
		{
			char sz[BUFFERSIZE];
			wchar_t wz[BUFFERSIZE];
		} buffer;

		wchar_t wchar;			// temp wchar_t
		char achar;				// temp char
		int buffersize;			// size of text.sz (used only for the call to _cfltcvt)
		int bufferiswide;		// non-zero = buffer contains wide chars already

								// Used for parsing the format
		const wchar_t* saved_formatW;
		const char* saved_formatA;

		// This is the structure which stores the values corresponding to each positional param
		positional_param pos_value[100/*NL_ARGMAX*/];

		int pass;						// Ctr for scanning the format string in diff passes
		int noofpasses;					// Set to 2 for positional formats, otherwise 1
		int max_pos;					// Keeping track of the current max positional arg
		int type_pos;					// position of an arg denoting a type
		int width_pos;					// position of an arg denoting width
		int precis_pos;					// position of an arg denoting precision
		int format_type;				// type of format string
		char* heapbuf;					// non-zero = test.sz using heap buffer to be freed

		unsigned char _con_ch_buf[5/*MB_LEN_MAX*/];	// ptr to putch() buffer
		unsigned short _ch_buf_used;				// if the _con_ch_buf is used

		CStream* m_pStream;
	};

}//nsWin32

#endif//WINQL_FILE_STREAMFORMATTER_H_2
