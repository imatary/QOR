//SmallObjectBucket.cpp

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "CodeQOR/MemoryManagement/SmallObjectBucket.h"
#include "CodeQOR/MemoryManagement/ManagedAllocator.h"

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
	//--------------------------------------------------------------------------------
	CSmallObjectBucket::CSmallObjectBucket( Cmp_uint_ptr uiUnitSize ) :
	  m_uiUnitSize( uiUnitSize )
	, m_pLastPage( 0 )
	, m_uiAllocCount( 0 )
	{
	}

	//--------------------------------------------------------------------------------
	CSmallObjectBucket::CSmallObjectBucket( const CSmallObjectBucket& src )
	{
		m_uiUnitSize = src.m_uiUnitSize;
		m_pLastPage = src.m_pLastPage;
		m_uiAllocCount = src.m_uiAllocCount;
	}

	//--------------------------------------------------------------------------------
	CSmallObjectBucket::~CSmallObjectBucket()
	{
	}

	//--------------------------------------------------------------------------------
	Cmp_uint_ptr CSmallObjectBucket::UnitSize( void )
	{
		return m_uiUnitSize;							//Get allocation element size, all allocations in this bucket are this size
	}

	//--------------------------------------------------------------------------------
	bool CSmallObjectBucket::IsEmpty( void )
	{
		return m_PageMap.Size() == 0 ? true : false;	//The bucket is empty if the page map is empty
	}

	//--------------------------------------------------------------------------------
	void CSmallObjectBucket::FreePage( CSmallObjectPage* pCheckPage, unsigned char* pElement )
	{
		t_AddressRange range( reinterpret_cast< Cmp_uint_ptr >( pElement ), 1 );
		CSmallObjectPage* pPage = m_PageMap.Find( range );	//Find the page that contained the address
		if( pCheckPage == pPage )							//Check that it is the one we intend to free
		{
			m_PageMap.Remove( range );						//Remove the map entry
			FastHeap().Free/*< CSmallObjectPage >*/( pPage );	//Free the page
		}
		else
		{
			//throw( "Small Object Heap deletion failure!" );
		}
	}

	//--------------------------------------------------------------------------------
	CSmallObjectPage* CSmallObjectBucket::Page( unsigned char* pElement, Cmp_uint_ptr uiSize )
	{
		CSmallObjectPage* pPage = 0;
		t_AddressRange range( reinterpret_cast< Cmp_uint_ptr >( pElement ), uiSize );
		pPage = m_PageMap.Find( range );												//Find the page containing the item to delete
		if( !pPage )
		{
			//throw( "Small Object Heap, failure to find the page of item to delete." );
		}
		return pPage;																	//Return the page
	}

	//--------------------------------------------------------------------------------
	CSmallObjectPage* CSmallObjectBucket::Page( void )
	{
		CSmallObjectPage* pPage = m_pLastPage;			//try the last used page first
		if( pPage && !pPage->IsFull() )
		{
			return pPage;								//just reuse the last used page
		}
		unsigned long ulIndex = m_PageMap.Size() - 1;	//search the page map backwards
		while( ulIndex != (unsigned long)(-1) )			//from the most recently allocated
		{
			pPage = m_PageMap[ ulIndex ].Second();		//get the page
			if( pPage && !pPage->IsFull() )				//use it if its not full
			{
				m_pLastPage = pPage;					//cache the last accessed page
				return pPage;							//return it
			}
			ulIndex--;									//work down to the first page
		}

		return 0;										//Indicate we didn't find a page to allocate in, a new one will be needed
	}

	//--------------------------------------------------------------------------------
	CSmallObjectPage* CSmallObjectBucket::AddPage()
	{
		Cmp_uint_ptr uiMapWords = 1 + ( m_uiAllocCount / 4096 );								//use larger pages as the bucket grows
		void* pPageMem = FastNew< void >( sizeof( CSmallObjectPage ), __LINE__, __FILE__ );		//allocate memory for the page from the fast heap
		CSmallObjectPage* pPage = new( pPageMem ) CSmallObjectPage( m_uiUnitSize, uiMapWords );	//construct a page object in the allocated memory
		t_Item item( t_AddressRange ( reinterpret_cast< Cmp_uint_ptr >( pPage->Memory() ), m_uiUnitSize * ( uiMapWords * CSmallObjectPage::siWordBits ) ), pPage );
		m_PageMap.Append( item );																//Add an entry to the page map
		m_pLastPage = pPage;																	//cache this page as the last one we dealt with
		return pPage;																			//return the page
	}

	//--------------------------------------------------------------------------------
	void* CSmallObjectBucket::Allocate( Cmp_uint_ptr uiAllocSize )
	{
		CSmallObjectPage* pPage = Page();			//Get a page in which to allocate

		if( pPage == 0 )
		{
			pPage = AddPage();						//Add a new page to the map
		}

		m_uiAllocCount++;							//Increment the count of allocations
		return pPage->Allocate( m_uiUnitSize );		//Allocate withing the page
	}

	//--------------------------------------------------------------------------------
	bool CSmallObjectBucket::Test( void* pElement, Cmp_uint_ptr uiAllocSize )
	{
		bool bResult = false;
		if( pElement )
		{
			CSmallObjectPage* pPage = 0;
			t_AddressRange range( reinterpret_cast< Cmp_uint_ptr >( pElement ), uiAllocSize );
			pPage = m_PageMap.Find( range );												//Find the page containing the item
			if( pPage )
			{
				bResult = true;
			}
		}

		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CSmallObjectBucket::Free( void* pElement, Cmp_uint_ptr uiAllocSize )
	{
		bool bResult = false;
		if( pElement == 0 )			//If there's no element to delete
		{
			bResult = true;			//just succeed immediately
		}
		else
		{
			CSmallObjectPage* pPage = Page( reinterpret_cast< unsigned char* >( pElement ), uiAllocSize );	//Get the Page the element lives in
			if( pPage )
			{
				bResult = pPage->Free( pElement, m_uiUnitSize );											//Free the element within the page
				if( bResult )
				{
					m_uiAllocCount--;																		//Decrement the allocation count
					if( pPage->IsEmpty() )																	//If the page is empty
					{
						if( m_pLastPage == pPage )															//invalidate recent page cache
						{
							m_pLastPage = 0;
						}
						FreePage( pPage, reinterpret_cast< unsigned char* >( pElement ) );					//Free the page
					}
				}
				else
				{
					//throw( "Small Object Bucket, failed free within page" );
				}
			}
			else
			{
				//throw( "Small Object Bucket, failure to find page for free" );
			}
		}

		return bResult;
	}

	//--------------------------------------------------------------------------------
	void CSmallObjectBucket::Analyse( void(*pTrace)( char* ) )
	{
	}

}//nsCodeQOR

