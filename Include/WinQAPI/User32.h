//User32.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef WINQAPI_USER32_H_1
#define WINQAPI_USER32_H_1

#include "WinQAPI/Kernel32.h"
#include "../Source/SystemQOR/MSWindows/WinQAPI/include/DynamicLibrary.h"

#if	( WINVER < 0x0600 )
#	define UOI_HEAPSIZE    5
#	define UOI_IO          6
#endif

#ifndef		__MINGW32__
#	ifndef WINEVENTPROC
		typedef VOID (CALLBACK* WINEVENTPROC)( HWINEVENTHOOK hWinEventHook, DWORD dwEvent, HWND hwnd, LONG idObject, LONG idChild, DWORD idEventThread, DWORD dwmsEventTime );
#	endif//WINEVENTPROC
#endif	//__MINGW32__

#if	( WINVER < 0x0500 )
#	define EDD_GET_DEVICE_INTERFACE_NAME 0x00000001
#endif

#if (_WIN32_WINNT < 0x0502)
	typedef  PVOID           HPOWERNOTIFY;
	typedef  HPOWERNOTIFY   *PHPOWERNOTIFY;
#endif

#if (_WIN32_WINDOWS < 0x0410 || _WIN32_WINNT < 0x0500 )
#	ifndef tagALTTABINFO //It turns up in NT4 SP6
		typedef struct tagALTTABINFO
		{
			DWORD cbSize;
			int cItems;
			int cColumns;
			int cRows;
			int iColFocus;
			int iRowFocus;
			int cxItem;
			int cyItem;
			POINT ptStart;
		} ALTTABINFO, *PALTTABINFO, *LPALTTABINFO;

		typedef struct tagCOMBOBOXINFO
		{
			DWORD cbSize;
			RECT rcItem;
			RECT rcButton;
			DWORD stateButton;
			HWND hwndCombo;
			HWND hwndItem;
			HWND hwndList;
		} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;

#		define CCHILDREN_TITLEBAR              5
#		define CCHILDREN_SCROLLBAR				5

		typedef struct tagTITLEBARINFO
		{
			DWORD cbSize;
			RECT rcTitleBar;
			DWORD rgstate[CCHILDREN_TITLEBAR + 1];
		} TITLEBARINFO, *PTITLEBARINFO, *LPTITLEBARINFO;

		typedef struct tagWINDOWINFO
		{
			DWORD cbSize;
			RECT rcWindow;
			RECT rcClient;
			DWORD dwStyle;
			DWORD dwExStyle;
			DWORD dwWindowStatus;
			UINT cxWindowBorders;
			UINT cyWindowBorders;
			ATOM atomWindowType;
			WORD wCreatorVersion;
		} WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO;

		typedef struct tagSCROLLBARINFO
		{
			DWORD cbSize;
			RECT rcScrollBar;
			int dxyLineButton;
			int xyThumbTop;
			int xyThumbBottom;
			int reserved;
			DWORD rgstate[CCHILDREN_SCROLLBAR + 1];
		} SCROLLBARINFO, *PSCROLLBARINFO, *LPSCROLLBARINFO;

		typedef struct tagMENUBARINFO
		{
			DWORD cbSize;
			RECT rcBar;          // rect of bar, popup, item
			HMENU hMenu;         // real menu handle of bar, popup
			HWND hwndMenu;       // hwnd of item submenu if one
			BOOL fBarFocused:1;  // bar, popup has the focus
			BOOL fFocused:1;     // item has the focus
		} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;

		typedef struct tagCURSORINFO
		{
			DWORD   cbSize;
			DWORD   flags;
			HCURSOR hCursor;
			POINT   ptScreenPos;
		} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;

#	endif
#	ifndef tagGUITHREADINFO //It turns up in NT4 SP3
		typedef struct tagGUITHREADINFO
		{
			DWORD   cbSize;
			DWORD   flags;
			HWND    hwndActive;
			HWND    hwndFocus;
			HWND    hwndCapture;
			HWND    hwndMenuOwner;
			HWND    hwndMoveSize;
			HWND    hwndCaret;
			RECT    rcCaret;
		} GUITHREADINFO, *PGUITHREADINFO, FAR * LPGUITHREADINFO;
#	endif

	typedef struct tagMENUINFO
	{
		DWORD   cbSize;
		DWORD   fMask;
		DWORD   dwStyle;
		UINT    cyMax;
		HBRUSH  hbrBack;
		DWORD   dwContextHelpID;
		ULONG_PTR dwMenuData;
	}   MENUINFO, FAR *LPMENUINFO;
	typedef MENUINFO CONST FAR *LPCMENUINFO;

#endif

#if (_WIN32_WINDOWS <= 0x0410 && _WIN32_WINNT < 0x0400 )
	typedef struct 
	{  
		UINT cbSize;
		HWND hwnd;
		DWORD dwFlags;
		UINT uCount;
		DWORD dwTimeout;
	} FLASHWINFO,  *PFLASHWINFO;

	typedef struct tagTRACKMOUSEEVENT 
	{
		DWORD cbSize;
		DWORD dwFlags;
		HWND  hwndTrack;
		DWORD dwHoverTime;
	} TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;

//define these so that CommCtrl.h will not try to redef tagTRACKMOUSEEVENT
#	define TME_HOVER       0x00000001
#	define TME_LEAVE       0x00000002
#	if ( WINVER >= 0x0500 )
#		define TME_NONCLIENT   0x00000010
#	endif /* WINVER >= 0x0500 */
#	define TME_QUERY       0x40000000
#	define TME_CANCEL      0x80000000
#	define HOVER_DEFAULT   0xFFFFFFFF

#endif

#if ( _WIN32_WINNT <= 0x0400 )

	typedef struct tagMOUSEINPUT 
	{
		LONG    dx;
		LONG    dy;
		DWORD   mouseData;
		DWORD   dwFlags;
		DWORD   time;
		ULONG_PTR dwExtraInfo;
	} MOUSEINPUT, *PMOUSEINPUT, FAR* LPMOUSEINPUT;

	typedef struct tagKEYBDINPUT 
	{
		WORD    wVk;
		WORD    wScan;
		DWORD   dwFlags;
		DWORD   time;
		ULONG_PTR dwExtraInfo;
	} KEYBDINPUT, *PKEYBDINPUT, FAR* LPKEYBDINPUT;

	typedef struct tagHARDWAREINPUT 
	{
		DWORD   uMsg;
		WORD    wParamL;
		WORD    wParamH;
	} HARDWAREINPUT, *PHARDWAREINPUT, FAR* LPHARDWAREINPUT;

	#define INPUT_MOUSE     0
	#define INPUT_KEYBOARD  1
	#define INPUT_HARDWARE  2

	typedef struct tagINPUT 
	{
		DWORD   type;
		union
		{
			MOUSEINPUT      mi;
			KEYBDINPUT      ki;
			HARDWAREINPUT   hi;
		} DUMMYUNIONNAME;
	} INPUT, *PINPUT, FAR* LPINPUT;
#endif

#if( WINVER < 0x0500 )
	DECLARE_HANDLE(HMONITOR);
	typedef  PVOID	HDEVNOTIFY;

	typedef struct tagLASTINPUTINFO 
	{
		UINT cbSize;
		DWORD dwTime;
	} LASTINPUTINFO, * PLASTINPUTINFO;

	typedef struct tagMOUSEMOVEPOINT {
		int   x;
		int   y;
		DWORD time;
		ULONG_PTR dwExtraInfo;
	} MOUSEMOVEPOINT, *PMOUSEMOVEPOINT, FAR* LPMOUSEMOVEPOINT;

	typedef struct tagUPDATELAYEREDWINDOWINFO
	{
		DWORD               cbSize;
		HDC                 hdcDst;
		POINT CONST*		pptDst;
		SIZE CONST*			psize;
		HDC                 hdcSrc;
		POINT CONST*		pptSrc;
		COLORREF            crKey;
		BLENDFUNCTION CONST*	pblend;
		DWORD               dwFlags;
		RECT CONST*			prcDirty;
	} UPDATELAYEREDWINDOWINFO, *PUPDATELAYEREDWINDOWINFO;

#endif

#ifdef __MINGW32__
	typedef struct tagUPDATELAYEREDWINDOWINFO
	{
		DWORD               cbSize;
		HDC                 hdcDst;
		POINT CONST*		pptDst;
		SIZE CONST*			psize;
		HDC                 hdcSrc;
		POINT CONST*		pptSrc;
		COLORREF            crKey;
		BLENDFUNCTION CONST*	pblend;
		DWORD               dwFlags;
		RECT CONST*			prcDirty;
	} UPDATELAYEREDWINDOWINFO, *PUPDATELAYEREDWINDOWINFO;
#endif//__MINGW32__

#if ( _WIN32_WINDOWS < 0x0500 || _WIN32_WINNT == 0x0400 )
	typedef BOOL( CALLBACK* MONITORENUMPROC )( HMONITOR , HDC , LPRECT , LPARAM );
	typedef struct tagMONITORINFO
	{
		DWORD   cbSize;
		RECT    rcMonitor;
		RECT    rcWork;
		DWORD   dwFlags;
	} MONITORINFO, *LPMONITORINFO;
#endif

#if ( _WIN32_WINNT < 0x0501 )

	typedef struct 
	{
		UINT  cbSize;
		HDESK hdesk;
		HWND  hwnd;
		LUID  luid;
	} BSMINFO, *PBSMINFO;

	DECLARE_HANDLE(HRAWINPUT);

	//Raw Input data header
	 
	typedef struct tagRAWINPUTHEADER 
	{
		DWORD dwType;
		DWORD dwSize;
		HANDLE hDevice;
		WPARAM wParam;
	} RAWINPUTHEADER, *PRAWINPUTHEADER, *LPRAWINPUTHEADER;

	typedef struct tagRAWINPUTDEVICELIST 
	{
		HANDLE hDevice;
		DWORD dwType;
	} RAWINPUTDEVICELIST, *PRAWINPUTDEVICELIST;

	//Raw Input request APIs
	 
	typedef struct tagRAWINPUTDEVICE 
	{
		USHORT usUsagePage; // Toplevel collection UsagePage
		USHORT usUsage;     // Toplevel collection Usage
		DWORD dwFlags;
		HWND hwndTarget;    // Target hwnd. NULL = follows keyboard focus
	} RAWINPUTDEVICE, *PRAWINPUTDEVICE, *LPRAWINPUTDEVICE;

	typedef CONST RAWINPUTDEVICE* PCRAWINPUTDEVICE;

	//Raw format of the mouse input
	 
	typedef struct tagRAWMOUSE 
	{
		//Indicator flags.
		 
		USHORT usFlags;

		//The transition state of the mouse buttons.
		 
		union tagRAWMOUSEunion_anon1
		{
			ULONG ulButtons;
			struct tagRAWMOUSEstruct_anon1
			{
				USHORT  usButtonFlags;
				USHORT  usButtonData;
			} DUMMYSTRUCTNAME;
		} DUMMYUNIONNAME;


		//The raw state of the mouse buttons.
		 
		ULONG ulRawButtons;

		//The signed relative or absolute motion in the X direction.
		 
		LONG lLastX;

		//The signed relative or absolute motion in the Y direction.
		 
		LONG lLastY;

		//Device-specific additional information for the event.
		 
		ULONG ulExtraInformation;

	} RAWMOUSE, *PRAWMOUSE, *LPRAWMOUSE;

	typedef struct tagRAWKEYBOARD 
	{
		//The "make" scan code (key depression).
		 
		USHORT MakeCode;

		//The flags field indicates a "break" (key release) and other
		// miscellaneous scan code information defined in ntddkbd.h.
		 
		USHORT Flags;

		USHORT Reserved;

		//Windows message compatible information
		 
		USHORT VKey;
		UINT   Message;

		//Device-specific additional information for the event.
		 
		ULONG ExtraInformation;


	} RAWKEYBOARD, *PRAWKEYBOARD, *LPRAWKEYBOARD;

	//Raw format of the input from Human Input Devices
	 
	typedef struct tagRAWHID 
	{
		DWORD dwSizeHid;    // byte size of each report
		DWORD dwCount;      // number of input packed
		BYTE bRawData[1];
	} RAWHID, *PRAWHID, *LPRAWHID;

	typedef struct tagRAWINPUT 
	{
		RAWINPUTHEADER header;
		union 
		{
			RAWMOUSE    mouse;
			RAWKEYBOARD keyboard;
			RAWHID      hid;
		} data;
	} RAWINPUT, *PRAWINPUT, *LPRAWINPUT;
#endif

#if( _WIN32_WINNT < 0x0600 )

	typedef struct _ICONINFOEXA 
	{
		DWORD   cbSize;
		BOOL    fIcon;
		DWORD   xHotspot;
		DWORD   yHotspot;
		HBITMAP hbmMask;
		HBITMAP hbmColor;
		WORD    wResID;
		CHAR    szModName[MAX_PATH];
		CHAR    szResName[MAX_PATH];
	} ICONINFOEXA, *PICONINFOEXA;

	typedef struct _ICONINFOEXW 
	{
		DWORD   cbSize;
		BOOL    fIcon;
		DWORD   xHotspot;
		DWORD   yHotspot;
		HBITMAP hbmMask;
		HBITMAP hbmColor;
		WORD    wResID;
		WCHAR   szModName[MAX_PATH];
		WCHAR   szResName[MAX_PATH];
	} ICONINFOEXW, *PICONINFOEXW;
#	ifdef UNICODE
		typedef ICONINFOEXW ICONINFOEX;
		typedef PICONINFOEXW PICONINFOEX;
#	else
		typedef ICONINFOEXA ICONINFOEX;
		typedef PICONINFOEXA PICONINFOEX;
#	endif // UNICODE
#endif//( _WIN32_WINNT < 0x0600 )

#ifdef __MINGW32__
#if( _WIN32_WINNT >= 0x0600 )
	typedef struct _ICONINFOEXA
	{
		DWORD   cbSize;
		BOOL    fIcon;
		DWORD   xHotspot;
		DWORD   yHotspot;
		HBITMAP hbmMask;
		HBITMAP hbmColor;
		WORD    wResID;
		CHAR    szModName[MAX_PATH];
		CHAR    szResName[MAX_PATH];
	} ICONINFOEXA, *PICONINFOEXA;

	typedef struct _ICONINFOEXW
	{
		DWORD   cbSize;
		BOOL    fIcon;
		DWORD   xHotspot;
		DWORD   yHotspot;
		HBITMAP hbmMask;
		HBITMAP hbmColor;
		WORD    wResID;
		WCHAR   szModName[MAX_PATH];
		WCHAR   szResName[MAX_PATH];
	} ICONINFOEXW, *PICONINFOEXW;
#	ifdef UNICODE
		typedef ICONINFOEXW ICONINFOEX;
		typedef PICONINFOEXW PICONINFOEX;
#	else
		typedef ICONINFOEXA ICONINFOEX;
		typedef PICONINFOEXA PICONINFOEX;
#	endif // UNICODE
#endif//( _WIN32_WINNT >= 0x0600 )
	typedef BOOL (__QCMP_STDCALLCONVENTION* DESKTOPENUMPROC)(LPTSTR, LPARAM);

#endif//__MINGW32__
//--------------------------------------------------------------------------------
namespace nsWinQAPI
{
	//Updated to be complete with Windows Server 2008 Build 6001 System32\User32.dll

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQAPI ) CUser32 : public CDll
	{
	public:

		//--------------------------------------------------------------------------------
		CUser32() : CDll( TEXT("user32.dll") )
		{						
		}

		//--------------------------------------------------------------------------------
		static CUser32& Instance( void )
		{
			static CUser32 _instance;
			return _instance;
		}

		//--------------------------------------------------------------------------------
		~CUser32()
		{						
		}

		//--------------------------------------------------------------------------------
		//Keyboard Input functions
		HKL ActivateKeyboardLayout( HKL hkl, UINT Flags );
		BOOL BlockInput( BOOL fBlockIt );
		BOOL EnableWindow( HWND hWnd, BOOL bEnable );
		HWND GetActiveWindow( void );
		SHORT GetAsyncKeyState( int vKey );
		HWND GetFocus(void);
		UINT GetKBCodePage();
		HKL GetKeyboardLayout( DWORD idThread );
		UINT GetKeyboardLayoutList( int nBuff, HKL* lpList );
		BOOL GetKeyboardLayoutName( LPTSTR pwszKLID );
		BOOL GetKeyboardState( PBYTE lpKeyState );
		int GetKeyboardType( int nTypeFlag );
		int GetKeyNameText( LONG lParam, LPTSTR lpString, int nSize );
		SHORT GetKeyState( int nVirtKey );
		BOOL GetLastInputInfo( PLASTINPUTINFO plii );
		BOOL IsWindowEnabled( HWND hWnd );
		VOID keybd_event( BYTE bVk, BYTE bScan, DWORD dwFlags, void* dwExtraInfo );
		HKL LoadKeyboardLayout( LPCTSTR pwszKLID, UINT Flags );
		UINT MapVirtualKey( UINT uCode, UINT uMapType );
		UINT MapVirtualKeyEx( UINT uCode, UINT uMapType, HKL dwhkl );
		DWORD OemKeyScan( WORD wOemChar );
		BOOL RegisterHotKey( HWND hWnd, int id, UINT fsModifiers, UINT vk );
		UINT SendInput( UINT nInputs, LPINPUT pInputs, int cbSize );
		HWND SetActiveWindow( HWND hWnd );
		HWND SetFocus( HWND hWnd );
		BOOL SetKeyboardState( LPBYTE lpKeyState );
		int ToAscii( UINT uVirtKey, UINT uScanCode, PBYTE lpKeyState, LPWORD lpChar, UINT uFlags );
		int ToAsciiEx( UINT uVirtKey, UINT uScanCode, PBYTE lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl );
		int ToUnicode( UINT wVirtKey, UINT wScanCode, const PBYTE lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags );
		int ToUnicodeEx( UINT wVirtKey, UINT wScanCode, const PBYTE lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl );
		BOOL UnloadKeyboardLayout( HKL hkl );
		BOOL UnregisterHotKey( HWND hWnd, int id );
		SHORT VkKeyScan( TCHAR ch );
		SHORT VkKeyScanEx( TCHAR ch, HKL dwhkl );
		//--------------------------------------------------------------------------------
		//Clipboard functions
		BOOL AddClipboardFormatListener( HWND hwnd );
		BOOL ChangeClipboardChain( HWND hWndRemove, HWND hWndNewNext );
		BOOL CloseClipboard();
		int CountClipboardFormats();
		BOOL EmptyClipboard(void);
		UINT EnumClipboardFormats( UINT format );
		HANDLE GetClipboardData( UINT uFormat );
		int GetClipboardFormatName( UINT format, LPTSTR lpszFormatName, int cchMaxCount );
		HWND GetClipboardOwner(void);
		DWORD GetClipboardSequenceNumber(void);
		HWND GetClipboardViewer(void);
		HWND GetOpenClipboardWindow();
		int GetPriorityClipboardFormat( UINT* paFormatPriorityList, int cFormats );
		BOOL GetUpdatedClipboardFormats( PUINT lpuiFormats, UINT cFormats, PUINT pcFormatsOut );
		BOOL IsClipboardFormatAvailable( UINT format );
		BOOL OpenClipboard( HWND hWndNewOwner );
		UINT RegisterClipboardFormat( LPCTSTR lpszFormat );
		BOOL RemoveClipboardFormatListener( HWND hwnd );
		HANDLE SetClipboardData( UINT uFormat, HANDLE hMem );
		HWND SetClipboardViewer( HWND hWndNewViewer );
		//--------------------------------------------------------------------------------
		//Window functions
		BOOL AdjustWindowRect( ::LPRECT lpRect, DWORD dwStyle, BOOL bMenu );
		BOOL AdjustWindowRectEx( ::LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle );
		BOOL AllowSetForegroundWindow( DWORD dwProcessId );
		BOOL AnimateWindow( HWND hwnd, DWORD dwTime, DWORD dwFlags );
		BOOL AnyPopup(void);
		UINT ArrangeIconicWindows( HWND hWnd );
		HDWP BeginDeferWindowPos( int nNumWindows );
		BOOL BringWindowToTop( HWND hWnd );
		WORD CascadeChildWindows( HWND hWndParent, WORD wFlags );
		WORD CascadeWindows( HWND hwndParent, UINT wHow, const ::RECT* lpRect, UINT cKids, const HWND* lpKids );
		BOOL ChangeWindowMessageFilter( UINT message, DWORD dwFlag );
		HWND ChildWindowFromPoint( HWND hWndParent, ::POINT Point );
		HWND ChildWindowFromPointEx( HWND hwndParent, ::POINT pt, UINT uFlags );
		BOOL CloseWindow( HWND hWnd );
		HWND mxCreateWindow( LPCTSTR lpClassName, LPCTSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam );
		HWND CreateWindowEx( DWORD dwExStyle, LPCTSTR lpClassName, LPCTSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam );
		HDWP DeferWindowPos( HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags );
		BOOL DeregisterShellHookWindow( HWND hWnd );
		BOOL DestroyWindow( HWND hWnd );
		BOOL EndDeferWindowPos( HDWP hWinPosInfo );
		BOOL EndTask( HWND hWnd, BOOL fShutDown, BOOL fForce );
		BOOL EnumChildWindows( HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam );
		BOOL EnumThreadWindows( DWORD dwThreadId, WNDENUMPROC lpfn, LPARAM lParam );
		BOOL EnumWindows( WNDENUMPROC lpEnumFunc, LPARAM lParam );
		HWND FindWindow( LPCTSTR lpClassName, LPCTSTR lpWindowName );
		HWND FindWindowEx( HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpszClass, LPCTSTR lpszWindow );
		BOOL GetAltTabInfo( HWND hwnd, int iItem, ::PALTTABINFO pati, LPTSTR pszItemText, UINT cchItemText );
		HWND GetAncestor( HWND hwnd, UINT gaFlags );
		BOOL GetClientRect( HWND hWnd, ::LPRECT lpRect );
		HWND GetDesktopWindow(void);
		HWND GetForegroundWindow(void);
		BOOL GetGUIThreadInfo( DWORD idThread, ::LPGUITHREADINFO lpgui );
		HWND GetLastActivePopup( HWND hWnd );
		BOOL GetLayeredWindowAttributes( HWND hwnd, COLORREF* pcrKey, BYTE* pbAlpha, DWORD* pdwFlags );
		HWND GetParent( HWND hWnd );
		BOOL GetProcessDefaultLayout( DWORD* pdwDefaultLayout );
		HWND GetShellWindow(void);
		BOOL GetTitleBarInfo( HWND hwnd, ::PTITLEBARINFO pti );
		HWND GetTopWindow( HWND hWnd );
		HWND GetWindow( HWND hWnd, UINT uCmd );
		BOOL GetWindowInfo( HWND hwnd, ::PWINDOWINFO pwi );
		UINT GetWindowModuleFileName( HWND hwnd, LPTSTR lpszFileName, UINT cchFileNameMax );
		BOOL GetWindowPlacement( HWND hWnd, ::WINDOWPLACEMENT* lpwndpl );
		BOOL GetWindowRect( HWND hWnd, ::LPRECT lpRect );
		int GetWindowText( HWND hWnd, LPTSTR lpString, int nMaxCount );
		int GetWindowTextLength( HWND hWnd );
		DWORD GetWindowThreadProcessId( HWND hWnd, LPDWORD lpdwProcessId );
		int InternalGetWindowText( HWND hWnd, LPWSTR lpString, int nMaxCount );
		BOOL IsChild( HWND hWndParent, HWND hWnd );
		BOOL IsGUIThread( BOOL bConvert );
		BOOL IsHungAppWindow( HWND hWnd );
		BOOL IsIconic( HWND hWnd );
		BOOL IsProcessDPIAware(void);
		BOOL IsWindow( HWND hWnd );
		BOOL IsWindowUnicode( HWND hWnd );
		BOOL IsWindowVisible( HWND hWnd );
		BOOL IsZoomed( HWND hWnd );
		BOOL LockSetForegroundWindow( UINT uLockCode );
		void LogicalToPhysicalPoint( HWND hWnd, ::LPPOINT lpPoint );
		BOOL MoveWindow( HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint );
		BOOL OpenIcon( HWND hWnd );
		void PhysicalToLogicalPoint( HWND hWnd, ::LPPOINT lpPoint );
		HWND RealChildWindowFromPoint( HWND hwndParent, ::POINT ptParentClientCoords );
		UINT RealGetWindowClass( HWND hwnd, LPTSTR pszType, UINT cchType );
		BOOL RegisterShellHookWindow( HWND hWnd );
		BOOL SetForegroundWindow( HWND hWnd );
		BOOL SetLayeredWindowAttributes( HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags );
		HWND SetParent( HWND hWndChild, HWND hWndNewParent );
		BOOL SetProcessDefaultLayout( DWORD dwDefaultLayout );
		BOOL SetProcessDPIAware(void);
		BOOL SetWindowPlacement( HWND hWnd, ::WINDOWPLACEMENT* lpwndpl );
		BOOL SetWindowPos( HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags );
		BOOL SetWindowText( HWND hWnd, LPCTSTR lpString );
		BOOL ShowOwnedPopups( HWND hWnd, BOOL fShow );
		BOOL ShowWindow( HWND hWnd, int nCmdShow );
		BOOL ShowWindowAsync( HWND hWnd, int nCmdShow );
		BOOL SoundSentry(void);
		void SwitchToThisWindow( HWND hWnd, BOOL fAltTab );
		WORD TileWindows( HWND hwndParent, UINT wHow, ::RECT* lpRect, UINT cKids, const HWND* lpKids );
		BOOL UpdateLayeredWindow( HWND hwnd, HDC hdcDst, ::POINT* pptDst, ::SIZE* psize, HDC hdcSrc, ::POINT* pptSrc, COLORREF crKey, ::BLENDFUNCTION* pblend, DWORD dwFlags );
		BOOL UpdateLayeredWindowIndirect( HWND hwnd, const ::UPDATELAYEREDWINDOWINFO* pULWInfo );
		HWND WindowFromPhysicalPoint( ::POINT Point );
		HWND WindowFromPoint( ::POINT Point );

		//--------------------------------------------------------------------------------
		//Menu functions
		BOOL AppendMenu( HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCTSTR lpNewItem );
		DWORD CheckMenuItem( HMENU hmenu, UINT uIDCheckItem, UINT uCheck );
		BOOL CheckMenuRadioItem( HMENU hmenu, UINT idFirst, UINT idLast, UINT idCheck, UINT uFlags );
		HMENU CreateMenu(void);
		HMENU CreatePopupMenu(void);
		BOOL DeleteMenu( HMENU hMenu, UINT uPosition, UINT uFlags );
		BOOL DestroyMenu( HMENU hMenu );
		BOOL DrawMenuBar( HWND hWnd );
		BOOL EnableMenuItem( HMENU hMenu, UINT uIDEnableItem, UINT uEnable );
		BOOL EndMenu(void);
		HMENU GetMenu( HWND hWnd );
		BOOL GetMenuBarInfo( HWND hwnd, LONG idObject, LONG idItem, PMENUBARINFO pmbi );
		LONG GetMenuCheckMarkDimensions(void);
		UINT GetMenuDefaultItem( HMENU hMenu, UINT fByPos, UINT gmdiFlags );
		BOOL GetMenuInfo( HMENU hmenu, ::LPCMENUINFO lpcmi );
		int GetMenuItemCount( HMENU hMenu );
		UINT GetMenuItemID( HMENU hMenu, int nPos );
		BOOL GetMenuItemInfo( HMENU hMenu, UINT uItem, BOOL fByPosition, LPMENUITEMINFO lpmii );
		BOOL GetMenuItemRect( HWND hWnd, HMENU hMenu, UINT uItem, ::LPRECT lprcItem );
		UINT GetMenuState( HMENU hMenu, UINT uId, UINT uFlags );
		int GetMenuString( HMENU hMenu, UINT uIDItem, LPTSTR lpString, int nMaxCount, UINT uFlag );
		HMENU GetSubMenu( HMENU hMenu, int nPos );
		HMENU GetSystemMenu( HWND hWnd, BOOL bRevert );
		BOOL HiliteMenuItem( HWND hwnd, HMENU hmenu, UINT uItemHilite, UINT uHilite );
		BOOL InsertMenu( HMENU hMenu, UINT uPosition, UINT uFlags, void* uIDNewItem, LPCTSTR lpNewItem );
		BOOL InsertMenuItem( HMENU hMenu, UINT uItem, BOOL fByPosition, LPCMENUITEMINFO lpmii );
		BOOL IsMenu( HMENU hMenu );
		HMENU LoadMenu( HINSTANCE hInstance, LPCTSTR lpMenuName );
		HMENU LoadMenuIndirect( CONST MENUTEMPLATE* lpMenuTemplate );
		int MenuItemFromPoint( HWND hWnd, HMENU hMenu, POINT ptScreen );
		BOOL ModifyMenu( HMENU hMenu, UINT uPosition, UINT uFlags, void* uIDNewItem, LPCTSTR lpNewItem );
		BOOL RemoveMenu( HMENU hMenu, UINT uPosition, UINT uFlags );
		BOOL SetMenu( HWND hWnd, HMENU hMenu );
		BOOL SetMenuDefaultItem( HMENU hMenu, UINT uItem, UINT fByPos );
		BOOL SetMenuInfo( HMENU hmenu, ::LPCMENUINFO lpcmi );
		BOOL SetMenuItemBitmaps( HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked );
		BOOL SetMenuItemInfo( HMENU hMenu, UINT uItem, BOOL fByPosition, LPMENUITEMINFO lpmii );
		BOOL TrackPopupMenu( HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, HWND prcRect );
		BOOL TrackPopupMenuEx( HMENU hmenu, UINT fuFlags, int x, int y, HWND hwnd, ::LPTPMPARAMS lptpm );
		//--------------------------------------------------------------------------------
		//Process and Thread functions
		BOOL AttachThreadInput( DWORD idAttach, DWORD idAttachTo, BOOL fAttach );
		DWORD GetGuiResources( HANDLE hProcess, DWORD uiFlags );
		BOOL IsWow64Message(void);
		BOOL UserHandleGrantAccess( HANDLE hUserHandle, HANDLE hJob, BOOL bGrant );
		DWORD WaitForInputIdle( HANDLE hProcess, DWORD dwMilliseconds );
		//--------------------------------------------------------------------------------
		//Painting functions
		HDC BeginPaint( HWND hwnd, ::LPPAINTSTRUCT lpPaint );
		BOOL DrawAnimatedRects( HWND hwnd, int idAni, CONST ::RECT* lprcFrom, CONST ::RECT* lprcTo );
		BOOL DrawCaption( HWND hwnd, HDC hdc, ::LPCRECT lprc, UINT uFlags );
		BOOL DrawEdge( HDC hdc, ::LPRECT qrc, UINT edge, UINT grfFlags );
		BOOL DrawFocusRect( HDC hDC, CONST ::RECT* lprc );
		BOOL DrawFrameControl( HDC hdc, ::LPRECT lprc, UINT uType, UINT uState );
		BOOL DrawState( HDC hdc, HBRUSH hbr, ::DRAWSTATEPROC lpOutputFunc, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT fuFlags );
		BOOL EndPaint( HWND hWnd, CONST ::PAINTSTRUCT* lpPaint );
		int ExcludeUpdateRgn( HDC hDC, HWND hWnd );
		BOOL GetUpdateRect( HWND hWnd, ::LPRECT lpRect, BOOL bErase );
		int GetUpdateRgn( HWND hWnd, HRGN hRgn, BOOL bErase );
		HDC GetWindowDC( HWND hWnd );
		int GetWindowRgn( HWND hWnd, HRGN hRgn );
		int GetWindowRgnBox( HWND hWnd, ::LPRECT lprc );
		BOOL GrayString( HDC hDC, HBRUSH hBrush, ::GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight );
		BOOL InvalidateRect( HWND hWnd, CONST ::RECT* lpRect, BOOL bErase );
		BOOL InvalidateRgn( HWND hWnd, HRGN hRgn, BOOL bErase );
		BOOL LockWindowUpdate( HWND hWndLock );
		BOOL PaintDesktop( HDC hdc );
		BOOL RedrawWindow( HWND hWnd, CONST ::RECT* lprcUpdate, HRGN hrgnUpdate, UINT flags );
		int SetWindowRgn( HWND hWnd, HRGN hRgn, BOOL bRedraw );
		BOOL UpdateWindow( HWND hWnd );
		BOOL ValidateRect( HWND hWnd, CONST ::RECT* lpRect );
		BOOL ValidateRgn( HWND hWnd, HRGN hRgn );
		HWND WindowFromDC( HDC hDC );
		//--------------------------------------------------------------------------------
		//Message and Message Queue functions
		long BroadcastSystemMessage( DWORD dwFlags, LPDWORD lpdwRecipients, UINT uiMessage, WPARAM wParam, LPARAM lParam );
		long BroadcastSystemMessageExA( DWORD dwFlags, LPDWORD lpdwRecipients, UINT uiMessage, WPARAM wParam, LPARAM lParam, ::PBSMINFO pBSMInfo );
		long BroadcastSystemMessageExW( DWORD dwFlags, LPDWORD lpdwRecipients, UINT uiMessage, WPARAM wParam, LPARAM lParam, ::PBSMINFO pBSMInfo );
		LRESULT DispatchMessage( const MSG* lpmsg );
		BOOL GetInputState(void);
		BOOL GetMessage( LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax );
		LPARAM GetMessageExtraInfo(void);
		DWORD GetMessagePos(void);
		LONG GetMessageTime(void);
		DWORD GetQueueStatus( UINT flags );
		BOOL InSendMessage(void);
		DWORD InSendMessageEx( LPVOID lpReserved );
		BOOL PeekMessage( LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg );
		BOOL PostMessage( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam );
		void PostQuitMessage( int nExitCode );
		BOOL PostThreadMessage( DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam );
		UINT RegisterWindowMessage( LPCTSTR lpString );
		BOOL ReplyMessage( LRESULT lResult );
		BOOL SendMessageCallbackA( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, ::SENDASYNCPROC lpCallBack, ULONG_PTR dwData );
		BOOL SendMessageCallbackW( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, ::SENDASYNCPROC lpCallBack, ULONG_PTR dwData );
		LRESULT SendMessageTimeout( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult );
		LRESULT SendMessage( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam );
		BOOL SendNotifyMessage( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam );
		LPARAM SetMessageExtraInfo( LPARAM lParam );
		BOOL TranslateMessage( const MSG* lpMsg );
		BOOL WaitMessage(void);

		//--------------------------------------------------------------------------------
		//Hook functions
		BOOL CallMsgFilter( LPMSG lpMsg, int nCode );
		LRESULT CallNextHookEx( HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam );
		HHOOK SetWindowsHookEx( int idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId );
		BOOL UnhookWindowsHookEx( HHOOK hhk );
		//--------------------------------------------------------------------------------
		//Window Procedure functions
		LRESULT CallWindowProc( WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam );
		LRESULT DefWindowProc( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam );
		//--------------------------------------------------------------------------------
		//DC functions
		LONG ChangeDisplaySettings( ::LPDEVMODE lpDevMode, DWORD dwflags );
		LONG ChangeDisplaySettingsEx( LPCTSTR lpszDeviceName, ::LPDEVMODE lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam );
		BOOL EnumDisplayDevices( LPCTSTR lpDevice, DWORD iDevNum, ::PDISPLAY_DEVICE lpDisplayDevice, DWORD dwFlags );
		BOOL EnumDisplaySettings( LPCTSTR lpszDeviceName, DWORD iModeNum, ::LPDEVMODE lpDevMode );
		BOOL EnumDisplaySettingsEx( LPCTSTR lpszDeviceName, DWORD iModeNum, ::LPDEVMODE lpDevMode, DWORD dwFlags );
		HDC GetDC( HWND hWnd );
		HDC GetDCEx( HWND hWnd, HRGN hrgnClip, DWORD flags );
		int ReleaseDC( HWND hWnd, HDC hDC );
		//--------------------------------------------------------------------------------
		//String functions
		LPSTR CharLowerA( LPSTR lpsz );
		LPWSTR CharLowerW( LPWSTR lpwsz );
		DWORD CharLowerBuffA( LPSTR lpsz, DWORD cchLength );
		DWORD CharLowerBuffW( LPWSTR lpwsz, DWORD cchLength );
		LPSTR CharNextA( LPCSTR lpsz );
		LPWSTR CharNextW( LPCWSTR lpwsz );
		LPSTR CharNextExA( WORD CodePage, LPCSTR lpCurrentChar, DWORD dwFlags );
		LPSTR CharPrevA( LPCSTR lpszStart, LPCSTR lpszCurrent );
		LPWSTR CharPrevW( LPCWSTR lpwszStart, LPCWSTR lpwszCurrent );
		LPSTR CharPrevExA( WORD CodePage, LPCSTR lpStart, LPCSTR lpCurrentChar, DWORD dwFlags );
		BOOL CharToOemA( LPCSTR lpszSrc, LPSTR lpszDst );
		BOOL CharToOemW( LPCWSTR lpwszSrc, LPSTR lpszDst );
		BOOL CharToOemBuffA( LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength );
		BOOL CharToOemBuffW( LPCWSTR lpwszSrc, LPSTR lpszDst, DWORD cchDstLength );
		LPSTR CharUpperA( LPSTR lpsz );
		LPWSTR CharUpperW( LPWSTR lpwsz );
		DWORD CharUpperBuffA( LPSTR lpsz, DWORD cchLength );
		DWORD CharUpperBuffW( LPWSTR lpwsz, DWORD cchLength );
		BOOL IsCharAlphaA( char ch );
		BOOL IsCharAlphaW( wchar_t wch );
		BOOL IsCharAlphaNumericA( char ch );
		BOOL IsCharAlphaNumericW( wchar_t wch );
		BOOL IsCharLowerA( char ch );
		BOOL IsCharLowerW( wchar_t wch );
		BOOL IsCharUpperA( char ch );
		BOOL IsCharUpperW( wchar_t wch );
		int LoadStringA( HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int nBufferMax );
		int LoadStringW( HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBufferMax );
		BOOL OemToCharA( LPCSTR lpszSrc, LPSTR lpszDst );
		BOOL OemToCharW( LPCSTR lpszSrc, LPWSTR lpwszDst );
		BOOL OemToCharBuffA( LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength );
		BOOL OemToCharBuffW( LPCWSTR lpwszSrc, LPWSTR lpwszDst, DWORD cchDstLength );
		int wvsprintfA( LPSTR lpOutput, LPCSTR lpFmt, va_list arglist );
		int wvsprintfW( LPWSTR lpOutput, LPCWSTR lpFmt, va_list arglist );
		//--------------------------------------------------------------------------------
		//Button Control functions
		BOOL CheckDlgButton( HWND hDlg, int nIDButton, UINT uCheck );
		BOOL CheckRadioButton( HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton );
		UINT IsDlgButtonChecked( HWND hDlg, int nIDButton );
		//--------------------------------------------------------------------------------
		//Coordinate Transform functions
		BOOL ClientToScreen( HWND hWnd, ::LPPOINT lpPoint );
		BOOL ScreenToClient( HWND hWnd, ::LPPOINT lpPoint );
		int MapWindowPoints( HWND hWndFrom, HWND hWndTo, ::LPPOINT lpPoints, UINT cPoints );
		//--------------------------------------------------------------------------------
		//Cursor functions
		BOOL ClipCursor( const RECT* lpRect );
		HCURSOR mxCopyCursor( HCURSOR pcur );
		HCURSOR CreateCursor( HINSTANCE hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, const VOID* pvANDPlane, const VOID* pvXORPlane );
		BOOL DestroyCursor( HCURSOR hCursor );
		BOOL GetClipCursor( LPRECT lpRect );
		HCURSOR GetCursor(void);
		BOOL GetCursorInfo( PCURSORINFO pci );
		BOOL GetCursorPos( LPPOINT lpPoint );
		BOOL GetPhysicalCursorPos( LPPOINT lpPoint );
		HCURSOR LoadCursor( HINSTANCE hInstance, LPCTSTR lpCursorName );
		HCURSOR LoadCursorFromFile( LPCTSTR lpFileName );
		BOOL SetCursorPos( int X, int Y );
		BOOL SetPhysicalCursorPos( int X, int Y );
		int ShowCursor( BOOL bShow );
		HCURSOR SetCursor( HCURSOR hCursor );
		BOOL SetSystemCursor( HCURSOR hcur, DWORD id );
		//--------------------------------------------------------------------------------
		//Window Station and Desktop functions
		HDESK OpenDesktop( LPCTSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess );
		BOOL CloseDesktop( HDESK hDesktop );
		HDESK CreateDesktop( LPCTSTR lpszDesktop, LPCTSTR lpszDevice, ::LPDEVMODE pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, ::LPSECURITY_ATTRIBUTES lpsa );
		HDESK CreateDesktopEx( LPCTSTR lpszDesktop, LPCTSTR lpszDevice, ::LPDEVMODE pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, ::LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid );
		BOOL EnumDesktops( HWINSTA hwinsta, DESKTOPENUMPROC lpEnumFunc, LPARAM lParam );
		HWINSTA CreateWindowStation( LPCTSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, ::LPSECURITY_ATTRIBUTES lpsa );
		BOOL CloseWindowStation( HWINSTA hWinSta );
		BOOL EnumWindowStations( WINSTAENUMPROC lpEnumFunc, LPARAM lParam );
		HWINSTA GetProcessWindowStation(void);
		HDESK GetThreadDesktop( DWORD dwThreadId );
		BOOL GetUserObjectInformation( HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded );
		HDESK OpenInputDesktop( DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess );
		HWINSTA OpenWindowStation( LPTSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess );
		BOOL SetProcessWindowStation( HWINSTA hWinSta );
		BOOL SetThreadDesktop( HDESK hDesktop );
		BOOL SetUserObjectInformation( HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength );
		BOOL SwitchDesktop( HDESK hDesktop );
		BOOL EnumDesktopWindows( HDESK hDesktop, ::WNDENUMPROC lpfn, LPARAM lParam );
		//--------------------------------------------------------------------------------
		//Keyboard Accelerator functions
		int CopyAcceleratorTable( HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries );
		HACCEL CreateAcceleratorTable( LPACCEL lpaccl, int cEntries );
		BOOL DestroyAcceleratorTable( HACCEL hAccel );
		HACCEL LoadAccelerators( HINSTANCE hInstance, LPCTSTR lpTableName );
		int TranslateAccelerator( HWND hWnd, HACCEL hAccTable, LPMSG lpMsg );
		//--------------------------------------------------------------------------------
		//Icon functions
		HICON CopyIcon( HICON hIcon );
		HICON CreateIcon( HINSTANCE hInstance, int nWidth, int nHeight, BYTE cPlanes, BYTE cBitsPixel, const BYTE* lpbANDbits, const BYTE* lpbXORbits );
		HICON CreateIconFromResource( PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer );
		HICON CreateIconFromResourceEx( PBYTE pbIconBits, DWORD cbIconBits, BOOL fIcon, DWORD dwVersion, int cxDesired, int cyDesired, UINT uFlags );
		HICON CreateIconIndirect( ::PICONINFO piconinfo );
		BOOL DestroyIcon( HICON hIcon );
		BOOL DrawIcon( HDC hDC, int X, int Y, HICON hIcon );
		BOOL DrawIconEx( HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags );
		BOOL GetIconInfo( HICON hIcon, ::PICONINFO piconinfo );
		BOOL GetIconInfoEx( HICON hIcon, ::PICONINFOEX piconinfoex );
		HICON LoadIcon( HINSTANCE hInstance, LPCTSTR lpIconName );
		int LookupIconIdFromDirectory( PBYTE presbits, BOOL fIcon );
		int LookupIconIdFromDirectoryEx( PBYTE presbits, BOOL fIcon, int cxDesired, int cyDesired, UINT Flags );
		UINT PrivateExtractIcons( LPCTSTR lpszFile, int nIconIndex, int cxIcon, int cyIcon, HICON* phicon, UINT* piconid, UINT nIcons, UINT flags );
		//--------------------------------------------------------------------------------
		//Resource functions
		HANDLE CopyImage( HANDLE hImage, UINT uType, int cxDesired, int cyDesired, UINT fuFlags );
		HANDLE LoadImage( HINSTANCE hinst, LPCTSTR lpszName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad );
		//--------------------------------------------------------------------------------
		//Rectangle functions
		BOOL CopyRect( ::LPRECT lprcDst, CONST ::RECT* lprcSrc );
		BOOL EqualRect( CONST ::RECT* lprc1, CONST ::RECT* lprc2 );
		BOOL InflateRect( ::LPRECT lprc, int dx, int dy );
		BOOL IntersectRect( ::LPRECT lprcDst, CONST ::RECT* lprcSrc1, CONST ::RECT* lprcSrc2 );
		BOOL IsRectEmpty( CONST ::RECT* lprc );
		BOOL OffsetRect( ::LPRECT lprc, int dx, int dy );
		BOOL PtInRect( CONST ::RECT* lprc, POINT pt );
		BOOL SetRect( ::LPRECT lprc, int xLeft, int yTop, int xRight, int yBottom );
		BOOL SetRectEmpty( ::LPRECT lprc );
		BOOL SubtractRect( ::LPRECT lprcDst, CONST ::RECT* lprcSrc1, CONST ::RECT* lprcSrc2 );
		BOOL UnionRect( ::LPRECT lprcDst, CONST ::RECT* lprcSrc1, CONST ::RECT* lprcSrc2 );
		//--------------------------------------------------------------------------------
		//Caret functions
		BOOL CreateCaret( HWND hWnd, HBITMAP hBitmap, int nWidth, int nHeight );
		BOOL DestroyCaret(void);
		UINT GetCaretBlinkTime(void);
		BOOL GetCaretPos( LPPOINT lpPoint );
		BOOL HideCaret( HWND hWnd );
		BOOL SetCaretBlinkTime( UINT uMSeconds );
		BOOL SetCaretPos( int X, int Y );
		BOOL ShowCaret( HWND hWnd );
		//--------------------------------------------------------------------------------
		//Dialog functions
		HWND CreateDialogIndirectParam( HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, ::DLGPROC lpDialogFunc, LPARAM lParamInit );
		HWND CreateDialogParamA( HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, ::DLGPROC lpDialogFunc, LPARAM dwInitParam );
		HWND CreateDialogParamW( HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, ::DLGPROC lpDialogFunc, LPARAM dwInitParam );
		LRESULT DefDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
		INT_PTR DialogBoxIndirectParam( HINSTANCE hInstance, LPCDLGTEMPLATE hDialogTemplate, HWND hWndParent, ::DLGPROC lpDialogFunc, LPARAM dwInitParam );
		INT_PTR DialogBoxParam( HINSTANCE hInstance, LPCTSTR lpTemplateName, HWND hWndParent, ::DLGPROC lpDialogFunc, LPARAM dwInitParam );
		BOOL EndDialog( HWND hDlg, INT_PTR nResult );
		LONG GetDialogBaseUnits(void);
		int GetDlgCtrlID( HWND hwndCtl );
		HWND GetDlgItem( HWND hDlg, int nIDDlgItem );
		UINT GetDlgItemInt( HWND hDlg, int nIDDlgItem, BOOL* lpTranslated, BOOL bSigned );
		UINT GetDlgItemText( HWND hDlg, int nIDDlgItem, LPTSTR lpString, int nMaxCount );
		HWND GetNextDlgGroupItem( HWND hDlg, HWND hCtl, BOOL bPrevious );
		HWND GetNextDlgTabItem( HWND hDlg, HWND hCtl, BOOL bPrevious );
		BOOL IsDialogMessage( HWND hDlg, LPMSG lpMsg );
		BOOL MapDialogRect( HWND hDlg, LPRECT lpRect );
		int MessageBox( HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType );
		int MessageBoxEx( HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType, WORD wLanguageId );
		int MessageBoxIndirect( const ::LPMSGBOXPARAMS lpMsgBoxParams );
		//NOTE: Thanks to CPian Maurizio Pisano
		int MessageBoxTimeout( HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType, WORD wLanguageId, DWORD dwMilliseconds );
		LRESULT SendDlgItemMessage( HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam );
		BOOL SetDlgItemInt( HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned );
		BOOL SetDlgItemText( HWND hDlg, int nIDDlgItem, LPCTSTR lpString );
		//--------------------------------------------------------------------------------
		//Multi Document Interface functions
		HWND CreateMDIWindow( LPCTSTR lpClassName, LPCTSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam );
		LRESULT DefFrameProc( HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam );
		LRESULT DefMDIChildProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
		BOOL TranslateMDISysAccel( HWND hWndClient, LPMSG lpMsg );
		//--------------------------------------------------------------------------------
		//Dynamic Data Exchange functions
		BOOL DdeAbandonTransaction( DWORD idInst, HCONV hConv, DWORD idTransaction ) const;
		LPBYTE DdeAccessData( HDDEDATA hData, LPDWORD pcbDataSize, DWORD __WINQAPI_ERR_ONLY( idInst ) ) const;
		BOOL DdeUnaccessData( HDDEDATA hData, DWORD __WINQAPI_ERR_ONLY( idInst ) ) const;
		HDDEDATA DdeAddData( HDDEDATA hData, LPBYTE pSrc, DWORD cb, DWORD cbOff, DWORD __WINQAPI_ERR_ONLY( idInst ) ) const;
		HDDEDATA DdeClientTransaction( LPBYTE pData, DWORD cbData, HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType, DWORD dwTimeout, LPDWORD pdwResult, DWORD __WINQAPI_ERR_ONLY( idInst ) ) const;
		int DdeCmpStringHandles( HSZ hsz1, HSZ hsz2 ) const;
		HCONV DdeConnect( DWORD idInst, HSZ hszService, HSZ hszTopic, PCONVCONTEXT pCC ) const;
		HCONVLIST DdeConnectList( DWORD idInst, HSZ hszService, HSZ hszTopic, HCONVLIST hConvList, PCONVCONTEXT pCC ) const;
		HDDEDATA DdeCreateDataHandle( DWORD idInst, LPBYTE pSrc, DWORD cb, DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd ) const;
		HSZ mxDdeCreateStringHandle( DWORD idInst, LPTSTR psz, int iCodePage ) const;
		BOOL DdeDisconnect( HCONV hConv, DWORD __WINQAPI_ERR_ONLY( idInst ) ) const;
		BOOL DdeDisconnectList( HCONVLIST hConvList, DWORD __WINQAPI_ERR_ONLY( idInst ) ) const;
		BOOL DdeEnableCallback( DWORD idInst, HCONV hConv, UINT wCmd ) const;
		BOOL DdeFreeDataHandle( HDDEDATA hData, DWORD __WINQAPI_ERR_ONLY( idInst ) ) const;
		BOOL DdeFreeStringHandle( DWORD idInst, HSZ hsz ) const;
		DWORD DdeGetData( HDDEDATA hData, LPBYTE pDst, DWORD cbMax, DWORD cbOff, DWORD __WINQAPI_ERR_ONLY( idInst ) ) const;
		UINT DdeGetLastError( DWORD idInst ) const;
		BOOL DdeImpersonateClient( HCONV hConv, DWORD __WINQAPI_ERR_ONLY( idInst ) ) const;
		UINT DdeInitialize( LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes ) const;
		BOOL DdeKeepStringHandle( DWORD idInst, HSZ hsz ) const;
		HDDEDATA DdeNameService( DWORD idInst, UINT hsz1, UINT hsz2, UINT afCmd ) const;
		BOOL DdePostAdvise( DWORD idInst, HSZ hszTopic, HSZ hszItem ) const;
		UINT DdeQueryConvInfo( HCONV hConv, DWORD idTransaction, PCONVINFO pConvInfo, DWORD __WINQAPI_ERR_ONLY( idInst ) ) const;
		HCONV DdeQueryNextServer( HCONVLIST hConvList, HCONV hConvPrev ) const;
		DWORD DdeQueryString( DWORD idInst, HSZ hsz, LPTSTR psz, DWORD cchMax, int iCodePage ) const;
		HCONV DdeReconnect( HCONV hConv, DWORD __WINQAPI_ERR_ONLY( idInst ) ) const;
		BOOL DdeSetQualityOfService( HWND hwndClient, const SECURITY_QUALITY_OF_SERVICE* pqosNew, PSECURITY_QUALITY_OF_SERVICE pqosPrev ) const;
		BOOL DdeSetUserHandle( HCONV hConv, DWORD id, DWORD_PTR hUser, DWORD __WINQAPI_ERR_ONLY( idInst ) ) const;
		BOOL DdeUninitialize( DWORD idInst ) const;
		BOOL FreeDDElParam( UINT msg, LPARAM lParam ) const;
		LPARAM PackDDElParam( UINT msg, UINT_PTR uiLo, UINT_PTR uiHi ) const;
		BOOL ImpersonateDdeClientWindow( HWND hWndClient, HWND hWndServer ) const;
		LPARAM ReuseDDElParam( LPARAM lParam, UINT msgIn, UINT msgOut, UINT_PTR uiLo, UINT_PTR uiHi ) const;
		BOOL UnpackDDElParam( UINT msg, LPARAM lParam, PUINT_PTR puiLo, PUINT_PTR puiHi ) const;
		//--------------------------------------------------------------------------------
		//Raw Input functions
		LRESULT DefRawInputProc( PRAWINPUT* paRawInput, INT nInput, UINT cbSizeHeader );
		UINT GetRawInputBuffer( PRAWINPUT pData, PUINT pcbSize, UINT cbSizeHeader );
		UINT GetRawInputData( HRAWINPUT hRawInput, UINT uiCommand, LPVOID pData, PUINT pcbSize, UINT cbSizeHeader );
		UINT GetRawInputDeviceInfo( HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize );
		UINT GetRawInputDeviceList( PRAWINPUTDEVICELIST pRawInputDeviceList, PUINT puiNumDevices, UINT cbSize );
		UINT GetRegisteredRawInputDevices( PRAWINPUTDEVICE pRawInputDevices, PUINT puiNumDevices, UINT cbSize );
		BOOL RegisterRawInputDevices( PCRAWINPUTDEVICE pRawInputDevices, UINT uiNumDevices, UINT cbSize );
		//--------------------------------------------------------------------------------
		//List Box functions
		int DlgDirList( HWND hDlg, LPTSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType );
		BOOL DlgDirSelectEx( HWND hDlg, LPTSTR lpString, int nCount, int nIDListBox );
		DWORD GetListBoxInfo( HWND hwnd );
		//--------------------------------------------------------------------------------
		//Combo Box functions
		int DlgDirListComboBox( HWND hDlg, LPTSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype );
		BOOL DlgDirSelectComboBoxEx( HWND hDlg, LPTSTR lpString, int nCount, int nIDComboBox );
		BOOL GetComboBoxInfo( HWND hwndCombo, PCOMBOBOXINFO pcbi );
		//--------------------------------------------------------------------------------
		//Mouse functions
		BOOL DragDetect( HWND hwnd, ::POINT pt );
		HWND GetCapture( void );
		UINT GetDoubleClickTime( void );
		int GetMouseMovePointsEx( UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution );
		VOID mouse_event( DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData, ULONG_PTR dwExtraInfo );
		BOOL ReleaseCapture(void);
		HWND SetCapture( HWND hWnd );
		BOOL SetDoubleClickTime( UINT uInterval );
		BOOL SwapMouseButton( BOOL fSwap );
		BOOL TrackMouseEvent( LPTRACKMOUSEEVENT lpEventTrack );
		//--------------------------------------------------------------------------------
		//Font and Text functions
		int DrawText( HDC hDC, LPCTSTR lpString, int nCount, ::LPRECT lpRect, UINT uFormat );
		int DrawTextEx( HDC hdc, LPTSTR lpchText, int cchText, ::LPRECT lprc, UINT dwDTFormat, ::LPDRAWTEXTPARAMS lpDTParams );
		DWORD GetTabbedTextExtent( HDC hDC, LPCTSTR lpString, int nCount, int nTabPositions, CONST LPINT lpnTabStopPositions );
		LONG TabbedTextOut( HDC hDC, int X, int Y, LPCTSTR lpString, int nCount, int nTabPositions, CONST ::LPINT lpnTabStopPositions, int nTabOrigin );
		//--------------------------------------------------------------------------------
		//ScrollBar functions
		BOOL EnableScrollBar( HWND hWnd, UINT wSBFlags, UINT wArrows );
		BOOL GetScrollBarInfo( HWND hwnd, LONG idObject, ::PSCROLLBARINFO psbi );
		BOOL GetScrollInfo( HWND hwnd, int fnBar, ::LPSCROLLINFO lpsi );
		int GetScrollPos( HWND hWnd, int nBar );
		BOOL GetScrollRange( HWND hWnd, int nBar, LPINT lpMinPos, LPINT lpMaxPos );
		BOOL ScrollDC( HDC hDC, int dx, int dy, const ::RECT *lprcScroll, const ::RECT *lprcClip, HRGN hrgnUpdate, ::LPRECT lprcUpdate );
		BOOL ScrollWindow( HWND hWnd, int XAmount, int YAmount, const ::RECT* lpRect, const ::RECT* lpClipRect );
		int ScrollWindowEx( HWND hWnd, int dx, int dy, const ::RECT* prcScroll, const ::RECT* prcClip, HRGN hrgnUpdate, ::LPRECT prcUpdate, UINT flags );
		int SetScrollInfo( HWND hwnd, int fnBar, ::LPCSCROLLINFO lpsi, BOOL fRedraw );
		int SetScrollPos( HWND hWnd, int nBar, int nPos, BOOL bRedraw );
		BOOL SetScrollRange( HWND hWnd, int nBar, int nMinPos, int nMaxPos, BOOL bRedraw );
		BOOL ShowScrollBar( HWND hWnd, int wBar, BOOL bShow );
		//--------------------------------------------------------------------------------
		BOOL EnumDisplayMonitors( HDC hdc, LPCRECT lprcClip, ::MONITORENUMPROC lpfnEnum, LPARAM dwData );
		BOOL GetMonitorInfo( HMONITOR hMonitor, ::LPMONITORINFO lpmi );
		HMONITOR MonitorFromPoint( ::POINT pt, DWORD dwFlags );
		HMONITOR MonitorFromRect( LPCRECT lprc, DWORD dwFlags );
		HMONITOR MonitorFromWindow( HWND hwnd, DWORD dwFlags );
		//--------------------------------------------------------------------------------
		//Window Properties functions
		int EnumProps( HWND hWnd, PROPENUMPROC lpEnumFunc );
		int EnumPropsEx( HWND hWnd, PROPENUMPROCEX lpEnumFunc, LPARAM lParam );
		HANDLE GetProp( HWND hWnd, LPCTSTR lpString );
		HANDLE RemoveProp( HWND hWnd, LPCTSTR lpString );
		BOOL SetProp( HWND hWnd, LPCTSTR lpString, HANDLE hData );
		//--------------------------------------------------------------------------------
		//System Shutdwown functions
		BOOL ExitWindowsEx( UINT uFlags, DWORD dwReason );
		BOOL LockWorkStation(void);
		BOOL ShutdownBlockReasonCreate( HWND hWnd, LPCWSTR pwszReason );
		BOOL WINAPI ShutdownBlockReasonDestroy( HWND hWnd );
		BOOL WINAPI ShutdownBlockReasonQuery( HWND hWnd, LPWSTR pwszBuff, DWORD* pcchBuff );
		//--------------------------------------------------------------------------------
		//Filled Shapes functions
		int FillRect( HDC hDC, CONST ::RECT* lprc, HBRUSH hbr );
		int FrameRect( HDC hDC, CONST ::RECT* lprc, HBRUSH hbr );
		BOOL InvertRect( HDC hDC, CONST ::RECT* lprc );
		//--------------------------------------------------------------------------------
		//Error Handling functions
		BOOL FlashWindow( HWND hWnd, BOOL bInvert );
		BOOL FlashWindowEx( ::PFLASHWINFO pfwi );
		BOOL MessageBeep( UINT uType );
		void SetLastErrorEx( DWORD dwErrCode, DWORD dwType );
		//--------------------------------------------------------------------------------
		//Window-Class functions
		BOOL GetClassInfo( HINSTANCE hInstance, LPCTSTR lpClassName, LPWNDCLASS lpWndClass );
		BOOL GetClassInfoExA( HINSTANCE hinst, LPCSTR lpszClass, LPWNDCLASSEXA lpwcx );
		BOOL GetClassInfoExW( HINSTANCE hinst, LPCWSTR lpszClass, LPWNDCLASSEXW lpwcx );
		ULONG_PTR GetClassLongPtr( HWND hWnd, int nIndex );
		int GetClassName( HWND hWnd, LPTSTR lpClassName, int nMaxCount );
		WORD GetClassWord( HWND hWnd, int nIndex );
		LONG GetWindowLong( HWND hWnd, int nIndex );
		ATOM RegisterClass( CONST WNDCLASS* lpWndClass );
		ATOM RegisterClassExA( CONST WNDCLASSEXA* lpwcx );
		ATOM RegisterClassExW( CONST WNDCLASSEXW* lpwcx );
		ULONG_PTR SetClassLongPtr( HWND hWnd, int nIndex, LONG_PTR dwNewLong );
		WORD SetClassWord( HWND hWnd, int nIndex, WORD wNewWord );
		LONG SetWindowLong( HWND hWnd, int nIndex, LONG dwNewLong );
		BOOL UnregisterClass( LPCTSTR lpClassName, HINSTANCE hInstance );

		void DisableProcessWindowsGhosting(void);
		LRESULT SendIMEMessageEx( HWND hwnd, LPARAM lParam );
		BOOL WINNLSEnableIME( HWND hwnd, BOOL bFlag );//Obselete do not use

		//TODO: DesktopWindowManager

		//--------------------------------------------------------------------------------
		//Shell functions
		BOOL SetMenuContextHelpId( HMENU hmenu, DWORD dwContextHelpId );
		DWORD GetMenuContextHelpId( HMENU hmenu );
		BOOL SetWindowContextHelpId( HWND hwnd, DWORD dwContextHelpId );
		DWORD GetWindowContextHelpId( HWND hwnd );
		BOOL WinHelp( HWND hWndMain, LPCTSTR lpszHelp, UINT uCommand, ULONG_PTR dwData );
		//--------------------------------------------------------------------------------
		//System Information functions
		DWORD GetSysColor( int nIndex );
		int GetSystemMetrics( int nIndex );
		BOOL SetSysColors( int cElements, const INT* lpaElements, const COLORREF* lpaRgbValues );
		BOOL SystemParametersInfo( UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni );
		//--------------------------------------------------------------------------------
		//Brush functions
		HBRUSH GetSysColorBrush( int nIndex );
		//--------------------------------------------------------------------------------
		//Authorization functions
		BOOL GetUserObjectSecurity( HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSD, DWORD nLength, LPDWORD lpnLengthNeeded );
		BOOL SetUserObjectSecurity( HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID );
		//--------------------------------------------------------------------------------
		//Active Accessibility functions
		HWINEVENTHOOK SetWinEventHook( UINT eventMin, UINT eventMax, HMODULE hmodWinEventProc, WINEVENTPROC lpfnWinEventProc, DWORD idProcess, DWORD idThread, UINT dwflags );
		BOOL UnhookWinEvent( HWINEVENTHOOK hWinEventHook );
		BOOL IsWinEventHookInstalled( DWORD dwEvent );
		void NotifyWinEvent( DWORD dwEvent, HWND hwnd, LONG idObject, LONG idChild );
		//--------------------------------------------------------------------------------
		//Timer functions
		BOOL KillTimer( HWND hWnd, UINT_PTR uIDEvent );
		UINT_PTR SetTimer( HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc );
		//--------------------------------------------------------------------------------
		//Bitmap functions
		HBITMAP LoadBitmap( HINSTANCE hInstance, LPCTSTR lpBitmapName );
		//--------------------------------------------------------------------------------
		//Synchronization functions
		DWORD MsgWaitForMultipleObjects( DWORD nCount, const HANDLE* pHandles, BOOL bWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask );
		DWORD MsgWaitForMultipleObjectsEx( DWORD nCount, const HANDLE* pHandles, DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags );
		//--------------------------------------------------------------------------------
		//Printing functions
		BOOL PrintWindow( HWND hwnd, HDC hdcBlt, UINT nFlags );
		//--------------------------------------------------------------------------------
		//Device Management functions
		HDEVNOTIFY RegisterDeviceNotification( HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags );
		BOOL UnregisterDeviceNotification( HDEVNOTIFY Handle );
		//--------------------------------------------------------------------------------
		//Power Management functions
		HPOWERNOTIFY RegisterPowerSettingNotification( HANDLE hRecipient, LPCGUID PowerSettingGuid, DWORD Flags );
		BOOL UnregisterPowerSettingNotification( HPOWERNOTIFY Handle );

	};

}//nsWinQAPI

#endif//WINQAPI_USER32_H_1
