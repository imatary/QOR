//Basestring.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "SystemQOR/Posix/Basestring.h"
#include <assert.h>
#include <errno.h>
#include <assert.h>
#include <errno.h>
#include <ctype.h>
#include <limits.h>
#include "CodeQOR/Tracing/FunctionContextBase.h"

//--------------------------------------------------------------------------------
namespace nsBaseCRT
{
	__QOR_IMPLEMENT_OCLASS_LUID( Cstring );

	//--------------------------------------------------------------------------------
	//Nonzero if either X or Y is not aligned on a "long" boundary.
	template< typename T > bool unaligned( T*& x, T*& y )
	{
		return (((long)x & (sizeof (long) - 1)) | ((long)y & (sizeof (long) - 1))) ? true : false;
	}

	//--------------------------------------------------------------------------------
	Cstring::Cstring()
	{
		__QCS_MEMBER_FCONTEXT( "Cstring::Cstring" );
	}

	//--------------------------------------------------------------------------------
	Cstring::~Cstring()
	{
		__QCS_MEMBER_FCONTEXT( "Cstring::~Cstring" );
	}

    //--------------------------------------------------------------------------------
    void* Cstring::memccpy( void* dst0, const void* src0, int endchar0, size_t len0 )
    {
        __QCS_FCONTEXT( "Cstring::memccpy" );

        void* ptr = 0;
        char* dst = reinterpret_cast< char* >( dst0 );

#if		( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )//favour size over speed

        char* src = const_cast< char* >( reinterpret_cast< const char* >( src0 ) );
        char endchar = endchar0 & 0xff;

        while( len0-- )
        {
            if( ( *dst++ = *src++ ) == endchar )
            {
                ptr = dst;
                break;
            }
        }

#else												//favour speed over size

        const char* src = reinterpret_cast< const char*>( src0 );
        long* aligned_dst;
        const long* aligned_src;
        int len = len0;
        char endchar = endchar0 & 0xff;

        // If the size is small, or either SRC or DST is unaligned, then punt into
        // the byte copy loop.  This should be rare.
        char* aligned_check = const_cast< char* >( src );
        if( ( len >= sizeof( long ) ) && !unaligned( aligned_check, dst ) )
        {
            int i;
            unsigned long mask = 0;

            aligned_dst = reinterpret_cast< long* >( dst );
            aligned_src = reinterpret_cast< const long* >( src );

            /* The fast code reads the ASCII one word at a time and only
            performs the bytewise search on word-sized segments if they
            contain the search character, which is detected by XORing
            the word-sized segment with a word-sized block of the search
            character and then detecting for the presence of NULL in the
            result.  */
            for( i = 0; i < sizeof( long ); i++ )
            {
                mask = ( mask << 8 ) + endchar;
            }

            // Copy one long word at a time if possible.
            while( len >= sizeof( long ) )
            {
                unsigned long buffer = ( *( reinterpret_cast< unsigned long* >( const_cast< long* >( aligned_src ) ) ) );
                buffer ^=  mask;
                if( DETECTNULL( buffer ) )
                {
                    break; // endchar is found, go byte by byte from here
                }
                *aligned_dst++ = *aligned_src++;
                len -= sizeof( long );
            }

            // Pick up any residual with a byte copier.
            dst = reinterpret_cast< char* >( aligned_dst );
            src = reinterpret_cast< const char* >( aligned_src );
        }

        while( len-- )
        {
            if( ( *dst++ = *src++ ) == endchar )
            {
                ptr = dst;
                break;
            }
        }

#endif//!( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )
        return ptr;
    }

    //--------------------------------------------------------------------------------
    ///The memcpy() function shall copy n bytes from the object pointed to by s2
    ///into the object pointed to by s1. If copying takes place between objects that
    ///overlap, the behavior is undefined.
    void* Cstring::memcpy( void* s1, const void* s2, size_t n )
    {
        __QCS_FCONTEXT( "Cstring::memcpy" );
        unsigned char* p1 = reinterpret_cast< unsigned char* >( const_cast< void* >( s1 ) );
        unsigned char* p2 = reinterpret_cast< unsigned char* >( const_cast< void* >( s2 ) );

        while( n > 0 )
        {
            *p1 = *p2;
            p1++;
            p2++;
            n--;
        }

        return s1;
    }

    //--------------------------------------------------------------------------------
    errno_t Cstring::memcpy_s( void* dst, size_t sizeInBytes, const void* src, size_t count )
    {
        __QCS_FCONTEXT( "Cstring::memcpy_s" );

        errno_t errResult = 0;
        if( count != 0 )
        {
            if( dst == 0 )
            {
                errResult = EINVAL;
            }
            else
            {
                if( src == 0 || sizeInBytes < count )
                {
                    // zeroes the destination buffer
                    memset( dst, 0, sizeInBytes );

                    if( src == 0 )
                    {
                        errResult = EINVAL;
                    }

                    if( sizeInBytes < count )
                    {
                        errResult = ERANGE;
                    }
                }
                else
                {
                    memcpy( dst, src, count );
                }
            }
        }
        return errResult;
    }

    //--------------------------------------------------------------------------------
    void* Cstring::memmove( void* dst_void, const void* src_void, size_t length )
    {
        __QCS_FCONTEXT( "Cstring::memmove" );
#if		( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )//favour size over speed
        char *dst = reinterpret_cast< char* >( dst_void );
        const char* src = reinterpret_cast< const char* >( src_void );

        if( src < dst && dst < src + length )
        {
            // Have to copy backwards
            src += length;
            dst += length;
            while( length-- )
            {
                *--dst = *--src;
            }
        }
        else
        {
            while( length-- )
            {
                *dst++ = *src++;
            }
        }
#else												//favour speed over size
        char* dst = reinterpret_cast< char* >( dst_void );
        const char *src = reinterpret_cast< const char* >( src_void );
        long *aligned_dst;
        const long *aligned_src;
        int len = length;

        if( src < dst && dst < src + len )
        {
            // Destructive overlap...have to copy backwards
            src += len;
            dst += len;
            while( len-- )
            {
                *--dst = *--src;
            }
        }
        else
        {
            // Use optimizing algorithm for a non-destructive copy to closely
            // match memcpy. If the size is small or either SRC or DST is unaligned,
            // then punt into the byte copy loop.  This should be rare.
            if( !( len < ( sizeof (long) << 2 ) ) && !( ( (long)src & ( sizeof (long) - 1 ) ) | ( (long)dst & ( sizeof (long) - 1 ) ) ) )
            {
                aligned_dst = (long*)dst;
                aligned_src = (long*)src;

                // Copy 4X long words at a time if possible.
                while( len >= ( sizeof (long) << 2 ) )
                {
                    *aligned_dst++ = *aligned_src++;
                    *aligned_dst++ = *aligned_src++;
                    *aligned_dst++ = *aligned_src++;
                    *aligned_dst++ = *aligned_src++;
                    len -= ( sizeof (long) << 2 ) ;
                }

                // Copy one long word at a time if possible.
                while( len >= ( sizeof (long) ) )
                {
                    *aligned_dst++ = *aligned_src++;
                    len -= ( sizeof (long) );
                }

                // Pick up any residual with a byte copier.
                dst = (char*)aligned_dst;
                src = (char*)aligned_src;
            }

            while( len-- )
            {
                *dst++ = *src++;
            }
        }

#endif//!( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )

        return dst_void;
    }

    //--------------------------------------------------------------------------------
    errno_t Cstring::memmove_s( void* dst, size_t sizeInBytes, const void* src, size_t count )
    {
        __QCS_FCONTEXT( "Cstring::memmove_s" );

        errno_t errResult = 0;

        if( count != 0 )
        {
            if( dst == 0 || src == 0 )
            {
                errResult = EINVAL;
            }
            else if( sizeInBytes < count )
            {
                errResult = ERANGE;
            }
            else
            {
                memmove( dst, src, count );
            }
        }

        return errResult;
    }

    //--------------------------------------------------------------------------------
    char* Cstring::strcpy( char* dst0, const char* src0 )
    {
        __QCS_FCONTEXT( "Cstring::strcpy" );

#if		( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )//favour size over speed

        char* s = dst0;

        while( *dst0++ = *src0++);
        return s;
#else												//favour speed over size
        char* dst = dst0;
        const char* src = src0;
        long* aligned_dst;
        const long* aligned_src;

        // If SRC or DEST is unaligned, then copy bytes.
        if( !unaligned( src, dst ) )
        {
            aligned_dst = (long*)dst;
            aligned_src = (long*)src;

            // SRC and DEST are both "long int" aligned, try to do "long int" sized copies.
            while( !DETECTNULL( *aligned_src ) )
            {
                *aligned_dst++ = *aligned_src++;
            }

            dst = (char*)aligned_dst;
            src = (char*)aligned_src;
        }

        while( *dst++ = *src++ );

        return dst0;
#endif//!( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )//favour size over speed
    }

    //--------------------------------------------------------------------------------
    errno_t Cstring::strcpy_s( char* dst, size_t SizeInBytes, const char* src )
    {
        __QCS_FCONTEXT( "Cstring::strcpy_s" );

        errno_t errResult = 0;
        char* p;
        size_t available;

        if( dst == 0 || SizeInBytes == 0 )
        {
            errno = EINVAL;
            errResult = EINVAL;
        }
        else
        {
            if( src == 0 )
            {
                *dst = 0;

                if( SizeInBytes != ( (size_t)-1 ) && SizeInBytes != INT_MAX && ( (size_t)1 ) < SizeInBytes )
                {
                    memset( dst + 1, 0xFE, ( UINT_MAX < ( (size_t)( SizeInBytes - 1 ) ) ? UINT_MAX : ( SizeInBytes - 1 ) ) * sizeof( *dst ) );
                }

                errno = EINVAL;
                errResult = EINVAL;

            }
            else
            {
                p = dst;
                available = SizeInBytes;
                while( ( *p++ = *src++ ) != 0 && --available > 0 )
                {
                }

                if( available == 0 )
                {
                    *dst = 0;
                    if( SizeInBytes != ( (size_t)-1 ) && SizeInBytes != INT_MAX && ( (size_t)1 ) < SizeInBytes )
                    {
                        memset( dst + 1, 0xFE, ( UINT_MAX < ( (size_t)( SizeInBytes - 1 ) ) ? UINT_MAX : ( SizeInBytes - 1 ) ) * sizeof( *dst ) );
                    }
#pragma TODO( "Raise ERANGE - Buffer is too small" )
                    errResult = ERANGE;
                }
                else
                {
                    if( SizeInBytes != ( (size_t) -1 ) && SizeInBytes != INT_MAX && ( (size_t)( SizeInBytes - available + 1 ) ) < SizeInBytes )
                    {
                        memset( dst + ( SizeInBytes - available + 1 ), 0xFE, ( UINT_MAX < ( (size_t)( SizeInBytes - ( SizeInBytes - available + 1 ) ) ) ? UINT_MAX : ( SizeInBytes - ( SizeInBytes - available + 1 ) ) ) * sizeof( *dst ) );
                    }
                }
            }
        }
        return errResult;
    }

    //--------------------------------------------------------------------------------
    char* Cstring::strncpy( char* dst0, const char* src0, size_t count )
    {
        __QCS_FCONTEXT( "Cstring::strncpy" );
#if		( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )//favour size over speed
        char* dscan;
        const char* sscan;

        dscan = dst0;
        sscan = src0;
        while( count > 0 )
        {
            --count;
            if( ( *dscan++ = *sscan++ ) == '\0' )
            {
                break;
            }
        }

        while( count-- > 0 )
        {
            *dscan++ = '\0';
        }

        return dst0;
#else												//favour speed over size
        char* dst = dst0;
        const char* src = src0;
        long* aligned_dst;
        const long* aligned_src;

        // If SRC and DEST is aligned and count large enough, then copy words.

        if( !( ( (long)src & ( sizeof(long) - 1 ) ) | ( (long)dst & ( sizeof(long) - 1 ) ) ) && !( count < sizeof (long) ) )
        {
            aligned_dst = (long*)dst;
            aligned_src = (long*)src;

            // SRC and DEST are both "long int" aligned, try to do "long int" sized copies.
            while( count >= sizeof( long int ) && !DETECTNULL( *aligned_src ) )
            {
                count -= sizeof( long int );
                *aligned_dst++ = *aligned_src++;
            }

            dst = (char*)aligned_dst;
            src = (char*)aligned_src;
        }

        while( count > 0 )
        {
            --count;
            if( ( *dst++ = *src++ ) == '\0' )
            {
                break;
            }
        }

        while( count-- > 0 )
        {
            *dst++ = '\0';
        }

        return dst0;
#endif//!( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )
    }

    //--------------------------------------------------------------------------------
    errno_t Cstring::strncpy_s( char* dst, size_t SizeInBytes, const char* src, size_t MaxCount )
    {
        __QCS_FCONTEXT( "Cstring::strncpy_s" );
        errno_t errResult = 0;
        char* p;
        size_t available;

        if( MaxCount == 0 && dst == 0 && SizeInBytes == 0 )
        {
            errResult = 0;
        }
        else
        {
            if( dst == 0 || SizeInBytes == 0 )
            {
                errno = EINVAL;
                errResult = EINVAL;
            }
            else
            {
                if( MaxCount == 0 )
                {
                    // notice that the source string pointer can be NULL in this case
                    *dst = 0;
                    if( SizeInBytes != ( (size_t)-1 ) && SizeInBytes != INT_MAX && ( (size_t)1 ) < SizeInBytes )
                    {
                        memset( dst + 1, 0xFE, ( UINT_MAX < ( (size_t)( SizeInBytes - 1 ) ) ? UINT_MAX : ( SizeInBytes - 1 ) ) * sizeof( *dst ) );
                    }
                    errResult = 0;
                }
                else
                {
                    if( src == 0 )
                    {
                        *dst = 0;
                        if( SizeInBytes != ( (size_t)-1 ) && SizeInBytes != INT_MAX && ( (size_t)1 ) < SizeInBytes )
                        {
                            memset( dst + 1, 0xFE, ( UINT_MAX < ( (size_t)( SizeInBytes - 1 ) ) ? UINT_MAX : ( SizeInBytes - 1 ) ) * sizeof( *dst ) );
                        }
                        errno = EINVAL;
                        errResult = EINVAL;
                    }
                    else
                    {
                        p = dst;
                        available = SizeInBytes;
                        if( MaxCount == -1 )
                        {
                            while( ( *p++ = *src++ ) != 0 && --available > 0 )
                            {
                            }
                        }
                        else
                        {
                            assert( ( MaxCount < SizeInBytes ) );

                            while( ( *p++ = *src++ ) != 0 && --available > 0 && --MaxCount > 0 )
                            {
                            }

                            if( MaxCount == 0 )
                            {
                                *p = 0;
                            }
                        }

                        if( available == 0 )
                        {
                            if( MaxCount == -1 )
                            {
                                dst[ SizeInBytes - 1 ] = 0;
                                errResult = nsPlatform::STRUNCATE;
                            }
                            else
                            {
                                *dst = 0;
                                if( SizeInBytes != ( (size_t)-1 ) && SizeInBytes != INT_MAX && ( (size_t)1 ) < SizeInBytes )
                                {
                                    memset( dst + 1, 0xFE, ( UINT_MAX < ( (size_t)( SizeInBytes - 1 ) ) ? UINT_MAX : ( SizeInBytes - 1 ) ) * sizeof( *dst ) );
                                }

#pragma TODO( "Raise ERANGE - Buffer is too small" )
                                errResult = ERANGE;
                            }
                        }
                        else
                        {
                            if( SizeInBytes != ( (size_t)-1 ) && SizeInBytes != INT_MAX && ( (size_t)(SizeInBytes - available + 1) ) < SizeInBytes )
                            {
                                memset( dst + (SizeInBytes - available + 1), 0xFE, ( UINT_MAX < ( (size_t)( SizeInBytes - (SizeInBytes - available + 1) ) ) ?
                                UINT_MAX : ( SizeInBytes - (SizeInBytes - available + 1) ) ) * sizeof( *dst ) );
                            }
                        }
                    }
                }
            }
        }
        return errResult;
    }

    //--------------------------------------------------------------------------------
    char* Cstring::strcat( char* s1, const char* s2 )
    {
        __QCS_FCONTEXT( "Cstring::strcat" );
#if		( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )//favour size over speed
        char* s = s1;

        while( *s1 )
        {
            s1++;
        }

        while( *s1++ = *s2++ );

#else												//favour speed over size

        char *s = s1;

        // Skip over the data in s1 as quickly as possible.
        if( aligned( s1 ) )
        {
            unsigned long* aligned_s1 = (unsigned long*)s1;
            while( !DETECTNULL( *aligned_s1 ) )
            {
                aligned_s1++;
            }
            s1 = (char*)aligned_s1;
        }

        while( *s1 )
        {
            s1++;
        }

        /* s1 now points to the its trailing null character, we can
        just use strcpy to do the work for us now.

        ?!? We might want to just include strcpy here.
        Also, this will cause many more unaligned string copies because
        s1 is much less likely to be aligned.  I don't know if its worth
        tweaking strcpy to handle this better.  */
        strcpy( s1, s2 );
#endif//!( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )

        return s;
    }

    //--------------------------------------------------------------------------------
    errno_t Cstring::strcat_s( char* dst, size_t SizeInBytes, const char* src )
    {
        __QCS_FCONTEXT( "Cstring::strcat_s" );

        char* p;
        size_t available;
        errno_t errResult = 0;

        if( dst == 0 || SizeInBytes == 0 )
        {
            errResult = EINVAL;
            errno = EINVAL;
        }
        else
        {
            if( src == 0 )
            {
                *dst = 0;
                if( SizeInBytes != (size_t)-1 && SizeInBytes != INT_MAX && (size_t)(1) < SizeInBytes )
                {
                    memset( dst + 1, 0xFE, ( SizeInBytes - 1 ) );
                }
                errno = EINVAL;
                errResult = EINVAL;
            }
            else
            {
                p = dst;
                available = SizeInBytes;
                while( available > 0 && *p != 0 )
                {
                    p++;
                    available--;
                }

                if( available == 0 )
                {
                    *dst = 0;
                    if( SizeInBytes != (size_t)-1 && SizeInBytes != INT_MAX && (size_t)(1) < SizeInBytes )
                    {
                        memset( dst + 1, 0xFE, ( SizeInBytes - 1 ) );
                    }

#pragma TODO( "Raise EINVAL - String is not null terminated" )
                    errResult = EINVAL;
                }
                else
                {

                    while( ( *p++ = *src++ ) != 0 && --available > 0 )
                    {
                    }

                    if( available == 0 )
                    {
                        *dst = 0;
                        if( SizeInBytes != (size_t)-1 && SizeInBytes != INT_MAX && (size_t)(1) < SizeInBytes )
                        {
                            memset( dst + 1, 0xFE, ( SizeInBytes - 1 ) );
                        }
#pragma TODO( "Raise ERANGE - Buffer is too small" )
                        errResult = ERANGE;
                    }
                    else
                    {
                        *dst = 0;
                        if( SizeInBytes != (size_t)-1 && SizeInBytes != INT_MAX && (size_t)(SizeInBytes - available + 1) < SizeInBytes )
                        {
                            memset( dst + SizeInBytes - available + 1, 0xFE, ( SizeInBytes - ( SizeInBytes - available + 1 ) ) );
                        }
                    }
                }
            }
        }
        return errResult;
    }

    //--------------------------------------------------------------------------------
    char* Cstring::strncat( char* s1, const char* s2, size_t n )
    {
        __QCS_FCONTEXT( "Cstring::strncat" );

#if		( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )//favour size over speed

        char* s = s1;

        while( *s1 )
        {
            s1++;
        }

        while( n-- != 0 && ( *s1++ = *s2++ ) )
        {
            if( n == 0 )
            {
                *s1 = '\0';
            }
        }

#else												//favour speed over size
        char* s = s1;

        // Skip over the data in s1 as quickly as possible.
        if( aligned( s1 ) )
        {
            unsigned long* aligned_s1 = (unsigned long*)s1;
            while( !DETECTNULL( *aligned_s1 ) )
            {
                aligned_s1++;
            }
            s1 = (char*)aligned_s1;
        }

        while( *s1 )
        {
            s1++;
        }

        // s1 now points to the its trailing null character, now copy
        //up to N bytes from S2 into S1 stopping if a NULL is encountered in S2.
        //It is not safe to use strncpy here since it copies EXACTLY N
        //characters, NULL padding if necessary.
        while( n-- != 0 && ( *s1++ = *s2++ ) )
        {
            if( n == 0 )
            {
                *s1 = '\0';
            }
        }

#endif//!( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )

        return s;
    }

    //--------------------------------------------------------------------------------
    errno_t Cstring::strncat_s( char* dst, size_t SizeInBytes, const char* src, size_t MaxCount )
    {
        __QCS_FCONTEXT( "Cstring::strncat_s" );
        errno_t errResult = 0;

        char *p;
        size_t available;

        if( MaxCount == 0 && dst == 0 && SizeInBytes == 0)
        {
            errResult = 0;
        }
        else if( dst == 0 || SizeInBytes == 0 )
        {
            errResult = EINVAL;
        }
        else
        {
            if( MaxCount != 0 && src == 0 )
            {
                *dst = 0;
                if( SizeInBytes != ( (size_t)-1 ) && SizeInBytes != INT_MAX && ( (size_t)( 1 ) ) < SizeInBytes )
                {
                    memset( dst + ( 1 ), 0xFE, ( UINT_MAX < ( (size_t)( SizeInBytes - ( 1 ) ) ) ? UINT_MAX : ( SizeInBytes - ( 1 ) ) ) * sizeof( *dst ) );
                }

                errResult = EINVAL;
            }
            else
            {
                p = dst;
                available = SizeInBytes;
                while( available > 0 && *p != 0 )
                {
                    p++;
                    available--;
                }

                if( available == 0 )
                {
                    *dst = 0;
                    if( SizeInBytes != ( (size_t)-1 ) && SizeInBytes != INT_MAX && ( (size_t)( 1 ) ) < SizeInBytes )
                    {
                        memset( dst + 1, 0xFE, ( UINT_MAX < ( (size_t)( SizeInBytes - 1 ) ) ? UINT_MAX : ( SizeInBytes - 1 ) ) * sizeof( *dst ) );
                    }

#pragma TODO( "Raise EINVAL - String is not null terminated" )
                    errResult = EINVAL;
                }
                else
                {
                    if( MaxCount == -1 )
                    {
                        while( ( *p++ = *src++ ) != 0 && --available > 0 )
                        {
                        }
                    }
                    else
                    {
                        assert( ( MaxCount < available ) );

                        while( MaxCount > 0 && ( *p++ = *src++) != 0 && --available > 0 )
                        {
                            MaxCount--;
                        }

                        if( MaxCount == 0 )
                        {
                            *p = 0;
                        }
                    }

                    if( available == 0 )
                    {
                        if( MaxCount == -1 )
                        {
                            dst[ SizeInBytes - 1 ] = 0;
                            errResult = nsPlatform::STRUNCATE;
                        }

                        *dst = 0;
                        if( SizeInBytes != ( (size_t)-1 ) && SizeInBytes != INT_MAX && ( (size_t)1 ) < SizeInBytes )
                        {
                            memset( dst + 1, 0xFE, ( UINT_MAX < ( (size_t)( SizeInBytes - 1 ) ) ? UINT_MAX : ( SizeInBytes - 1 ) ) * sizeof( *dst ) );
                        }

#pragma TODO( "Raise ERANGE - Buffer is too small" )
                        errResult = ERANGE;
                    }
                    else
                    {
                        if( SizeInBytes != ( (size_t)-1 ) && SizeInBytes != INT_MAX && ( (size_t)( SizeInBytes - available + 1 ) ) < SizeInBytes )
                        {
                            memset( dst + ( SizeInBytes - available + 1 ), 0xFE, ( UINT_MAX < ( (size_t)( SizeInBytes - ( SizeInBytes - available + 1 ) ) ) ? UINT_MAX : ( SizeInBytes - ( SizeInBytes - available + 1 ) ) ) * sizeof( *dst ) );
                        }
                    }
                }
            }
        }
        return errResult;
    }


    //--------------------------------------------------------------------------------
    int Cstring::memcmp( const void* m1, const void* m2, size_t n )
    {
        __QCS_FCONTEXT( "Cstring::memcmp" );

        unsigned char* s1 = const_cast< unsigned char* >( reinterpret_cast< const unsigned char* >( m1 ) );
        unsigned char* s2 = const_cast< unsigned char* >( reinterpret_cast< const unsigned char* >( m2 ) );

#if		( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )//favour size over speed

        while( n-- )
        {
            if( *s1 != *s2 )
            {
                return *s1 - *s2;
            }
            s1++;
            s2++;
        }
        return 0;
#else												//favour speed over size

        unsigned long* a1;
        unsigned long* a2;

        // If the size is too small, or either pointer is unaligned,
        //then we punt to the byte compare loop.  Hopefully this will
        //not turn up in inner loops.
        if( !( n >= sizeof( long ) ) && !unaligned( s1, s2 ) )
        {
            // Otherwise, load and compare the blocks of memory one  word at a time.
            a1 = reinterpret_cast< unsigned long* >( s1 );
            a2 = reinterpret_cast< unsigned long* >( s2 );
            while( n >= sizeof( long ) )
            {
                if( *a1 != *a2 )
                {
                    break;
                }
                a1++;
                a2++;
                n -= sizeof( long );
            }

            // check m mod LBLOCKSIZE remaining characters

            s1 = reinterpret_cast< unsigned char* >( a1 );
            s2 = reinterpret_cast< unsigned char* >( a2 );
        }

        while( n-- )
        {
            if( *s1 != *s2 )
            {
                return *s1 - *s2;
            }
            s1++;
            s2++;
        }

        return 0;
#endif//!( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )
    }

    //--------------------------------------------------------------------------------
    int Cstring::strcmp( const char* s1, const char* s2 )
    {
        __QCS_FCONTEXT( "Cstring::strcmp" );
#if		( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )//favour size over speed
        while( *s1 != '\0' && *s1 == *s2 )
        {
            s1++;
            s2++;
        }

        return ( ( *( const_cast< unsigned char* >( reinterpret_cast< const unsigned char* >( s1 ) ) ) ) -
                ( *( const_cast< unsigned char* >( reinterpret_cast< const unsigned char* >( s2 ) ) ) ) );
#else												//favour speed over size
        unsigned long* a1;
        unsigned long* a2;

        // If s1 or s2 are unaligned, then compare bytes.
        if( !unaligned( s1, s2 ) )
        {
            // If s1 and s2 are word-aligned, compare them a word at a time.
            a1 = const_cast< unsigned long* >( reinterpret_cast< const unsigned long* >( s1 ) );
            a2 = const_cast< unsigned long* >( reinterpret_cast< const unsigned long* >( s2 ) );
            while( *a1 == *a2 )
            {
                // To get here, *a1 == *a2, thus if we find a null in *a1,
                //then the strings must be equal, so return zero.
                if( DETECTNULL( *a1 ) )
                {
                    return 0;
                }

                a1++;
                a2++;
            }

            // A difference was detected in last few bytes of s1, so search bytewise
            s1 = reinterpret_cast< char* >( a1 );
            s2 = reinterpret_cast< char* >( a2 );
        }

        while( *s1 != '\0' && *s1 == *s2 )
        {
            s1++;
            s2++;
        }
        return ( *( (unsigned char*) s1 ) ) - ( *( (unsigned char*) s2 ) );
#endif//!		( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )//favour size over speed
    }

    //--------------------------------------------------------------------------------
    int Cstring::strcoll( const char* s1, const char* s2 )
    {
        __QCS_FCONTEXT( "Cstring::strcoll" );
        return strcmp( s1, s2 );
    }


    //--------------------------------------------------------------------------------
    int Cstring::strncmp( const char* s1, const char* s2, size_t n )
    {
        //__QCS_FCONTEXT( "Cstring::strncmp" );

        if( n == 0 )
        {
            return 0;
        }

#if		( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )//favour size over speed

        while( n-- != 0 && *s1 == *s2 )
        {
            if( n == 0 || *s1 == '\0' )
            {
                break;
            }
            s1++;
            s2++;
        }

#else												//favour speed over size
        unsigned long *a1;
        unsigned long *a2;

        // If s1 or s2 are unaligned, then compare bytes.
        if( !unaligned( s1, s2 ) )
        {
            // If s1 and s2 are word-aligned, compare them a word at a time.
            a1 = const_cast< unsigned long* >( reinterpret_cast< const unsigned long* >( s1 ) );
            a2 = const_cast< unsigned long* >( reinterpret_cast< const unsigned long* >( s2 ) );
            while( n >= sizeof(long) && *a1 == *a2 )
            {
                n -= sizeof(long);

                // If we've run out of bytes or hit a null, return zero since we already know *a1 == *a2.
                if( n == 0 || DETECTNULL( *a1 ) )
                {
                    return 0;
                }

                a1++;
                a2++;
            }

            // A difference was detected in last few bytes of s1, so search bytewise
            s1 = reinterpret_cast< char* >( a1 );
            s2 = reinterpret_cast< char* >( a2 );
        }

        while( n-- > 0 && *s1 == *s2 )
        {
            // If we've run out of bytes or hit a null, return zero since we already know *s1 == *s2.
            if( n == 0 || *s1 == '\0' )
            {
                return 0;
            }
            s1++;
            s2++;
        }

#endif//!( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )

        return ( *( const_cast< unsigned char* >( reinterpret_cast< const unsigned char* >( s1 ) ) ) )
                - ( *( const_cast< unsigned char*>( reinterpret_cast< const unsigned char* >( s2 ) ) ) );

    }

    //--------------------------------------------------------------------------------
    int Cstring::stricmp( const char* s1, const char* s2 )
    {
        __QCS_FCONTEXT( "Cstring::stricmp" );
        while( *s1 != '\0' && tolower( *s1 ) == tolower( *s2 ) )
        {
            s1++;
            s2++;
        }

        return tolower( *( const_cast< unsigned char* >( reinterpret_cast< const unsigned char* >( s1 ) ) ) ) -
                tolower( *( const_cast< unsigned char* >( reinterpret_cast< const unsigned char* >( s2 ) ) ) );
    }

    //--------------------------------------------------------------------------------
    int Cstring::strnicmp( const char* s1, const char* s2, size_t n )
    {
        __QCS_FCONTEXT( "Cstring::strnicmp" );
        if( n == 0 )
        {
            return 0;
        }

        while( n-- != 0 && tolower( *s1 ) == tolower( *s2 ) )
        {
            if( n == 0 || *s1 == '\0' || *s2 == '\0' )
            {
                break;
            }
            s1++;
            s2++;
        }

        return tolower( *( const_cast< unsigned char* >( reinterpret_cast< const unsigned char* >( s1 ) ) ) ) -
                tolower( *( const_cast< unsigned char* >( reinterpret_cast< const unsigned char* >( s2 ) ) ) );
    }

    //--------------------------------------------------------------------------------
    size_t Cstring::strxfrm( char* s1, const char* s2, size_t n )
    {
        __QCS_FCONTEXT( "Cstring::strxfrm" );
        size_t res;
        res = 0;
        while( n-- > 0 )
        {
            if( ( *s1++ = *s2++ ) != '\0' )
            {
                ++res;
            }
            else
            {
                return res;
            }
        }

        while( *s2 )
        {
            ++s2;
            ++res;
        }

        return res;
    }

    //--------------------------------------------------------------------------------
    void* Cstring::memchr( const void* src_void, int c, size_t length )
    {
        __QCS_FCONTEXT( "Cstring::memchr" );

#if		( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )//favour size over speed

        const unsigned char* src = reinterpret_cast< const unsigned char* >( src_void );

        c &= 0xff;

        while( length-- )
        {
            if( *src == c )
            {
                return const_cast< void* >( reinterpret_cast< const void* >( src ) );
            }
            src++;
        }

#else												//favour speed over size

        const unsigned char* src = reinterpret_cast< const unsigned char* >(  src_void );
        unsigned long* asrc;
        unsigned long  buffer;
        unsigned long  mask;
        int i, j;

        c &= 0xff;

        // If the size is small, or src is unaligned, then use the bytewise loop.  We can hope this is rare.
        if( ( length >= sizeof( long ) ) && !unaligned( src ) )
        {
            /* The fast code reads the ASCII one word at a time and only
            performs the bytewise search on word-sized segments if they
            contain the search character, which is detected by XORing
            the word-sized segment with a word-sized block of the search
            character and then detecting for the presence of NULL in the
            result.  */
            asrc = const_cast< unsigned long* >( reinterpret_cast< const unsigned long* >( src ) );
            mask = 0;
            for( i = 0; i < sizeof( long ); i++ )
            {
                mask = ( mask << 8 ) + c;
            }

            while( length >= sizeof( long ) )
            {
                buffer = *asrc;
                buffer ^=  mask;
                if( DETECTNULL( buffer ) )
                {
                    src = reinterpret_cast< unsigned char* >( asrc );
                    for( j = 0; j < sizeof( long ); j++ )
                    {
                        if( *src == c )
                        {
                            return const_cast< void* >( reinterpret_cast< const void* >( src ) );
                        }
                        src++;
                    }
                }
                length -= sizeof( long );
                asrc++;
            }

            // If there are fewer than LBLOCKSIZE characters left,
            //then we resort to the bytewise loop.

            src = reinterpret_cast< unsigned char* >( asrc );
        }

        while( length-- )
        {
            if( *src == c )
            {
                return const_cast< void* >( reinterpret_cast< const void* >( src ) );
            }
            src++;
        }

#endif//!( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )

        return 0;
    }

    //--------------------------------------------------------------------------------
    char* Cstring::strchr( const char* s1, int i )
    {
        __QCS_FCONTEXT( "Cstring::strchr" );

        const unsigned char* s = reinterpret_cast< const unsigned char* >( s1 );
        unsigned char c = static_cast< unsigned char >( i );

#if		( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )//favour size over speed

        while( *s && *s != c )
        {
            s++;
        }

        if( *s != c )
        {
            s = 0;
        }

        return const_cast< char* >( reinterpret_cast< const char* >( s ) );

#else												//favour speed over size

        unsigned long mask, j;
        unsigned long* aligned_addr;

        if( !unaligned( s ) )
        {
            mask = 0;
            for( j = 0; j < sizeof( long ); j++ )
            {
                mask = ( mask << 8 ) | c;
            }

            aligned_addr = const_cast< unsigned long* >( reinterpret_cast< const unsigned long* >( s ) );
            while( !DETECTNULL( *aligned_addr ) && !DETECTCHAR( *aligned_addr, mask ) )
            {
                aligned_addr++;
            }

            // The block of bytes currently pointed to by aligned_addr contains either a null or
            //the target char, or both.  We catch it using the bytewise search.

            s = reinterpret_cast< unsigned char* >( aligned_addr );
        }

        while( *s && *s != c )
        {
            s++;
        }

        if( *s == c )
        {
            return const_cast< char* >( reinterpret_cast< const char* >( s ) );
        }

        return NULL;

#endif//!( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )

    }

    //--------------------------------------------------------------------------------
    size_t Cstring::strcspn( const char* s1, const char* s2 )
    {
        __QCS_FCONTEXT( "Cstring::strcspn" );

        const char* s = s1;
        const char* c;

        while( *s1 )
        {
            for( c = s2; *c; c++ )
            {
                if( *s1 == *c )
                {
                    break;
                }
            }

            if( *c )
            {
                break;
            }
            s1++;
        }

        return s1 - s;
    }

    //--------------------------------------------------------------------------------
    char* Cstring::strpbrk( const char* s1, const char* s2 )
    {
        __QCS_FCONTEXT( "Cstring::strpbrk" );

        const char* c = s2;

        if( !*s1 )
        {
            return 0;
        }

        while( *s1 )
        {
            for( c = s2; *c; c++ )
            {
                if( *s1 == *c )
                {
                    break;
                }
            }

            if( *c )
            {
                break;
            }
            s1++;
        }

        if( *c == '\0' )
        {
            s1 = 0;
        }

        return const_cast< char* >( s1 );
    }

    //--------------------------------------------------------------------------------
    char* Cstring::strrchr( const char* s, int i )
    {
        __QCS_FCONTEXT( "Cstring::strrchr" );

        const char* last = 0;

        if( i )
        {
            while( ( s = strchr( s, i ) ) != 0 )
            {
                last = s;
                s++;
            }
        }
        else
        {
            last = strchr( s, i );
        }

        return const_cast< char* >( last );
    }

    //--------------------------------------------------------------------------------
    size_t Cstring::strspn( const char* s1, const char* s2 )
    {
        __QCS_FCONTEXT( "Cstring::strspn" );
        const char* s = s1;
        const char* c;

        while( *s1 )
        {
            for( c = s2; *c; c++ )
            {
                if( *s1 == *c )
                {
                    break;
                }
            }

            if( *c == '\0' )
            {
                break;
            }
            s1++;
        }

        return s1 - s;
    }

    //--------------------------------------------------------------------------------
#pragma __QCMP_DISABLE_WARNING( __QCMP_WARN_COND_EXPR_IS_CONST )
    char* Cstring::strstr( const char* searchee, const char* lookfor )
    {
        __QCS_FCONTEXT( "Cstring::strstr" );

        if( *searchee == 0 )
        {
            if( *lookfor )
            {
                return 0;
            }
            return const_cast< char* >( searchee );
        }

        while( *searchee )
        {
            size_t i;
            i = 0;

            while( true )
            {
                if( lookfor[ i ] == 0 )
                {
                    return const_cast< char* >( searchee );
                }

                if( lookfor[ i ] != searchee[ i ] )
                {
                    break;
                }
                i++;
            }

            searchee++;
        }

        return 0;
    }
#pragma __QCMP_DEFAULT_WARNING( __QCMP_WARN_COND_EXPR_IS_CONST )

    //--------------------------------------------------------------------------------
    char* Cstring::strtok( char* s, const char* delim )
    {
        __QCS_FCONTEXT( "Cstring::strtok" );

#pragma TODO ("Get these from the SystemQOR common layer Execution Context" )
        bool skip_leading_delim = true;
        char** lasts = 0;

        register char* spanp;
        register int c, sc;
        char* tok;

        if( s == 0 && ( s = *lasts ) == 0 )
        {
            return 0;
        }

        //Skip (span) leading delimiters (s += strspn(s, delim), sort of).
    cont:

        c = *s++;
        for( spanp = const_cast< char* >( delim ); ( sc = *spanp++ ) != 0; )
        {
            if( c == sc )
            {
                if( skip_leading_delim )
                {
                    goto cont;
                }
                else
                {
                    *lasts = s;
                    s[ -1 ] = 0;
                    return ( s - 1 );
                }
            }
        }

        if( c == 0 ) // no non-delimiter characters
        {
            *lasts = 0;
            return 0;
        }

        tok = s - 1;

        //Scan token (scan for delimiters: s += strcspn(s, delim), sort of).
        // Note that delim must have one NUL; we stop if we see that, too.

        for( ;; )
        {
            c = *s++;
            spanp = const_cast< char* >( delim );
            do
            {
                if( ( sc = *spanp++ ) == c )
                {
                    if( c == 0 )
                    {
                        s = 0;
                    }
                    else
                    {
                        s[ -1 ] = 0;
                    }
                    *lasts = s;
                    return( tok );
                }
            } while( sc != 0 );
        }
        // NOTREACHED
    }

    //--------------------------------------------------------------------------------
    char* Cstring::strtok_r( char*, const char*, char** )
    {
        __QCS_FCONTEXT( "Cstring::strtok_r" );
#pragma TODO ("strtok_r" )
        char* pResult = 0;
        return pResult;
    }

    //--------------------------------------------------------------------------------
    char* Cstring::strtok_s( char* , const char* , char** )
    {
        __QCS_FCONTEXT( "Cstring::strtok_s" );
#pragma TODO ("strtok_s" )
        char* pResult = 0;
        return pResult;
    }

    //--------------------------------------------------------------------------------
#pragma __QCMP_DISABLE_WARNING( __QCMP_WARN_COND_EXPR_IS_CONST )
    void* Cstring::memset( void* m, int c, size_t n )
    {
        __QCS_FCONTEXT( "Cstring::memset" );

        char* s = reinterpret_cast< char* >( m );

#if		( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )//favour size over speed

        while( n-- != 0 )
        {
            *s++ = static_cast< char >( c );
        }

        return m;
#else												//favour speed over size

        int i;
        unsigned long buffer;
        unsigned long* aligned_addr;
        unsigned int d = c & 0xff;	// To avoid sign extension, copy C to an unsigned variable.

        if( ( n >= sizeof( long ) ) && !unaligned( m ) )
        {
            // If we get this far, we know that n is large and m is word-aligned.
            aligned_addr = reinterpret_cast< unsigned long* >( m );

            // Store D into each char sized location in BUFFER so that we can set large blocks quickly.
            if( sizeof( long ) == 4 )
            {
                buffer = ( d << 8 ) | d;
                buffer |= ( buffer << 16 );
            }
            else
            {
                buffer = 0;
                for( i = 0; i < sizeof( long ); i++ )
                {
                    buffer = ( buffer << 8 ) | d;
                }
            }

            while( n >= sizeof( long ) * 4 )
            {
                *aligned_addr++ = buffer;
                *aligned_addr++ = buffer;
                *aligned_addr++ = buffer;
                *aligned_addr++ = buffer;
                n -= 4 * sizeof( long );
            }

            while( n >= sizeof( long ) )
            {
                *aligned_addr++ = buffer;
                n -= sizeof( long );
            }

            // Pick up the remainder with a bytewise loop.
            s = reinterpret_cast< char* >( aligned_addr );
        }

        while( n-- )
        {
            *s++ = static_cast< char >( d );
        }

        return m;
#endif//!( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )

    }
#pragma __QCMP_DEFAULT_WARNING( __QCMP_WARN_COND_EXPR_IS_CONST )

    //--------------------------------------------------------------------------------
#pragma TODO ("Hook this up to the error mechanism" )
    char* Cstring::strerror( int errnum )
    {
        __QCS_FCONTEXT( "Cstring::strerror" );
        char* error;

        switch( errnum )
        {
        default:
            error = "";
            break;
        }

        return error;
    }

    //--------------------------------------------------------------------------------
#pragma TODO ("Hook this up to the error mechanism" )
    int Cstring::strerror_r( int errnum, char* strerrbuf, size_t buflen )
    {
        __QCS_FCONTEXT( "Cstring::strerror_r" );
        int iResult = 0;

        switch( errnum )
        {
        default:
            iResult = 0;
            break;
        }

        return iResult;
    }

    //--------------------------------------------------------------------------------
#pragma TODO ("Hook this up to the error mechanism" )
    errno_t Cstring::strerror_s( char* Buf, size_t SizeInBytes, int ErrNum )
    {
        __QCS_FCONTEXT( "Cstring::strerror_s" );
        errno_t errResult = 0;
        return errResult;
    }

    //--------------------------------------------------------------------------------
    size_t Cstring::strlen( const char* str )
    {
        __QCS_FCONTEXT( "Cstring::strlen" );

        const char* start = str;

		if( !start )
		{
			return 0;
		}

#if		( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )//favour size over speed

        while( *str )
        {
            str++;
        }

#else												//favour speed over size

        unsigned long* aligned_addr;

        if( !unaligned( str ) )
        {
            // If the string is word-aligned, we can check for the presence of
            //a null in each word-sized block.
            aligned_addr = const_cast< unsigned long* >( reinterpret_cast< const unsigned long* >( str ) );
            while( !DETECTNULL (*aligned_addr) )
            {
                aligned_addr++;
            }

            // Once a null is detected, we check each byte in that block for a precise position of the null.
            str = reinterpret_cast< char* >( aligned_addr );
        }

        while( *str )
        {
            str++;
        }

#endif//!( __QOR_PERFORMANCE < __QCS_BALANCED_PERF_ )

        return str - start;
    }

    //--------------------------------------------------------------------------------
    size_t Cstring::strnlen( const char* s, size_t MaxCount )
    {
        __QCS_FCONTEXT( "Cstring::strnlen" );
        size_t Result = 0;

        for (; Result < MaxCount && *s; Result++, s++);

        return Result;

    }

    //--------------------------------------------------------------------------------
    int Cstring::strnicoll( const char* s1, const char* s2, size_t count )
    {
        __QCS_FCONTEXT( "Cstring::strnicoll" );
        return strnicmp( s1, s2, count );
    }

    //--------------------------------------------------------------------------------
    char* Cstring::strdup( char const* str )
    {
        __QCS_FCONTEXT( "Cstring::strdup" );
        char* pResult = 0;
        __QCS_PROTECT
        {
            size_t len = strlen( str ) + 1;
            char* pResult = reinterpret_cast< char* >( ::malloc( len ) );
            if( pResult )
            {
                memcpy( pResult, str, len );
            }
        }__QCS_ENDPROTECT
        return pResult;
    }


}//nsBaseCRT

