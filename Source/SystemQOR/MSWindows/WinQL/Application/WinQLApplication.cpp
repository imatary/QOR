//WinQLApplication.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "SystemQOR.h"
__QCMP_WARNING_PUSH
__QCMP_WARNING_DISABLE( __QCMP_WARN_THIS_USED_IN_BASE_INIT_LIST, "Safe usage: saved in member for later use" );
#include "WinQL/System/FileSystem/WinQLCRTFile.h"
__QCMP_WARNING_POP
#include "WinQL/Application/WinQLApplication.h"
#include "WinQAPI/User32.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	__QOR_IMPLEMENT_OCLASS_GUID( CWin32Application, 0x11110951, 0xEBB7, 0x4B5D, 0x84, 0xFD, 0x56, 0x71, 0xA0, 0x73, 0xD0, 0x62 );
	nsCodeQOR::CTExternalRegEntry< CWin32Application > CWin32Application::RegEntry;
	CWin32Application::ref_type g_Win32Application( 0 );


	//Implement a special waitable event for handling high level application events
	//--------------------------------------------------------------------------------
	CApplicationEvent::CApplicationEvent( CWin32Application& Application ) : CEvent(0, 0, CEvent::_CREATE_EVENT_MANUAL_RESET, EVENT_MODIFY_STATE | SYNCHRONIZE, 0 )
	, m_Application( Application )
	{
	}

	//--------------------------------------------------------------------------------
	CApplicationEvent::~CApplicationEvent()
	{
	}

	//--------------------------------------------------------------------------------
	void CApplicationEvent::OnSignaled( void )
	{
		m_Application.ProcessEvent();//Cause the next high level application event to be processed
		this->Reset();//Reset this trigger event to enable processing the next high level event
	}

	//--------------------------------------------------------------------------------
	CWin32Application::ref_type CWin32Application::TheWin32Application( void )
	{
		return g_Win32Application;
	}

	//--------------------------------------------------------------------------------
	CWin32Application::CWin32Application() :
		m_bStopping( false )
	,	m_ulIdleWaitMillseconds( 100 )
	,	m_AppEvent( *this )
	,	m_pWorkflow( nullptr )
	{
		g_Win32Application.Attach( this, false );
		AddWaitableObject( m_AppEvent.Ref() );
	}

	//--------------------------------------------------------------------------------
	CWin32Application::~CWin32Application()
	{
		g_Win32Application.Detach();
	}

	//--------------------------------------------------------------------------------
	nsCodeQOR::CTLRef< CProcess > CWin32Application::Process( void )
	{
		return nsCodeQOR::CTLRef< CProcess >( nsWin32::ThisProcess(), false );
	}

	//--------------------------------------------------------------------------------
	CConsole::ref_type CWin32Application::Console( void )
	{
		return CConsole::TheWin32Console();
	}

	//--------------------------------------------------------------------------------
	void CWin32Application::SetRole( nsQOR::IRole::ref_type Role )
	{
		m_Role = Role;
	}

	//--------------------------------------------------------------------------------
	nsQOR::IRole::ref_type CWin32Application::GetRole( void )
	{
		return m_Role;
	}

	//Workflow integration
	//If the application uses a Wrokflow it is integrated here and processes all application events
	//--------------------------------------------------------------------------------
	void CWin32Application::SetWorkflow( nsQOR::IWorkflow::ref_type pWorkflow )
	{
		m_pWorkflow = pWorkflow;
	}

	//--------------------------------------------------------------------------------
	nsQOR::IWorkflow::ref_type CWin32Application::GetWorkflow( void )
	{
		return m_pWorkflow;
	}

	//--------------------------------------------------------------------------------
	bool CWin32Application::SetAutoRestart( const CWString& strCommandLine, unsigned long ulFlags )
	{
		if( m_Restart.IsNull() )
		{
			m_Restart.Attach( new CAppRestart( strCommandLine, ulFlags ), true );
			return true;
		}
		return false;
	}

	//--------------------------------------------------------------------------------
	void CWin32Application::ClearAutoRestart( void )
	{
		m_Restart.Dispose();
	}

	//--------------------------------------------------------------------------------
	bool CWin32Application::SetAutoRecovery( unsigned long ulPingIntervalMilliseconds )
	{
		if( m_Recovery.IsNull() )
		{
			m_Recovery.Attach( new CAppRecovery( ulPingIntervalMilliseconds ), true );
			return true;
		}
		return false;
	}

	//--------------------------------------------------------------------------------
	void CWin32Application::ClearAutoRecovery( void )
	{
		m_Recovery.Dispose();
	}

	//------------------------------------------------------------------------------
	void CWin32Application::SetOuter( IApplication::ref_type OuterApplication )
	{
		m_OuterApplication = OuterApplication;
	}

	//--------------------------------------------------------------------------------
	void CWin32Application::Setup( void )
	{
		_WINQ_FCONTEXT( "CWin32Application::Setup" );
		if( !m_OuterApplication.IsNull() )
		{
			m_OuterApplication->Setup();
		}
	}

	//--------------------------------------------------------------------------------
	void CWin32Application::Shutdown( void )
	{
		_WINQ_FCONTEXT( "CWin32Application::Shutdown" );
		if( !m_OuterApplication.IsNull() )
		{
			m_OuterApplication->Shutdown();
		}
	}

	//--------------------------------------------------------------------------------
	int CWin32Application::Run( nsQOR::CWorkflow::ref_type pWorkflow )
	{
		_WINQ_FCONTEXT( "CWin32Application::Run" );

		SetWorkflow( pWorkflow );

		return Run();
	}

	//--------------------------------------------------------------------------------
	int CWin32Application::Run( void )
	{
		_WINQ_FCONTEXT( "CWin32Application::Run" );

		if( !m_Role.IsNull() )
		{
			m_Role->Setup( *this );
		}

		if( m_pWorkflow )
		{
			m_pWorkflow->PushState( m_pWorkflow->InitialState(), nullptr );
		}

		RunLoop();

		if( !m_Role.IsNull() )
		{
			m_Role->Shutdown( *this );
		}
		return 0;
	}

	//--------------------------------------------------------------------------------
	void CWin32Application::RunLoop()
	{
		_WINQ_FCONTEXT( "CWin32Application::RunLoop" );
		unsigned long ulWaitResult = (unsigned long)( -1 );
		nsWinQAPI::CUser32& User32( nsWinQAPI::CUser32::Instance() );

		while( !m_bStopping )
		{
			unsigned long ulCount = m_Handles.size();

			ulWaitResult = User32.MsgWaitForMultipleObjectsEx( ulCount, (const HANDLE*)( m_Handles.data() ), m_ulIdleWaitMillseconds, QS_ALLINPUT, MWMO_ALERTABLE | MWMO_INPUTAVAILABLE );

			switch( ulWaitResult )
			{
			case Wait_Failed:
			{
				//quit
				unsigned long ulError = nsWinQAPI::CKernel32::GetLastError();
				m_bStopping = true;
			}
			break;
			case Wait_Timeout:
				//idle
				OnIdle();
				break;
			case Wait_IO_Completion:
				break;
			default:
				if( ulWaitResult >= Wait_Abandoned_0 && ulWaitResult < ( Wait_Abandoned_0 + ulCount ) )
				{
					//A mutex being waited on has been abandoned
				}
				else if( ulWaitResult >= Wait_Object_0 && ulWaitResult < ( Wait_Object_0 + ulCount ) )
				{
					//A handle being waited on has been signalled
					CWaitableObject::ref_type WaitableObject = m_VecWaitableObjects.at( ulWaitResult - Wait_Object_0 )->Ref();

					if( !WaitableObject.IsNull() )
					{
						WaitableObject->OnSignaled();
					}
				}
				else if( ulWaitResult == ( Wait_Object_0 + ulCount ) )
				{
					//Defer to Message Handler
					m_bStopping = !m_MessageHandler().RouteMessage();
				}
			}
		}
	}

	//--------------------------------------------------------------------------------
	void CWin32Application::OnIdle( void )
	{
		//Defer OnIdle processing to Workflow
		if (m_pWorkflow)
		{
			m_pWorkflow->OnIdle();
		}
	}

	//--------------------------------------------------------------------------------
	void CWin32Application::Stop( void )
	{
		_WINQ_FCONTEXT( "CWin32Application::Stop" );
		m_bStopping = true;
	}

	//--------------------------------------------------------------------------------
	void CWin32Application::AddWaitableObject( CWaitableObject::ref_type WaitableObject )
	{
		_WINQ_FCONTEXT( "CWin32Application::AddWaitableObject" );
		if( m_VecWaitableObjects.size() < MAXIMUM_WAIT_OBJECTS )
		{
			m_VecWaitableObjects.push_back( WaitableObject );
			m_Handles.push_back( WaitableObject->Handle()->Use() );
		}
	}

	//--------------------------------------------------------------------------------
	void CWin32Application::RemoveWaitableObject( CWaitableObject::ref_type WaitableObject )
	{
		_WINQ_FCONTEXT( "CWin32Application::RemoveWaitableObject" );
		m_Handles.erase( std::remove( m_Handles.begin(), m_Handles.end(), WaitableObject->Handle()->Use() ), m_Handles.end() );		
		m_VecWaitableObjects.erase( std::remove( m_VecWaitableObjects.begin(), m_VecWaitableObjects.end(), WaitableObject ), m_VecWaitableObjects.end() );
	}

	//--------------------------------------------------------------------------------
	unsigned long CWin32Application::GetIdleWaitMilliseconds()
	{
		return m_ulIdleWaitMillseconds;
	}

	//--------------------------------------------------------------------------------
	void CWin32Application::SetIdleWaitMilliseconds( unsigned long ulMilliseconds )
	{
		m_ulIdleWaitMillseconds = ulMilliseconds;
	}

	//--------------------------------------------------------------------------------
	//Process an application level event from the queue
	void CWin32Application::ProcessEvent( void )
	{
		_WINQ_FCONTEXT( "CWin32Application::ProcessEvent" );
		while( m_AppEventQueue.size() > 0 )
		{
			nsQOR::IEvent* pEvent = m_AppEventQueue.front();
			m_AppEventQueue.pop_front();
			if( m_pWorkflow && m_pWorkflow->CurrentState() )
			{
				m_pWorkflow->CurrentState()->HandleEvent( pEvent );
			}
		}
	}

	//--------------------------------------------------------------------------------
	//Use triggering of an internal event to process an a high level application event through the queue
	void CWin32Application::EnqueueEvent( nsQOR::IEvent::ref_type pEvent )
	{
		_WINQ_FCONTEXT( "CWin32Application::EnqueueEvent" );
		m_AppEventQueue.push_back( pEvent.operator->() );
		m_AppEvent.Set();
	}

	/*
	//--------------------------------------------------------------------------------
	bool CBaseApplication::GetStartupInfo( void )
	{
		bool bStartupInfo = true;

        __QCMP_TRY
		{
			//GetStartupInfo can throw unspecified SEH
            ThisProcess()->GetStartupInfo( &m_StartupInfo );
        }
		__QCMP_EXCEPT( nsWin32::eEXCEPTION_EXECUTE_HANDLER ) 
		{
            bStartupInfo = false;
        }

		return bStartupInfo;
	}
	*/

}//nsWin32

