//WinQLMallocSpy.cpp

// Copyright Querysoft Limited 2013, 2015, 2017
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/CodeServices/WinQLPolicy.h"
#include "WinQL/Application/Threading/WinQLCriticalSection.h"
#include <assert.h>
#include "WinQL/COM/Server/Impls/WinQLMallocSpy.h"
#include "WinQAPI/OLE32.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{ 
	__QOR_IMPLEMENT_COMCLASS_ID( CMallocSpy, IMallocSpy, 0x0000001d, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 );

	const GUID IMallocSpy::_IID = { 0x0000001d, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };

	//--------------------------------------------------------------------------------
	CMallocSpy::CMallocSpy()
	{
		_WINQ_FCONTEXT( "CMallocSpy::CMallocSpy" );
		m_BytesRequested = 0;
		m_ulAllocationCount = 0;
		RegisterInterface( dynamic_cast< IMallocSpy* >( this ) );
	}

	//--------------------------------------------------------------------------------
	CMallocSpy::~CMallocSpy()
	{
		_WINQ_FCONTEXT( "CMallocSpy::~CMallocSpy" );
		m_ListAllocs.Free();
	}

	//--------------------------------------------------------------------------------
	Cmp_ulong_ptr CMallocSpy::PreAlloc( Cmp_ulong_ptr cbRequest )
	{
		_WINQ_FCONTEXT( "CMallocSpy::PreAlloc" );
		m_BytesRequested = cbRequest;
		return ( m_BytesRequested + ulHeaderSize + ulFooterSize );
	}

	//--------------------------------------------------------------------------------
	void* CMallocSpy::PostAlloc( void* pActual )
	{
		_WINQ_FCONTEXT( "CMallocSpy::PostAlloc" );
	
		if( pActual == 0 )
		{
			return 0;
		}

		AddToList( Users_Offset( pActual ) );
		Head_Signature( pActual ) = cHeadSign;
		Buffer_Length( pActual ) = m_BytesRequested;
		
		unsigned long ulID = ++m_ulAllocationCount;		//Place the ID in the HEADER
		Buffer_Id( pActual ) = ulID;
		
		Buffer_FileName( pActual ) = 0;					//Place the FILENAME in the HEADER
		Buffer_LineNumber( pActual ) = 0;				//Place the LINE NUMBER in the HEADER
		
		memset( Users_Offset( pActual ), cAllocSign, m_ulAllocationCount );		//Set the UsersBuffer to a known char

		Tail_Signature( pActual ) = cTailSign;			//Place the TailSigniture in the HEADER

		//Show Allocation
		/*
		if(GetErrorPosting(EP_IMALLOC_ALLOCS))
			InternalTraceFmt(L"TRACE - IMallocSpy Alloc - 0x%p,\tID=%08lu,\t%Iu byte(s)\n", Users_Offset(pActual), ulID, m_BytesRequested );
			*/

		
		if( m_ulBreakID == ulID )						//Break at indicated Allocation
		{
			m_DebugHelper.Break();
		}
		
		return Users_Offset( pActual );					// Return the actual users buffer
	}

	//--------------------------------------------------------------------------------
	//pRequest is the users pointer to their buffer, not the header
	void* CMallocSpy::PreFree( void* pRequest, int fSpyed )
	{
		_WINQ_FCONTEXT( "CMallocSpy::PreFree" );
		
		//E_OUTOFMEMORY condition
		if( !pRequest )
		{
			return 0;
		}

		//If this memory was alloced under IMallocSpy, need to remove it
		if( fSpyed )
		{			
			RemoveFromList( pRequest );							//Remove this pointer from the list
	
			void* pActual = Header_Offset( pRequest );
			unsigned long ulID = Buffer_Id( pActual );
					
			if( Head_Signature( pActual ) != cHeadSign )		//Make sure that the head/tail signitures are intact
			{
				//InternalTraceFmt(L"TRACE - IMallocSpy HeadSigniture Corrupted! - 0x%p, ID=%08lu, %Iu byte(s)\n", pRequest, ulID, Buffer_Length(pActual));
			}

			if( Tail_Signature( pActual ) != cTailSign )
			{
				//InternalTraceFmt(L"TRACE - IMallocSpy TailSigniture Corrupted! - 0x%p, ID=%08lu, %Iu byte(s)\n", pRequest, ulID, Buffer_Length(pActual));
			}
			
			if( m_ulBreakID == ulID )							//Break at indicated Allocation
			{
				m_DebugHelper.Break();
			}
			
			memset(pRequest, cFreeSign, Buffer_Length(pActual));	//Set the UsersBuffer to a known char			
			return pActual;										//Need to return the actual header pointer to free the entire buffer including the heading
		}

		//else
		return pRequest;
	}

	//--------------------------------------------------------------------------------
	void CMallocSpy::PostFree( int fSpyed )
	{
		_WINQ_FCONTEXT( "CMallocSpy::PostFree" );
		QOR_PP_UNREF( fSpyed );
	}

	//--------------------------------------------------------------------------------
	Cmp_ulong_ptr CMallocSpy::PreRealloc( void* pRequest, Cmp_ulong_ptr cbRequest, void** ppNewRequest, int fSpyed )
	{
		_WINQ_FCONTEXT( "CMallocSpy::PreRealloc" );
		
		assert( pRequest && ppNewRequest );
    
		//If this was alloced under IMallocSpy we need to adjust the size stored in the header
		if( fSpyed )
		{			
			RemoveFromList( pRequest );					//Remove the original pRequest pointer from the list since Realloc could change the original pointer
			*ppNewRequest = Header_Offset( pRequest );	//Find the start 				
			m_BytesRequested = cbRequest;				//Store the new desired size			
			return ( m_BytesRequested + ulHeaderSize + ulFooterSize );		//Return the total size, including extra
		}

		*ppNewRequest = pRequest;
		return cbRequest;
	}

	//--------------------------------------------------------------------------------
	void* CMallocSpy::PostRealloc( void* pActual, int fSpyed )
	{
		_WINQ_FCONTEXT( "CMallocSpy::PostRealloc" );

		
		if( !pActual )
		{
			return 0;										//E_OUTOFMEMORY condition
		}
		
		if( fSpyed )										//If this buffer was alloced under IMallocSpy
		{
			
			AddToList( Users_Offset( pActual ) );			//pActual is the pointer to header. Add the new pointer to the list
			
			if( Head_Signature( pActual ) != cHeadSign )	//HeadSigniture should still be intact
			{
				//InternalTraceFmt(L"TRACE - IMallocSpy HeadSigniture Corrupted! - 0x%p, ID=%08lu, %Iu byte(s)\n", Users_Offset(pActual), Buffer_Id(pActual), Buffer_Length(pActual));
			}
		
			//ID should still be intact

			
			Buffer_Length( pActual ) = m_BytesRequested;	//Place the new Size in the HEADER
			Buffer_FileName( pActual ) = 0;					//Place the new FileName in the HEADER
			Buffer_LineNumber( pActual ) = 0;				//Place the new Line Number in the HEADER
			Tail_Signature( pActual ) = cTailSign;			//Need to place the tail signiture again, since it will be over written by the realloc

			//Show ReAllocations
			/*
			if(GetErrorPosting(EP_IMALLOC_ALLOCS))
				InternalTraceFmt(L"TRACE - IMallocSpy Realloc - 0x%p,\tID=%08lu,\t%Iu byte(s)\n", Users_Offset(pActual), Buffer_Id(pActual), m_BytesRequested);
			*/
			
			return Users_Offset( pActual );					//Return the actual "user" buffer
		}
    
		//else
		return pActual;
	}

	//--------------------------------------------------------------------------------
	void* CMallocSpy::PreGetSize( void* pRequest, int fSpyed )
	{
		_WINQ_FCONTEXT( "CMallocSpy::PreGetSize" );

		if( fSpyed )
		{
			return Header_Offset( pRequest );
		}

		return pRequest;
	}

	//--------------------------------------------------------------------------------
	Cmp_ulong_ptr CMallocSpy::PostGetSize( Cmp_ulong_ptr cbActual, int fSpyed )
	{
		_WINQ_FCONTEXT( "CMallocSpy::PostGetSize" );
		
		if( fSpyed )
		{
			return cbActual - ulHeaderSize - ulFooterSize;
		}

		return cbActual;
	}
		
	//--------------------------------------------------------------------------------
	void* CMallocSpy::PreDidAlloc( void* pRequest, int fSpyed )
	{
		_WINQ_FCONTEXT( "CMallocSpy::PreDidAlloc" );
		
		if( fSpyed )
		{
			return Header_Offset( pRequest );
		}

		return pRequest;
	}

	//--------------------------------------------------------------------------------
	int CMallocSpy::PostDidAlloc( void* pRequest, int fSpyed, int fActual )
	{
		_WINQ_FCONTEXT( "CMallocSpy::PostDidAlloc" );

		QOR_PP_UNREF2( pRequest, fSpyed );
		return fActual;
	}

	//--------------------------------------------------------------------------------
	void CMallocSpy::PreHeapMinimize( void )
	{
		_WINQ_FCONTEXT( "CMallocSpy::PreHeapMinimize" );
	}

	//--------------------------------------------------------------------------------
	void CMallocSpy::PostHeapMinimize( void )
	{
		_WINQ_FCONTEXT( "CMallocSpy::PostHeapMinimize" );
	}

	//--------------------------------------------------------------------------------
	long CMallocSpy::AddToList( void* pv )
	{
		_WINQ_FCONTEXT( "CMallocSpy::AddToList" );
		
		if( pv != 0 )
		{
			m_ListAllocs.Append( pv );
		}
		return OK;
	}

	//--------------------------------------------------------------------------------
	long CMallocSpy::RemoveFromList( void* pv )
	{
		_WINQ_FCONTEXT( "CMallocSpy::RemoveFromList" );
		
		unsigned long ulPosition = 0;
		while( ulPosition < m_ListAllocs.Size() )
		{
			if( m_ListAllocs[ ulPosition ] == pv )
			{
				m_ListAllocs.RemoveAt( ulPosition );
				return OK;
			}
			ulPosition++;
		}

		return E_Fail;
	}

	//--------------------------------------------------------------------------------
	long CMallocSpy::DumpLeaks( void )
	{
		_WINQ_FCONTEXT( "CMallocSpy::DumpLeaks" );
		unsigned long	cTotalLeaks	= 0;
		size_t	cTotalBytes	= 0;
		unsigned long dwSelection = 0;//IDOK;

		//Display Leaks to the Output Window
		while( m_ListAllocs.Size() != 0 )
		{	
			//Obtain the pointer to the leaked memory
			void* pRequest = m_ListAllocs[ 0 ];
			assert(pRequest);

			m_ListAllocs.RemoveAt( 0 );
		
			void* pActual = Header_Offset(pRequest);
			assert(pActual);

			//Make sure that the head/tail signitures are intact
			if( Head_Signature( pActual ) != cHeadSign )
			{
				//InternalTraceFmt(L"TRACE - IMallocSpy HeadSigniture Corrupted! - 0x%p, ID=%08lu, %Iu byte(s)\n", pRequest, Buffer_Id(pActual), Buffer_Length(pActual));
			}

			if( Tail_Signature( pActual ) != cTailSign )
			{
				//InternalTraceFmt(L"TRACE - IMallocSpy TailSigniture Corrupted! - 0x%p, ID=%08lu, %Iu byte(s)\n", pRequest, Buffer_Id(pActual), Buffer_Length(pActual));
			}

			size_t			ulSize		 = Buffer_Length(pActual);
			//unsigned long	ulID		 = Buffer_Id(pActual);
			//wchar_t*		pwszFileName = Buffer_FileName(pActual);
			//unsigned long	ulLine		 = Buffer_LineNumber(pActual);
		
			//Display a message box for all leaks (until the user is tired of it...)
			
			if( dwSelection == 0 )
			{
				/*
				dwSelection = wMessageBox( GetFocus(), MB_TASKMODAL | MB_ICONWARNING | MB_OKCANCEL | MB_DEFBUTTON1, 
					L"IMallocSpy Leak", 
						L"IMallocSpy Leak:\n"
						L"0x%p, ID=%08lu, %Iu byte(s), File: %s, Line %d\n\n",
						pRequest, ulID, ulSize, pwszFileName, ulLine);
						*/
			}
			
			//Include FileName and Line Number of the leak...
			//InternalTraceFmt(L"-- IMallocSpy Leak! - 0x%p,\tID=%08lu,\t%Iu byte(s),\tFile: %s,\tLine %d" wWndEOL, pRequest, ulID, ulSize, pwszFileName, ulLine);
		
			cTotalLeaks++;
			cTotalBytes += ulSize;

			//Free the Leak
			//You really cant free the leak since the app could be potentially still
			//using it.  Or the DLL may still be in use or have attached threads...
			//SAFE_FREE(pActual);
		}

		if(cTotalLeaks)
		{
			//InternalTraceFmt(L"-- IMallocSpy Total Leaks: %lu = %Iu byte(s)" wWndEOL, cTotalLeaks, cTotalBytes);
		}
		return OK;

	}

	//--------------------------------------------------------------------------------
	void CMallocSpy::Reset( void )
	{
		_WINQ_FCONTEXT( "CMallocSpy::Reset" );
		m_ulAllocationCount = 0;
	}

}//nsWin32
