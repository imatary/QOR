//CharDecl.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//WinQL Character class

#ifndef WINQL_CS_TXT_CHARDECL_H_3
#define WINQL_CS_TXT_CHARDECL_H_3

#include <assert.h>
#include <errno.h>
#include <wctype.h>
#include "CodeQOR/DataTypes/OTypes.h"

#include "WinQL/Application/ErrorSystem/WinQLError.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	class CLocaleThreadData;

	template< typename TType > struct Char;	//Forward declare the Char template

	typedef Char< unsigned char >		SBUChar;	    //Single Byte Unsigned Character
	typedef Char< signed char >			SBSChar;	//Single Byte Signed Character

	//Forward declare the supported character types	
#if		( __QCMP_DEFINED_COMPILERDEFAULTSIGNEDCHAR == 1 )//The compiler uses a default char that is signed
	typedef SBSChar SBChar;							//Single Byte Character with default signing
#else
	typedef SBUChar SBChar;                         //Single Byte Character with default signing
#endif//( __QCMP_DEFINED_COMPILERDEFAULTSIGNEDCHAR == 1 )

	typedef Char< int >					UTF32Char;	//Full unicode code point - UTF-32 representation 
	typedef Char< unsigned short >		UTF16Char;	//UTF-16 16 Bit Character or sub character unit
	typedef UTF32Char					IChar;		//Integer Character analogue for C library. Many C Lib functions take an int for char operations

	//Set the default character type according to the ANSI/UNICODE compilation options
#if ( __QOR_UNICODE  == __QCS_YES_ )
	typedef UTF16Char mxChar;
#else
    typedef SBChar mxChar;
#endif

	//--------------------------------------------------------------------------------
	template< typename TType >
	struct Char : public nsCodeQOR::BaseChar< Char< TType >, TType >
	{
		typedef nsCodeQOR::BaseChar< Char< TType >, TType > BaseName;

	public:

		__QOR_DECLARE_OCLASS_ID( Char );

        __QCMP_USING_BASE( m );
		typedef TType char_type;		//enable access to the fundamental type being stored

		//--------------------------------------------------------------------------------
		Char()
		{
			m = 0;
		}

        //--------------------------------------------------------------------------------
        Char( const char_type& src )
        {
            m = src;
        }

		//--------------------------------------------------------------------------------
		template< typename TTSource >
		Char( const Char< TTSource >& src )
		{			
			*this = src;
		}

		//--------------------------------------------------------------------------------
		void operator = ( const char_type& src )
		{
			m = src;
		}

		//--------------------------------------------------------------------------------
		template< typename TTSource >
		void operator = ( const Char< TTSource >& src )
		{ 				
			src.Convert( &this->m );
		} 

		//--------------------------------------------------------------------------------
		char To_char() const;
		signed char To_schar() const;
		unsigned char To_uchar() const;
		unsigned int To_uint() const;
		int To_int() const;
		wchar_t To_wchar() const;

		//--------------------------------------------------------------------------------
		//Used to get a const fundamental string pointer from a Char
		const TType* c_str() const
		{
			return &this->m;
		}

		//--------------------------------------------------------------------------------
		template< typename TDest >
		operator TDest()
		{
			TDest dest;
			int iResult = Convert( &dest );
			if( iResult == 0 )
			{
				//TODO: Raise a char conversion fault;
				dest = 0;
			}
			return dest;
		}

		//--------------------------------------------------------------------------------
		int Convert( char* pDst ) const
		{
			if( pDst != 0 )
			{
				*pDst = To_char();
				return 1;
			}
			return 0;
		}

		//--------------------------------------------------------------------------------
		int Convert( signed char* pDst ) const
		{
			if( pDst != 0 )
			{
				*pDst = To_schar();
				return 1;
			}
			return 0;
		}

		//--------------------------------------------------------------------------------
		int Convert( unsigned char* pDst ) const
		{
			if( pDst != 0 )
			{
				*pDst = To_uchar();
				return 1;
			}
			return 0;
		}

		//--------------------------------------------------------------------------------
		int Convert( unsigned int* pDst ) const
		{
			if( pDst != 0 )
			{
				*pDst = To_uint();
				return 1;
			}
			return 0;
		}

		//--------------------------------------------------------------------------------
		int Convert( int* pDst ) const
		{
			if( pDst != 0 )
			{
				*pDst = To_int();
				return 1;
			}
			return 0;
		}

		//--------------------------------------------------------------------------------
		int Convert( wchar_t* pDst ) const
		{
			if( pDst != 0 )
			{
				*pDst = To_wchar();
				return 1;
			}
			return 0;
		}

		bool isalnum() const;
		bool isalpha() const;
		bool ascii_isalpha() const;

		//------------------------------------------------------------------------------
		bool isascii() const
		{
			return ( (unsigned)m < 0x80 ) ? true : false;
		}

		bool isblank() const;
		bool iscntrl() const;
		bool isdigit() const;
		bool isgraph() const;
		bool islower() const;
		bool isprint() const;
		bool ispunct() const;
		bool isspace() const;
		bool isupper() const;
		bool isxdigit() const;
		int toascii() const;
		int tolower() const;
		int ascii_tolower() const;
		int toupper() const;
		int ascii_toupper() const;

		bool isalnum( CLocaleThreadData* pLocaleThreadData ) const;
		bool isalpha( CLocaleThreadData* pLocaleThreadData ) const;
		bool isblank( CLocaleThreadData* pLocaleThreadData ) const;
		bool iscntrl( CLocaleThreadData* pLocaleThreadData ) const;
		bool isdigit( CLocaleThreadData* pLocaleThreadData ) const;
		bool isgraph( CLocaleThreadData* pLocaleThreadData ) const;
		bool islower( CLocaleThreadData* pLocaleThreadData ) const;
		bool isprint( CLocaleThreadData* pLocaleThreadData ) const;
		bool ispunct( CLocaleThreadData* pLocaleThreadData ) const;
		bool isspace( CLocaleThreadData* pLocaleThreadData ) const;
		bool isupper( CLocaleThreadData* pLocaleThreadData ) const;
		bool isxdigit( CLocaleThreadData* pLocaleThreadData ) const;
		int tolower( CLocaleThreadData* pLocaleThreadData ) const;
		int toupper( CLocaleThreadData* pLocaleThreadData ) const;
		bool isleadbyte( CLocaleThreadData* pLocaleThreadData ) const;
		int todigit() const;

	private:

		int ischartype( int iFlag, CLocaleThreadData* pLocaleThreadData ) const;
		int isctype( int mask, CLocaleThreadData* plocinfo ) const;

		//#define chvalidchk( _Flag, _Locale) chvalidator( _Locale, _Flag )		
		#define __fast_ch_check( mask ) chvalidator( 0, mask )

		int chvalidator( CLocaleThreadData* plocinfo, int mask ) const;

	};

	template struct __QOR_INTERFACE( __WINQL ) Char< unsigned char >;
	template struct __QOR_INTERFACE( __WINQL ) Char< signed char >;
	//template struct __QOR_INTERFACE( __WINQL ) Char< char >;
	//template struct __QOR_INTERFACE( __WINQL ) Char< unsigned int >;
	template struct __QOR_INTERFACE( __WINQL ) Char< unsigned short >;
	template struct __QOR_INTERFACE( __WINQL ) Char< int >;

	nsCodeQOR::Bool operator == ( const UTF16Char&, const UTF16Char& );

}//nsWin32

#endif//WINQL_CS_TXT_CHARDECL_H_3
