//WinQLLSAPolicy.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/Definitions/Constants.h"
#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "WinQL/System/Security/WinQLLSAPolicy.h"
#include "WinQAPI/AdvAPI32.h"

using namespace nsWinQAPI;

//--------------------------------------------------------------------------------
namespace nsWin32
{
	__QOR_IMPLEMENT_OCLASS_LUID( CLSAUnicodeString );
	__QOR_IMPLEMENT_OCLASS_LUID( CLSAUnicodeStringArray );

	//--------------------------------------------------------------------------------
	CLSAUnicodeStringArray::CLSAUnicodeStringArray( nsWin32::LSAUnicodeString* pSrcArray, unsigned long ulCount ) : m_AdvAPI32Library( CAdvAPI32::Instance() )
	{
		_WINQ_FCONTEXT( "CLSAUnicodeStringArray::CLSAUnicodeStringArray" );
		m_pLSAArray = pSrcArray;
		m_pStrArray = 0;
		m_bFreeLSA = true;
		m_bFreeLSAArray = false;
        m_bFreeString = false;
		m_ulCount = ulCount;
	}

	//--------------------------------------------------------------------------------
	CLSAUnicodeStringArray::CLSAUnicodeStringArray( wchar_t** pStrArray, unsigned long ulCount ) : m_AdvAPI32Library( CAdvAPI32::Instance() )
	{
		_WINQ_FCONTEXT( "CLSAUnicodeStringArray::CLSAUnicodeStringArray" );
		m_pLSAArray = 0;
		m_pStrArray = pStrArray;
		m_bFreeLSA = false;
		m_bFreeLSAArray = false;
        m_bFreeString = false;
		m_ulCount = ulCount;
	}

	//--------------------------------------------------------------------------------
	CLSAUnicodeStringArray::~CLSAUnicodeStringArray()
	{
		_WINQ_FCONTEXT( "CLSAUnicodeStringArray::~CLSAUnicodeStringArray" );
		if( m_bFreeLSA )
		{
			m_AdvAPI32Library.LsaFreeMemory( m_pLSAArray );
		}
		if( m_bFreeLSAArray )
		{
            for( ULONG ulIndex = 0; ulIndex < m_ulCount; ulIndex++ )
            {
                delete m_pLSAArray[ ulIndex ].Buffer;
                m_pLSAArray[ ulIndex ].Buffer = 0;
            }
			delete [] m_pLSAArray;
		}
		if ( m_bFreeString )
		{
			for( ULONG ulIndex = 0; ulIndex < m_ulCount; ulIndex++ )
			{
				delete m_pStrArray[ ulIndex ];
			}
			delete [] m_pStrArray;
		}
					
	}

	//--------------------------------------------------------------------------------
	CLSAUnicodeStringArray::operator nsWin32::LSAUnicodeString*( void )
	{
		_WINQ_FCONTEXT( "CLSAUnicodeStringArray::operator LSAUnicodeString*" );
		if( m_pStrArray != 0 && m_pLSAArray == 0 )
		{
			m_pLSAArray = new LSAUnicodeString[ m_ulCount ];
			for( ULONG ulIndex = 0; ulIndex < m_ulCount; ulIndex++ )
			{
				m_pLSAArray[ ulIndex ].Length = static_cast< USHORT >( wcslen( m_pStrArray[ ulIndex ] ) * sizeof(WCHAR) );
				m_pLSAArray[ ulIndex ].MaximumLength = static_cast< USHORT >( m_pLSAArray[ ulIndex ].Length + sizeof(WCHAR) );
                m_pLSAArray[ ulIndex ].Buffer = new WCHAR[ m_pLSAArray[ ulIndex ].MaximumLength / sizeof( WCHAR ) ];
				memcpy( m_pLSAArray[ ulIndex ].Buffer, m_pStrArray[ ulIndex ], m_pLSAArray[ ulIndex ].Length );
                m_pLSAArray[ ulIndex ].Buffer[ m_pLSAArray[ ulIndex ].MaximumLength / sizeof(WCHAR) ] = (WCHAR)(0);
			}
            m_bFreeLSAArray = true;
		}
		return m_pLSAArray;
	}

	//--------------------------------------------------------------------------------
	CLSAUnicodeStringArray::operator wchar_t**()
	{
		_WINQ_FCONTEXT( "CLSAUnicodeStringArray::operator wchar_t**" );
		if( m_pStrArray == 0 && m_pLSAArray != 0 )
		{
			m_pStrArray = new wchar_t*[ m_ulCount ];
			for( ULONG ulIndex = 0; ulIndex < m_ulCount; ulIndex++ )
			{
				m_pStrArray[ ulIndex ] = new WCHAR[ m_pLSAArray[ ulIndex ].Length + 1 ];
				memcpy( m_pStrArray[ ulIndex ], m_pLSAArray[ ulIndex ].Buffer, m_pLSAArray[ ulIndex ].Length * sizeof(WCHAR ) );
				m_pStrArray[ ulIndex ][ m_pLSAArray[ ulIndex ].Length ] = 0;
			}
            m_bFreeString = true;
		}
		return m_pStrArray;
	}

	//--------------------------------------------------------------------------------

	//--------------------------------------------------------------------------------
	CLSAUnicodeString::CLSAUnicodeString()
	{
		_WINQ_FCONTEXT( "CLSAUnicodeString::CLSAUnicodeString" );
		Length = 0;
		MaximumLength = 0;
		Buffer = 0;
		m_bFree = false;
		m_pContainedString = 0;
	}

	//--------------------------------------------------------------------------------
	CLSAUnicodeString::CLSAUnicodeString( wchar_t* Str )
	{
		_WINQ_FCONTEXT( "CLSAUnicodeString::CLSAUnicodeString" );
		if( Str != 0 )
		{
			Length = static_cast< USHORT >( wcslen( Str ) * sizeof(WCHAR) );
			MaximumLength = ( Length + sizeof(WCHAR) );
		}
		else
		{
			Length = 0;
			MaximumLength = 0;
		}
		Buffer = Str;
		m_bFree = false;
		m_pContainedString = 0;
	}

	//--------------------------------------------------------------------------------
	CLSAUnicodeString::CLSAUnicodeString( const nsWin32::LSAUnicodeString* pLSAString )
	{
		_WINQ_FCONTEXT( "CLSAUnicodeString::CLSAUnicodeString" );
		Length = pLSAString->Length;
		MaximumLength = pLSAString->MaximumLength;
		Buffer = pLSAString->Buffer;
		m_pContainedString = const_cast< UnicodeString* >( pLSAString );
		m_bFree = true;
	}

	//--------------------------------------------------------------------------------
	CLSAUnicodeString::~CLSAUnicodeString()
	{
		_WINQ_FCONTEXT( "CLSAUnicodeString::~CLSAUnicodeString" );
		if( m_bFree )
		{
			CAdvAPI32 AdvAPI32Library;
			AdvAPI32Library.LsaFreeMemory( m_pContainedString );
		}
	}

	//--------------------------------------------------------------------------------
	CLSAUnicodeString::operator wchar_t*()
	{
		_WINQ_FCONTEXT( "CLSAUnicodeString::operator LPWSTR" );
		if( m_pContainedString == 0 && Buffer != 0 )
		{						
			LPWSTR pStr = new WCHAR[ ( Length / sizeof( WCHAR ) ) + 1 ];
			memcpy( pStr, Buffer, Length );
			pStr[ ( Length / sizeof( WCHAR ) ) ] = 0;
			return pStr;
		}
		else if( m_pContainedString != 0 )
		{
			LPWSTR pStr = new WCHAR[ ( m_pContainedString->Length / sizeof( WCHAR ) ) + 1 ];
			memcpy( pStr, m_pContainedString->Buffer, m_pContainedString->Length );
			pStr[ ( m_pContainedString->Length / sizeof( WCHAR ) ) ] = 0;
			return pStr;
		}
		return 0;
	}

	//--------------------------------------------------------------------------------				
	bool CLSAUnicodeString::Orphan( nsWin32::LSAUnicodeString*& pString )
	{
		_WINQ_FCONTEXT( "CLSAUnicodeString::Orphan" );
		bool bResult = m_bFree;
		m_bFree = false;
		pString = m_pContainedString;
		return bResult;
	}

	//--CLSAPolicy--------------------------------------------------------------------

	__QOR_IMPLEMENT_OCLASS_LUID( CLSAPolicy );

	//--------------------------------------------------------------------------------
	CLSAPolicy::CLSAPolicy( wchar_t* strSystemName, unsigned long DesiredAccess ) : m_AdvAPI32Library( CAdvAPI32::Instance() )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::CLSAPolicy" );
        __QOR_PROTECT
        {
			memset( &m_Attributes, 0, sizeof( LSAObjectAttributes ) );
			m_Attributes.Length = sizeof( ::LSA_OBJECT_ATTRIBUTES );
			CLSAUnicodeString SystemName( strSystemName );
			m_Status = m_AdvAPI32Library.LsaOpenPolicy( strSystemName ? reinterpret_cast< ::PLSA_UNICODE_STRING >( &SystemName ) : 0, reinterpret_cast< ::PLSA_OBJECT_ATTRIBUTES >( &m_Attributes ), DesiredAccess, &m_PolicyHandle );
        }__QOR_ENDPROTECT
	}

	//--------------------------------------------------------------------------------
	CLSAPolicy::~CLSAPolicy()
	{
		_WINQ_FCONTEXT( "CLSAPolicy::~CLSAPolicy" );
		m_Status = m_AdvAPI32Library.LsaClose( m_PolicyHandle );
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::AddAccountRights( void* AccountSid, wchar_t** paRights, unsigned long CountOfRights )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::AddAccountRights" );
		bool bResult = false;
        __QOR_PROTECT
        {
			if( m_Status == STATUS_SUCCESS )
			{
				CLSAUnicodeStringArray RightsArray( paRights, CountOfRights );
				bResult = ( m_AdvAPI32Library.LsaAddAccountRights( m_PolicyHandle, AccountSid, reinterpret_cast< ::PLSA_UNICODE_STRING >( RightsArray.operator nsWin32::LSAUnicodeString*() ), CountOfRights ) == STATUS_SUCCESS );
			}
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::EnumerateAccountRights( void* AccountSid, nsCodeQOR::CTLinkedList< nsWin32::CWString::ref_type >& Rights )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::EnumerateAccountRights" );
		bool bResult = false;
		__QOR_PROTECT
		{
			if( m_Status == STATUS_SUCCESS )
			{
				LSAUnicodeString* UserRights = 0;
                ULONG CountOfRights = 0;
				bResult = ( m_AdvAPI32Library.LsaEnumerateAccountRights( m_PolicyHandle, AccountSid, reinterpret_cast< ::PLSA_UNICODE_STRING* >( &UserRights ), &CountOfRights ) == STATUS_SUCCESS );
				if( bResult )
				{
					for( ULONG ulIndex = 0; ulIndex < CountOfRights; ulIndex++ )
					{
						CWString wstr;
						wchar_t* pBuffer = wstr.GetBufferSetLength( ( UserRights[ ulIndex ].Length / sizeof(WCHAR) ) + 1 );								
						memcpy( pBuffer, UserRights[ ulIndex ].Buffer, UserRights[ ulIndex ].Length );
						Rights.Append( new CWString::ref_type( wstr() ) );
					}
				}
			}
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::EnumerateAccountsWithUserRight( wchar_t* strRight, void** EnumerationBuffer, unsigned long* CountReturned )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::EnumerateAccountsWithUserRight" );
		bool bResult = false;
        __QOR_PROTECT
        {
			*CountReturned = 0;
			*EnumerationBuffer = 0;
			if( m_Status == STATUS_SUCCESS )
			{
				CLSAUnicodeString LSAString( strRight );
				bResult = ( m_AdvAPI32Library.LsaEnumerateAccountsWithUserRight( m_PolicyHandle, ( strRight != 0 ) ? reinterpret_cast< ::PLSA_UNICODE_STRING >( &LSAString ) : 0, EnumerationBuffer, CountReturned ) == STATUS_SUCCESS );
			}
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::EnumerateTrustedDomains( unsigned long* EnumerationContext, void** Buffer, unsigned long PreferedMaximumLength, unsigned long* CountReturned )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::EnumerateTrustedDomains" );
		bool bResult = false;
        __QOR_PROTECT
        {
			*Buffer = 0;
			*CountReturned = 0;
			if( m_Status == STATUS_SUCCESS )
			{ 
				bResult = ( m_AdvAPI32Library.LsaEnumerateTrustedDomains( m_PolicyHandle, EnumerationContext, Buffer, 
					PreferedMaximumLength, CountReturned ) == STATUS_SUCCESS );
			}
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::EnumerateTrustedDomainsEx( unsigned long* EnumerationContext, void** Buffer, unsigned long PreferredMaximumLength, unsigned long* CountReturned )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::EnumerateTrustedDomainsEx" );
		bool bResult = false;
        __QOR_PROTECT
        {
			*Buffer = 0;
			*CountReturned = 0;
			NTSTATUS Status = STATUS_NO_MORE_ENTRIES;
			if( m_Status == STATUS_SUCCESS )
			{
				Status = m_AdvAPI32Library.LsaEnumerateTrustedDomainsEx( m_PolicyHandle, EnumerationContext,
				Buffer, PreferredMaximumLength, CountReturned );

				bResult = ( Status == STATUS_SUCCESS || Status == STATUS_MORE_ENTRIES );
			}
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::FreeMemory( void* pMem )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::FreeMemory" );
		bool bResult = false;
        __QOR_PROTECT
        {
			bResult = ( m_AdvAPI32Library.LsaFreeMemory( pMem ) == STATUS_SUCCESS ) ? true : false;
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::LookupNames( unsigned long Count, wchar_t** paNames, nsWin32::LSAReferencedDomainList** ReferencedDomains, nsWin32::LSATranslatedSID** Sids )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::LookupNames" );
		bool bResult = false;
        __QOR_PROTECT
        {
			CLSAUnicodeStringArray NamesArray( paNames, Count );
			bResult = ( m_AdvAPI32Library.LsaLookupNames( m_PolicyHandle, Count, reinterpret_cast< ::PLSA_UNICODE_STRING >( NamesArray.operator nsWin32::LSAUnicodeString*() ), reinterpret_cast< ::PLSA_REFERENCED_DOMAIN_LIST* >( ReferencedDomains ), reinterpret_cast< ::PLSA_TRANSLATED_SID* >( Sids ) ) == STATUS_SUCCESS );
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::LookupNames2( unsigned long Flags, unsigned long Count, wchar_t** paNames, nsWin32::LSAReferencedDomainList** ReferencedDomains, nsWin32::LSATranslatedSID2** Sids )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::LookupNames2" );
		bool bResult = false;
        __QOR_PROTECT
        {
			CLSAUnicodeStringArray NamesArray( paNames, Count );
			bResult = ( m_AdvAPI32Library.LsaLookupNames2( m_PolicyHandle, Flags, Count, reinterpret_cast< ::PLSA_UNICODE_STRING >( NamesArray.operator nsWin32::LSAUnicodeString*() ), reinterpret_cast< ::PLSA_REFERENCED_DOMAIN_LIST* >( ReferencedDomains ), reinterpret_cast< ::PLSA_TRANSLATED_SID2* >( Sids ) ) == STATUS_SUCCESS );
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::LookupPrivilegeValueT( wchar_t* StrName, nsWin32::PLUID Value )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::LookupPrivilegeValue" );
		bool bResult = false;
        __QOR_PROTECT
        {
			CLSAUnicodeString Name( StrName );
			bResult = ( m_AdvAPI32Library.LsaLookupPrivilegeValue( m_PolicyHandle, reinterpret_cast< ::PUNICODE_STRING >( &Name ), reinterpret_cast< ::PLUID >( Value ) ) == STATUS_SUCCESS );
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::LookupSids( unsigned long Count, void** Sids, nsWin32::LSAReferencedDomainList** ReferencedDomains, nsWin32::LSATranslatedName** Names )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::LookupSids" );
		bool bResult = false;
        __QOR_PROTECT
        {
			bResult = ( m_AdvAPI32Library.LsaLookupSids( m_PolicyHandle, Count, Sids, reinterpret_cast< ::PLSA_REFERENCED_DOMAIN_LIST* >( ReferencedDomains ), reinterpret_cast< ::PLSA_TRANSLATED_NAME* >( Names ) ) == STATUS_SUCCESS );
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::QueryTrustedDomainInfo( void* TrustedDomainSid, nsWin32::eTrustedInformationClass InformationClass, 
		void** Buffer )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::QueryTrustedDomainInfo" );
		bool bResult = false;
        __QOR_PROTECT
        {
			*Buffer = 0;
			bResult = ( m_AdvAPI32Library.LsaQueryTrustedDomainInfo( m_PolicyHandle, TrustedDomainSid, static_cast< ::TRUSTED_INFORMATION_CLASS >( InformationClass ), Buffer ) == STATUS_SUCCESS );
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::QueryTrustedDomainInfoByName( wchar_t* StrTrustedDomainName, eTrustedInformationClass InformationClass, void** Buffer )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::QueryTrustedDomainInfoByName" );
		bool bResult = false;
        __QOR_PROTECT
        {
			*Buffer = 0;
			CLSAUnicodeString TrustedDomainName( StrTrustedDomainName );
			bResult = ( m_AdvAPI32Library.LsaQueryTrustedDomainInfoByName( m_PolicyHandle, reinterpret_cast< ::PLSA_UNICODE_STRING >( &TrustedDomainName ), static_cast< ::TRUSTED_INFORMATION_CLASS >( InformationClass ), Buffer ) == STATUS_SUCCESS );
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::RemoveAccountRights( void* AccountSid, unsigned char AllRights, wchar_t** paUserRights, 
		unsigned long CountOfRights )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::RemoveAccountRights" );
		bool bResult = false;
        __QOR_PROTECT
        {
			CLSAUnicodeStringArray UserRights( paUserRights, CountOfRights );
			bResult = ( m_AdvAPI32Library.LsaRemoveAccountRights( m_PolicyHandle, AccountSid, AllRights, reinterpret_cast< ::PLSA_UNICODE_STRING >( UserRights.operator nsWin32::LSAUnicodeString*() ), CountOfRights ) == STATUS_SUCCESS );
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::RetrievePrivateData( wchar_t* StrKeyName, wchar_t** pStrPrivateData )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::RetrievePrivateData" );
		bool bResult = false;
        __QOR_PROTECT
        {
			CLSAUnicodeString KeyName( StrKeyName );
			LSAUnicodeString* pPrivateData = 0;					
			*pStrPrivateData = 0;
			bResult = ( m_AdvAPI32Library.LsaRetrievePrivateData( m_PolicyHandle, reinterpret_cast< ::PLSA_UNICODE_STRING >( &KeyName ), reinterpret_cast< ::PLSA_UNICODE_STRING* >( &pPrivateData ) ) == STATUS_SUCCESS );
			if( bResult )
			{						
				CLSAUnicodeString PrivateData( pPrivateData );
				*pStrPrivateData = PrivateData;
			}
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::SetTrustedDomainInfoByName( wchar_t* StrTrustedDomainName, nsWin32::eTrustedInformationClass InformationClass, void* Buffer )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::SetTrustedDomainInfoByName" );
		bool bResult = false;
        __QOR_PROTECT
        {
			CLSAUnicodeString TrustedDomainName( StrTrustedDomainName );
			bResult = ( m_AdvAPI32Library.LsaSetTrustedDomainInfoByName( m_PolicyHandle, reinterpret_cast< ::PLSA_UNICODE_STRING >( &TrustedDomainName ), static_cast< ::TRUSTED_INFORMATION_CLASS >( InformationClass ), Buffer ) == STATUS_SUCCESS );
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::SetTrustedDomainInformation( void* TrustedDomainSid, nsWin32::eTrustedInformationClass InformationClass, void* Buffer )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::SetTrustedDomainInformation" );
		bool bResult = false;
        __QOR_PROTECT
        {
			bResult = ( m_AdvAPI32Library.LsaSetTrustedDomainInformation( m_PolicyHandle, TrustedDomainSid, static_cast< ::TRUSTED_INFORMATION_CLASS >( InformationClass ), Buffer ) == STATUS_SUCCESS );
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CLSAPolicy::StorePrivateData( wchar_t* StrKeyName, wchar_t* StrPrivateData )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::StorePrivateData" );
		bool bResult = false;
        __QOR_PROTECT
        {
			CLSAUnicodeString KeyName( StrKeyName );
			CLSAUnicodeString PrivateData( StrPrivateData );
			bResult = ( m_AdvAPI32Library.LsaStorePrivateData( m_PolicyHandle, reinterpret_cast< ::PLSA_UNICODE_STRING >( &KeyName ), reinterpret_cast< ::PLSA_UNICODE_STRING >( &PrivateData ) ) == STATUS_SUCCESS );
        }__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	void* CLSAPolicy::Handle( void ) const
	{
		_WINQ_FCONTEXT( "CLSAPolicy::Handle" );
		return m_PolicyHandle;
	}

	//--protected---------------------------------------------------------------------
			

	//--------------------------------------------------------------------------------
	CLSAPolicy::CLSAPolicy() : m_AdvAPI32Library( CAdvAPI32::Instance() )
	{
		_WINQ_FCONTEXT( "CLSAPolicy::CLSAPolicy" );
		m_Status = STATUS_INVALID_HANDLE;
		m_PolicyHandle = const_cast< void* >( Invalid_Handle_Value );
		memset( &m_Attributes, 0, sizeof( LSAObjectAttributes ) );
	}


	//--CLSATrustedDomain-------------------------------------------------------------

	__QOR_IMPLEMENT_OCLASS_LUID( CLSATrustedDomain );

	//--------------------------------------------------------------------------------
	CLSATrustedDomain::CLSATrustedDomain( const CLSAPolicy& src, wchar_t* StrTrustedDomainName, unsigned long DesiredAccess )
	{
		_WINQ_FCONTEXT( "CLSATrustedDomain::CLSATrustedDomain" );
		__QOR_PROTECT
		{
			CLSAUnicodeString TrustedDomainName( StrTrustedDomainName );
			m_Status = m_AdvAPI32Library.LsaOpenTrustedDomainByName( src.Handle(), reinterpret_cast< ::PLSA_UNICODE_STRING >( &TrustedDomainName ), DesiredAccess, &m_PolicyHandle );
			m_pSID = 0;
			m_bPersistent = true;
		}__QOR_ENDPROTECT
	}

	//--------------------------------------------------------------------------------
	CLSATrustedDomain::CLSATrustedDomain( const CLSAPolicy& src, TrustedDomainInformationEx* pTrustedDomainInformation, TrustedDomainAuthInformation* AuthenticationInformation, unsigned long DesiredAccess ) : CLSAPolicy()
	{
		_WINQ_FCONTEXT( "CLSATrustedDomain::CLSATrustedDomain" );
		__QOR_PROTECT
		{
			m_Status = m_AdvAPI32Library.LsaCreateTrustedDomainEx( src.Handle(), 
				reinterpret_cast< ::PTRUSTED_DOMAIN_INFORMATION_EX >( pTrustedDomainInformation ), 
				reinterpret_cast< ::PTRUSTED_DOMAIN_AUTH_INFORMATION >( AuthenticationInformation ), DesiredAccess, &m_PolicyHandle );
			m_pSID = pTrustedDomainInformation->Sid;
		}__QOR_ENDPROTECT
	}

	//--------------------------------------------------------------------------------
	CLSATrustedDomain::~CLSATrustedDomain()
	{
		_WINQ_FCONTEXT( "CLSATrustedDomain::~CLSATrustedDomain" );
		if( m_bPersistent == false && m_pSID != 0 )
		{
			__QOR_PROTECT
			{
				m_Status = m_AdvAPI32Library.LsaDeleteTrustedDomain( m_PolicyHandle, m_pSID );
			}__QOR_ENDPROTECT
		}
	}

	//--------------------------------------------------------------------------------
	void CLSATrustedDomain::MakePersistent( bool bPersistent )
	{
		_WINQ_FCONTEXT( "CLSATrustedDomain::MakePersistent" );
		if( bPersistent == true || m_pSID != 0 )
		{
			m_bPersistent = bPersistent;
		}
	}

}//nsWin32
