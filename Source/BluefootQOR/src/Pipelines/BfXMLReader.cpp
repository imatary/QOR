//BfXMLReader.cpp

// Copyright Querysoft Limited 2015, 2016
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "BluefootQOR/Pipelines/BFXMLReader.h"
#include "BluefootQOR/BFSink.h"
#include "BluefootQOR/BFSource.h"
#include "CodeQOR/Tracing/FunctionContextBase.h"

// Error strings for the XML reader
#define XMLERR_OK                         "no error occurred"
#define XMLERR_ERRORBYCONSUMER            "error triggered by consumer"
#define XMLERR_UNEXPECTEDEOF              "unexpected end of file"
#define XMLERR_MORETHANONEDOCTYPE         "more than one document type definition"
#define XMLERR_ERRORPARSINGELEMENT        "error occurred while parsing element"
#define XMLERR_TAGMISMATCH                "tag mismatch"
#define XMLERR_ERRORPARSINGCONTENT        "error occurred while parsing content"
#define XMLERR_UNEXPECTEDCHARACTER        "unexpected character"
#define XMLERR_INVALIDNAMEFORPI           "invalid name for processing instruction"
#define XMLERR_VERSIONEXPECTED            "version expected while reading the XML declaration"
#define XMLERR_WRONGVALUEFORSDECL         "wrong value for standalone declaration"
#define XMLERR_EDECLORSDDECLEXPECTED      "encoding declaration or standalone declaration expected while reading the XML declaration"
#define XMLERR_SDDECLEXPECTED             "standalone declaration expected while reading the XML declaration"
#define XMLERR_ERRORPARSINGDOCTYPE        "error occurred while parsing document type definition"
#define XMLERR_LETTEREXPECTED             "letter is expected"
#define XMLERR_ERRORPARSINGCOMMENT        "error occurred while parsing comment"
#define XMLERR_ERRORPARSINGREFERENCE      "error occurred while parsing reference"
#define XMLERR_INTERNALGENERALENTITYINDTD "internal general entity reference not allowed in DTD"
#define XMLERR_EXTERNALGENERALENTITYINAV  "external parsed general entity reference not allowed in attribute value"
#define XMLERR_EXTERNALGENERALENTITYINDTD "external parsed general entity reference not allowed in DTD"
#define XMLERR_UNPARSEDENTITYREFERENCE    "unparsed entity reference in wrong context"
#define XMLERR_RECURSIVEENTITIES          "recursive entities"
#define XMLERR_ERRORINTEXTDECL            "error in the text declaration of an external entity"

//------------------------------------------------------------------------------
namespace nsBluefoot
{
	static bool StripTextDecl( CXMLReader::CXMLString& str );
	CXMLReader::CXMLString Simplify( const CXMLReader::CXMLString& strSource );

	// the constants for the lookup table
	static const signed char cltWS      =  0; // white space
	static const signed char cltPer     =  1; // %
	static const signed char cltAmp     =  2; // &
	static const signed char cltGt      =  3; // >
	static const signed char cltLt      =  4; // <
	static const signed char cltSlash   =  5; // /
	static const signed char cltQm      =  6; // ?
	static const signed char cltEm      =  7; // !
	static const signed char cltDash    =  8; // -
	static const signed char cltCB      =  9; // ]
	static const signed char cltOB      = 10; // [
	static const signed char cltEq      = 11; // =
	static const signed char cltDq      = 12; // "
	static const signed char cltSq      = 13; // '
	static const signed char cltUnknown = 14;

	// character lookup table
	static const signed char charLookupTable[ 256 ] = 
	{
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0x00 - 0x07
		cltUnknown, // 0x08
		cltWS,      // 0x09 \t
		cltWS,      // 0x0A \n
		cltUnknown, // 0x0B
		cltUnknown, // 0x0C
		cltWS,      // 0x0D \r
		cltUnknown, // 0x0E
		cltUnknown, // 0x0F
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0x17 - 0x16
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0x18 - 0x1F
		cltWS,      // 0x20 Space
		cltEm,      // 0x21 !
		cltDq,      // 0x22 "
		cltUnknown, // 0x23
		cltUnknown, // 0x24
		cltPer,     // 0x25 %
		cltAmp,     // 0x26 &
		cltSq,      // 0x27 '
		cltUnknown, // 0x28
		cltUnknown, // 0x29
		cltUnknown, // 0x2A
		cltUnknown, // 0x2B
		cltUnknown, // 0x2C
		cltDash,    // 0x2D -
		cltUnknown, // 0x2E
		cltSlash,   // 0x2F /
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0x30 - 0x37
		cltUnknown, // 0x38
		cltUnknown, // 0x39
		cltUnknown, // 0x3A
		cltUnknown, // 0x3B
		cltLt,      // 0x3C <
		cltEq,      // 0x3D =
		cltGt,      // 0x3E >
		cltQm,      // 0x3F ?
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0x40 - 0x47
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0x48 - 0x4F
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0x50 - 0x57
		cltUnknown, // 0x58
		cltUnknown, // 0x59
		cltUnknown, // 0x5A
		cltOB,      // 0x5B [
		cltUnknown, // 0x5C
		cltCB,      // 0x5D]
		cltUnknown, // 0x5E
		cltUnknown, // 0x5F
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0x60 - 0x67
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0x68 - 0x6F
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0x70 - 0x77
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0x78 - 0x7F
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0x80 - 0x87
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0x88 - 0x8F
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0x90 - 0x97
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0x98 - 0x9F
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0xA0 - 0xA7
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0xA8 - 0xAF
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0xB0 - 0xB7
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0xB8 - 0xBF
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0xC0 - 0xC7
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0xC8 - 0xCF
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0xD0 - 0xD7
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0xD8 - 0xDF
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0xE0 - 0xE7
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0xE8 - 0xEF
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, // 0xF0 - 0xF7
		cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown, cltUnknown  // 0xF8 - 0xFF
	};

	static const char Begi = (char)CXMLReader::NameBeginning;
	static const char NtBg = (char)CXMLReader::NameNotBeginning;
	static const char NotN = (char)CXMLReader::NotName;

	//------------------------------------------------------------------------------
	static const char nameCharTable[128] =
	{
	// 0x00
		NotN, NotN, NotN, NotN, NotN, NotN, NotN, NotN,
		NotN, NotN, NotN, NotN, NotN, NotN, NotN, NotN,
	// 0x10
		NotN, NotN, NotN, NotN, NotN, NotN, NotN, NotN,
		NotN, NotN, NotN, NotN, NotN, NotN, NotN, NotN,
	// 0x20 (0x2D is '-', 0x2E is '.')
		NotN, NotN, NotN, NotN, NotN, NotN, NotN, NotN,
		NotN, NotN, NotN, NotN, NotN, NtBg, NtBg, NotN,
	// 0x30 (0x30..0x39 are '0'..'9', 0x3A is ':')
		NtBg, NtBg, NtBg, NtBg, NtBg, NtBg, NtBg, NtBg,
		NtBg, NtBg, Begi, NotN, NotN, NotN, NotN, NotN,
	// 0x40 (0x41..0x5A are 'A'..'Z')
		NotN, Begi, Begi, Begi, Begi, Begi, Begi, Begi,
		Begi, Begi, Begi, Begi, Begi, Begi, Begi, Begi,
	// 0x50 (0x5F is '_')
		Begi, Begi, Begi, Begi, Begi, Begi, Begi, Begi,
		Begi, Begi, Begi, NotN, NotN, NotN, NotN, Begi,
	// 0x60 (0x61..0x7A are 'a'..'z')
		NotN, Begi, Begi, Begi, Begi, Begi, Begi, Begi,
		Begi, Begi, Begi, Begi, Begi, Begi, Begi, Begi,
	// 0x70
		Begi, Begi, Begi, Begi, Begi, Begi, Begi, Begi,
		Begi, Begi, Begi, NotN, NotN, NotN, NotN, NotN
	};

	//------------------------------------------------------------------------------
	static inline CXMLReader::NameChar fastDetermineNameChar( nsCodeQOR::CChar16 ch )
	{
		unsigned short uc = ch.Unicode();

		if( !( uc & ~0x7f ) ) // uc < 128
		{
			return (CXMLReader::NameChar)nameCharTable[ uc ];
		}

		CXMLReader::CXMLString::char_type::eCategory cat = ch.Category();

		if( ( cat >= nsCodeQOR::CChar16::Letter_Uppercase && cat <= nsCodeQOR::CChar16::Letter_Other ) || cat == nsCodeQOR::CChar16::Number_Letter )
		{
			return CXMLReader::NameBeginning;
		}

		if( ( cat >= nsCodeQOR::CChar16::Number_DecimalDigit && cat <= nsCodeQOR::CChar16::Number_Other ) || ( cat >= nsCodeQOR::CChar16::Mark_NonSpacing && cat <= nsCodeQOR::CChar16::Mark_Enclosing ) )
		{
			return CXMLReader::NameNotBeginning;
		}

		return CXMLReader::NotName;
	}

	//------------------------------------------------------------------------------
	static CXMLReader::NameChar determineNameChar( CXMLReader::CXMLString::char_type ch )
	{
		return fastDetermineNameChar( ch );
	}

	//------------------------------------------------------------------------------
	__QOR_IMPLEMENT_OCLASS_LUID( CXMLReader );

	//------------------------------------------------------------------------------
	CXMLReader::CXMLReader( CSource* pSource ) : CTextReader( pSource)
	{
		__QCS_MEMBER_FCONTEXT( "CXMLReader::CXMLReader" );

		m_bUseNamespaces = true;
		m_bUseNamespacePrefixes = true;
		m_bReportWhitespaceCharData = true;
		m_bReportEntities = true;				
		m_bStartDTDwasReported = false;
		m_Done = 0;
		m_pParseStack = 0;
		m_bParsePI_xmldecl = false;
		m_bParseName_useRef = false;
		m_bParseReference_charDataRead = false;
		m_bParseExternalID_allowPublicID = true;
		m_iStringArrayPos = 0;
		m_iStringValueLen = 0;
		m_iNameArrayPos = 0;
		m_iNameValueLen = 0;
		m_iRefArrayPos = 0;
		m_iRefValueLen = 0;
		m_bSkippedEntityInContent = false;
		m_bXmldecl_possible = false;
		m_bDoctype_read = false;
		m_bContentCharDataRead = false;
		m_iLineNr = 0 ;
		m_iColumnNr = 0;
		m_C = EndOfDocument;
	}

	//------------------------------------------------------------------------------
	CXMLReader::~CXMLReader()
	{
		__QCS_MEMBER_FCONTEXT( "CXMLReader::~CXMLReader" );
	}

	//------------------------------------------------------------------------------
	CXMLReader::CXMLReader( const CXMLReader& Src ) : CTextReader( Src )
	{
		__QCS_MEMBER_FCONTEXT( "CXMLReader::CXMLReader" );
	}

	//------------------------------------------------------------------------------
	CXMLReader& CXMLReader::operator = ( const CXMLReader& Src )
	{
		__QCS_MEMBER_FCONTEXT( "CXMLReader::operator =" );
		if( &Src != this )
		{
			CTextReader::operator=( Src );
		}

		return *this;
	}

	//------------------------------------------------------------------------------
	void CXMLReader::Run()
	{
		/*bool bResult = */Parse();		
	}

	//Properties

	//------------------------------------------------------------------------------
	void* CXMLReader::Property( const CXMLString&, bool* ok ) const
	{
		__QCS_MEMBER_FCONTEXT( "CXMLReader::Property" );
		if( ok != 0 )
		{
			*ok = false;
		}
		return 0;
	}

	//------------------------------------------------------------------------------
	void CXMLReader::SetProperty( const CXMLString&, void* )
	{
		__QCS_MEMBER_FCONTEXT( "CXMLReader::SetProperty" );
	}

	//------------------------------------------------------------------------------
	bool CXMLReader::HasProperty( const CXMLString& ) const
	{
		__QCS_MEMBER_FCONTEXT( "CXMLReader::HasProperty" );
		return false;
	}

	//------------------------------------------------------------------------------
	bool CXMLReader::Feature( const CXMLString& name, bool* ok ) const
	{
		//const CXmlSimpleReaderPrivate* d = d_ptr.operator nsBluefoot::CXmlSimpleReaderPrivate *();

		if( ok != 0 )
		{
			*ok = true;
		}

		if( name == CXMLString( _TXT( "http://xml.org/sax/features/namespaces" ) ) ) 
		{
			return m_bUseNamespaces;
		} 
		else if( name == CXMLString( _TXT("http://xml.org/sax/features/namespace-prefixes" ) ) ) 
		{
			return m_bUseNamespacePrefixes;
		} 
		else if( name == CXMLString( _TXT( "http://trolltech.com/xml/features/report-whitespace-only-CharData" ) ) || name == CXMLString( _TXT( "http://qt-project.org/xml/features/report-whitespace-only-CharData") ) ) 
		{ 
			return m_bReportWhitespaceCharData;
		} 
		else if( name == CXMLString( _TXT( "http://trolltech.com/xml/features/report-start-end-entity" ) ) || name == CXMLString( _TXT( "http://qt-project.org/xml/features/report-start-end-entity" ) )) 
		{
			return m_bReportEntities;
		} 
		else 
		{
			//qWarning("Unknown feature %s", name.toLatin1().data());
			if( ok != 0 )
			{
				*ok = false;
			}
		}
		return false;
	}

	/*!
		Turns on the feature \a name if \a enable is true; otherwise turns it off.

		The \a name parameter must be one of the following strings:
		\table
		\header \i Feature \i Default \i Notes
		\row \i \e http://xml.org/sax/features/namespaces
			 \i true
			 \i If enabled, namespaces are reported to the content handler.
		\row \i \e http://xml.org/sax/features/namespace-prefixes
			 \i false
			 \i If enabled, the original prefixed names
				and attributes used for namespace declarations are
				reported.
		\row \i \e http://trolltech.com/xml/features/report-whitespace-only-CharData
			 \i true
			 \i If enabled, CharData that consist of
				only whitespace characters are reported
				using QXmlContentHandler::characters(). If disabled, whitespace is silently
				discarded.
		\row \i \e http://trolltech.com/xml/features/report-start-end-entity
			 \i false
			 \i If enabled, the parser reports
				QXmlContentHandler::startEntity() and
				QXmlContentHandler::endEntity() events, so character data
				might be reported in chunks.
				If disabled, the parser does not report these events, but
				silently substitutes the entities, and reports the character
				data in one chunk.
		\endtable
	*/
	//------------------------------------------------------------------------------
	void CXMLReader::SetFeature( const CXMLString& name, bool enable )
	{
		//CXmlSimpleReaderPrivate* const d = d_ptr.operator nsBluefoot::CXmlSimpleReaderPrivate *();

		if( name == CXMLString( _TXT( "http://xml.org/sax/features/namespaces" ) ) ) 
		{
			m_bUseNamespaces = enable;
		} 
		else if( name == CXMLString( _TXT( "http://xml.org/sax/features/namespace-prefixes") ) ) 
		{
			m_bUseNamespacePrefixes = enable;
		} 
		else if( name == CXMLString( _TXT( "http://trolltech.com/xml/features/report-whitespace-only-CharData" ) ) || name == CXMLString( _TXT( "http://qt-project.org/xml/features/report-whitespace-only-CharData" ) ) ) 
		{
			m_bReportWhitespaceCharData = enable;
		} 
		else if( name == CXMLString(  _TXT( "http://trolltech.com/xml/features/report-start-end-entity" ) ) || name == CXMLString(  _TXT( "http://qt.project.org/xml/features/report-start-end-entity" ) ) ) 
		{
			m_bReportEntities = enable;
		} 
		else 
		{
			//TODO:qWarning("Unknown feature %s", name.toLatin1().data());
		}
	}

	//------------------------------------------------------------------------------
	bool CXMLReader::HasFeature( const CXMLString& name ) const
	{
		if( name == CXMLString( _TXT( "http://xml.org/sax/features/namespaces" ) )
			|| name == CXMLString( _TXT( "http://xml.org/sax/features/namespace-prefixes" ) )
			|| name == CXMLString( _TXT( "http://trolltech.com/xml/features/report-whitespace-only-CharData" ) )
			|| name == CXMLString( _TXT( "http://qt-project.org/xml/features/report-whitespace-only-CharData" ) )
			|| name == CXMLString( _TXT( "http://trolltech.com/xml/features/report-start-end-entity" ) )
			|| name == CXMLString( _TXT( "http://qt-project.org/xml/features/report-start-end-entity" ) ) ) 
		{
			return true;
		} 
		else 
		{
			return false;
		}
	}

	//------------------------------------------------------------------------------
	bool CXMLReader::Parse( bool bIncremental )
	{
		if( bIncremental ) 
		{
			InitIncrementalParsing();
		} 
		else 
		{
			delete m_pParseStack;
			m_pParseStack = 0;
		}
		Init();

		// call the handler
		ContentHandler().SetDocumentLocator( m_Locator.operator nsBluefoot::CXmlLocator *() );
		if( !ContentHandler().StartDocument() ) 
		{
			ReportParseError( ContentHandler().ErrorString() );
			while( !m_Tags.empty() )
			{
				m_Tags.pop();
			}
			return false;
		}

		m_bSkippedEntityInContent = false;
		return ParseBeginOrContinue( 0, bIncremental );
	}

	//------------------------------------------------------------------------------
	void CXMLReader::InitIncrementalParsing()
	{
		if( m_pParseStack )
		{
			while( !m_pParseStack->empty() )
			{
				m_pParseStack->pop();
			}
		}
		else
		{
			m_pParseStack = new std::stack< ParseState >;
		}
	}

	//------------------------------------------------------------------------------
	// This private function initializes the reader. 
	void CXMLReader::Init()
	{
		m_iLineNr = 0;
		m_iColumnNr = -1;
		InitData();

		m_ExternParameterEntities.clear();
		m_ParameterEntities.clear();
		m_ExternEntities.clear();
		m_Entities.clear();

		while( !m_Tags.empty() )
		{
			m_Tags.pop();
		}

		m_Doctype.Clear();
		m_XmlVersion.Clear();
		m_Encoding.Clear();
		m_Standalone = CXMLReader::Unknown;
		m_Error.Clear();
	}

	//------------------------------------------------------------------------------
	// This private function initializes the XML data related variables. 
	// Especially, it reads the data from the input source.
	void CXMLReader::InitData()
	{
		m_C = 0xFF;
		while( !m_XmlRefStack.empty() )
		{
			m_XmlRefStack.pop();
		}
		Next();
	}

	//------------------------------------------------------------------------------
	//This private function moves the cursor to the next character.
	void CXMLReader::Next()
	{
		int count = m_XmlRefStack.size();
		while( count != 0 ) 
		{
			if( m_XmlRefStack.top().isEmpty() ) 
			{
				m_XmlRefStack.pop();
				count--;
			} 
			else 
			{
				m_C = m_XmlRefStack.top().next();
				return;
			}
		}

		// the following could be written nicer, but since it is a time-critical
		// function, rather optimize for speed
		CXMLString::char_type bc = m_C;

		m_C = NextChar();
		// If we are not incremental parsing, we just skip over EndOfData chars to give the
		// parser an uninterrupted stream of document chars.
		if( m_C == CXMLString::char_type( EndOfData ) && m_pParseStack == 0 )
		{
			m_C = NextChar();
		}
		if( bc == CXMLString::char_type('\n') )
		{
			m_iLineNr++;
			m_iColumnNr = -1;
		} 
		else if( bc == CXMLString::char_type('\r') ) 
		{
			if( m_C != CXMLString::char_type('\n') ) 
			{
				m_iLineNr++;
				m_iColumnNr = -1;
			}
		}
		++m_iColumnNr;
	}

	//------------------------------------------------------------------------------
	CXMLReader::CXMLString::char_type CXMLReader::NextChar()
	{
		CXMLString::char_type NextChar = CXMLString::char_type( EndOfDocument );
		unsigned long ulUnitsRead = 0;
		while( Pump( ulUnitsRead ) && ulUnitsRead == 0 )
		{
		}
		
		if( ulUnitsRead == 1 )
		{
			NextChar = m_StringSink.GetData().At( m_StringSink.GetData().Len() - 1 ).Unicode();
		}
		return NextChar;
	}

	//------------------------------------------------------------------------------
	void CXMLReader::ReportParseError( const CXMLReader::CXMLString& Error )
	{
		this->m_Error = Error;
		if( !ErrorHandler.IsNull() ) 
		{
			if( this->m_Error.IsEmpty() ) 
			{
				const CXmlParseException ex( nsCodeQOR::CString( _TXT( XMLERR_OK ) ), m_iColumnNr+1, m_iLineNr+1, thisPublicId, thisSystemId );
				ErrorHandler().FatalError(ex);
			} 
			else 
			{
				const CXmlParseException ex( nsCodeQOR::CString( this->m_Error ), m_iColumnNr+1, m_iLineNr+1, thisPublicId, thisSystemId );
				ErrorHandler().FatalError(ex);
			}
		}
	}

	//------------------------------------------------------------------------------
	bool CXMLReader::ParseContinue()
	{
		if( m_pParseStack == 0 || m_pParseStack->empty() )
		{
			return false;
		}
		InitData();
		int state = m_pParseStack->top().m_iState;
		m_pParseStack->pop();
		return ParseBeginOrContinue( state, true );
	}

	//------------------------------------------------------------------------------
	//Common part of parse() and parseContinue()
	bool CXMLReader::ParseBeginOrContinue( int state, bool incremental )
	{
		bool atEndOrig = atEnd();

		if( state == 0 ) 
		{
			if( !ParseProlog() ) 
			{
				if( incremental && m_Error.IsEmpty() ) 
				{
					PushParseState( 0, 0 );
					return true;
				} 
				else 
				{
					while( !m_Tags.empty() )
					{
						m_Tags.pop();
					}
					return false;
				}
			}
			state = 1;
		}

		if( state == 1 ) 
		{
			if( !ParseElement() ) 
			{
				if( incremental && m_Error.IsEmpty() ) 
				{
					PushParseState( 0, 1 );
					return true;
				} 
				else 
				{
					while( !m_Tags.empty() )
					{
						m_Tags.pop();
					}
					return false;
				}
			}
			state = 2;
		}
		// parse Misc*
		while( !atEnd() ) 
		{
			if( !ParseMisc() ) 
			{
				if( incremental && m_Error.IsEmpty() ) 
				{
					PushParseState( 0, 2 );
					return true;
				} 
				else 
				{
					while( !m_Tags.empty() )
					{
						m_Tags.pop();
					}
					return false;
				}
			}
		}

		if( !atEndOrig && incremental ) 
		{
			// we parsed something at all, so be prepared to come back later
			PushParseState( 0, 2 );
			return true;
		}
		// is stack empty?
		if( !m_Tags.empty() && !m_Error.IsEmpty() ) 
		{
			ReportParseError( CXMLString( _TXT( XMLERR_UNEXPECTEDEOF ) ) );
			while( !m_Tags.empty() )
			{
				m_Tags.pop();
			}
			return false;
		}
		// call the handler
		if( !ContentHandler.IsNull() ) 
		{
			delete m_pParseStack;
			m_pParseStack = 0;
			if( !ContentHandler().EndDocument() ) 
			{
				ReportParseError( ContentHandler().ErrorString() );
				return false;
			}
		}
		return true;
	}

	//------------------------------------------------------------------------------
	//Parses the prolog [22].
	bool CXMLReader::ParseProlog()
	{
		const signed char Init             = 0;
		const signed char EatWS            = 1; // eat white spaces
		const signed char Lt               = 2; // '<' read
		const signed char Em               = 3; // '!' read
		const signed char DocType          = 4; // read doctype
		const signed char Comment          = 5; // read comment
		const signed char CommentR         = 6; // same as Comment, but already reported
		const signed char PInstr           = 7; // read PI
		const signed char PInstrR          = 8; // same as PInstr, but already reported
		const signed char Done             = 9;

		const signed char InpWs            = 0;
		const signed char InpLt            = 1; // <
		const signed char InpQm            = 2; // ?
		const signed char InpEm            = 3; // !
		const signed char InpD             = 4; // D
		const signed char InpDash          = 5; // -
		const signed char InpUnknown       = 6;

		static const signed char table[ 9 ][ 7 ] = 
		{
		 /*  InpWs   InpLt  InpQm  InpEm  InpD      InpDash  InpUnknown */
			{ EatWS,  Lt,    -1,    -1,    -1,       -1,       -1      }, // Init
			{ -1,     Lt,    -1,    -1,    -1,       -1,       -1      }, // EatWS
			{ -1,     -1,    PInstr,Em,    Done,     -1,       Done    }, // Lt
			{ -1,     -1,    -1,    -1,    DocType,  Comment,  -1      }, // Em
			{ EatWS,  Lt,    -1,    -1,    -1,       -1,       -1      }, // DocType
			{ EatWS,  Lt,    -1,    -1,    -1,       -1,       -1      }, // Comment
			{ EatWS,  Lt,    -1,    -1,    -1,       -1,       -1      }, // CommentR
			{ EatWS,  Lt,    -1,    -1,    -1,       -1,       -1      }, // PInstr
			{ EatWS,  Lt,    -1,    -1,    -1,       -1,       -1      }  // PInstrR
		};

		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			m_bXmldecl_possible = true;
			m_bDoctype_read = false;
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParseProlog, state );
					return false;
				}
			}
		}

		for(;;) 
		{
			switch( state ) 
			{
				case DocType:
					if( m_bDoctype_read ) 
					{
						ReportParseError( CXMLString( _TXT( XMLERR_MORETHANONEDOCTYPE ) ) );
						return false;
					} 
					else 
					{
						m_bDoctype_read = false;
					}
					break;
				case Comment:
					if( !LexicalHandler.IsNull() ) 
					{
						if( !LexicalHandler().Comment( CXMLString() ) ) 
						{
							ReportParseError( LexicalHandler().ErrorString() );
							return false;
						}
					}
					state = CommentR;
					break;
				case PInstr:
					// call the handler
					//if( !ContentHandler.IsNull() ) 
					{
						if( m_bXmldecl_possible && !m_XmlVersion.IsEmpty() ) 
						{
							CXMLString value( CXMLString( _TXT( "version='" ) ) );
							value.Append( m_XmlVersion );
							value.Append( '\'' );
							if( !m_Encoding.IsEmpty() ) 
							{
								value.Append( CXMLString( _TXT( " encoding='" ) ) );
								value.Append( m_Encoding );
								value.Append( '\'' );
							}

							if( m_Standalone == CXMLReader::Yes ) 
							{
								value.Append( CXMLString( _TXT( " standalone='yes'" ) ) );
							} 
							else if( m_Standalone == CXMLReader::No ) 
							{
								value.Append( CXMLString( _TXT( " standalone='no'" ) ) );
							}
							if( !ContentHandler().ProcessingInstruction( CXMLString( _TXT( "xml" ) ), value ) ) 
							{
								ReportParseError( ContentHandler().ErrorString() );
								return false;
							}
						} 
						else 
						{
							if( !ContentHandler().ProcessingInstruction( name(), string() ) ) 
							{
								ReportParseError( ContentHandler().ErrorString() );
								return false;
							}
						}
					}
					// XML declaration only on first position possible
					m_bXmldecl_possible = false;
					state = PInstrR;
					break;
				case Done:
					return true;
				case -1:
					ReportParseError( CXMLString( _TXT( XMLERR_ERRORPARSINGELEMENT ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParseProlog, state );
				return false;
			}

			if( m_C.IsSpace() ) 
			{
				input = InpWs;
			} 
			else if( m_C == CXMLString::char_type( '<'  ) ) 
			{
				input = InpLt;
			} 
			else if( m_C == CXMLString::char_type( '?' ) ) 
			{
				input = InpQm;
			} 
			else if( m_C == CXMLString::char_type( '!' ) ) 
			{
				input = InpEm;
			} 
			else if( m_C == CXMLString::char_type( 'D' ) ) 
			{
				input = InpD;
			} 
			else if( m_C == CXMLString::char_type( '-' ) ) 
			{
				input = InpDash;
			} 
			else 
			{
				input = InpUnknown;
			}

			state = table[ state ][ input ];

			switch( state ) 
			{
				case EatWS:
					// XML declaration only on first position possible
					m_bXmldecl_possible = false;
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseProlog, state );
						return false;
					}
					break;
				case Lt:
					Next();
					break;
				case Em:
					// XML declaration only on first position possible
					m_bXmldecl_possible = false;
					Next();
					break;
				case DocType:
					if (!ParseDoctype()) 
					{
						ParseFailed( &CXMLReader::ParseProlog, state );
						return false;
					}
					break;
				case Comment:
				case CommentR:
					if( !ParseComment() ) 
					{
						ParseFailed( &CXMLReader::ParseProlog, state );
						return false;
					}
					break;
				case PInstr:
				case PInstrR:
					m_bParsePI_xmldecl = m_bXmldecl_possible;
					if( !ParsePI() ) 
					{
						ParseFailed( &CXMLReader::ParseProlog, state );
						return false;
					}
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	//Parse an element [39].
	//Precondition: the opening '<' is already read.
	bool CXMLReader::ParseElement()
	{
		const int Init             =  0;
		const int ReadName         =  1;
		const int Ws1              =  2;
		const int STagEnd          =  3;
		const int STagEnd2         =  4;
		const int ETagBegin        =  5;
		const int ETagBegin2       =  6;
		const int Ws2              =  7;
		const int EmptyTag         =  8;
		const int Attrib           =  9;
		const int AttribPro        = 10; // like Attrib, but processAttribute was already called
		const int Ws3              = 11;
		const int Done             = 12;

		const int InpWs            = 0; // whitespace
		const int InpNameBe        = 1; // NameBeginning
		const int InpGt            = 2; // >
		const int InpSlash         = 3; // /
		const int InpUnknown       = 4;

		static const int table[ 12 ][ 5 ] = 
		{
		 /*  InpWs      InpNameBe    InpGt        InpSlash     InpUnknown */
			{ -1,        ReadName,    -1,          -1,          -1        }, // Init
			{ Ws1,       Attrib,      STagEnd,     EmptyTag,    -1        }, // ReadName
			{ -1,        Attrib,      STagEnd,     EmptyTag,    -1        }, // Ws1
			{ STagEnd2,  STagEnd2,    STagEnd2,    STagEnd2,    STagEnd2  }, // STagEnd
			{ -1,        -1,          -1,          ETagBegin,   -1        }, // STagEnd2
			{ -1,        ETagBegin2,  -1,          -1,          -1        }, // ETagBegin
			{ Ws2,       -1,          Done,        -1,          -1        }, // ETagBegin2
			{ -1,        -1,          Done,        -1,          -1        }, // Ws2
			{ -1,        -1,          Done,        -1,          -1        }, // EmptyTag
			{ Ws3,       Attrib,      STagEnd,     EmptyTag,    -1        }, // Attrib
			{ Ws3,       Attrib,      STagEnd,     EmptyTag,    -1        }, // AttribPro
			{ -1,        Attrib,      STagEnd,     EmptyTag,    -1        }  // Ws3
		};
		
		int state;
		int input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = m_pParseStack->top().m_iState;
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParseElement, state );
					return false;
				}
			}
		}

		for(;;) 
		{
			switch( state ) 
			{
				case ReadName:
					// store it on the stack
					m_Tags.push(name());
					// empty the attributes
					m_AttList.Clear();
					if( m_bUseNamespaces )
					{
						m_NamespaceSupport.PushContext();
					}
					break;
				case ETagBegin2:
					if( !ProcessElementETagBegin2() )
					{
						return false;
					}
					break;
				case Attrib:
					if( !ProcessElementAttribute() )
					{
						return false;
					}
					state = AttribPro;
					break;
				case Done:
					return true;
				case -1:
					ReportParseError( CXMLString( _TXT( XMLERR_ERRORPARSINGELEMENT ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParseElement, state );
				return false;
			}

			if( fastDetermineNameChar( m_C ) == NameBeginning ) 
			{
				input = InpNameBe;
			} 
			else if( m_C == '>' ) 
			{
				input = InpGt;
			} 
			else if( m_C.IsSpace() ) 
			{
				input = InpWs;
			} 
			else if( m_C == '/' ) 
			{
				input = InpSlash;
			} 
			else 
			{
				input = InpUnknown;
			}
			state = table[ state ][ input ];

			switch( state ) 
			{
				case ReadName:
					m_bParseName_useRef = false;
					if( !ParseName() ) 
					{
						ParseFailed( &CXMLReader::ParseElement, state );
						return false;
					}
					break;
				case Ws1:
				case Ws2:
				case Ws3:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseElement, state );
						return false;
					}
					break;
				case STagEnd:
					// call the handler
					//if( !ContentHandler.IsNull() ) 
					{
						const CXMLString& tagsTop = m_Tags.top();
						if( m_bUseNamespaces ) 
						{
							CXMLString uri, lname;
							m_NamespaceSupport.ProcessName( tagsTop, false, uri, lname );
							if( !ContentHandler().StartElement( uri, lname, tagsTop, m_AttList ) ) 
							{
								ReportParseError( ContentHandler().ErrorString() );
								return false;
							}
						} 
						else 
						{
							if( !ContentHandler().StartElement( CXMLString(), CXMLString(), tagsTop, m_AttList ) ) 
							{
								ReportParseError( ContentHandler().ErrorString() );
								return false;
							}
						}
					}
					Next();
					break;
				case STagEnd2:
					if( !ParseContent() ) 
					{
						ParseFailed( &CXMLReader::ParseElement, state );
						return false;
					}
					break;
				case ETagBegin:
					Next();
					break;
				case ETagBegin2:
					// get the name of the tag
					m_bParseName_useRef = false;
					if( !ParseName() ) 
					{
						ParseFailed( &CXMLReader::ParseElement, state );
						return false;
					}
					break;
				case EmptyTag:
					if( m_Tags.empty() ) 
					{
						ReportParseError( CXMLString( _TXT( XMLERR_TAGMISMATCH ) ) );
						return false;
					}
					if( !ProcessElementEmptyTag() )
					{
						return false;
					}
					Next();
					break;
				case Attrib:
				case AttribPro:
					// get name and value of attribute
					if( !ParseAttribute() ) 
					{
						ParseFailed( &CXMLReader::ParseElement, state );
						return false;
					}
					break;
				case Done:
					Next();
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	//Parse Misc [27].
	bool CXMLReader::ParseMisc()
	{
		const signed char Init             = 0;
		const signed char Lt               = 1; // '<' was read
		const signed char Comment          = 2; // read comment
		const signed char eatWS            = 3; // eat whitespaces
		const signed char PInstr           = 4; // read PI
		const signed char Comment2         = 5; // read comment

		const signed char InpWs            = 0; // S
		const signed char InpLt            = 1; // <
		const signed char InpQm            = 2; // ?
		const signed char InpEm            = 3; // !
		const signed char InpUnknown       = 4;

		static const signed char table[ 3 ][ 5 ] = 
		{
		 /*  InpWs   InpLt  InpQm  InpEm     InpUnknown */
			{ eatWS,  Lt,    -1,    -1,       -1        }, // Init
			{ -1,     -1,    PInstr,Comment,  -1        }, // Lt
			{ -1,     -1,    -1,    -1,       Comment2  }  // Comment
		};

		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParseMisc, state );
					return false;
				}
			}
		}

		for(;;) 
		{
			switch( state ) 
			{
				case eatWS:
					return true;

				case PInstr:
					if( !ContentHandler.IsNull() ) 
					{
						if( !ContentHandler().ProcessingInstruction( name(),string() ) ) 
						{
							ReportParseError( ContentHandler().ErrorString() );
							return false;
						}
					}
					return true;

				case Comment2:
					if( !LexicalHandler.IsNull() ) 
					{
						if( !LexicalHandler().Comment( string() ) ) 
						{
							ReportParseError( LexicalHandler().ErrorString() );
							return false;
						}
					}
					return true;

				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_UNEXPECTEDCHARACTER ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParseMisc, state );
				return false;
			}

			if( m_C.IsSpace() ) 
			{
				input = InpWs;
			} 
			else if( m_C == CXMLString::char_type( '<' ) ) 
			{
				input = InpLt;
			} 
			else if( m_C == CXMLString::char_type( '?' ) ) 
			{
				input = InpQm;
			} 
			else if( m_C == CXMLString::char_type( '!' ) ) 
			{
				input = InpEm;
			} 
			else 
			{
				input = InpUnknown;
			}
			
			state = table[ state ][ input ];

			switch( state ) 

			{
				case eatWS:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseMisc, state );
						return false;
					}
					break;
				case Lt:
					Next();
					break;
				case PInstr:
					m_bParsePI_xmldecl = false;
					if( !ParsePI() ) 
					{
						ParseFailed( &CXMLReader::ParseMisc, state );
						return false;
					}
					break;
				case Comment:
					Next();
					break;
				case Comment2:
					if( !ParseComment() ) 
					{
						ParseFailed( &CXMLReader::ParseMisc, state );
						return false;
					}
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	/*Parse a document type definition (doctypedecl [28]).

	  Precondition: the beginning '<!' of the doctype is already read the head
	  stands on the 'D' of '<!DOCTYPE'.

	  If this function was successful, the head-position is on the first
	  character after the document type definition.	*/
	bool CXMLReader::ParseDoctype()
	{
		const signed char Init             =  0;
		const signed char Doctype          =  1; // read the doctype
		const signed char Ws1              =  2; // eat_ws
		const signed char Doctype2         =  3; // read the doctype, part 2
		const signed char Ws2              =  4; // eat_ws
		const signed char Sys              =  5; // read SYSTEM or PUBLIC
		const signed char Ws3              =  6; // eat_ws
		const signed char MP               =  7; // markupdecl or PEReference
		const signed char MPR              =  8; // same as MP, but already reported
		const signed char PER              =  9; // PERReference
		const signed char Mup              = 10; // markupdecl
		const signed char Ws4              = 11; // eat_ws
		const signed char MPE              = 12; // end of markupdecl or PEReference
		const signed char Done             = 13;

		const signed char InpWs            = 0;
		const signed char InpD             = 1; // 'D'
		const signed char InpS             = 2; // 'S' or 'P'
		const signed char InpOB            = 3; // [
		const signed char InpCB            = 4; //]
		const signed char InpPer           = 5; // %
		const signed char InpGt            = 6; // >
		const signed char InpUnknown       = 7;

		static const signed char table[ 13 ][ 8 ] = 
		{
		 /*  InpWs,  InpD       InpS       InpOB  InpCB  InpPer InpGt  InpUnknown */
			{ -1,     Doctype,   -1,        -1,    -1,    -1,    -1,    -1        }, // Init
			{ Ws1,    -1,        -1,        -1,    -1,    -1,    -1,    -1        }, // Doctype
			{ -1,     Doctype2,  Doctype2,  -1,    -1,    -1,    -1,    Doctype2  }, // Ws1
			{ Ws2,    -1,        Sys,       MP,    -1,    -1,    Done,  -1        }, // Doctype2
			{ -1,     -1,        Sys,       MP,    -1,    -1,    Done,  -1        }, // Ws2
			{ Ws3,    -1,        -1,        MP,    -1,    -1,    Done,  -1        }, // Sys
			{ -1,     -1,        -1,        MP,    -1,    -1,    Done,  -1        }, // Ws3
			{ -1,     -1,        -1,        -1,    MPE,   PER,   -1,    Mup       }, // MP
			{ -1,     -1,        -1,        -1,    MPE,   PER,   -1,    Mup       }, // MPR
			{ Ws4,    -1,        -1,        -1,    MPE,   PER,   -1,    Mup       }, // PER
			{ Ws4,    -1,        -1,        -1,    MPE,   PER,   -1,    Mup       }, // Mup
			{ -1,     -1,        -1,        -1,    MPE,   PER,   -1,    Mup       }, // Ws4
			{ -1,     -1,        -1,        -1,    -1,    -1,    Done,  -1        }  // MPE
		};
		
		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			m_bStartDTDwasReported = false;
			m_SystemId.Clear();
			m_PublicId.Clear();
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParseDoctype, state );
					return false;
				}
			}
		}

		for(;;) 
		{
			switch( state ) 
			{
				case Doctype2:
					m_Doctype = name();
					break;
				case MP:
					if( !m_bStartDTDwasReported ) 
					{
						m_bStartDTDwasReported = true;
						if( !LexicalHandler().StartDTD( m_Doctype, m_PublicId, m_SystemId ) ) 
						{
							ReportParseError( LexicalHandler().ErrorString() );
							return false;
						}
					}
					state = MPR;
					break;
				case Done:
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_ERRORPARSINGDOCTYPE ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParseDoctype, state );
				return false;
			}

			if( m_C.IsSpace() ) 
			{
				input = InpWs;
			} 
			else if( m_C == 'D' ) 
			{
				input = InpD;
			} 
			else if( m_C == 'S' ) 
			{
				input = InpS;
			} 
			else if( m_C == 'P' ) 
			{
				input = InpS;
			} 
			else if( m_C == '[' ) 
			{
				input = InpOB;
			} 
			else if( m_C == ']' ) 
			{
				input = InpCB;
			} 
			else if( m_C == '%' ) 
			{
				input = InpPer;
			} 
			else if( m_C == '>' ) 
			{
				input = InpGt;
			} 
			else 
			{
				input = InpUnknown;
			}
			state = table[ state ][ input ];

			switch( state ) 
			{
				case Doctype:
					m_ParseString_s = CXMLString( _TXT( "DOCTYPE" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseDoctype, state );
						return false;
					}
					break;
				case Ws1:
				case Ws2:
				case Ws3:
				case Ws4:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseDoctype, state );
						return false;
					}
					break;
				case Doctype2:
					m_bParseName_useRef = false;
					if( !ParseName() ) 
					{
						ParseFailed( &CXMLReader::ParseDoctype, state );
						return false;
					}
					break;
				case Sys:
					m_bParseExternalID_allowPublicID = false;
					if( !ParseExternalID() ) 
					{
						ParseFailed( &CXMLReader::ParseDoctype, state );
						return false;
					}
					thisPublicId = m_PublicId;
					thisSystemId = m_SystemId;
					break;
				case MP:
				case MPR:
					if( !next_eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseDoctype, state );
						return false;
					}
					break;
				case PER:
					m_ParsePEReference_context = InDTD;
					if( !ParsePEReference() ) 
					{
						ParseFailed( &CXMLReader::ParseDoctype, state );
						return false;
					}
					break;
				case Mup:
					if( !ParseMarkupdecl() ) 
					{
						ParseFailed( &CXMLReader::ParseDoctype, state );
						return false;
					}
					break;
				case MPE:
					if( !next_eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseDoctype, state );
						return false;
					}
					break;
				case Done:
					if( !LexicalHandler.IsNull() ) 
					{
						if( !m_bStartDTDwasReported ) 
						{
							m_bStartDTDwasReported = true;
							if( !LexicalHandler().StartDTD( m_Doctype, m_PublicId, m_SystemId ) ) 
							{
								ReportParseError( LexicalHandler().ErrorString() );
								return false;
							}
						}
						if( !LexicalHandler().EndDTD() ) 
						{
							ReportParseError( LexicalHandler().ErrorString() );
							return false;
						}
					}
					Next();
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	/*Parse a comment [15].

	  Precondition: the beginning '<!' of the comment is already read and the head
	  stands on the first '-' of '<!--'.

	  If this funktion was successful, the head-position is on the first
	  character after the comment.*/
	bool CXMLReader::ParseComment()
	{
		const signed char Init             = 0;
		const signed char Dash1            = 1; // the first dash was read
		const signed char Dash2            = 2; // the second dash was read
		const signed char Com              = 3; // read comment
		const signed char Com2             = 4; // read comment (help state)
		const signed char ComE             = 5; // finished reading comment
		const signed char Done             = 6;

		const signed char InpDash          = 0; // -
		const signed char InpGt            = 1; // >
		const signed char InpUnknown       = 2;

		static const signed char table[ 6 ][ 3 ] = 
		{
		 /*  InpDash  InpGt  InpUnknown */
			{ Dash1,   -1,    -1  }, // Init
			{ Dash2,   -1,    -1  }, // Dash1
			{ Com2,    Com,   Com }, // Dash2
			{ Com2,    Com,   Com }, // Com
			{ ComE,    Com,   Com }, // Com2
			{ -1,      Done,  -1  }  // ComE
		};

		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed(&CXMLReader::ParseComment, state);
					return false;
				}
			}
		}

		for(;;) 
		{
			switch( state ) 
			{
				case Dash2:
					StringClear();
					break;
				case Com2:
					// if next character is not a dash than don't skip it
					if( !atEnd() && m_C != '-' )
					{
						StringAddC( '-' );
					}
					break;
				case Done:
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_ERRORPARSINGCOMMENT ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof(&CXMLReader::ParseComment, state);
				return false;
			}

			if( m_C == '-' ) 
			{
				input = InpDash;
			} 
			else if( m_C == '>' ) 
			{
				input = InpGt;
			} 
			else 
			{
				input = InpUnknown;
			}
			state = table[ state ][ input ];

			switch( state ) 
			{
				case Dash1:
					Next();
					break;
				case Dash2:
					Next();
					break;
				case Com:
					StringAddC();
					Next();
					break;
				case Com2:
					Next();
					break;
				case ComE:
					Next();
					break;
				case Done:
					Next();
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	/*Parse a processing instruction [16].

	  If xmldec is true, it tries to parse a PI or a XML declaration [23].

	  Precondition: the beginning '<' of the PI is already read and the head stand
	  on the '?' of '<?'.

	  If this funktion was successful, the head-position is on the first
	  character after the PI.
	*/
	bool CXMLReader::ParsePI()
	{
		const signed char Init             =  0;
		const signed char QmI              =  1; // ? was read
		const signed char Name             =  2; // read Name
		const signed char XMLDecl          =  3; // read XMLDecl
		const signed char Ws1              =  4; // eat ws after "xml" of XMLDecl
		const signed char PInstr           =  5; // read PI
		const signed char Ws2              =  6; // eat ws after Name of PI
		const signed char Version          =  7; // read versionInfo
		const signed char Ws3              =  8; // eat ws after versionInfo
		const signed char EorSD            =  9; // read EDecl or SDDecl
		const signed char Ws4              = 10; // eat ws after EDecl or SDDecl
		const signed char SD               = 11; // read SDDecl
		const signed char Ws5              = 12; // eat ws after SDDecl
		const signed char ADone            = 13; // almost done
		const signed char Char             = 14; // Char was read
		const signed char Qm               = 15; // Qm was read
		const signed char Done             = 16; // finished reading content

		const signed char InpWs            = 0; // whitespace
		const signed char InpNameBe        = 1; // NameBeginning
		const signed char InpGt            = 2; // >
		const signed char InpQm            = 3; // ?
		const signed char InpUnknown       = 4;

		static const signed char table[ 16 ][ 5 ] = 
		{
		 /*  InpWs,  InpNameBe  InpGt  InpQm   InpUnknown  */
			{ -1,     -1,        -1,    QmI,    -1     }, // Init
			{ -1,     Name,      -1,    -1,     -1     }, // QmI
			{ -1,     -1,        -1,    -1,     -1     }, // Name (this state is left not through input)
			{ Ws1,    -1,        -1,    -1,     -1     }, // XMLDecl
			{ -1,     Version,   -1,    -1,     -1     }, // Ws1
			{ Ws2,    -1,        -1,    Qm,     -1     }, // PInstr
			{ Char,   Char,      Char,  Qm,     Char   }, // Ws2
			{ Ws3,    -1,        -1,    ADone,  -1     }, // Version
			{ -1,     EorSD,     -1,    ADone,  -1     }, // Ws3
			{ Ws4,    -1,        -1,    ADone,  -1     }, // EorSD
			{ -1,     SD,        -1,    ADone,  -1     }, // Ws4
			{ Ws5,    -1,        -1,    ADone,  -1     }, // SD
			{ -1,     -1,        -1,    ADone,  -1     }, // Ws5
			{ -1,     -1,        Done,  -1,     -1     }, // ADone
			{ Char,   Char,      Char,  Qm,     Char   }, // Char
			{ Char,   Char,      Done,  Qm,     Char   }, // Qm
		};
		
		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParsePI, state );
					return false;
				}
			}
		}

		for(;;) 
		{
			switch( state ) 
			{
				case Name:
					// test what name was read and determine the next state
					// (not very beautiful, I admit)
					if( name()/*TODO:.toLower()*/ == CXMLString( _TXT( "xml" ) ) ) 
					{
						if( m_bParsePI_xmldecl && name() == CXMLString( _TXT( "xml" ) ) ) 
						{
							state = XMLDecl;
						} 
						else 
						{
							ReportParseError( CXMLString( _TXT( XMLERR_INVALIDNAMEFORPI ) ) );
							return false;
						}
					} 
					else 
					{
						state = PInstr;
						StringClear();
					}
					break;

				case Version:
					// get version (syntax like an attribute)
					if( name() != CXMLString( _TXT( "version" ) ) ) 
					{
						ReportParseError( CXMLString( _TXT( XMLERR_VERSIONEXPECTED ) ) );
						return false;
					}
					m_XmlVersion = string();
					break;

				case EorSD:
					// get the EDecl or SDDecl (syntax like an attribute)
					if( name() == CXMLString( _TXT( "standalone" ) ) ) 
					{
						if( string()== CXMLString( _TXT( "yes" ) ) ) 
						{
							m_Standalone = CXMLReader::Yes;
						} 
						else if( string() == CXMLString( _TXT( "no" ) ) ) 
						{
							m_Standalone = CXMLReader::No;
						} 
						else 
						{
							ReportParseError( CXMLString( _TXT( XMLERR_WRONGVALUEFORSDECL ) ) );
							return false;
						}
					} 
					else if( name() == CXMLString( _TXT( "encoding" ) ) ) 
					{
						m_Encoding = string();
					} 
					else 
					{
						ReportParseError( CXMLString( _TXT( XMLERR_EDECLORSDDECLEXPECTED ) ) );
						return false;
					}
					break;

				case SD:

					if( name() != CXMLString( _TXT( "standalone" ) ) ) 
					{
						ReportParseError( CXMLString(_TXT( XMLERR_SDDECLEXPECTED ) ) );
						return false;
					}

					if( string() == CXMLString( _TXT( "yes" ) ) )
					{
						m_Standalone = CXMLReader::Yes;
					} 
					else if(string() == CXMLString( _TXT( "no" ) ) ) 
					{
						m_Standalone = CXMLReader::No;
					} 
					else 
					{
						ReportParseError( CXMLString( _TXT( XMLERR_WRONGVALUEFORSDECL ) ) );
						return false;
					}
					break;

				case Qm:
					// test if the skipping was legal
					if( !atEnd() && m_C != '>' )
					{
						StringAddC( '?' );
					}
					break;
				case Done:
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_UNEXPECTEDCHARACTER ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParsePI, state );
				return false;
			}

			if( m_C.IsSpace() ) 
			{
				input = InpWs;
			} 
			else if( determineNameChar( m_C ) == NameBeginning ) 
			{
				input = InpNameBe;
			} 
			else if( m_C == '>' ) 
			{
				input = InpGt;
			} 
			else if( m_C == '?' ) 
			{
				input = InpQm;
			} 
			else 
			{
				input = InpUnknown;
			}
			state = table[ state ][ input ];

			switch( state ) 
			{
				case QmI:
					Next();
					break;
				case Name:
					m_bParseName_useRef = false;
					if( !ParseName() ) 
					{
						ParseFailed( &CXMLReader::ParsePI, state );
						return false;
					}
					break;
				case Ws1:
				case Ws2:
				case Ws3:
				case Ws4:
				case Ws5:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParsePI, state );
						return false;
					}
					break;
				case Version:
					if( !ParseAttribute() ) 
					{
						ParseFailed( &CXMLReader::ParsePI, state );
						return false;
					}
					break;
				case EorSD:
					if( !ParseAttribute() ) 
					{
						ParseFailed( &CXMLReader::ParsePI, state );
						return false;
					}
					break;

				case SD:
					// get the SDDecl (syntax like an attribute)
					if( m_Standalone != CXMLReader::Unknown ) 
					{
						// already parsed the standalone declaration
						ReportParseError( CXMLString( _TXT( XMLERR_UNEXPECTEDCHARACTER ) ) );
						return false;
					}

					if( !ParseAttribute() ) 
					{
						ParseFailed( &CXMLReader::ParsePI, state );
						return false;
					}
					break;
				case ADone:
					Next();
					break;
				case Char:
					StringAddC();
					Next();
					break;
				case Qm:
					// skip the '?'
					Next();
					break;
				case Done:
					Next();
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	bool CXMLReader::ProcessElementETagBegin2()
	{
		const CXMLString& name = this->name();

		// pop the stack and compare it with the name
		CXMLString strTop = m_Tags.top();
		if( ! ( strTop == name ) ) 
		{
			m_Tags.pop();
			ReportParseError( CXMLString( _TXT( XMLERR_TAGMISMATCH ) ) );
			return false;
		}
		else
		{
			m_Tags.pop();
		}

		// call the handler
		//if( !ContentHandler.IsNull() ) 
		{
			nsCodeQOR::CUCS2String uri, lname;

			if( m_bUseNamespaces )
			{
				m_NamespaceSupport.ProcessName( name, false, uri, lname );
			}

			if( !ContentHandler().EndElement( uri, lname, name ) ) 
			{
				ReportParseError( ContentHandler().ErrorString() );
				return false;
			}
		}

		if( m_bUseNamespaces ) 
		{
			CXmlNamespaceSupport::NamespaceMap prefixesBefore, prefixesAfter;

			if( !ContentHandler.IsNull() )
			{
				prefixesBefore = m_NamespaceSupport.m_Ns;
			}

			m_NamespaceSupport.PopContext();
			// call the handler for prefix mapping
			if( !ContentHandler.IsNull() ) 
			{
				prefixesAfter = m_NamespaceSupport.m_Ns;
				if( prefixesBefore.size() != prefixesAfter.size() ) 
				{
					/*TOOD:
					for( NamespaceMap::const_iterator it = prefixesBefore.cbegin(); it != prefixesBefore.cend(); ++it ) 
					{
						if( !it->first.empty() && ( prefixesAfter.find( it->first ) == prefixesAfter.end() ) ) 
						{
							if( !contentHnd->endPrefixMapping( it->first ) ) 
							{
								reportParseError( contentHnd->errorString() );
								return false;
							}
						}
					}
					*/
				}
			}
		}
		return true;
	}

	//------------------------------------------------------------------------------
	//Helper to break down the size of the code in the case statement.Return false on error, otherwise true.
	bool CXMLReader::ProcessElementAttribute()
	{
		CXMLString uri, lname, prefix;
		const CXMLString& name = this->name();
		const CXMLString& string = this->string();

		// add the attribute to the list
		if( m_bUseNamespaces ) 
		{
			// is it a namespace declaration?
			m_NamespaceSupport.SplitName( name, prefix, lname );
			if( prefix == CXMLString( _TXT( "xmlns" ) ) ) 
			{
				// namespace declaration
				m_NamespaceSupport.SetPrefix( lname, string );
				if( m_bUseNamespacePrefixes ) 
				{
					// according to http://www.w3.org/2000/xmlns/, the "prefix"
					// xmlns maps to the namespace name
					// http://www.w3.org/2000/xmlns/
					m_AttList.Append(name, nsCodeQOR::CUCS2String( _TXT( "http://www.w3.org/2000/xmlns/" ) ), lname, string );
				}
				// call the handler for prefix mapping
				if( !ContentHandler.IsNull() ) 
				{
					if( !ContentHandler().StartPrefixMapping( lname, string ) ) 
					{
						ReportParseError( ContentHandler().ErrorString() );
						return false;
					}
				}
			} 
			else 
			{
				// no namespace delcaration
				m_NamespaceSupport.ProcessName( name, true, uri, lname );
				m_AttList.Append( name, uri, lname, string );
			}
		} 
		else 
		{
			// no namespace support
			m_AttList.Append( name, uri, lname, string );
		}
		return true;
	}

	//------------------------------------------------------------------------------
	//Parse a Name [5] and store the name in name or ref (if useRef is true).
	bool CXMLReader::ParseName()
	{
		const int Init             = 0;
		const int Name1            = 1; // parse first character of the name
		const int Name             = 2; // parse name
		const int Done             = 3;

		static const int table[ 3 ][ 3 ] = 
		{
		 /*  InpNameBe  InpNameCh  InpUnknown */
			{ Name1,     -1,        -1    }, // Init
			{ Name,      Name,      Done  }, // Name1
			{ Name,      Name,      Done  }  // Name
		};
		int state;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = m_pParseStack->top().m_iState;
			m_pParseStack->pop();

			if( !m_pParseStack->empty()) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}

				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParseName, state );
					return false;
				}
			}
		}

		for (;;) 
		{
			switch (state) 
			{
				case Done:
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_LETTEREXPECTED ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParseName, state );
				return false;
			}

			// we can safely do the (int) cast thanks to the Q_ASSERTs earlier in this function
			state = table[ state ][ (int)fastDetermineNameChar( m_C ) ];

			switch( state ) 
			{
				case Name1:
					if( m_bParseName_useRef ) 
					{
						RefClear();
						RefAddC();
					} 
					else 
					{
						NameClear();
						NameAddC();
					}
					Next();
					break;

				case Name:
					if( m_bParseName_useRef ) 
					{
						RefAddC();
					} 
					else 
					{
						NameAddC();
					}
					Next();
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	/*Parse a content [43].
	  A content is only used between tags. If a end tag is found the < is already
	  read and the head stand on the '/' of the end tag '</name>'.
	*/
	bool CXMLReader::ParseContent()
	{
		const signed char Init             =  0;
		const signed char ChD              =  1; // CharData
		const signed char ChD1             =  2; // CharData help state
		const signed char ChD2             =  3; // CharData help state
		const signed char Ref              =  4; // Reference
		const signed char Lt               =  5; // '<' read
		const signed char PInstr           =  6; // PI
		const signed char PInstrR          =  7; // same as PInstr, but already reported
		const signed char Elem             =  8; // Element
		const signed char Em               =  9; // '!' read
		const signed char Com              = 10; // Comment
		const signed char ComR             = 11; // same as Com, but already reported
		const signed char CDS              = 12; // CDSect
		const signed char CDS1             = 13; // read a CDSect
		const signed char CDS2             = 14; // read a CDSect (help state)
		const signed char CDS3             = 15; // read a CDSect (help state)
		const signed char Done             = 16; // finished reading content

		const signed char InpLt            = 0; // <
		const signed char InpGt            = 1; // >
		const signed char InpSlash         = 2; // /
		const signed char InpQMark         = 3; // ?
		const signed char InpEMark         = 4; // !
		const signed char InpAmp           = 5; // &
		const signed char InpDash          = 6; // -
		const signed char InpOpenB         = 7; // [
		const signed char InpCloseB        = 8; //]
		const signed char InpUnknown       = 9;

		static const signed char mapCLT2FSMChar[] = 
		{
			InpUnknown, // white space
			InpUnknown, // %
			InpAmp,     // &
			InpGt,      // >
			InpLt,      // <
			InpSlash,   // /
			InpQMark,   // ?
			InpEMark,   // !
			InpDash,    // -
			InpCloseB,  //]
			InpOpenB,   // [
			InpUnknown, // =
			InpUnknown, // "
			InpUnknown, // '
			InpUnknown  // unknown
		};

		static const signed char table[ 16 ][ 10 ] = 
		{
		 /*  InpLt  InpGt  InpSlash  InpQMark  InpEMark  InpAmp  InpDash  InpOpenB  InpCloseB  InpUnknown */
			{ Lt,    ChD,   ChD,      ChD,      ChD,      Ref,    ChD,     ChD,      ChD1,      ChD  }, // Init
			{ Lt,    ChD,   ChD,      ChD,      ChD,      Ref,    ChD,     ChD,      ChD1,      ChD  }, // ChD
			{ Lt,    ChD,   ChD,      ChD,      ChD,      Ref,    ChD,     ChD,      ChD2,      ChD  }, // ChD1
			{ Lt,    -1,    ChD,      ChD,      ChD,      Ref,    ChD,     ChD,      ChD2,      ChD  }, // ChD2
			{ Lt,    ChD,   ChD,      ChD,      ChD,      Ref,    ChD,     ChD,      ChD,       ChD  }, // Ref (same as Init)
			{ -1,    -1,    Done,     PInstr,   Em,       -1,     -1,      -1,       -1,        Elem }, // Lt
			{ Lt,    ChD,   ChD,      ChD,      ChD,      Ref,    ChD,     ChD,      ChD,       ChD  }, // PInstr (same as Init)
			{ Lt,    ChD,   ChD,      ChD,      ChD,      Ref,    ChD,     ChD,      ChD,       ChD  }, // PInstrR
			{ Lt,    ChD,   ChD,      ChD,      ChD,      Ref,    ChD,     ChD,      ChD,       ChD  }, // Elem (same as Init)
			{ -1,    -1,    -1,       -1,       -1,       -1,     Com,     CDS,      -1,        -1   }, // Em
			{ Lt,    ChD,   ChD,      ChD,      ChD,      Ref,    ChD,     ChD,      ChD,       ChD  }, // Com (same as Init)
			{ Lt,    ChD,   ChD,      ChD,      ChD,      Ref,    ChD,     ChD,      ChD,       ChD  }, // ComR
			{ CDS1,  CDS1,  CDS1,     CDS1,     CDS1,     CDS1,   CDS1,    CDS1,     CDS2,      CDS1 }, // CDS
			{ CDS1,  CDS1,  CDS1,     CDS1,     CDS1,     CDS1,   CDS1,    CDS1,     CDS2,      CDS1 }, // CDS1
			{ CDS1,  CDS1,  CDS1,     CDS1,     CDS1,     CDS1,   CDS1,    CDS1,     CDS3,      CDS1 }, // CDS2
			{ CDS1,  Init,  CDS1,     CDS1,     CDS1,     CDS1,   CDS1,    CDS1,     CDS3,      CDS1 }  // CDS3
		};
		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			m_bContentCharDataRead = false;
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParseContent, state );
					return false;
				}
			}
		}

		for(;;) 
		{
			switch( state ) 
			{
				case Ref:
					if( !m_bContentCharDataRead )
					{
						m_bContentCharDataRead = m_bParseReference_charDataRead;
					}
					break;
				case PInstr:
					if( !ContentHandler.IsNull() ) 
					{
						if( !ContentHandler().ProcessingInstruction( name(),string() ) ) 
						{
							ReportParseError( ContentHandler().ErrorString() );
							return false;
						}
					}
					state = PInstrR;
					break;
				case Com:
					if( !LexicalHandler.IsNull() ) 
					{
						if( !LexicalHandler().Comment( string() ) ) 
						{
							ReportParseError( LexicalHandler().ErrorString() );
							return false;
						}
					}
					state = ComR;
					break;
				case CDS:
					StringClear();
					break;
				case CDS2:
					if( !atEnd() && m_C != ']' )
					{
						StringAddC( ']' );
					}
					break;

				case CDS3:
					// test if this skipping was legal
					if( !atEnd() ) 
					{
						if( m_C == '>' ) 
						{
							// the end of the CDSect
							if( !LexicalHandler.IsNull() ) 
							{
								if( !LexicalHandler().StartCDATA() ) 
								{
									ReportParseError( LexicalHandler().ErrorString() );
									return false;
								}
							}
							if( !ContentHandler.IsNull() ) 
							{
								if( !ContentHandler().Characters( string() ) ) 
								{
									ReportParseError( ContentHandler().ErrorString() );
									return false;
								}
							}
							if( !LexicalHandler.IsNull() ) 
							{
								if( !LexicalHandler().EndCDATA() ) 
								{
									ReportParseError( LexicalHandler().ErrorString() );
									return false;
								}
							}
						} 
						else if( m_C == ']' ) 
						{
							// three or more ']'
							StringAddC( ']' );
						} 
						else 
						{
							// after ']]' comes another character
							StringAddC( ']' );
							StringAddC( ']' );
						}
					}
					break;
				case Done:
					// call the handler for CharData
					if( !ContentHandler.IsNull() ) 
					{
						if( m_bContentCharDataRead ) 
						{
							CXMLString strSimplified = Simplify( string() );
							if( m_bReportWhitespaceCharData || !strSimplified.IsEmpty() ) 
							{
								if( !ContentHandler().Characters( string() ) ) 
								{
									ReportParseError( ContentHandler().ErrorString() );
									return false;
								}
							}
						}
					}
					// Done
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_ERRORPARSINGCONTENT ) ) );
					return false;
			}

			// get input (use lookup-table instead of nested ifs for performance
			// reasons)
			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParseContent, state );
				return false;
			}

			input = mapCLT2FSMChar[ charLookupTable[ m_C.Unicode() ] ];
			
			state = table[ state ][ input ];

			switch( state ) 
			{
				case Init:
					// skip the ending '>' of a CDATASection
					Next();
					break;
				case ChD:
					// on first call: clear string
					if( !m_bContentCharDataRead ) 
					{
						m_bContentCharDataRead = true;
						StringClear();
					}
					StringAddC();
					if( m_bReportEntities ) 
					{
						if( !ReportEndEntities() )
						{
							return false;
						}
					}
					Next();
					break;

				case ChD1:
					// on first call: clear string
					if( !m_bContentCharDataRead ) 
					{
						m_bContentCharDataRead = true;
						StringClear();
					}
					StringAddC();
					if( m_bReportEntities ) 
					{
						if( !ReportEndEntities() )
						{
							return false;
						}
					}
					Next();
					break;
				case ChD2:
					StringAddC();
					if( m_bReportEntities ) 
					{
						if( !ReportEndEntities() )
						{
							return false;
						}
					}
					Next();
					break;
				case Ref:
					if( !m_bContentCharDataRead ) 
					{
						// reference may be CharData; so clear string to be safe
						StringClear();
						m_ParseReference_context = InContent;
						if( !ParseReference() ) 
						{
							ParseFailed( &CXMLReader::ParseContent, state );
							return false;
						}
					} 
					else 
					{
						if( m_bReportEntities ) 
						{
							// report character data in chunks
							//if( !ContentHandler.IsNull() ) 
							{
								CXMLString strSimplified = Simplify( string() );
								if( m_bReportWhitespaceCharData || !strSimplified.IsEmpty() ) 
								{
									if( !ContentHandler().Characters( string() ) ) 
									{
										ReportParseError( ContentHandler().ErrorString() );
										return false;
									}
								}
							}
							StringClear();
						}
						m_ParseReference_context = InContent;
						if( !ParseReference() ) 
						{
							ParseFailed( &CXMLReader::ParseContent, state );
							return false;
						}
					}
					break;
				case Lt:
					// call the handler for CharData
					if( !ContentHandler.IsNull() ) 
					{
						if( m_bContentCharDataRead ) 
						{
							CXMLString strSimplified = Simplify( string() );
							if( m_bReportWhitespaceCharData || !strSimplified.IsEmpty() ) 
							{
								if( !ContentHandler().Characters( string() ) ) 
								{
									ReportParseError( ContentHandler().ErrorString() );
									return false;
								}
							}
						}
					}
					m_bContentCharDataRead = false;
					Next();
					break;
				case PInstr:
				case PInstrR:
					m_bParsePI_xmldecl = false;
					if( !ParsePI() ) 
					{
						ParseFailed( &CXMLReader::ParseContent, state );
						return false;
					}
					break;
				case Elem:
					if( !ParseElement() ) 
					{
						ParseFailed( &CXMLReader::ParseContent, state );
						return false;
					}
					break;
				case Em:
					Next();
					break;
				case Com:
				case ComR:
					if( !ParseComment() ) 
					{
						ParseFailed( &CXMLReader::ParseContent, state );
						return false;
					}
					break;
				case CDS:
					m_ParseString_s = CXMLString( _TXT( "[CDATA[" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseContent, state );
						return false;
					}
					break;
				case CDS1:
					StringAddC();
					Next();
					break;
				case CDS2:
					// skip ']'
					Next();
					break;
				case CDS3:
					// skip ']'...
					Next();
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	//Helper to break down the size of the code in the case statement.Return false on error, otherwise true.
	bool CXMLReader::ProcessElementEmptyTag()
	{
		nsCodeQOR::CUCS2String uri, lname;
		// pop the stack and call the handler
		if( !ContentHandler.IsNull() ) 
		{
			if( m_bUseNamespaces ) 
			{
				// report startElement first...
				m_NamespaceSupport.ProcessName( m_Tags.top(), false, uri, lname );
				if( !ContentHandler().StartElement( uri, lname, m_Tags.top(), m_AttList) ) 
				{
					ReportParseError( ContentHandler().ErrorString() );
					return false;
				}
				// ... followed by endElement...
				if( !ContentHandler().EndElement( uri, lname, m_Tags.top() ) ) 
				{
					m_Tags.pop();
					ReportParseError( ContentHandler().ErrorString() );
					return false;
				}
				else
				{
					m_Tags.pop();
				}

				// ... followed by endPrefixMapping
				std::vector< CXMLString > prefixesBefore, prefixesAfter;
				
				if( !ContentHandler.IsNull() ) 
				{
					prefixesBefore = m_NamespaceSupport.Prefixes();
				}

				m_NamespaceSupport.PopContext();
				// call the handler for prefix mapping
				prefixesAfter = m_NamespaceSupport.Prefixes();
				for( std::vector< CXMLString >::iterator it = prefixesBefore.begin(); it != prefixesBefore.end(); ++it ) 
				{
					if( std::find( prefixesAfter.begin(), prefixesAfter.end(), *it ) == prefixesAfter.end() )
					{
						if( !ContentHandler().EndPrefixMapping(*it) ) 
						{
							ReportParseError( ContentHandler().ErrorString() );
							return false;
						}
					}
				}
			} 
			else 
			{
				// report startElement first...
				if( !ContentHandler().StartElement( CXMLString(), CXMLString(), m_Tags.top(), m_AttList ) ) 
				{
					ReportParseError( ContentHandler().ErrorString() );
					return false;
				}
				// ... followed by endElement
				if( !ContentHandler().EndElement( CXMLString(), CXMLString(), m_Tags.top() ) ) 
				{
					m_Tags.pop();
					ReportParseError( ContentHandler().ErrorString() );
					return false;
				}
				else
				{
					m_Tags.pop();
				}
			}
		} 
		else 
		{
			m_Tags.pop();
			m_NamespaceSupport.PopContext();
		}
		return true;
	}

	//------------------------------------------------------------------------------
	/* Parse an Attribute [41].

		Precondition: the head stands on the first character of the name
		of the attribute (i.e. all whitespaces are already parsed).

		The head stand on the next character after the end quotes. The
		variable name contains the name of the attribute and the variable
		string contains the value of the attribute.
	*/
	bool CXMLReader::ParseAttribute()
	{
		const int Init             = 0;
		const int PName            = 1; // parse name
		const int Ws               = 2; // eat ws
		const int Eq               = 3; // the '=' was read
		const int Quotes           = 4; // " or ' were read

		const int InpNameBe        = 0;
		const int InpEq            = 1; // =
		const int InpDq            = 2; // "
		const int InpSq            = 3; // '
		const int InpUnknown       = 4;

		static const int table[ 4 ][ 5 ] = 
		{
		 /*  InpNameBe  InpEq  InpDq    InpSq    InpUnknown */
			{ PName,     -1,    -1,      -1,      -1    }, // Init
			{ -1,        Eq,    -1,      -1,      Ws    }, // PName
			{ -1,        Eq,    -1,      -1,      -1    }, // Ws
			{ -1,        -1,    Quotes,  Quotes,  -1    }  // Eq
		};

		int state;
		int input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = m_pParseStack->top().m_iState;
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}

				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParseAttribute, state );
					return false;
				}
			}
		}

		for (;;) 
		{
			switch( state ) 
			{
				case Quotes:
					// Done
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_UNEXPECTEDCHARACTER ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParseAttribute, state );
				return false;
			}
			if( determineNameChar( m_C ) == NameBeginning ) 
			{
				input = InpNameBe;
			} 
			else if( m_C == '=' ) 
			{
				input = InpEq;
			} 
			else if( m_C == '"' ) 
			{
				input = InpDq;
			} 
			else if( m_C == '\'' ) 
			{
				input = InpSq;
			} 
			else 
			{
				input = InpUnknown;
			}

			state = table[ state ][ input ];

			switch( state ) 
			{
				case PName:
					m_bParseName_useRef = false;
					if( !ParseName() ) 
					{
						ParseFailed( &CXMLReader::ParseAttribute, state );
						return false;
					}
					break;
				case Ws:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseAttribute, state );
						return false;
					}
					break;
				case Eq:
					if( !next_eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseAttribute, state );
						return false;
					}
					break;
				case Quotes:
					if( !ParseAttValue() ) 
					{
						ParseFailed( &CXMLReader::ParseAttribute, state );
						return false;
					}
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	/*Parses over a simple string.
	  After the string was successfully parsed, the head is on the first character after the string.*/
	bool CXMLReader::ParseString()
	{
		const signed char InpCharExpected  = 0; // the character that was expected
		const signed char InpUnknown       = 1;

		signed char state; // state in this function is the position in the string s
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			m_Done = static_cast< signed char >( m_ParseString_s.Len() );
			state = 0;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParseString, state );
					return false;
				}
			}
		}

		for (;;) 
		{
			if( state == m_Done ) 
			{
				return true;
			}

			if (atEnd()) 
			{
				UnexpectedEof(&CXMLReader::ParseString, state);
				return false;
			}

			if( m_C == m_ParseString_s[ (int)state ] ) 
			{
				input = InpCharExpected;
			} 
			else 
			{
				input = InpUnknown;
			}
			
			if( input == InpCharExpected ) 
			{
				state++;
			} 
			else 
			{
				// Error
				ReportParseError( CXMLString( _TXT( XMLERR_UNEXPECTEDCHARACTER ) ) );
				return false;
			}

			Next();
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	/*Parse a ExternalID [75].
	  If allowPublicID is true parse ExternalID [75] or PublicID [83].*/
	bool CXMLReader::ParseExternalID()
	{
		const signed char Init             =  0;
		const signed char Sys              =  1; // parse 'SYSTEM'
		const signed char SysWS            =  2; // parse the whitespace after 'SYSTEM'
		const signed char SysSQ            =  3; // parse SystemLiteral with '
		const signed char SysSQ2           =  4; // parse SystemLiteral with '
		const signed char SysDQ            =  5; // parse SystemLiteral with "
		const signed char SysDQ2           =  6; // parse SystemLiteral with "
		const signed char Pub              =  7; // parse 'PUBLIC'
		const signed char PubWS            =  8; // parse the whitespace after 'PUBLIC'
		const signed char PubSQ            =  9; // parse PubidLiteral with '
		const signed char PubSQ2           = 10; // parse PubidLiteral with '
		const signed char PubDQ            = 11; // parse PubidLiteral with "
		const signed char PubDQ2           = 12; // parse PubidLiteral with "
		const signed char PubE             = 13; // finished parsing the PubidLiteral
		const signed char PubWS2           = 14; // parse the whitespace after the PubidLiteral
		const signed char PDone            = 15; // done if allowPublicID is true
		const signed char Done             = 16;

		const signed char InpSQ            = 0; // '
		const signed char InpDQ            = 1; // "
		const signed char InpS             = 2; // S
		const signed char InpP             = 3; // P
		const signed char InpWs            = 4; // white space
		const signed char InpUnknown       = 5;

		static const signed char table[ 15 ][ 6 ] = 
		{
		 /*  InpSQ    InpDQ    InpS     InpP     InpWs     InpUnknown */
			{ -1,      -1,      Sys,     Pub,     -1,       -1      }, // Init
			{ -1,      -1,      -1,      -1,      SysWS,    -1      }, // Sys
			{ SysSQ,   SysDQ,   -1,      -1,      -1,       -1      }, // SysWS
			{ Done,    SysSQ2,  SysSQ2,  SysSQ2,  SysSQ2,   SysSQ2  }, // SysSQ
			{ Done,    SysSQ2,  SysSQ2,  SysSQ2,  SysSQ2,   SysSQ2  }, // SysSQ2
			{ SysDQ2,  Done,    SysDQ2,  SysDQ2,  SysDQ2,   SysDQ2  }, // SysDQ
			{ SysDQ2,  Done,    SysDQ2,  SysDQ2,  SysDQ2,   SysDQ2  }, // SysDQ2
			{ -1,      -1,      -1,      -1,      PubWS,    -1      }, // Pub
			{ PubSQ,   PubDQ,   -1,      -1,      -1,       -1      }, // PubWS
			{ PubE,    -1,      PubSQ2,  PubSQ2,  PubSQ2,   PubSQ2  }, // PubSQ
			{ PubE,    -1,      PubSQ2,  PubSQ2,  PubSQ2,   PubSQ2  }, // PubSQ2
			{ -1,      PubE,    PubDQ2,  PubDQ2,  PubDQ2,   PubDQ2  }, // PubDQ
			{ -1,      PubE,    PubDQ2,  PubDQ2,  PubDQ2,   PubDQ2  }, // PubDQ2
			{ PDone,   PDone,   PDone,   PDone,   PubWS2,   PDone   }, // PubE
			{ SysSQ,   SysDQ,   PDone,   PDone,   PDone,    PDone   }  // PubWS2
		};

		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			m_SystemId.Clear();
			m_PublicId.Clear();
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParseExternalID, state );
					return false;
				}
			}
		}

		for(;;) 
		{
			switch( state ) 
			{
				case PDone:
					if( m_bParseExternalID_allowPublicID ) 
					{
						m_PublicId = string();
						return true;
					} 
					else 
					{
						ReportParseError( CXMLString( _TXT( XMLERR_UNEXPECTEDCHARACTER ) ) );
						return false;
					}
				case Done:
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_UNEXPECTEDCHARACTER ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParseExternalID, state );
				return false;
			}

			if( m_C.IsSpace() ) 
			{
				input = InpWs;
			} 
			else if( m_C == '\'' ) 
			{
				input = InpSQ;
			} 
			else if( m_C == '"' ) 
			{
				input = InpDQ;
			} 
			else if( m_C == 'S' ) 
			{
				input = InpS;
			} 
			else if( m_C == 'P' ) 
			{
				input = InpP;
			} 
			else 
			{
				input = InpUnknown;
			}
			state = table[ state ][ input ];

			switch( state ) 
			{
				case Sys:
					m_ParseString_s = CXMLString( _TXT( "SYSTEM" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseExternalID, state );
						return false;
					}
					break;
				case SysWS:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseExternalID, state );
						return false;
					}
					break;
				case SysSQ:
				case SysDQ:
					StringClear();
					Next();
					break;
				case SysSQ2:
				case SysDQ2:
					StringAddC();
					Next();
					break;
				case Pub:
					m_ParseString_s = CXMLString( _TXT( "PUBLIC" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseExternalID, state );
						return false;
					}
					break;
				case PubWS:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseExternalID, state );
						return false;
					}
					break;
				case PubSQ:
				case PubDQ:
					StringClear();
					Next();
					break;
				case PubSQ2:
				case PubDQ2:
					StringAddC();
					Next();
					break;
				case PubE:
					Next();
					break;
				case PubWS2:
					m_PublicId = this->string();
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseExternalID, state );
						return false;
					}
					break;
				case Done:
					m_SystemId = this->string();
					Next();
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	//Parse a PEReference [69]
	bool CXMLReader::ParsePEReference()
	{
		const signed char Init             = 0;
		const signed char Next             = 1;
		const signed char Name             = 2;
		const signed char NameR            = 3; // same as Name, but already reported
		const signed char Done             = 4;

		const signed char InpSemi          = 0; // ;
		const signed char InpPer           = 1; // %
		const signed char InpUnknown       = 2;

		static const signed char table[ 4 ][ 3 ] = 
		{
		 /*  InpSemi  InpPer  InpUnknown */
			{ -1,      Next,   -1    }, // Init
			{ -1,      -1,     Name  }, // Next
			{ Done,    -1,     -1    }, // Name
			{ Done,    -1,     -1    }  // NameR
		};
		
		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParsePEReference, state );
					return false;
				}
			}
		}

		for(;;) 
		{
			switch( state ) 
			{
				case Name:
					{
						bool skipIt = true;
						CXMLString xmlRefString;

						std::map< const CXMLString, CXMLString >::iterator it;
						it = m_ParameterEntities.find( Ref() );
						if( it != m_ParameterEntities.end() ) 
						{
							skipIt = false;
							xmlRefString = it->second;
						} 
						else if( !EntityResolver.IsNull() ) 
						{
							std::map< const CXMLString, ExternParameterEntity >::iterator it2;
							it2 = m_ExternParameterEntities.find( Ref() );
							CXmlInputSource* ret = 0;
							if( it2 != m_ExternParameterEntities.end() ) 
							{
								if( !EntityResolver().ResolveEntity((*it2).second.m_PublicId, (*it2).second.m_SystemId, ret ) ) 
								{
									//delete ret;
									ReportParseError( EntityResolver().ErrorString() );
									return false;
								}
								//if( ret ) 
								{
									//xmlRefString = ret->Data();
									//delete ret;
									if( !StripTextDecl( xmlRefString ) ) 
									{
										ReportParseError( CXMLString( _TXT( XMLERR_ERRORINTEXTDECL ) ) );
										return false;
									}
									skipIt = false;
								}
							}
						}

						if( skipIt ) 
						{
							if( !ContentHandler.IsNull() ) 
							{
								if( !ContentHandler().SkippedEntity( '%' + Ref() ) ) 
								{
									ReportParseError( ContentHandler().ErrorString() );
									return false;
								}
							}
						} 
						else 
						{
							if( m_ParsePEReference_context == InEntityValue ) 
							{
								// Included in literal
								if( !InsertXmlRef( xmlRefString, Ref(), true ) )
								{
									return false;
								}
							} 
							else if( m_ParsePEReference_context == InDTD ) 
							{
								// Included as PE
								if( !InsertXmlRef( ' ' + xmlRefString + ' ', Ref(), false ) )
								{
									return false;
								}
							}
						}
					}
					state = NameR;
					break;
				case Done:
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_LETTEREXPECTED ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParsePEReference, state );
				return false;
			}

			if( m_C == ';' ) 
			{
				input = InpSemi;
			} 
			else if( m_C == '%' ) 
			{
				input = InpPer;
			} 
			else 
			{
				input = InpUnknown;
			}
			state = table[ state ][ input ];

			switch( state ) 
			{
				case Next:
					this->Next();
					break;
				case Name:
				case NameR:
					m_bParseName_useRef = true;
					if( !ParseName() ) 
					{
						ParseFailed( &CXMLReader::ParsePEReference, state );
						return false;
					}
					break;
				case Done:
					this->Next();
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	//Parse a markupdecl [29].
	bool CXMLReader::ParseMarkupdecl()
	{
		const signed char Init             = 0;
		const signed char Lt               = 1; // < was read
		const signed char Em               = 2; // ! was read
		const signed char CE               = 3; // E was read
		const signed char Qm               = 4; // ? was read
		const signed char Dash             = 5; // - was read
		const signed char CA               = 6; // A was read
		const signed char CEL              = 7; // EL was read
		const signed char CEN              = 8; // EN was read
		const signed char CN               = 9; // N was read
		const signed char Done             = 10;

		const signed char InpLt            = 0; // <
		const signed char InpQm            = 1; // ?
		const signed char InpEm            = 2; // !
		const signed char InpDash          = 3; // -
		const signed char InpA             = 4; // A
		const signed char InpE             = 5; // E
		const signed char InpL             = 6; // L
		const signed char InpN             = 7; // N
		const signed char InpUnknown       = 8;

		static const signed char table[ 4 ][ 9 ] = 
		{
		 /*  InpLt  InpQm  InpEm  InpDash  InpA   InpE   InpL   InpN   InpUnknown */
			{ Lt,    -1,    -1,    -1,      -1,    -1,    -1,    -1,    -1     }, // Init
			{ -1,    Qm,    Em,    -1,      -1,    -1,    -1,    -1,    -1     }, // Lt
			{ -1,    -1,    -1,    Dash,    CA,    CE,    -1,    CN,    -1     }, // Em
			{ -1,    -1,    -1,    -1,      -1,    -1,    CEL,   CEN,   -1     }  // CE
		};
		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParseMarkupdecl, state );
					return false;
				}
			}
		}

		for(;;) 
		{
			switch( state ) 
			{
				case Qm:
					if( !ContentHandler.IsNull() ) 
					{
						if( !ContentHandler().ProcessingInstruction( name(),string() ) ) 
						{
							ReportParseError( ContentHandler().ErrorString() );
							return false;
						}
					}
					return true;
				case Dash:
					if( !LexicalHandler.IsNull() ) 
					{
						if( !LexicalHandler().Comment( string() ) ) 
						{
							ReportParseError( LexicalHandler().ErrorString() );
							return false;
						}
					}
					return true;
				case CA:
					return true;
				case CEL:
					return true;
				case CEN:
					return true;
				case CN:
					return true;
				case Done:
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_LETTEREXPECTED ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParseMarkupdecl, state );
				return false;
			}

			if( m_C == '<' ) 
			{
				input = InpLt;
			} 
			else if( m_C == '?' ) 
			{
				input = InpQm;
			}
			else if( m_C == '!' ) 
			{
				input = InpEm;
			} 
			else if( m_C == '-' ) 
			{
				input = InpDash;
			} 
			else if( m_C == 'A' ) 
			{
				input = InpA;
			} 
			else if( m_C == 'E' ) 
			{
				input = InpE;
			} 
			else if( m_C == 'L' ) 
			{
				input = InpL;
			} 
			else if( m_C == 'N' ) 
			{
				input = InpN;
			} 
			else 
			{
				input = InpUnknown;
			}
			state = table[ state ][ input ];

			switch( state ) 
			{
				case Lt:
					Next();
					break;
				case Em:
					Next();
					break;
				case CE:
					Next();
					break;
				case Qm:
					m_bParsePI_xmldecl = false;
					if( !ParsePI() ) 
					{
						ParseFailed( &CXMLReader::ParseMarkupdecl, state );
						return false;
					}
					break;
				case Dash:
					if( !ParseComment() ) 
					{
						ParseFailed( &CXMLReader::ParseMarkupdecl, state );
						return false;
					}
					break;
				case CA:
					if( !ParseAttlistDecl() ) 
					{
						ParseFailed( &CXMLReader::ParseMarkupdecl, state );
						return false;
					}
					break;
				case CEL:
					if( !ParseElementDecl() ) 
					{
						ParseFailed( &CXMLReader::ParseMarkupdecl, state );
						return false;
					}
					break;
				case CEN:
					if( !ParseEntityDecl() ) 
					{
						ParseFailed( &CXMLReader::ParseMarkupdecl, state );
						return false;
					}
					break;
				case CN:
					if( !ParseNotationDecl() ) 
					{
						ParseFailed( &CXMLReader::ParseMarkupdecl, state );
						return false;
					}
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	bool CXMLReader::ReportEndEntities()
	{
		int count = (int)m_XmlRefStack.size();
		while( count != 0 && m_XmlRefStack.top().isEmpty() ) 
		{
			if( !ContentHandler.IsNull() ) 
			{
				CXMLString strSimplified = Simplify( string() );
				if( m_bReportWhitespaceCharData || !strSimplified.IsEmpty() ) 
				{
					if( !ContentHandler().Characters( string() ) ) 
					{
						ReportParseError( ContentHandler().ErrorString() );
						return false;
					}
				}
			}
			StringClear();
			if( !LexicalHandler.IsNull() ) 
			{
				if( !LexicalHandler().EndEntity( m_XmlRefStack.top().m_Name ) ) 
				{
					ReportParseError( LexicalHandler().ErrorString() );
					return false;
				}
			}
			m_XmlRefStack.pop();
			count--;
		}
		return true;
	}

	//------------------------------------------------------------------------------
	/*Parse a Reference [67].

	  parseReference_charDataRead is set to true if the reference must not be
	  parsed. The character(s) which the reference mapped to are appended to
	  string. The head stands on the first character after the reference.

	  parseReference_charDataRead is set to false if the reference must be parsed.
	  The charachter(s) which the reference mapped to are inserted at the reference
	  position. The head stands on the first character of the replacement).*/
	bool CXMLReader::ParseReference()
	{
		// temporary variables (only used in very local context, so they don't interfere with incremental parsing)
		unsigned int tmp;
		//bool ok;

		const signed char Init             =  0;
		const signed char SRef             =  1; // start of a reference
		const signed char ChRef            =  2; // parse CharRef
		const signed char ChDec            =  3; // parse CharRef decimal
		const signed char ChHexS           =  4; // start CharRef hexadecimal
		const signed char ChHex            =  5; // parse CharRef hexadecimal
		const signed char Name             =  6; // parse name
		const signed char DoneD            =  7; // done CharRef decimal
		const signed char DoneH            =  8; // done CharRef hexadecimal
		const signed char DoneN            =  9; // done EntityRef

		const signed char InpAmp           = 0; // &
		const signed char InpSemi          = 1; // ;
		const signed char InpHash          = 2; // #
		const signed char InpX             = 3; // x
		const signed char InpNum           = 4; // 0-9
		const signed char InpHex           = 5; // a-f A-F
		const signed char InpUnknown       = 6;

		static const signed char table[ 8 ][ 7 ] = 
		{
		 /*  InpAmp  InpSemi  InpHash  InpX     InpNum  InpHex  InpUnknown */
			{ SRef,   -1,      -1,      -1,      -1,     -1,     -1    }, // Init
			{ -1,     -1,      ChRef,   Name,    Name,   Name,   Name  }, // SRef
			{ -1,     -1,      -1,      ChHexS,  ChDec,  -1,     -1    }, // ChRef
			{ -1,     DoneD,   -1,      -1,      ChDec,  -1,     -1    }, // ChDec
			{ -1,     -1,      -1,      -1,      ChHex,  ChHex,  -1    }, // ChHexS
			{ -1,     DoneH,   -1,      -1,      ChHex,  ChHex,  -1    }, // ChHex
			{ -1,     DoneN,   -1,      -1,      -1,     -1,     -1    }  // Name
		};
		signed char state;
		signed char input;

		if( m_pParseStack ==0 || m_pParseStack->empty() ) 
		{
			m_bParseReference_charDataRead = false;
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !( this->*function )() ) 
				{
					ParseFailed(&CXMLReader::ParseReference, state );
					return false;
				}
			}
		}

		for (;;) 
		{
			switch (state) 
			{
				case DoneD:
					return true;
				case DoneH:
					return true;
				case DoneN:
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_ERRORPARSINGREFERENCE ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof(&CXMLReader::ParseReference, state);
				return false;
			}

			if( m_C == '&' ) 
			{
				input = InpAmp;
			} 
			else if( m_C == ';') 
			{
				input = InpSemi;
			} 
			else if( m_C == '#') 
			{
				input = InpHash;
			} 
			else if( m_C == 'x') 
			{
				input = InpX;
			} 
			else if ('0' <= m_C && m_C <= '9') 
			{
				input = InpNum;
			} 
			else if ('a' <= m_C && m_C <= 'f') 
			{
				input = InpHex;
			} 
			else if ('A' <= m_C && m_C <= 'F') 
			{
				input = InpHex;
			} 
			else 
			{
				input = InpUnknown;
			}

			state = table[ state ][ input ];

			switch (state) 
			{
				case SRef:
					RefClear();
					Next();
					break;
				case ChRef:
					Next();
					break;
				case ChDec:
					RefAddC();
					Next();
					break;
				case ChHexS:
					Next();
					break;
				case ChHex:
					RefAddC();
					Next();
					break;
				case Name:
					// read the name into the ref
					m_bParseName_useRef = true;
					if (!ParseName()) 
					{
						ParseFailed(&CXMLReader::ParseReference, state);
						return false;
					}
					break;

				case DoneD:
					tmp = Ref().ToUInt(10);
					StringAddC( char( tmp ) );
/*
					{
						reportParseError( nsCodeQOR::CString( _TXT( XMLERR_ERRORPARSINGREFERENCE ) ) );
						return false;
					}
					*/
					m_bParseReference_charDataRead = true;
					Next();
					break;

				case DoneH:
					tmp = Ref().ToUInt(16);
					//if( ok ) 
					{
						StringAddC( char( tmp ) );
					} 
					/*
					else 
					{
						reportParseError( nsCodeQOR::CString( _TXT( XMLERR_ERRORPARSINGREFERENCE ) ) );
						return false;
					}
					*/
					m_bParseReference_charDataRead = true;
					Next();
					break;

				case DoneN:
					if (!ProcessReference())
					{
						return false;
					}
					Next();
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	/*Parse a AttValue [10]

	  Precondition: the head stands on the beginning " or '

	  If this function was successful, the head stands on the first
	  character after the closing " or ' and the value of the attribute
	  is in string().
	*/
	bool CXMLReader::ParseAttValue()
	{
		const signed char Init             = 0;
		const signed char Dq               = 1; // double quotes were read
		const signed char DqRef            = 2; // read references in double quotes
		const signed char DqC              = 3; // signed character read in double quotes
		const signed char Sq               = 4; // single quotes were read
		const signed char SqRef            = 5; // read references in single quotes
		const signed char SqC              = 6; // signed character read in single quotes
		const signed char Done             = 7;

		const signed char InpDq            = 0; // "
		const signed char InpSq            = 1; // '
		const signed char InpAmp           = 2; // &
		const signed char InpLt            = 3; // <
		const signed char InpUnknown       = 4;

		static const signed char table[ 7 ][ 5 ] = 
		{
		 /*  InpDq  InpSq  InpAmp  InpLt InpUnknown */
			{ Dq,    Sq,    -1,     -1,   -1    }, // Init
			{ Done,  DqC,   DqRef,  -1,   DqC   }, // Dq
			{ Done,  DqC,   DqRef,  -1,   DqC   }, // DqRef
			{ Done,  DqC,   DqRef,  -1,   DqC   }, // DqC
			{ SqC,   Done,  SqRef,  -1,   SqC   }, // Sq
			{ SqC,   Done,  SqRef,  -1,   SqC   }, // SqRef
			{ SqC,   Done,  SqRef,  -1,   SqC   }  // SqRef
		};
		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}

				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParseAttValue, state );
					return false;
				}
			}
		}

		for( ;; ) 
		{
			switch( state ) 
			{
				case Done:
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_UNEXPECTEDCHARACTER ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParseAttValue, state );
				return false;
			}

			if( m_C == '"' ) 
			{
				input = InpDq;
			} 
			else if( m_C == '\'' ) 
			{
				input = InpSq;
			} 
			else if( m_C == '&' ) 
			{
				input = InpAmp;
			} 
			else if( m_C == '<' ) 
			{
				input = InpLt;
			} 
			else 
			{
				input = InpUnknown;
			}
			state = table[ state ][ input ];

			switch( state ) 
			{
				case Dq:
				case Sq:
					StringClear();
					Next();
					break;
				case DqRef:
				case SqRef:
					m_ParseReference_context = InAttributeValue;
					if( !ParseReference() ) 
					{
						ParseFailed( &CXMLReader::ParseAttValue, state );
						return false;
					}
					break;
				case DqC:
				case SqC:
					StringAddC();
					Next();
					break;
				case Done:
					Next();
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	/*Parse a AttlistDecl [52].

	  Precondition: the beginning '<!' is already read and the head
	  stands on the 'A' of '<!ATTLIST'
	*/
	bool CXMLReader::ParseAttlistDecl()
	{
		const signed char Init             =  0;
		const signed char Attlist          =  1; // parse the string "ATTLIST"
		const signed char Ws               =  2; // whitespace read
		const signed char Name             =  3; // parse name
		const signed char Ws1              =  4; // whitespace read
		const signed char Attdef           =  5; // parse the AttDef
		const signed char Ws2              =  6; // whitespace read
		const signed char Atttype          =  7; // parse the AttType
		const signed char Ws3              =  8; // whitespace read
		const signed char DDecH            =  9; // DefaultDecl with #
		const signed char DefReq           = 10; // parse the string "REQUIRED"
		const signed char DefImp           = 11; // parse the string "IMPLIED"
		const signed char DefFix           = 12; // parse the string "FIXED"
		const signed char Attval           = 13; // parse the AttValue
		const signed char Ws4              = 14; // whitespace read
		const signed char Done             = 15;

		const signed char InpWs            = 0; // white space
		const signed char InpGt            = 1; // >
		const signed char InpHash          = 2; // #
		const signed char InpA             = 3; // A
		const signed char InpI             = 4; // I
		const signed char InpF             = 5; // F
		const signed char InpR             = 6; // R
		const signed char InpUnknown       = 7;

		static const signed char table[ 15 ][ 8 ] = 
		{
		 /*  InpWs    InpGt    InpHash  InpA      InpI     InpF     InpR     InpUnknown */
			{ -1,      -1,      -1,      Attlist,  -1,      -1,      -1,      -1      }, // Init
			{ Ws,      -1,      -1,      -1,       -1,      -1,      -1,      -1      }, // Attlist
			{ -1,      -1,      -1,      Name,     Name,    Name,    Name,    Name    }, // Ws
			{ Ws1,     Done,    Attdef,  Attdef,   Attdef,  Attdef,  Attdef,  Attdef  }, // Name
			{ -1,      Done,    Attdef,  Attdef,   Attdef,  Attdef,  Attdef,  Attdef  }, // Ws1
			{ Ws2,     -1,      -1,      -1,       -1,      -1,      -1,      -1      }, // Attdef
			{ -1,      Atttype, Atttype, Atttype,  Atttype, Atttype, Atttype, Atttype }, // Ws2
			{ Ws3,     -1,      -1,      -1,       -1,      -1,      -1,      -1      }, // Attype
			{ -1,      Attval,  DDecH,   Attval,   Attval,  Attval,  Attval,  Attval  }, // Ws3
			{ -1,      -1,      -1,      -1,       DefImp,  DefFix,  DefReq,  -1      }, // DDecH
			{ Ws4,     Ws4,     -1,      -1,       -1,      -1,      -1,      -1      }, // DefReq
			{ Ws4,     Ws4,     -1,      -1,       -1,      -1,      -1,      -1      }, // DefImp
			{ Ws3,     -1,      -1,      -1,       -1,      -1,      -1,      -1      }, // DefFix
			{ Ws4,     Ws4,     -1,      -1,       -1,      -1,      -1,      -1      }, // Attval
			{ -1,      Done,    Attdef,  Attdef,   Attdef,  Attdef,  Attdef,  Attdef  }  // Ws4
		};

		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParseAttlistDecl, state );
					return false;
				}
			}
		}

		for(;;) 
		{
			switch( state ) 
			{
				case Name:
					m_AttDeclEName = name();
					break;
				case Attdef:
					m_AttDeclAName = name();
					break;
				case Done:
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_LETTEREXPECTED ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParseAttlistDecl, state );
				return false;
			}

			if( m_C.IsSpace() ) 
			{
				input = InpWs;
			} 
			else if( m_C == '>' ) 
			{
				input = InpGt;
			} 
			else if( m_C == '#' ) 
			{
				input = InpHash;
			} 
			else if( m_C == 'A' ) 
			{
				input = InpA;
			} 
			else if( m_C == 'I' ) 
			{
				input = InpI;
			} 
			else if( m_C == 'F' ) 
			{
				input = InpF;
			} 
			else if( m_C == 'R' ) 
			{
				input = InpR;
			} 
			else 
			{
				input = InpUnknown;
			}
			state = table[ state ][ input ];

			switch( state ) 
			{
				case Attlist:
					m_ParseString_s = CXMLString( _TXT( "ATTLIST" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseAttlistDecl, state );
						return false;
					}
					break;
				case Ws:
				case Ws1:
				case Ws2:
				case Ws3:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseAttlistDecl, state );
						return false;
					}
					break;
				case Name:
					m_bParseName_useRef = false;
					if( !ParseName() ) 
					{
						ParseFailed( &CXMLReader::ParseAttlistDecl, state );
						return false;
					}
					break;
				case Attdef:
					m_bParseName_useRef = false;
					if( !ParseName() ) 
					{
						ParseFailed( &CXMLReader::ParseAttlistDecl, state );
						return false;
					}
					break;
				case Atttype:
					if( !ParseAttType() ) 
					{
						ParseFailed( &CXMLReader::ParseAttlistDecl, state );
						return false;
					}
					break;
				case DDecH:
					Next();
					break;
				case DefReq:
					m_ParseString_s = CXMLString( _TXT( "REQUIRED" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseAttlistDecl, state );
						return false;
					}
					break;
				case DefImp:
					m_ParseString_s = CXMLString( _TXT( "IMPLIED" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseAttlistDecl, state );
						return false;
					}
					break;
				case DefFix:
					m_ParseString_s = CXMLString( _TXT( "FIXED" ) );
					if (!ParseString()) 
					{
						ParseFailed( &CXMLReader::ParseAttlistDecl, state );
						return false;
					}
					break;
				case Attval:
					if( !ParseAttValue() ) 
					{
						ParseFailed( &CXMLReader::ParseAttlistDecl, state );
						return false;
					}
					break;
				case Ws4:
					if( !DeclHandler.IsNull() ) 
					{
						// ### not all values are computed yet...
						if( !DeclHandler().AttributeDecl( m_AttDeclEName, m_AttDeclAName, CXMLString(), CXMLString(), CXMLString() ) ) 
						{
							ReportParseError( DeclHandler().ErrorString() );
							return false;
						}
					}
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseAttlistDecl, state );
						return false;
					}
					break;
				case Done:
					Next();
					break;
			}
		}
		//return false;
	}


	//------------------------------------------------------------------------------
	/*Parse a elementdecl [45].
	  Precondition: the beginning '<!E' is already read and the head
	  stands on the 'L' of '<!ELEMENT'	*/
	bool CXMLReader::ParseElementDecl()
	{
		const signed char Init             =  0;
		const signed char Elem             =  1; // parse the beginning string
		const signed char Ws1              =  2; // whitespace required
		const signed char Nam              =  3; // parse Name
		const signed char Ws2              =  4; // whitespace required
		const signed char Empty            =  5; // read EMPTY
		const signed char Any              =  6; // read ANY
		const signed char Cont             =  7; // read contentspec (except ANY or EMPTY)
		const signed char Mix              =  8; // read Mixed
		const signed char Mix2             =  9; //
		const signed char Mix3             = 10; //
		const signed char MixN1            = 11; //
		const signed char MixN2            = 12; //
		const signed char MixN3            = 13; //
		const signed char MixN4            = 14; //
		const signed char Cp               = 15; // parse cp
		const signed char Cp2              = 16; //
		const signed char WsD              = 17; // eat whitespace before Done
		const signed char Done             = 18;

		const signed char InpWs            =  0;
		const signed char InpGt            =  1; // >
		const signed char InpPipe          =  2; // |
		const signed char InpOp            =  3; // (
		const signed char InpCp            =  4; //)
		const signed char InpHash          =  5; // #
		const signed char InpQm            =  6; // ?
		const signed char InpAst           =  7; // *
		const signed char InpPlus          =  8; // +
		const signed char InpA             =  9; // A
		const signed char InpE             = 10; // E
		const signed char InpL             = 11; // L
		const signed char InpUnknown       = 12;

		static const signed char table[ 18 ][ 13 ] = 
		{
		 /*  InpWs   InpGt  InpPipe  InpOp  InpCp   InpHash  InpQm  InpAst  InpPlus  InpA    InpE    InpL    InpUnknown */
			{ -1,     -1,    -1,      -1,    -1,     -1,      -1,    -1,     -1,      -1,     -1,     Elem,   -1     }, // Init
			{ Ws1,    -1,    -1,      -1,    -1,     -1,      -1,    -1,     -1,      -1,     -1,     -1,     -1     }, // Elem
			{ -1,     -1,    -1,      -1,    -1,     -1,      -1,    -1,     -1,      Nam,    Nam,    Nam,    Nam    }, // Ws1
			{ Ws2,    -1,    -1,      -1,    -1,     -1,      -1,    -1,     -1,      -1,     -1,     -1,     -1     }, // Nam
			{ -1,     -1,    -1,      Cont,  -1,     -1,      -1,    -1,     -1,      Any,    Empty,  -1,     -1     }, // Ws2
			{ WsD,    Done,  -1,      -1,    -1,     -1,      -1,    -1,     -1,      -1,     -1,     -1,     -1     }, // Empty
			{ WsD,    Done,  -1,      -1,    -1,     -1,      -1,    -1,     -1,      -1,     -1,     -1,     -1     }, // Any
			{ -1,     -1,    -1,      Cp,    Cp,     Mix,     -1,    -1,     -1,      Cp,     Cp,     Cp,     Cp     }, // Cont
			{ Mix2,   -1,    MixN1,   -1,    Mix3,   -1,      -1,    -1,     -1,      -1,     -1,     -1,     -1     }, // Mix
			{ -1,     -1,    MixN1,   -1,    Mix3,   -1,      -1,    -1,     -1,      -1,     -1,     -1,     -1     }, // Mix2
			{ WsD,    Done,  -1,      -1,    -1,     -1,      -1,    WsD,    -1,      -1,     -1,     -1,     -1     }, // Mix3
			{ -1,     -1,    -1,      -1,    -1,     -1,      -1,    -1,     -1,      MixN2,  MixN2,  MixN2,  MixN2  }, // MixN1
			{ MixN3,  -1,    MixN1,   -1,    MixN4,  -1,      -1,    -1,     -1,      -1,     -1,     -1,     -1     }, // MixN2
			{ -1,     -1,    MixN1,   -1,    MixN4,  -1,      -1,    -1,     -1,      -1,     -1,     -1,     -1     }, // MixN3
			{ -1,     -1,    -1,      -1,    -1,     -1,      -1,    WsD,    -1,      -1,     -1,     -1,     -1     }, // MixN4
			{ WsD,    Done,  -1,      -1,    -1,     -1,      Cp2,   Cp2,    Cp2,     -1,     -1,     -1,     -1     }, // Cp
			{ WsD,    Done,  -1,      -1,    -1,     -1,      -1,    -1,     -1,      -1,     -1,     -1,     -1     }, // Cp2
			{ -1,     Done,  -1,      -1,    -1,     -1,      -1,    -1,     -1,      -1,     -1,     -1,     -1     }  // WsD
		};
		
		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParseElementDecl, state );
					return false;
				}
			}
		}

		for(;;) 
		{
			switch( state ) 
			{
				case Done:
					return true;
				case -1:
					ReportParseError( CXMLString( _TXT( XMLERR_UNEXPECTEDCHARACTER ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof(&CXMLReader::ParseElementDecl, state);
				return false;
			}

			if( m_C.IsSpace() ) 
			{
				input = InpWs;
			} 
			else if( m_C == '>' ) 
			{
				input = InpGt;
			} 
			else if( m_C == '|' ) 
			{
				input = InpPipe;
			} 
			else if( m_C == '(' ) 
			{
				input = InpOp;
			} 
			else if( m_C == ')' ) 
			{
				input = InpCp;
			} 
			else if( m_C == '#' ) 
			{
				input = InpHash;
			} 
			else if( m_C == '?' ) 
			{
				input = InpQm;
			} 
			else if( m_C == '*' ) 
			{
				input = InpAst;
			} 
			else if( m_C == '+' ) 
			{
				input = InpPlus;
			} 
			else if( m_C == 'A' ) 
			{
				input = InpA;
			} 
			else if( m_C == 'E' ) 
			{
				input = InpE;
			} 
			else if( m_C == 'L' ) 
			{
				input = InpL;
			} 
			else 
			{
				input = InpUnknown;
			}
			state = table[state][input];

			switch( state ) 
			{
				case Elem:
					m_ParseString_s = CXMLString( _TXT( "LEMENT" ) );
					if (!ParseString()) 
					{
						ParseFailed(&CXMLReader::ParseElementDecl, state);
						return false;
					}
					break;
				case Ws1:
					if (!eat_ws()) 
					{
						ParseFailed(&CXMLReader::ParseElementDecl, state);
						return false;
					}
					break;
				case Nam:
					m_bParseName_useRef = false;
					if (!ParseName()) 
					{
						ParseFailed(&CXMLReader::ParseElementDecl, state);
						return false;
					}
					break;
				case Ws2:
					if (!eat_ws()) 
					{
						ParseFailed(&CXMLReader::ParseElementDecl, state);
						return false;
					}
					break;
				case Empty:
					m_ParseString_s = CXMLString( _TXT( "EMPTY" ) );
					if (!ParseString()) 
					{
						ParseFailed(&CXMLReader::ParseElementDecl, state);
						return false;
					}
					break;
				case Any:
					m_ParseString_s = CXMLString( _TXT("ANY") );
					if (!ParseString()) 
					{
						ParseFailed(&CXMLReader::ParseElementDecl, state);
						return false;
					}
					break;
				case Cont:
					if (!next_eat_ws()) 
					{
						ParseFailed(&CXMLReader::ParseElementDecl, state);
						return false;
					}
					break;
				case Mix:
					m_ParseString_s = CXMLString( _TXT( "#PCDATA" ) );
					if (!ParseString()) 
					{
						ParseFailed(&CXMLReader::ParseElementDecl, state);
						return false;
					}
					break;
				case Mix2:
					if (!eat_ws()) 
					{
						ParseFailed(&CXMLReader::ParseElementDecl, state);
						return false;
					}
					break;
				case Mix3:
					Next();
					break;
				case MixN1:
					if (!next_eat_ws()) 
					{
						ParseFailed(&CXMLReader::ParseElementDecl, state);
						return false;
					}
					break;
				case MixN2:
					m_bParseName_useRef = false;
					if (!ParseName()) 
					{
						ParseFailed(&CXMLReader::ParseElementDecl, state);
						return false;
					}
					break;
				case MixN3:
					if (!eat_ws()) 
					{
						ParseFailed(&CXMLReader::ParseElementDecl, state);
						return false;
					}
					break;
				case MixN4:
					Next();
					break;
				case Cp:
					if (!ParseChoiceSeq()) 
					{
						ParseFailed(&CXMLReader::ParseElementDecl, state);
						return false;
					}
					break;
				case Cp2:
					Next();
					break;
				case WsD:
					if (!next_eat_ws()) 
					{
						ParseFailed(&CXMLReader::ParseElementDecl, state);
						return false;
					}
					break;
				case Done:
					Next();
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	/*Parse a EntityDecl [70].
	  Precondition: the beginning '<!E' is already read and the head
	  stand on the 'N' of '<!ENTITY'
	*/
	bool CXMLReader::ParseEntityDecl()
	{
		const signed char Init             =  0;
		const signed char Ent              =  1; // parse "ENTITY"
		const signed char Ws1              =  2; // white space read
		const signed char Name             =  3; // parse name
		const signed char Ws2              =  4; // white space read
		const signed char EValue           =  5; // parse entity value
		const signed char EValueR          =  6; // same as EValue, but already reported
		const signed char ExtID            =  7; // parse ExternalID
		const signed char Ws3              =  8; // white space read
		const signed char Ndata            =  9; // parse "NDATA"
		const signed char Ws4              = 10; // white space read
		const signed char NNam             = 11; // parse name
		const signed char NNamR            = 12; // same as NNam, but already reported
		const signed char PEDec            = 13; // parse PEDecl
		const signed char Ws6              = 14; // white space read
		const signed char PENam            = 15; // parse name
		const signed char Ws7              = 16; // white space read
		const signed char PEVal            = 17; // parse entity value
		const signed char PEValR           = 18; // same as PEVal, but already reported
		const signed char PEEID            = 19; // parse ExternalID
		const signed char PEEIDR           = 20; // same as PEEID, but already reported
		const signed char WsE              = 21; // white space read
		const signed char Done             = 22;
		const signed char EDDone           = 23; // done, but also report an external, unparsed entity decl

		const signed char InpWs            = 0; // white space
		const signed char InpPer           = 1; // %
		const signed char InpQuot          = 2; // " or '
		const signed char InpGt            = 3; // >
		const signed char InpN             = 4; // N
		const signed char InpUnknown       = 5;

		static const signed char table[ 22 ][ 6 ] = 
		{
		 /*  InpWs  InpPer  InpQuot  InpGt  InpN    InpUnknown */
			{ -1,    -1,     -1,      -1,    Ent,    -1      }, // Init
			{ Ws1,   -1,     -1,      -1,    -1,     -1      }, // Ent
			{ -1,    PEDec,  -1,      -1,    Name,   Name    }, // Ws1
			{ Ws2,   -1,     -1,      -1,    -1,     -1      }, // Name
			{ -1,    -1,     EValue,  -1,    -1,     ExtID   }, // Ws2
			{ WsE,   -1,     -1,      Done,  -1,     -1      }, // EValue
			{ WsE,   -1,     -1,      Done,  -1,     -1      }, // EValueR
			{ Ws3,   -1,     -1,      EDDone,-1,     -1      }, // ExtID
			{ -1,    -1,     -1,      EDDone,Ndata,  -1      }, // Ws3
			{ Ws4,   -1,     -1,      -1,    -1,     -1      }, // Ndata
			{ -1,    -1,     -1,      -1,    NNam,   NNam    }, // Ws4
			{ WsE,   -1,     -1,      Done,  -1,     -1      }, // NNam
			{ WsE,   -1,     -1,      Done,  -1,     -1      }, // NNamR
			{ Ws6,   -1,     -1,      -1,    -1,     -1      }, // PEDec
			{ -1,    -1,     -1,      -1,    PENam,  PENam   }, // Ws6
			{ Ws7,   -1,     -1,      -1,    -1,     -1      }, // PENam
			{ -1,    -1,     PEVal,   -1,    -1,     PEEID   }, // Ws7
			{ WsE,   -1,     -1,      Done,  -1,     -1      }, // PEVal
			{ WsE,   -1,     -1,      Done,  -1,     -1      }, // PEValR
			{ WsE,   -1,     -1,      Done,  -1,     -1      }, // PEEID
			{ WsE,   -1,     -1,      Done,  -1,     -1      }, // PEEIDR
			{ -1,    -1,     -1,      Done,  -1,     -1      }  // WsE
		};
		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParseEntityDecl, state );
					return false;
				}
			}
		}

		for (;;) 
		{
			switch( state ) 
			{
				case EValue:
					if( !EntityExist(name()) ) 
					{
						m_Entities.insert( std::make_pair( name(), string() ) );
						if(!DeclHandler.IsNull()) 
						{
							if( !DeclHandler().InternalEntityDecl(name(), string()) ) 
							{
								ReportParseError( DeclHandler().ErrorString() );
								return false;
							}
						}
					}
					state = EValueR;
					break;
				case NNam:
					if( !EntityExist(name()) ) 
					{
						m_ExternEntities.insert( std::make_pair( name(), ExternEntity( m_PublicId, m_SystemId, Ref() ) ) );
						if( !DTDHandler.IsNull() ) 
						{
							if( !DTDHandler().UnparsedEntityDecl( name(), m_PublicId, m_SystemId, Ref() ) ) 
							{
								ReportParseError( DeclHandler().ErrorString() );
								return false;
							}
						}
					}
					state = NNamR;
					break;
				case PEVal:
					if( !EntityExist( name() ) ) 
					{
						m_ParameterEntities.insert( std::make_pair( name(), string() ) );
						if( !DeclHandler.IsNull() ) 
						{
							if( !DeclHandler().InternalEntityDecl( '%' + name(), string() ) ) 
							{
								ReportParseError( DeclHandler().ErrorString() );
								return false;
							}
						}
					}
					state = PEValR;
					break;
				case PEEID:
					if( !EntityExist( name() ) ) 
					{
						m_ExternParameterEntities.insert( std::make_pair( name(), ExternParameterEntity( m_PublicId, m_SystemId ) ) );
						if( !DeclHandler.IsNull() ) 
						{
							if( !DeclHandler().ExternalEntityDecl( '%' + name(), m_PublicId, m_SystemId ) ) 
							{
								ReportParseError( DeclHandler().ErrorString() );
								return false;
							}
						}
					}
					state = PEEIDR;
					break;
				case EDDone:
					if( !EntityExist( name() ) ) 
					{
						m_ExternEntities.insert( std::make_pair( name(), ExternEntity( m_PublicId, m_SystemId, CXMLString() ) ) );
						if( !DeclHandler.IsNull() ) 
						{
							if( !DeclHandler().ExternalEntityDecl( name(), m_PublicId, m_SystemId ) ) 
							{
								ReportParseError( DeclHandler().ErrorString() );
								return false;
							}
						}
					}
					return true;
				case Done:
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_LETTEREXPECTED ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof(&CXMLReader::ParseEntityDecl, state);
				return false;
			}

			if( m_C.IsSpace() ) 
			{
				input = InpWs;
			} 
			else if( m_C == '%' ) 
			{
				input = InpPer;
			} 
			else if( m_C == '"' || m_C == '\'' ) 
			{
				input = InpQuot;
			} 
			else if( m_C == '>' ) 
			{
				input = InpGt;
			} 
			else if( m_C == 'N' ) 
			{
				input = InpN;
			} 
			else 
			{
				input = InpUnknown;
			}
			state = table[ state ][ input ];

			switch( state ) 
			{
				case Ent:
					m_ParseString_s = CXMLString( _TXT( "NTITY" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityDecl, state );
						return false;
					}
					break;
				case Ws1:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityDecl, state );
						return false;
					}
					break;
				case Name:
					m_bParseName_useRef = false;
					if( !ParseName() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityDecl, state );
						return false;
					}
					break;
				case Ws2:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityDecl, state );
						return false;
					}
					break;
				case EValue:
				case EValueR:
					if( !ParseEntityValue() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityDecl, state );
						return false;
					}
					break;
				case ExtID:
					m_bParseExternalID_allowPublicID = false;
					if( !ParseExternalID() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityDecl, state );
						return false;
					}
					break;
				case Ws3:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityDecl, state );
						return false;
					}
					break;
				case Ndata:
					m_ParseString_s = CXMLString( _TXT( " NDATA" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityDecl, state );
						return false;
					}
					break;
				case Ws4:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityDecl, state );
						return false;
					}
					break;
				case NNam:
				case NNamR:
					m_bParseName_useRef = true;
					if( !ParseName() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityDecl, state );
						return false;
					}
					break;
				case PEDec:
					Next();
					break;
				case Ws6:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityDecl, state );
						return false;
					}
					break;
				case PENam:
					m_bParseName_useRef = false;
					if( !ParseName() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityDecl, state );
						return false;
					}
					break;
				case Ws7:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityDecl, state );
						return false;
					}
					break;
				case PEVal:
				case PEValR:
					if( !ParseEntityValue() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityDecl, state );
						return false;
					}
					break;
				case PEEID:
				case PEEIDR:
					m_bParseExternalID_allowPublicID = false;
					if( !ParseExternalID() )
					{
						ParseFailed( &CXMLReader::ParseEntityDecl, state );
						return false;
					}
					break;
				case WsE:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityDecl, state );
						return false;
					}
					break;
				case EDDone:
					Next();
					break;
				case Done:
					Next();
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	/*Parse a NotationDecl [82].
	  Precondition: the beginning '<!' is already read and the head
	  stands on the 'N' of '<!NOTATION'*/
	bool CXMLReader::ParseNotationDecl()
	{
		const signed char Init             = 0;
		const signed char Not              = 1; // read NOTATION
		const signed char Ws1              = 2; // eat whitespaces
		const signed char Nam              = 3; // read Name
		const signed char Ws2              = 4; // eat whitespaces
		const signed char ExtID            = 5; // parse ExternalID
		const signed char ExtIDR           = 6; // same as ExtID, but already reported
		const signed char Ws3              = 7; // eat whitespaces
		const signed char Done             = 8;

		const signed char InpWs            = 0;
		const signed char InpGt            = 1; // >
		const signed char InpN             = 2; // N
		const signed char InpUnknown       = 3;

		static const signed char table[ 8 ][ 4 ] = 
		{
		 /*  InpWs   InpGt  InpN    InpUnknown */
			{ -1,     -1,    Not,    -1     }, // Init
			{ Ws1,    -1,    -1,     -1     }, // Not
			{ -1,     -1,    Nam,    Nam    }, // Ws1
			{ Ws2,    Done,  -1,     -1     }, // Nam
			{ -1,     Done,  ExtID,  ExtID  }, // Ws2
			{ Ws3,    Done,  -1,     -1     }, // ExtID
			{ Ws3,    Done,  -1,     -1     }, // ExtIDR
			{ -1,     Done,  -1,     -1     }  // Ws3
		};
		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParseNotationDecl, state );
					return false;
				}
			}
		}

		for (;;) 
		{
			switch( state ) 
			{
				case ExtID:
					// call the handler
					if (!DTDHandler.IsNull()) 
					{
						if( !DTDHandler().NotationDecl( name(), m_PublicId, m_SystemId ) ) 
						{
							ReportParseError( DTDHandler().ErrorString() );
							return false;
						}
					}
					state = ExtIDR;
					break;
				case Done:
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_UNEXPECTEDCHARACTER ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof(&CXMLReader::ParseNotationDecl, state);
				return false;
			}

			if( m_C.IsSpace() ) 
			{
				input = InpWs;
			} 
			else if( m_C == '>' ) 
			{
				input = InpGt;
			} 
			else if( m_C == 'N' ) 
			{
				input = InpN;
			} 
			else 
			{
				input = InpUnknown;
			}
			state = table[ state ][ input ];

			switch( state ) 
			{
				case Not:
					m_ParseString_s = CXMLString( _TXT( "NOTATION" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseNotationDecl, state );
						return false;
					}
					break;
				case Ws1:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseNotationDecl, state );
						return false;
					}
					break;
				case Nam:
					m_bParseName_useRef = false;
					if( !ParseName() ) 
					{
						ParseFailed( &CXMLReader::ParseNotationDecl, state );
						return false;
					}
					break;
				case Ws2:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseNotationDecl, state );
						return false;
					}
					break;
				case ExtID:
				case ExtIDR:
					m_bParseExternalID_allowPublicID = true;
					if( !ParseExternalID() ) 
					{
						ParseFailed( &CXMLReader::ParseNotationDecl, state );
						return false;
					}
					break;
				case Ws3:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseNotationDecl, state );
						return false;
					}
					break;
				case Done:
					Next();
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	//Helper function for parseReference()
	bool CXMLReader::ProcessReference()
	{
		CXMLString reference = Ref();
		if( reference == CXMLString( _TXT( "amp" ) ) ) 
		{
			if( m_ParseReference_context == InEntityValue ) 
			{
				// Bypassed
				StringAddC( '&' ); StringAddC( 'a' ); StringAddC( 'm' ); StringAddC( 'p' ); StringAddC( ';' );
			} 
			else 
			{
				// Included or Included in literal
				StringAddC( '&' );
			}
			m_bParseReference_charDataRead = true;
		} 
		else if( reference == CXMLString( _TXT( "lt" ) ) ) 
		{
			if( m_ParseReference_context == InEntityValue ) 
			{
				// Bypassed
				StringAddC( '&' );
				StringAddC( 'l' );
				StringAddC( 't' );
				StringAddC( ';' );
			} 
			else 
			{
				// Included or Included in literal
				StringAddC( '<' );
			}
			m_bParseReference_charDataRead = true;
		} 
		else if( reference == CXMLString( _TXT( "gt" ) ) ) 
		{
			if( m_ParseReference_context == InEntityValue ) 
			{
				// Bypassed
				StringAddC( '&' ); 
				StringAddC( 'g' );
				StringAddC( 't' );
				StringAddC( ';' );
			} 
			else 
			{
				// Included or Included in literal
				StringAddC( '>' );
			}
			m_bParseReference_charDataRead = true;
		} 
		else if( reference == CXMLString( _TXT( "apos" ) ) ) 
		{
			if( m_ParseReference_context == InEntityValue ) 
			{
				// Bypassed
				StringAddC( '&' );
				StringAddC( 'a' );
				StringAddC( 'p' );
				StringAddC( 'o' );
				StringAddC( 's' );
				StringAddC( ';' );
			} 
			else 
			{
				// Included or Included in literal
				StringAddC( '\'' );
			}
			m_bParseReference_charDataRead = true;
		} 
		else if( reference == CXMLString( _TXT( "quot" ) ) ) 
		{
			if( m_ParseReference_context == InEntityValue ) 
			{
				// Bypassed
				StringAddC( '&' );
				StringAddC( 'q' );
				StringAddC( 'u' );
				StringAddC( 'o' );
				StringAddC( 't' );
				StringAddC( ';' );
			} 
			else 
			{
				// Included or Included in literal
				StringAddC( '"' );
			}
			m_bParseReference_charDataRead = true;
		} 
		else 
		{
			std::map< const CXMLString, CXMLString >::iterator it;
			
			it = m_Entities.find( reference );
			if( it != m_Entities.end() ) 
			{
				// "Internal General"
				switch( m_ParseReference_context ) 
				{
					case InContent:
						// Included
						if( !InsertXmlRef( it->second, reference, false ) )
						{
							return false;
						}
						m_bParseReference_charDataRead = false;
						break;
					case InAttributeValue:
						// Included in literal
						if( !InsertXmlRef( it->second, reference, true ) )
						{
							return false;
						}
						m_bParseReference_charDataRead = false;
						break;
					case InEntityValue:
						{
							// Bypassed
							StringAddC( '&' );
							for( int i = 0; i < (int)reference.Len(); i++ ) 
							{
								StringAddC( reference[ i ] );
							}
							StringAddC( ';' );
							m_bParseReference_charDataRead = true;
						}
						break;
					case InDTD:
						// Forbidden
						m_bParseReference_charDataRead = false;
						ReportParseError( CXMLString( _TXT( XMLERR_INTERNALGENERALENTITYINDTD ) ) );
						return false;
				}
			} 
			else 
			{
				std::map< const CXMLString, ExternEntity >::iterator itExtern;
				itExtern = m_ExternEntities.find( reference );
				if( itExtern == m_ExternEntities.end() ) 
				{
					// entity not declared
					// ### check this case for conformance
					if( m_ParseReference_context == InEntityValue ) 
					{
						// Bypassed
						StringAddC( '&' );
						for( int i = 0; i < (int)reference.Len(); i++ ) 
						{
							StringAddC( reference[ i ] );
						}
						StringAddC( ';' );
						m_bParseReference_charDataRead = true;
					} 
					else 
					{
						// if we have some char data read, report it now
						if( m_ParseReference_context == InContent ) 
						{
							if( m_bContentCharDataRead ) 
							{
								CXMLString strSimplified = Simplify( string() );
								if( m_bReportWhitespaceCharData || !strSimplified.IsEmpty() ) 
								{
									if( !ContentHandler.IsNull() != 0 && !ContentHandler().Characters(string()) ) 
									{
										ReportParseError( ContentHandler().ErrorString() );
										return false;
									}
								}
								StringClear();
								m_bContentCharDataRead = false;
							}
						}

						if( !ContentHandler.IsNull() ) 
						{
							m_bSkippedEntityInContent = m_ParseReference_context == InContent;
							if( !ContentHandler().SkippedEntity( reference ) ) 
							{
								m_bSkippedEntityInContent = false;
								ReportParseError(ContentHandler().ErrorString());
								return false; // error
							}
							m_bSkippedEntityInContent = false;
						}
					}
				} 
				else if( (*itExtern).second.m_Notation.IsEmpty() ) 
				{
					// "External Parsed General"
					switch( m_ParseReference_context ) 
					{
						case InContent:
							{
								// Included if validating
								bool skipIt = true;
								if( !EntityResolver.IsNull() ) 
								{
									CXmlInputSource *ret = 0;
									if (!EntityResolver().ResolveEntity((*itExtern).second.m_PublicId, (*itExtern).second.m_SystemId, ret)) 
									{
										delete ret;
										ReportParseError( EntityResolver().ErrorString() );
										return false;
									}
									if( ret ) 
									{
										CXMLString xmlRefString;
										/*TODO:
										CXMLString buffer = ret->Data();
										while( buffer.Len() > 0 )
										{
											xmlRefString.Append( buffer );
											ret->FetchData();
											buffer = ret->Data();
										}
										*/
										delete ret;
										if( !StripTextDecl( xmlRefString ) ) 
										{
											ReportParseError( CXMLString( _TXT( XMLERR_ERRORINTEXTDECL ) ) );
											return false;
										}
										if( !InsertXmlRef( xmlRefString, reference, false ) )
										{
											return false;
										}
										skipIt = false;
									}
								}
								if( skipIt && !ContentHandler.IsNull() ) 
								{
									m_bSkippedEntityInContent = true;
									if( !ContentHandler().SkippedEntity( reference) ) 
									{
										m_bSkippedEntityInContent = false;
										ReportParseError( ContentHandler().ErrorString());
										return false; // error
									}
									m_bSkippedEntityInContent = false;
								}
								m_bParseReference_charDataRead = false;
							} break;
						case InAttributeValue:
							// Forbidden
							m_bParseReference_charDataRead = false;
							ReportParseError( CXMLString( _TXT( XMLERR_EXTERNALGENERALENTITYINAV ) ) );
							return false;
						case InEntityValue:
							{
								// Bypassed
								StringAddC( '&' );
								for( int i = 0; i < (int)reference.Len(); i++ ) 
								{
									StringAddC( reference[ i ] );
								}
								StringAddC( ';' );
								m_bParseReference_charDataRead = true;
							}
							break;
						case InDTD:
							// Forbidden
							m_bParseReference_charDataRead = false;
							ReportParseError( CXMLString( _TXT( XMLERR_EXTERNALGENERALENTITYINDTD ) ) );
							return false;
					}
				} 
				else 
				{
					// "Unparsed"
					// ### notify for "Occurs as Attribute Value" missing (but this is no refence, anyway)
					// Forbidden
					m_bParseReference_charDataRead = false;
					ReportParseError( CXMLString( _TXT( XMLERR_UNPARSEDENTITYREFERENCE ) ) );
					return false; // error
				}
			}
		}
		return true; // no error
	}

	//------------------------------------------------------------------------------
	//Parse a AttType [54]
	bool CXMLReader::ParseAttType()
	{
		const signed char Init             =  0;
		const signed char ST               =  1; // StringType
		const signed char TTI              =  2; // TokenizedType starting with 'I'
		const signed char TTI2             =  3; // TokenizedType helpstate
		const signed char TTI3             =  4; // TokenizedType helpstate
		const signed char TTE              =  5; // TokenizedType starting with 'E'
		const signed char TTEY             =  6; // TokenizedType starting with 'ENTITY'
		const signed char TTEI             =  7; // TokenizedType starting with 'ENTITI'
		const signed char N                =  8; // N read (TokenizedType or Notation)
		const signed char TTNM             =  9; // TokenizedType starting with 'NM'
		const signed char TTNM2            = 10; // TokenizedType helpstate
		const signed char NO               = 11; // Notation
		const signed char NO2              = 12; // Notation helpstate
		const signed char NO3              = 13; // Notation helpstate
		const signed char NOName           = 14; // Notation, read name
		const signed char NO4              = 15; // Notation helpstate
		const signed char EN               = 16; // Enumeration
		const signed char ENNmt            = 17; // Enumeration, read Nmtoken
		const signed char EN2              = 18; // Enumeration helpstate
		const signed char ADone            = 19; // almost done (make next and accept)
		const signed char Done             = 20;

		const signed char InpWs            =  0; // whitespace
		const signed char InpOp            =  1; // (
		const signed char InpCp            =  2; //)
		const signed char InpPipe          =  3; // |
		const signed char InpC             =  4; // C
		const signed char InpE             =  5; // E
		const signed char InpI             =  6; // I
		const signed char InpM             =  7; // M
		const signed char InpN             =  8; // N
		const signed char InpO             =  9; // O
		const signed char InpR             = 10; // R
		const signed char InpS             = 11; // S
		const signed char InpY             = 12; // Y
		const signed char InpUnknown       = 13;

		static const signed char table[ 19 ][ 14 ] = 
		{
		 /*  InpWs    InpOp    InpCp    InpPipe  InpC     InpE     InpI     InpM     InpN     InpO     InpR     InpS     InpY     InpUnknown */
			{ -1,      EN,      -1,      -1,      ST,      TTE,     TTI,     -1,      N,       -1,      -1,      -1,      -1,      -1     }, // Init
			{ Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done   }, // ST
			{ Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    TTI2,    Done,    Done,    Done   }, // TTI
			{ Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    TTI3,    Done,    Done   }, // TTI2
			{ Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done   }, // TTI3
			{ -1,      -1,      -1,      -1,      -1,      -1,      TTEI,    -1,      -1,      -1,      -1,      -1,      TTEY,    -1     }, // TTE
			{ Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done   }, // TTEY
			{ Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done   }, // TTEI
			{ -1,      -1,      -1,      -1,      -1,      -1,      -1,      TTNM,    -1,      NO,      -1,      -1,      -1,      -1     }, // N
			{ Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    TTNM2,   Done,    Done   }, // TTNM
			{ Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done,    Done   }, // TTNM2
			{ NO2,     -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1     }, // NO
			{ -1,      NO3,     -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1     }, // NO2
			{ NOName,  NOName,  NOName,  NOName,  NOName,  NOName,  NOName,  NOName,  NOName,  NOName,  NOName,  NOName,  NOName,  NOName }, // NO3
			{ NO4,     -1,      ADone,   NO3,     -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1     }, // NOName
			{ -1,      -1,      ADone,   NO3,     -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1     }, // NO4
			{ -1,      -1,      ENNmt,   -1,      ENNmt,   ENNmt,   ENNmt,   ENNmt,   ENNmt,   ENNmt,   ENNmt,   ENNmt,   ENNmt,   ENNmt  }, // EN
			{ EN2,     -1,      ADone,   EN,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1     }, // ENNmt
			{ -1,      -1,      ADone,   EN,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1     }  // EN2
		};
		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed( &CXMLReader::ParseAttType, state );
					return false;
				}
			}
		}

		for (;;) 
		{
			switch( state ) 
			{
				case ADone:
					return true;
				case Done:
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_LETTEREXPECTED ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParseAttType, state );
				return false;
			}

			if( m_C.IsSpace() ) 
			{
				input = InpWs;
			} 
			else if( m_C == '(' ) 
			{
				input = InpOp;
			} 
			else if( m_C == ')' ) 
			{
				input = InpCp;
			} 
			else if( m_C == '|' ) 
			{
				input = InpPipe;
			} 
			else if( m_C == 'C' ) 
			{
				input = InpC;
			} 
			else if( m_C == 'E' ) 
			{
				input = InpE;
			} 
			else if( m_C == 'I' ) 
			{
				input = InpI;
			} 
			else if( m_C == 'M' ) 
			{
				input = InpM;
			} 
			else if( m_C == 'N' ) 
			{
				input = InpN;
			} 
			else if( m_C == 'O' ) 
			{
				input = InpO;
			} 
			else if( m_C == 'R' ) 
			{
				input = InpR;
			} 
			else if( m_C == 'S' ) 
			{
				input = InpS;
			} 
			else if( m_C == 'Y' ) 
			{
				input = InpY;
			} 
			else 
			{
				input = InpUnknown;
			}
			state = table[ state ][ input ];

			switch( state ) 
			{
				case ST:
					m_ParseString_s = CXMLString( _TXT( "CDATA" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseAttType, state );
						return false;
					}
					break;
				case TTI:
					m_ParseString_s = CXMLString( _TXT( "ID" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseAttType, state );
						return false;
					}
					break;
				case TTI2:
					m_ParseString_s = CXMLString( _TXT( "REF" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseAttType, state );
						return false;
					}
					break;
				case TTI3:
					Next(); // S
					break;
				case TTE:
					m_ParseString_s = CXMLString( _TXT( "ENTIT" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseAttType, state );
						return false;
					}
					break;
				case TTEY:
					Next(); // Y
					break;
				case TTEI:
					m_ParseString_s = CXMLString( _TXT( "IES" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseAttType, state );
						return false;
					}
					break;
				case N:
					Next(); // N
					break;
				case TTNM:
					m_ParseString_s = CXMLString( _TXT( "MTOKEN" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseAttType, state );
						return false;
					}
					break;
				case TTNM2:
					Next(); // S
					break;
				case NO:
					m_ParseString_s = CXMLString( _TXT( "OTATION" ) );
					if( !ParseString() ) 
					{
						ParseFailed( &CXMLReader::ParseAttType, state );
						return false;
					}
					break;
				case NO2:
					if( !eat_ws() ) 
					{
						ParseFailed(&CXMLReader::ParseAttType, state);
						return false;
					}
					break;
				case NO3:
					if( !next_eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseAttType, state );
						return false;
					}
					break;
				case NOName:
					m_bParseName_useRef = false;
					if( !ParseName() ) 
					{
						ParseFailed( &CXMLReader::ParseAttType, state );
						return false;
					}
					break;
				case NO4:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseAttType, state );
						return false;
					}
					break;
				case EN:
					if( !next_eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseAttType, state );
						return false;
					}
					break;
				case ENNmt:
					if( !ParseNmtoken() ) 
					{
						ParseFailed( &CXMLReader::ParseAttType, state );
						return false;
					}
					break;
				case EN2:
					if( !eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseAttType, state );
						return false;
					}
					break;
				case ADone:
					Next();
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	/*Parse choice [49] or seq [50].

	  Precondition: the beginning '('S? is already read and the head
	  stands on the first non-whitespace character after it.*/
	bool CXMLReader::ParseChoiceSeq()
	{
		const signed char Init             = 0;
		const signed char Ws1              = 1; // eat whitespace
		const signed char CoS              = 2; // choice or set
		const signed char Ws2              = 3; // eat whitespace
		const signed char More             = 4; // more cp to read
		const signed char Name             = 5; // read name
		const signed char Done             = 6; //

		const signed char InpWs            = 0; // S
		const signed char InpOp            = 1; // (
		const signed char InpCp            = 2; //)
		const signed char InpQm            = 3; // ?
		const signed char InpAst           = 4; // *
		const signed char InpPlus          = 5; // +
		const signed char InpPipe          = 6; // |
		const signed char InpComm          = 7; // ,
		const signed char InpUnknown       = 8;

		static const signed char table[ 6 ][ 9 ] = 
		{
		 /*  InpWs   InpOp  InpCp  InpQm  InpAst  InpPlus  InpPipe  InpComm  InpUnknown */
			{ -1,     Ws1,   -1,    -1,    -1,     -1,      -1,      -1,      Name  }, // Init
			{ -1,     CoS,   -1,    -1,    -1,     -1,      -1,      -1,      CoS   }, // Ws1
			{ Ws2,    -1,    Done,  Ws2,   Ws2,    Ws2,     More,    More,    -1    }, // CS
			{ -1,     -1,    Done,  -1,    -1,     -1,      More,    More,    -1    }, // Ws2
			{ -1,     Ws1,   -1,    -1,    -1,     -1,      -1,      -1,      Name  }, // More (same as Init)
			{ Ws2,    -1,    Done,  Ws2,   Ws2,    Ws2,     More,    More,    -1    }  // Name (same as CS)
		};
		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed(&CXMLReader::ParseChoiceSeq, state);
					return false;
				}
			}
		}

		for (;;) 
		{
			switch( state ) 
			{
				case Done:
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_UNEXPECTEDCHARACTER ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParseChoiceSeq, state );
				return false;
			}
			if( m_C.IsSpace() ) 
			{
				input = InpWs;
			} 
			else if( m_C == '(') 
			{
				input = InpOp;
			} 
			else if( m_C == ')') 
			{
				input = InpCp;
			} 
			else if( m_C == '?')
			{
				input = InpQm;
			} 
			else if( m_C == '*' ) 
			{
				input = InpAst;
			} 
			else if( m_C == '+' ) 
			{
				input = InpPlus;
			} 
			else if( m_C == '|' ) 
			{
				input = InpPipe;
			} 
			else if( m_C == ',' ) 
			{
				input = InpComm;
			} 
			else 
			{
				input = InpUnknown;
			}
			state = table[ state ][ input ];

			switch( state ) 
			{
				case Ws1:
					if( !next_eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseChoiceSeq, state );
						return false;
					}
					break;
				case CoS:
					if( !ParseChoiceSeq() ) 
					{
						ParseFailed( &CXMLReader::ParseChoiceSeq, state );
						return false;
					}
					break;
				case Ws2:
					if( !next_eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseChoiceSeq, state );
						return false;
					}
					break;
				case More:
					if( !next_eat_ws() ) 
					{
						ParseFailed( &CXMLReader::ParseChoiceSeq, state );
						return false;
					}
					break;
				case Name:
					m_bParseName_useRef = false;
					if( !ParseName() ) 
					{
						ParseFailed( &CXMLReader::ParseChoiceSeq, state );
						return false;
					}
					break;
				case Done:
					Next();
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	//Parse a EntityValue [9]
	bool CXMLReader::ParseEntityValue()
	{
		const signed char Init             = 0;
		const signed char Dq               = 1; // EntityValue is double quoted
		const signed char DqC              = 2; // signed character
		const signed char DqPER            = 3; // PERefence
		const signed char DqRef            = 4; // Reference
		const signed char Sq               = 5; // EntityValue is double quoted
		const signed char SqC              = 6; // signed character
		const signed char SqPER            = 7; // PERefence
		const signed char SqRef            = 8; // Reference
		const signed char Done             = 9;

		const signed char InpDq            = 0; // "
		const signed char InpSq            = 1; // '
		const signed char InpAmp           = 2; // &
		const signed char InpPer           = 3; // %
		const signed char InpUnknown       = 4;

		static const signed char table[ 9 ][ 5 ] = 
		{
		 /*  InpDq  InpSq  InpAmp  InpPer  InpUnknown */
			{ Dq,    Sq,    -1,     -1,     -1    }, // Init
			{ Done,  DqC,   DqRef,  DqPER,  DqC   }, // Dq
			{ Done,  DqC,   DqRef,  DqPER,  DqC   }, // DqC
			{ Done,  DqC,   DqRef,  DqPER,  DqC   }, // DqPER
			{ Done,  DqC,   DqRef,  DqPER,  DqC   }, // DqRef
			{ SqC,   Done,  SqRef,  SqPER,  SqC   }, // Sq
			{ SqC,   Done,  SqRef,  SqPER,  SqC   }, // SqC
			{ SqC,   Done,  SqRef,  SqPER,  SqC   }, // SqPER
			{ SqC,   Done,  SqRef,  SqPER,  SqC   }  // SqRef
		};

		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				
				if( !(this->*function)() ) 
				{
					ParseFailed(&CXMLReader::ParseEntityValue, state);
					return false;
				}
			}
		}

		for (;;) 
		{
			switch( state ) 
			{
				case Done:
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_LETTEREXPECTED ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParseEntityValue, state );
				return false;
			}

			if( m_C == '"' ) 
			{
				input = InpDq;
			} 
			else if( m_C == '\'' ) 
			{
				input = InpSq;
			} 
			else if( m_C == '&' ) 
			{
				input = InpAmp;
			} 
			else if( m_C == '%' ) 
			{
				input = InpPer;
			} 
			else 
			{
				input = InpUnknown;
			}
			state = table[ state ][ input ];

			switch( state ) 
			{
				case Dq:
				case Sq:
					StringClear();
					Next();
					break;
				case DqC:
				case SqC:
					StringAddC();
					Next();
					break;
				case DqPER:
				case SqPER:
					m_ParsePEReference_context = InEntityValue;
					if( !ParsePEReference() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityValue, state );
						return false;
					}
					break;
				case DqRef:
				case SqRef:
					m_ParseReference_context = InEntityValue;
					if( !ParseReference() ) 
					{
						ParseFailed( &CXMLReader::ParseEntityValue, state );
						return false;
					}
					break;
				case Done:
					Next();
					break;
			}
		}
		//return false;
	}

	//------------------------------------------------------------------------------
	//Parse a Nmtoken [7] and store the name in name.
	bool CXMLReader::ParseNmtoken()
	{
		const signed char Init             = 0;
		const signed char NameF            = 1;
		const signed char Name             = 2;
		const signed char Done             = 3;

		const signed char InpNameCh        = 0; // NameChar without InpNameBe
		const signed char InpUnknown       = 1;

		static const signed char table[3][2] = 
		{
		 /*  InpNameCh  InpUnknown */
			{ NameF,     -1    }, // Init
			{ Name,      Done  }, // NameF
			{ Name,      Done  }  // Name
		};
		signed char state;
		signed char input;

		if( m_pParseStack == 0 || m_pParseStack->empty() ) 
		{
			state = Init;
		} 
		else 
		{
			state = static_cast< signed char >( m_pParseStack->top().m_iState );
			m_pParseStack->pop();

			if( !m_pParseStack->empty() ) 
			{
				ParseFunction function = m_pParseStack->top().m_Function;
				if( function == &CXMLReader::eat_ws ) 
				{
					m_pParseStack->pop();
				}
				if( !(this->*function)() ) 
				{
					ParseFailed(&CXMLReader::ParseNmtoken, state);
					return false;
				}
			}
		}

		for (;;) 
		{
			switch( state ) 
			{
				case Done:
					return true;
				case -1:
					// Error
					ReportParseError( CXMLString( _TXT( XMLERR_LETTEREXPECTED ) ) );
					return false;
			}

			if( atEnd() ) 
			{
				UnexpectedEof( &CXMLReader::ParseNmtoken, state );
				return false;
			}

			if( determineNameChar( m_C ) == NotName ) 
			{
				input = InpUnknown;
			} 
			else 
			{
				input = InpNameCh;
			}
			state = table[ state ][ input ];

			switch( state ) 
			{
				case NameF:
					NameClear();
					NameAddC();
					Next();
					break;
				case Name:
					NameAddC();
					Next();
					break;
			}
		}
		//return false;
	}


	//------------------------------------------------------------------------------
	// Returns true if a entity with the name exists, otherwise returns false.
	bool CXMLReader::EntityExist( const CXMLString& e) const
	{
		if( m_ParameterEntities.find(e) == m_ParameterEntities.end() && 
			m_ExternParameterEntities.find( e ) == m_ExternParameterEntities.end() && 
			m_ExternEntities.find(e) == m_ExternEntities.end() && m_Entities.find(e) == m_Entities.end() ) 
		{
			return false;
		} 
		else 
		{
			return true;
		}
	}

	//------------------------------------------------------------------------------
	//This private function is called when a parsing function encounters an unexpected EOF. 
	//It decides what to do (depending on incremental parsing or not).
	//where is a pointer to the function where the error occurred and state is the parsing state in this function.
	void CXMLReader::UnexpectedEof( CXMLReader::ParseFunction where, int state )
	{
		if( m_pParseStack == 0 ) 
		{
			ReportParseError( CXMLString( _TXT( XMLERR_UNEXPECTEDEOF ) ) );
		} 
		else 
		{
			if( m_C == CXMLString::char_type( EndOfDocument ) ) 
			{
				ReportParseError( CXMLString( _TXT( XMLERR_UNEXPECTEDEOF ) ) );
			} 
			else 
			{
				PushParseState( where, state );
			}
		}
	}

	//------------------------------------------------------------------------------
	//This private function is called when a parse...() function returned false. 
	//It determines if there was an error or if incremental parsing simply went out of data and does the right thing for the case. 
	// where is a pointer to the function where the error occurred and state is the parsing state in this function.
	void CXMLReader::ParseFailed( CXMLReader::ParseFunction where, int state )
	{
		if( m_pParseStack != 0 && m_Error.IsEmpty() ) 
		{
			PushParseState( where, state );
		}
	}

	//------------------------------------------------------------------------------
	inline static void UpdateValue( CXMLReader::CXMLString& value, const CXMLReader::CXMLString::char_type* array, int& arrayPos, int& valueLen )
	{
		memcpy( value.GetBufferSetLength( static_cast< unsigned short >( valueLen + arrayPos ) ) + valueLen, array, arrayPos * sizeof( CXMLReader::CXMLString::char_type ) );
		valueLen += arrayPos;
		value.ValidateBuffer( static_cast< unsigned short >( valueLen ) );
		arrayPos = 0;
	}

	//------------------------------------------------------------------------------
	const CXMLReader::CXMLString& CXMLReader::string()
	{
		UpdateValue( m_StringValue, m_StringArray, m_iStringArrayPos, m_iStringValueLen );
		return m_StringValue;
	}

	//------------------------------------------------------------------------------
	const CXMLReader::CXMLString& CXMLReader::name()
	{
		UpdateValue( m_NameValue, m_NameArray, m_iNameArrayPos, m_iNameValueLen );
		return m_NameValue;
	}

	//------------------------------------------------------------------------------
	/*This private function inserts and reports an entity substitution. The
	  substituted string is \a data and the name of the entity reference is \a
	  name. If \a inLiteral is true, the entity is IncludedInLiteral (i.e., " and '
	  must be quoted. Otherwise they are not quoted.

	  This function returns false on error.
	*/
	bool CXMLReader::InsertXmlRef( const CXMLString& data, const CXMLString& name, bool inLiteral )
	{
		if( inLiteral ) 
		{
			CXMLString tmp = data;

			tmp.Replace( '\"', CXMLString( _TXT( "&quot;" ) ) );
			tmp.Replace( '\'', CXMLString( _TXT( "&apos;" ) ) );
			m_XmlRefStack.push( XmlRef( name, tmp ) );
		} 
		else 
		{
			m_XmlRefStack.push( XmlRef( name, data ) );
		}
		int n = std::max( m_ParameterEntities.size(), m_Entities.size() );

		if( m_XmlRefStack.size() > static_cast< size_t >( n + 1 ) ) 
		{
			// recursive entities
			ReportParseError( CXMLString( _TXT( XMLERR_RECURSIVEENTITIES ) ) );
			return false;
		}
		if( m_bReportEntities && !LexicalHandler.IsNull() ) 
		{
			if( !LexicalHandler().StartEntity( name ) ) 
			{
				ReportParseError( LexicalHandler().ErrorString() );
				return false;
			}
		}
		return true;
	}

	/*This function strips the TextDecl [77] ("<?xml ...?>") from the string \a
	  str. The stripped version is stored in \a str. If this function finds an
	  invalid TextDecl, it returns false, otherwise true.

	  This function is used for external entities since those can include an
	  TextDecl that must be stripped before inserting the entity.*/
	static bool StripTextDecl( CXMLReader::CXMLString& str )
	{
		CXMLReader::CXMLString textDeclStart( _TXT( "<?xml" ) );
		/*TODO:
		if( str.startsWith( textDeclStart ) ) 
		{
			QRegExp textDecl( QString::fromLatin1(
				"^<\\?xml\\s+"
				"(version\\s*=\\s*((['\"])[-a-zA-Z0-9_.:]+\\3))?"
				"\\s*"
				"(encoding\\s*=\\s*((['\"])[A-Za-z][-a-zA-Z0-9_.]*\\6))?"
				"\\s*\\?>"
		   ));
			std::string strTmp = str.replace( textDecl, std::string( "" ) ); 
			if( strTmp.length() != str.length() )
			{
				return false; // external entity has wrong TextDecl
			}
			str = strTmp;
		}
		*/
		return true;
	}

	//------------------------------------------------------------------------------
	CXMLReader::CXMLString Simplify( const CXMLReader::CXMLString& strSource )
	{
		CXMLReader::CXMLString strResult;

		strResult = strSource.TrimLeft();
		strResult = strResult.TrimRight();
		/*
		std::string::const_iterator it = strSource.cbegin();
		while( isblank( *it ) )
		{
			it++;
		}
		while( it != strSource.cend() )
		{
			if( !isblank( *it ) || ( it != strSource.cbegin() && !isblank( *( it - 1 ) ) ) )
			{
				strResult.append( *it, 1 );
			}
		}
		std::string::reverse_iterator rit = strResult.rbegin();
		while( isblank( *rit ) )
		{
			strResult.erase( *rit, 1 );
		}
		*/
		return strResult;
	}

}//nsBluefoot

