//MockRepository.cpp

// Copyright Querysoft Limited 2017
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "HippoQOR/MockRepository.h"
#include "HippoQOR/TestExceptions.h"
#include "HippoQOR/Call.h"

//------------------------------------------------------------------------------
namespace nsUnitTesting
{
	//--------------------------------------------------------------------------------
	__QOR_INTERFACE( __HIPPO ) inline std::ostream& operator << ( std::ostream& os, const Call& call )
	{
		os << call.fileName << "(" << call.lineno << ") ";
		if (call.expectation == Once)
			os << "Expectation for ";
		else
			os << "Result set for ";

		os << call.funcName;

		if (call.getArgs())
			call.getArgs()->printTo(os);
		else
			os << "(...)";

		os << " on the mock at 0x" << call.mock << " was ";

		if (!call.satisfied)
			os << "not ";

		if (call.expectation == Once)
			os << "satisfied." << std::endl;
		else
			os << "used." << std::endl;

		return os;
	}

	//--------------------------------------------------------------------------------
	__QOR_INTERFACE( __HIPPO ) inline std::ostream &operator<<(std::ostream &os, const MockRepository &repo)
	{
		if (repo.expectations.size())
		{
			os << "Expections set:" << std::endl;
			for (std::list<Call *>::const_iterator exp = repo.expectations.begin(); exp != repo.expectations.end(); ++exp)
				os << **exp;
			os << std::endl;
		}

		if (repo.neverCalls.size())
		{
			os << "Functions explicitly expected to not be called:" << std::endl;
			for (std::list<Call *>::const_iterator exp = repo.neverCalls.begin(); exp != repo.neverCalls.end(); ++exp)
				os << **exp;
			os << std::endl;
		}

		if (repo.optionals.size())
		{
			os << "Optional results set up:" << std::endl;
			for (std::list<Call *>::const_iterator exp = repo.optionals.begin(); exp != repo.optionals.end(); ++exp)
				os << **exp;
			os << std::endl;
		}

		return os;
	}

	//--------------------------------------------------------------------------------
	inline void BaseException::setException(const char *description, MockRepository *repo) 
	{
		std::stringstream text;
		text << description;
		text << *repo;
		std::string result = text.str();
		strncpy(buffer, result.c_str(), sizeof(buffer)-1);
		buffer[sizeof(buffer)-1] = '\0';
	}

	//--------------------------------------------------------------------------------
	MockRepository::MockRepository() : autoExpect(true)
	{
	}

	//--------------------------------------------------------------------------------
	MockRepository::~MockRepository() 
	{
		if (!std::uncaught_exception())
			VerifyAll();
		reset();
		for (std::list<base_mock *>::iterator i = mocks.begin(); i != mocks.end(); i++) 
		{
			(*i)->destroy();
		}
		mocks.clear();
	}

	//--------------------------------------------------------------------------------
	void MockRepository::DoVoidExpectation(base_mock *mock, int funcno, const base_tuple &tuple) 
	{
		for (std::list<Call *>::iterator i = expectations.begin(); i != expectations.end(); ++i) 
		{
			Call *call = *i;
			if (call->mock == mock &&
				call->funcIndex == funcno &&
				call->matchesArgs(tuple) &&
				!call->satisfied)
			{
				bool allSatisfy = true;
				for (std::list<Call *>::iterator callsBefore = call->previousCalls.begin();
					callsBefore != call->previousCalls.end(); ++callsBefore)
				{
					if (!(*callsBefore)->satisfied)
					{
						allSatisfy = false;
					}
				}
				if (!allSatisfy) continue;

				call->satisfied = true;
					
				if (call->eHolder)
					call->eHolder->rethrow();

    			if (call->functor != NULL)
    				(*(TupleInvocable<void> *)(call->functor))(tuple);

				return;
	    	}
		}
		for (std::list<Call *>::iterator i = neverCalls.begin(); i != neverCalls.end(); ++i) 
		{
			Call *call = *i;
			if (call->mock == mock &&
				call->funcIndex == funcno &&
				call->matchesArgs(tuple))
			{
				bool allSatisfy = true;
				for (std::list<Call *>::iterator callsBefore = call->previousCalls.begin();
					callsBefore != call->previousCalls.end(); ++callsBefore)
				{
					if (!(*callsBefore)->satisfied)
					{
						allSatisfy = false;
					}
				}
				if (!allSatisfy) continue;

				call->satisfied = true;

				throw ExpectationException(this, call->getArgs(), call->funcName);
			}
		}
		for (std::list<Call *>::iterator i = optionals.begin(); i != optionals.end(); ++i) 
		{
			Call *call = *i;
			if (call->mock == mock &&
				call->funcIndex == funcno &&
				call->matchesArgs(tuple))
			{
				bool allSatisfy = true;
				for (std::list<Call *>::iterator callsBefore = call->previousCalls.begin();
					callsBefore != call->previousCalls.end(); ++callsBefore)
				{
					if (!(*callsBefore)->satisfied)
					{
						allSatisfy = false;
					}
				}
				if (!allSatisfy) continue;

				call->satisfied = true;

				if (call->eHolder)
					call->eHolder->rethrow();

            	if (call->functor != NULL)
            		(*(TupleInvocable<void> *)(call->functor))(tuple);

        		return;
			}
		}
		const char *funcName = NULL;
  		for (std::list<Call *>::iterator i = expectations.begin(); i != expectations.end() && !funcName; ++i) 
	  	{
			Call *call = *i;
			if (call->mock == mock &&
				call->funcIndex == funcno)
			funcName = call->funcName;
		}
  		for (std::list<Call *>::iterator i = optionals.begin(); i != optionals.end() && !funcName; ++i) 
		{
			Call *call = *i;
			if (call->mock == mock &&
				call->funcIndex == funcno)
			funcName = call->funcName;
		}
  		for (std::list<Call *>::iterator i = neverCalls.begin(); i != neverCalls.end() && !funcName; ++i) 
		{
			Call *call = *i;
			if (call->mock == mock &&
				call->funcIndex == funcno)
			funcName = call->funcName;
		}
		throw ExpectationException(this, &tuple, funcName);
	}
	//--------------------------------------------------------------------------------
	void MockRepository::VerifyAll() 
	{
		for (std::list<Call *>::iterator i = expectations.begin(); i != expectations.end(); i++) 
		{
			if (!(*i)->satisfied)
	    		throw CallMissingException(this);
		}
	}

	//--------------------------------------------------------------------------------
	void MockRepository::reset() 
	{
		for (std::list<Call *>::iterator i = expectations.begin(); i != expectations.end(); i++) 
		{
			delete *i;
		}
		expectations.clear();
		for (std::list<Call *>::iterator i = neverCalls.begin(); i != neverCalls.end(); i++) 
		{
			delete *i;
		}
		neverCalls.clear();
		for (std::list<Call *>::iterator i = optionals.begin(); i != optionals.end(); i++) 
		{
			delete *i;
		}
		optionals.clear();
	}


}//nsUnitTesting

