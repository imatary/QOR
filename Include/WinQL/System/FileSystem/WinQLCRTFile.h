//WinQLCRTFile.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//WinQL File object

#ifndef WINQL_FILE_CRTFILE_H_2
#define WINQL_FILE_CRTFILE_H_2

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "CodeQOR/DataStructures/TMap.h"
#include "WinQL/Application/ErrorSystem/WinQLErrorHandling.h"
#include "WinQL/Application/Threading/WinQLCriticalSection.h"
#include "WinQL/Application/Threading/WinQLThread.h"
#include "WinQL/System/FileSystem/WinQLFileManagement.h"
#include "WinQL/System/FileSystem/WinQLFile.h"
#include "WinQL/System/Clock/WinQLTime.h"
#include "WinQL/Application/Console/WinQLConsole.h"
#include "WinQL/Application/Threading/WinQLSynchronization.h"
#include "WinQL/CodeServices/Text/WinQLStringServices.h"
#include <stdio.h>
#include <stdint.h>
#include <wchar.h>

//--------------------------------------------------------------------------------
namespace nsWin32
{
	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CCRTFile : public FILE, public nsWin32::CFile
	{
	public:

		typedef nsCodeQOR::CTMap< int, CCRTFile* > TFileDescriptorMap;

		//--------------------------------------------------------------------------------
		typedef union doubleint 
		{
			Cmp__int64 bigint;
			struct 
			{
				unsigned long lowerhalf;
				long upperhalf;
			} twoints;
		} DINT;

		__QCMP_STATIC_CONSTANT( int, eof = -1 );
		__QCMP_STATIC_CONSTANT( unsigned int, _IOB_ENTRIES		= 20 );
		__QCMP_STATIC_CONSTANT( unsigned int, _SMALL_BUFSIZ		= 512 );
		__QCMP_STATIC_CONSTANT( unsigned int, _INTERNAL_BUFSIZ	= 4096 );
		__QCMP_STATIC_CONSTANT( unsigned short, m_scusIONoBuffering	= 0x0004 );//_IONBF
		__QCMP_STATIC_CONSTANT( unsigned short, _IOYOURBUF	= 0x0100 );
		__QCMP_STATIC_CONSTANT( unsigned short, _IOSETVBUF	= 0x0400 );
		__QCMP_STATIC_CONSTANT( unsigned short, _IOFEOF		= 0x0800 );
		__QCMP_STATIC_CONSTANT( unsigned short, _IOFLRTN		= 0x1000 );
		__QCMP_STATIC_CONSTANT( unsigned short, _IOCTRLZ		= 0x2000 );
		__QCMP_STATIC_CONSTANT( unsigned short, _IOCOMMIT	= 0x4000 );
		__QCMP_STATIC_CONSTANT( unsigned short, _IOLOCKED	= 0x8000 );
		__QCMP_STATIC_CONSTANT( unsigned char, FOPEN			= 0x01 );// file void* open
		__QCMP_STATIC_CONSTANT( unsigned char, FEOFLAG			= 0x02 );// end of file has been encountered
		__QCMP_STATIC_CONSTANT( unsigned char, FCRLF			= 0x04 );// CR-LF across read buffer (in text mode)
		__QCMP_STATIC_CONSTANT( unsigned char, FPIPE			= 0x08 );// file void* refers to a pipe
		__QCMP_STATIC_CONSTANT( unsigned char, FNOINHERIT		= 0x10 );// file void* opened _O_NOINHERIT
		__QCMP_STATIC_CONSTANT( unsigned char, FAPPEND			= 0x20 );// file void* opened O_APPEND
		__QCMP_STATIC_CONSTANT( unsigned char, FDEV				= 0x40 );// file void* refers to device
		__QCMP_STATIC_CONSTANT( unsigned char, FTEXT			= 0x80 );// file void* is in text mode
		__QCMP_STATIC_CONSTANT( int, __IOINFO_TM_ANSI		= 0 );// Regular Text
		__QCMP_STATIC_CONSTANT( int, __IOINFO_TM_UTF8		= 1 );// UTF8 Encoded
		__QCMP_STATIC_CONSTANT( int, __IOINFO_TM_UTF16LE		= 2 );// UTF16 Little Endian Encoded
		__QCMP_STATIC_CONSTANT( unsigned char, LF			= 10 );// line feed
		__QCMP_STATIC_CONSTANT( unsigned char, CR			= 13 );// carriage return
		__QCMP_STATIC_CONSTANT( unsigned char, CTRLZ			= 26 );// ctrl-z means eof for text
		__QCMP_STATIC_CONSTANT( int, BUF_SIZE				= 1025 );// size of LF translation buffer
		__QCMP_STATIC_CONSTANT( int, _BUFFER_FILL_PATTERN	= 0 );
		__QCMP_STATIC_CONSTANT( size_t, SIZE_MAX				= (4294967295U) );
		__QCMP_STATIC_CONSTANT( int, _SH_DENYRW				= 0x10 );// deny read/write mode
		__QCMP_STATIC_CONSTANT( int, _SH_DENYWR				= 0x20 );// deny write mode
		__QCMP_STATIC_CONSTANT( int, _SH_DENYRD				= 0x30 );// deny read mode
		__QCMP_STATIC_CONSTANT( int, _SH_DENYNO				= 0x40 );// deny none mode
		__QCMP_STATIC_CONSTANT( int, _SH_SECURE				= 0x80 );// secure mode
		__QCMP_STATIC_CONSTANT( unsigned short, _S_IFMT		= 0xF000 );// file type mask
		__QCMP_STATIC_CONSTANT( unsigned short, _S_IFDIR		= 0x4000 );//directory
		__QCMP_STATIC_CONSTANT( unsigned short, _S_IFCHR		= 0x2000 );//character special
		__QCMP_STATIC_CONSTANT( unsigned short, _S_IFIFO		= 0x1000 );//pipe
		__QCMP_STATIC_CONSTANT( unsigned short, _S_IFREG		= 0x8000 );//regular
		__QCMP_STATIC_CONSTANT( unsigned short, _S_IREAD		= 0x0100 );//read permission, owner
		__QCMP_STATIC_CONSTANT( unsigned short, _S_IWRITE	= 0x0080 );//write permission, owner
		__QCMP_STATIC_CONSTANT( unsigned short, _S_IEXEC		= 0x0040 );//execute/search permission, owner
		__QCMP_STATIC_CONSTANT( unsigned short, UTF16LE_BOM	= 0xFEFF );      // UTF16 Little Endian Byte Order Mark
		__QCMP_STATIC_CONSTANT( unsigned short, UTF16BE_BOM	= 0xFFFE );      // UTF16 Big Endian Byte Order Mark
		__QCMP_STATIC_CONSTANT( unsigned short, BOM_MASK		= 0xFFFF );      // Mask for testing Byte Order Mark
		__QCMP_STATIC_CONSTANT( unsigned int,   UTF8_BOM		= 0xBFBBEF );    // UTF8 Byte Order Mark
		__QCMP_STATIC_CONSTANT( int, UTF16_BOMLEN			= 2 );           // No of Bytes in a UTF16 BOM
		__QCMP_STATIC_CONSTANT( int, UTF8_BOMLEN				= 3 );           // No of Bytes in a UTF8 BOM
		__QCMP_STATIC_CONSTANT( int, _LK_UNLCK				= 0 );// unlock the file region
		__QCMP_STATIC_CONSTANT( int, _LK_LOCK				= 1 );// lock the file region
		__QCMP_STATIC_CONSTANT( int, _LK_NBLCK				= 2 );// non-blocking lock
		__QCMP_STATIC_CONSTANT( int, _LK_RLCK				= 3 );// lock for writing
		__QCMP_STATIC_CONSTANT( int, _LK_NBRLCK				= 4 );// non-blocking lock for writing
		__QCMP_STATIC_CONSTANT( intptr_t, _NO_CONSOLE_FILENO = (intptr_t)-2 );

		static int _commode;
		static int _fmode;
		static int _umaskval;
		static char _bufin[ 4096 ];

		CCRTFile();
		CCRTFile( int iFileDescriptor, const char* szMode );
		CCRTFile( const char* szFileName, const char* szMode );

		CCRTFile( CFileHandle& hFile );
		CCRTFile( const char* lpFileName, unsigned long dwDesiredAccess, unsigned long dwShareMode, nsWin32::LPSECURITY_ATTRIBUTES lpSecurityAttributes, unsigned long dwCreationDisposition, unsigned long dwFlagsAndAttributes, void* hTemplateFile );
		CCRTFile( const wchar_t* lpFileName, unsigned long dwDesiredAccess, unsigned long dwShareMode, nsWin32::LPSECURITY_ATTRIBUTES lpSecurityAttributes, unsigned long dwCreationDisposition, unsigned long dwFlagsAndAttributes, void* hTemplateFile );
		CCRTFile( const TCHAR* lpFileName, unsigned long dwDesiredAccess, unsigned long dwShareMode, nsWin32::LPSECURITY_ATTRIBUTES lpSecurityAttributes, unsigned long dwCreationDisposition, unsigned long dwFlagsAndAttributes, void* hTemplateFile, void* hTransaction, unsigned short* pusMiniVersion, void* pExtendedParameter );
		CCRTFile( const char* lpFileName, nsWin32::LPOFSTRUCT lpReOpenBuff, unsigned int uStyle );
		CCRTFile( void* hFile, nsWin32::LPFILE_ID_DESCRIPTOR lpFileID, unsigned long dwDesiredAccess, unsigned long dwShareMode, nsWin32::LPSECURITY_ATTRIBUTES lpSecurityAttributes, unsigned long dwFlags );
		CCRTFile( int fD, const char* szMode, CFileHandle& OSFileHandle );
		CCRTFile( int fD, char cFlags, CFileHandle& OSFileHandle );
		virtual ~CCRTFile();

		static void ioInit( nsWin32::STARTUPINFO& StartupInfo );
		static CCRTFile* StdFile( int i );

		void ClearError( void );
		virtual int Close( void );
		int EoF( void );
		int Error( void );
		int Flush( void );
		int GetC( void );
		int GetPos( fpos_t* pos );
		char* GetS( char* s, int n );
		int FileNo( void );
		void Lock( void );
		int PrintF( const char* szFormat, va_list vargs );
		int WPrintF( const wchar_t* szFormat, va_list vargs );
		int PutC( int i );
		int PutS( const char* sz );
		size_t Read( void* ptr, size_t size, size_t nmemb );
		CCRTFile* Reopen( const char* szFileName, const char* szMode );
		int ScanF( const char* szFormat, va_list vargs );
		int Seek( long int lOffset, int iWhence );
		int Seeki64( Cmp__int64 offset, int whence );
		int SeekO( off_t Offset , int iWhence );
		int SetPos( const fpos_t* pos );
		//long int Tell( void );
		off_t TellO( void );
		Cmp__int64 Telli64();
		int TryLock( void );
		void Unlock( void );
		size_t Write( const void* ptr, size_t size, size_t nmemb );		
		int GetCUnlocked( void );
		int PutCUnlocked( int i );
		wint_t PutCNoLockW( wchar_t ch );
		void Rewind( void );
		void SetBuffer( char* pchBuffer );
		int SetVBuffer( char* pchBuffer, int iMode, size_t Size );
		int UngetC( int i );

		static CCRTFile* s_pStdIn;		//0
		static CCRTFile* s_pStdOut;		//1
		static CCRTFile* s_pStdErr;		//2

	protected:

		//--------------------------------------------------------------------------------
		bool IsInUse()
		{
			return( ( _flag & ( _IOREAD | _IOWRT | _IORW ) ) ? true : false );
		}

		//--------------------------------------------------------------------------------
		bool UsesCustomBuffer()
		{
			return ( ( _flag & _IOMYBUF ) ? true : false );
		}

		//--------------------------------------------------------------------------------
		int _fileno()
		{
			return _file;
		}

		//--------------------------------------------------------------------------------
		bool UseBigBuffer()
		{
			return( ( _flag & ( _IOMYBUF | _IOYOURBUF ) ) ? true : false );
		}

		//--------------------------------------------------------------------------------
		bool UsesAnyBuffer()
		{
			return( ( _flag & ( _IOMYBUF | m_scusIONoBuffering | _IOYOURBUF ) ) ? true : false );
		}

		//--------------------------------------------------------------------------------
		int _isatty ()
		{			
			return (int)( m_chFlags & FDEV );
		}

		// Most significant Bit
#		define _msbit(c) ((c) & 0x80)
		// Independent byte has most significant bit set to 0
#		define  _utf8_is_independent(c)    ( _msbit( c ) == 0 )
		// Any leadbyte will have the patterns 11000xxx 11100xxx or 11110xxx
#		define  _utf8_is_leadbyte(c)       ( sachLookupTrailBytes[ (unsigned char)c ] != 0 )
		// Get no of trailing bytes from the lookup table
#		define  _utf8_no_of_trailbytes(c)  sachLookupTrailBytes[ (unsigned char)c ]
		
		int _dup();
		int _dup_nolock();
		int _eof();		

		int Create( const char* path, int pmode );
		int WCreate( const wchar_t* path, int pmode );
		template< typename _tchar > int Open( const _tchar* tszPath, int oflag, ... );		
		template< typename _tchar > int OpenS( const _tchar* path, int oflag, int shflag, ... );		
		
		int _pipe( FILE* ps[2], unsigned psize, int iTextmode );
		errno_t ReopenHelper( CCRTFile** pfile, const char* filename, const char* mode, int shflag );		
		CCRTFile* LOpen( const char* filename, const char* mode, int shflag );		
		template< typename _tchar > errno_t OpenSHelper( const _tchar* path, int oflag, int shflag, int pmode, int bSecure );
		char DecodeOpenFlags( int& iOFlag, nsWin32::SECURITY_ATTRIBUTES& SecurityAttributes, int& iFMode, unsigned long& dwFileAccess, int& iSHFlag, unsigned long& dwFileShare, unsigned long& dwFileCreate );
		unsigned long DecodeOpenAttributes( int& iOFlag, unsigned long& dwFileAccess, unsigned long& dwFileShare, int& iPMode, unsigned int& uiOSPlatform );
		template< typename _tchar > bool OnOpenError( unsigned long& dwFileAccess, int& iOFlag, const _tchar* tszPath, unsigned long& dwFileShare, unsigned long& dwFileCreate, nsWin32::SECURITY_ATTRIBUTES& SecurityAttributes, unsigned long& dwFileAttributes, errno_t& Result );
		bool PostOpenTextMode( int& iOFlag, char& chFileFlags, int& fmode, errno_t& Result, char& tmode, unsigned long& dwFileAccess, unsigned long& dwFileCreate );
		template< typename _tchar > errno_t PostOpen( int& iOFlag, char& chFileFlags, int& fmode, unsigned long& dwFileAccess, unsigned long& dwFileCreate, unsigned long& dwFileAttribute, const _tchar* tszPath, unsigned long& dwFileShare, nsWin32::SECURITY_ATTRIBUTES& SecurityAttributes );
		template< typename _tchar > errno_t OpenNoLockS( const _tchar* path, int oflag, int shflag, int pmode, int bSecure );

		int UMask( int iMode );
		errno_t UMaskS( int iMode, int* pOldMode );
		
		int LClose();
		int CloseNoLock();
		int LCloseNoLock();
		int SetMode( int iMode );
		int SetModeNoLock( int iMode );
		errno_t _set_fmode( int mode );
		errno_t _get_fmode( int* pMode );
		int LockingNoLock ( int iLockMode, long lBytes );
		int Locking( int iLockMode, long lBytes );
		int _fstat32( _stat32* buf );		
		int LWriteText( const void*& pvBuffer, unsigned long& ulDOSResult, unsigned int& uiCount, char& chTMode, int& iLFCount, int& iWritten, int& iCharCount );
		void LWriteUConsole( const void*& pvBuffer, char& chTMode, unsigned int& uiCount, int& iLFCount, int& iCharCount, unsigned long& ulDOSResult );
		int LWrite( const void* pvBuffer, unsigned uCount );
		size_t WriteNoLock( const void* pvBuffer, size_t size, size_t num );
		
	public:
		
		wint_t _putwch_nolock( wchar_t ch );

	protected:

		void FreeBuffer();
		int FillBuffer();
		void GetBuffer();
		int _filwbuf();
		int _stbuf();
		void FlushTempBuffer( int flag );		
		int FlushBuffer( int ch );
		int FlushBufferW( int ch );
		
		size_t ReadS( void* buffer, size_t bufferSize, size_t elementSize, size_t count );
		size_t ReadNoLockS( void* buffer, size_t bufferSize, size_t elementSize, size_t num );
		int LRead( void* buf, unsigned cnt );
		int LReadNoLock ( void* inputbuf, unsigned cnt );
		int InitRead( char& chTextMode, void*& pvInputBuffer, unsigned& uCount, void*& pRawBuffer );
		void InitReadPipe( char*& pchBuffer, int& iBytesRead, unsigned& uCount, char& chTextMode );
		void OnReadError( int& iResult, unsigned long& ulDOSResult );
		void PostReadText( char& chTextMode, int& iOSBytesRead, void*& pRawBuffer, unsigned long& ulDOSResult, int& iBytesRead, int& iResult, void*& pvInputBuffer, unsigned& uInputSize );
		void PostReadTextUTF16LE( char& chTextMode, int& iOSBytesRead, void*& pRawBuffer, unsigned long& ulDOSResult, int& iBytesRead, int& iResult, void*& pvInputBuffer, unsigned& uInputSize );
		
        wint_t _fgetc_nolock();
		wint_t _fgetwc_nolock();		
		int UngetCNoLock( int ch );
		
		int Commit();
		int DoFlush();
		int FlushNoLock();
		int fflush();
		long Length();
		int ChangeSize( long lSize );
		errno_t ChangeSizeS( Cmp__int64 i64Size );
		errno_t ChangeSizeNoLock( Cmp__int64 i64Size );
		long TellNoLock();		
		Cmp__int64 Telli64NoLock();
		long LTell();
		Cmp__int64 LTelli64();
		int SeekNoLock( long offset, int whence );
		long LSeek( long pos, int mthd );
		long LSeekNoLock( long pos, int mthd );				
		int Seeki64NoLock( Cmp__int64 offset, int whence );
		Cmp__int64 LSeeki64( Cmp__int64 pos, int mthd );
		Cmp__int64 LSeeki64NoLock( Cmp__int64 i64Pos, int iMethod );

	private:

		nsWin32::CCriticalSection m_Lock;

        unsigned char m_chFlags;	// attributes of file (e.g., open in text mode?)
        char m_chPipe;				// one char buffer for void*s opened on pipes
		char m_chTextMode : 7;		// __IOINFO_TM_ANSI or __IOINFO_TM_UTF8 or __IOINFO_TM_UTF16LE
		char m_bchUnicode : 1;      // Was the file opened as unicode?
        char m_achPipeBuffer[ 2 ];	// 2 more peak ahead chars for UNICODE mode
        Cmp__int64 m_i64StartPos;	// File position that matches buffer start
        bool m_bUTF8Translations;	// Buffer contains translations other than CRLF

		static TFileDescriptorMap s_FileDescriptorMap;
		static nsWin32::CCriticalSection s_FileDesMapLock;
		static char sachLookupTrailBytes[ 256 ];
		static void* _stdbuf[ 2 ];	// Buffer pointers for stdout and stderr
		static CCRTFile _iob[ _IOB_ENTRIES ];
		static nsWin32::CErrorHelper m_sErrorHelper;
		static nsWin32::CStringHelper m_sStringHelper;
		static nsWin32::CTimeHelper m_Win32TimeHelper;
		static nsWin32::CInterlockedHelper m_sInterlockedHelper;
		
	};

}//nsWin32

#endif//WINQL_FILE_CRTFILE_H_2
