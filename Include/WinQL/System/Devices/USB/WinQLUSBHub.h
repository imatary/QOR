//WinQLUSBHub.h

// Copyright Querysoft Limited 2013, 2017
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Win32 USB Hub Device

#ifndef WINQL_DEVICE_USBHUB_H_3
#define WINQL_DEVICE_USBHUB_H_3

#include "CompilerQOR.h"

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "CompilerQOR.h"
#include "WinQL/System/Devices/Interfaces/WinQLDeviceInterface.h"
#include "WinQL/System/Devices/WinQLIODevice.h"
#include <vector>

__QOR_DECLARE_REF(nsWin32, __WINQL, CUSBHub, CTExtRef);
//--------------------------------------------------------------------------------
namespace nsWin32
{
	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CUSBHub : public CDeviceInterface
	{
	public:

		__QOR_DECLARE_REF_TYPE(CUSBHub);

#pragma	__QCMP_PACK( 1 )

		//--------------------------------------------------------------------------------
		enum LogicalPowerSwitchingMode
		{
			eGanged = 0,
			eIndividual
		};

		//--------------------------------------------------------------------------------
		enum OverCurrentProtectionMode
		{
			eGlobal = 0,
			ePerPort,
			eNone
		};

		//--------------------------------------------------------------------------------
		typedef struct _USB_HUB_DESCRIPTOR 
		{
			byte	bDescriptorLength;
			byte	bDescriptorType;
			byte	bNumberOfPorts;
			unsigned short wHubCharacteristics;
			byte	bPowerOnToPowerGood;
			byte	bHubControlCurrent;
			byte	bRemoveAndPowerMask[64];
		} USB_HUB_DESCRIPTOR, *PUSB_HUB_DESCRIPTOR;

		//--------------------------------------------------------------------------------
		typedef struct _USB_30_HUB_DESCRIPTOR 
		{
			byte	bLength;
			byte	bDescriptorType;
			byte	bNumberOfPorts;
			unsigned short  wHubCharacteristics;
			byte	bPowerOnToPowerGood;
			byte	bHubControlCurrent;
			byte	bHubHdrDecLat;
			unsigned short	wHubDelay;
			unsigned short	DeviceRemovable;
		} USB_30_HUB_DESCRIPTOR, *PUSB_30_HUB_DESCRIPTOR;

		//--------------------------------------------------------------------------------
		typedef struct _USB_DEVICE_DESCRIPTOR 
		{
			byte bLength;
			byte bDescriptorType;
			unsigned short bcdUSB;
			byte bDeviceClass;
			byte bDeviceSubClass;
			byte bDeviceProtocol;
			byte bMaxPacketSize0;
			unsigned short idVendor;
			unsigned short idProduct;
			unsigned short bcdDevice;
			byte iManufacturer;
			byte iProduct;
			byte iSerialNumber;
			byte bNumConfigurations;
		} USB_DEVICE_DESCRIPTOR, *PUSB_DEVICE_DESCRIPTOR;

		//--------------------------------------------------------------------------------
		typedef struct _USB_CONFIGURATION_DESCRIPTOR 
		{
			byte bLength;
			byte bDescriptorType;
			unsigned short wTotalLength;
			byte bNumInterfaces;
			byte bConfigurationValue;
			byte iConfiguration;
			byte bmAttributes;
			byte MaxPower;
		} USB_CONFIGURATION_DESCRIPTOR, *PUSB_CONFIGURATION_DESCRIPTOR;

		//--------------------------------------------------------------------------------
		typedef enum _USB_HUB_NODE 
		{
			UsbHub,
			UsbMIParent
		} USB_HUB_NODE;

		//--------------------------------------------------------------------------------
		typedef struct _USB_HUB_INFORMATION 
		{
			//copy of data from hub descriptor
    
			USB_HUB_DESCRIPTOR HubDescriptor;
			byte HubIsBusPowered;

		} USB_HUB_INFORMATION, *PUSB_HUB_INFORMATION;

		//--------------------------------------------------------------------------------
		typedef struct _USB_MI_PARENT_INFORMATION 
		{
			unsigned long NumberOfInterfaces;
		} USB_MI_PARENT_INFORMATION, *PUSB_MI_PARENT_INFORMATION;

		//--------------------------------------------------------------------------------
		typedef struct _USB_NODE_INFORMATION 
		{
			USB_HUB_NODE NodeType;        /* hub, mi parent */
			union 
			{
				USB_HUB_INFORMATION HubInformation;
				USB_MI_PARENT_INFORMATION MiParentInformation;
			} u;
		} USB_NODE_INFORMATION, *PUSB_NODE_INFORMATION;

		//--------------------------------------------------------------------------------
		typedef enum _USB_HUB_TYPE 
		{
			UnknownHubType	  = 0,
			UsbRootHub        = 1,
			Usb20Hub          = 2,
			Usb30Hub          = 3
		} USB_HUB_TYPE;

		//--------------------------------------------------------------------------------
		typedef struct _USB_HUB_INFORMATION_EX 
		{
			USB_HUB_TYPE             HubType;
  
			// The higest valid port number on the hub
			unsigned short HighestPortNumber;
    
			union 
			{
				USB_HUB_DESCRIPTOR  UsbHubDescriptor;
				USB_30_HUB_DESCRIPTOR  Usb30HubDescriptor;    
			} u;    
		} USB_HUB_INFORMATION_EX, *PUSB_HUB_INFORMATION_EX;

	__QCMP_WARNING_DISABLE( __QCMP_WARN_NAMELESS_STRUCTUNION, "" )

		//--------------------------------------------------------------------------------
		typedef union _USB_HUB_CAP_FLAGS 
		{
			unsigned long ul;
			struct 
			{
				unsigned long HubIsHighSpeedCapable:1;
				unsigned long HubIsHighSpeed:1;
				unsigned long HubIsMultiTtCapable:1;
				unsigned long HubIsMultiTt:1;
				unsigned long HubIsRoot:1;
				unsigned long HubIsArmedWakeOnConnect:1;
				unsigned long HubIsBusPowered:1;
				unsigned long ReservedMBZ:25;
			};
		} USB_HUB_CAP_FLAGS, *PUSB_HUB_CAP_FLAGS;
	__QCMP_WARNING_DEFAULT( __QCMP_WARN_NAMELESS_STRUCTUNION )


		//--------------------------------------------------------------------------------
		typedef struct _USB_HUB_CAPABILITIES_EX 
		{
			USB_HUB_CAP_FLAGS CapabilityFlags;
		} USB_HUB_CAPABILITIES_EX, *PUSB_HUB_CAPABILITIES_EX;

	__QCMP_WARNING_DISABLE( __QCMP_WARN_NAMELESS_STRUCTUNION, "" )

		//--------------------------------------------------------------------------------
		typedef union _USB_PORT_PROPERTIES 
		{
			unsigned long ul;
    
			struct 
			{
				unsigned long PortIsUserConnectable  :1;
				unsigned long PortIsDebugCapable  :1;
				unsigned long ReservedMBZ  :30;
			};
		} USB_PORT_PROPERTIES, *PUSB_PORT_PROPERTIES;

	__QCMP_WARNING_DEFAULT( __QCMP_WARN_NAMELESS_STRUCTUNION )

		//--------------------------------------------------------------------------------
		typedef struct _USB_PORT_CONNECTOR_PROPERTIES 
		{
			
			unsigned long ConnectionIndex;			// one based port number			
			unsigned long ActualLength;				// The number of bytes required to hold the entire USB_PORT_CONNECTOR_PROPERTIES structure, including the full CompanionHubSymbolicLinkName string			
			USB_PORT_PROPERTIES  UsbPortProperties;	// bitmask of flags indicating properties and capabilities of the port			
			unsigned short CompanionIndex;			// Zero based index number of the companion port being queried.  	
			unsigned short CompanionPortNumber;		// Port number of the companion port			
			wchar_t CompanionHubSymbolicLinkName[1];	// Symbolic link name for the companion hub
		} USB_PORT_CONNECTOR_PROPERTIES, *PUSB_PORT_CONNECTOR_PROPERTIES;

	__QCMP_WARNING_DISABLE( __QCMP_WARN_NAMELESS_STRUCTUNION, "" )

		//--------------------------------------------------------------------------------
		typedef union _USB_PROTOCOLS 
		{
			unsigned long ul;  
			struct 
			{
				unsigned long Usb110 :1;
				unsigned long Usb200 :1;
				unsigned long Usb300 :1;
				unsigned long ReservedMBZ  :29;
			};    
		} USB_PROTOCOLS, *PUSB_PROTOCOLS;

		//--------------------------------------------------------------------------------
		typedef union _USB_NODE_CONNECTION_INFORMATION_EX_V2_FLAGS 
		{
			unsigned long ul;
			struct 
			{
				unsigned long DeviceIsOperatingAtSuperSpeedOrHigher  :1;
				unsigned long DeviceIsSuperSpeedCapableOrHigher  :1;
				unsigned long ReservedMBZ  :30;
			};
		} USB_NODE_CONNECTION_INFORMATION_EX_V2_FLAGS, *PUSB_NODE_CONNECTION_INFORMATION_EX_V2_FLAGS;

	__QCMP_WARNING_DEFAULT( __QCMP_WARN_NAMELESS_STRUCTUNION )

		//--------------------------------------------------------------------------------
		typedef struct _USB_NODE_CONNECTION_INFORMATION_EX_V2 
		{			
			unsigned long ConnectionIndex;		// one based port number			
			unsigned long Length;				// length of the structure

			// On input a bitmask that indicates which USB protocols are understood by the caller
			// On output a bitmask that indicates which USB signaling protocols are supported by the port
			USB_PROTOCOLS SupportedUsbProtocols;

			// A bitmask indicating properties of the connected device or port
			USB_NODE_CONNECTION_INFORMATION_EX_V2_FLAGS Flags;
		} USB_NODE_CONNECTION_INFORMATION_EX_V2, *PUSB_NODE_CONNECTION_INFORMATION_EX_V2;

		//--------------------------------------------------------------------------------
		typedef enum _USB_CONNECTION_STATUS 
		{
			NoDeviceConnected,
			DeviceConnected,

			// failure codes, these map to fail reasons
			DeviceFailedEnumeration,
			DeviceGeneralFailure,
			DeviceCausedOvercurrent,
			DeviceNotEnoughPower,
			DeviceNotEnoughBandwidth,
			DeviceHubNestedTooDeeply,
			DeviceInLegacyHub,
			DeviceEnumerating,
			DeviceReset
		} USB_CONNECTION_STATUS, *PUSB_CONNECTION_STATUS;

		//--------------------------------------------------------------------------------
		typedef struct _USB_ENDPOINT_DESCRIPTOR 
		{
			byte bLength;
			byte bDescriptorType;
			byte bEndpointAddress;
			byte bmAttributes;
			unsigned short wMaxPacketSize;
			byte bInterval;
		} USB_ENDPOINT_DESCRIPTOR, *PUSB_ENDPOINT_DESCRIPTOR;

		//--------------------------------------------------------------------------------
		typedef struct _USB_PIPE_INFO 
		{
			USB_ENDPOINT_DESCRIPTOR EndpointDescriptor;
			unsigned long ScheduleOffset;
		} USB_PIPE_INFO, *PUSB_PIPE_INFO;

		//--------------------------------------------------------------------------------
	__QCMP_WARNING_DISABLE( __QCMP_WARN_EXTENSION_USED_ZERO_SIZED_ARRAY, "" )
	__QCMP_WARNING_DISABLE( __QCMP_WARN_NAMELESS_STRUCTUNION, "" )

		typedef struct _USB_NODE_CONNECTION_INFORMATION 
		{
			unsigned long ConnectionIndex;
			// usb device descriptor returned by this device during enumeration
			USB_DEVICE_DESCRIPTOR DeviceDescriptor;
			byte CurrentConfigurationValue;
			byte LowSpeed;
			byte DeviceIsHub;
			unsigned short DeviceAddress;
			unsigned long NumberOfOpenPipes;
			USB_CONNECTION_STATUS ConnectionStatus;
			//USB_PIPE_INFO PipeList[ 0 ];
		} USB_NODE_CONNECTION_INFORMATION, *PUSB_NODE_CONNECTION_INFORMATION;
	__QCMP_WARNING_DEFAULT( __QCMP_WARN_EXTENSION_USED_ZERO_SIZED_ARRAY )
	__QCMP_WARNING_DEFAULT( __QCMP_WARN_NAMELESS_STRUCTUNION )

		//--------------------------------------------------------------------------------
	__QCMP_WARNING_DISABLE( __QCMP_WARN_EXTENSION_USED_ZERO_SIZED_ARRAY, "" )
		typedef struct _USB_NODE_CONNECTION_INFORMATION_EX 
		{
			unsigned long ConnectionIndex;
			// usb device descriptor returned by this device during enumeration
			USB_DEVICE_DESCRIPTOR DeviceDescriptor;
			byte CurrentConfigurationValue;			
			byte Speed;		// values for the speed field are defined in USB200.h
			byte DeviceIsHub;
			unsigned short DeviceAddress;
			unsigned long NumberOfOpenPipes;
			USB_CONNECTION_STATUS ConnectionStatus;
			//USB_PIPE_INFO PipeList[0];
		} USB_NODE_CONNECTION_INFORMATION_EX, *PUSB_NODE_CONNECTION_INFORMATION_EX;

	__QCMP_WARNING_DEFAULT( __QCMP_WARN_EXTENSION_USED_ZERO_SIZED_ARRAY )

		//--------------------------------------------------------------------------------
	__QCMP_WARNING_DISABLE( __QCMP_WARN_EXTENSION_USED_ZERO_SIZED_ARRAY, "" )

		typedef struct _USB_DESCRIPTOR_REQUEST 
		{
			unsigned long ConnectionIndex;
			struct 
			{
				byte bmRequest;
				byte bRequest;
				unsigned short wValue;
				unsigned short wIndex;
				unsigned short wLength;
			} SetupPacket;
			//byte Data[0];
		} USB_DESCRIPTOR_REQUEST, *PUSB_DESCRIPTOR_REQUEST;

	__QCMP_WARNING_DEFAULT( __QCMP_WARN_EXTENSION_USED_ZERO_SIZED_ARRAY )


		//--------------------------------------------------------------------------------
		typedef struct _USB_NODE_CONNECTION_NAME 
		{
			unsigned long ConnectionIndex;
			unsigned long ActualLength;
			wchar_t NodeName[1];	// unicode symbolic name for this node if it is a hub or parent driver null if this node is a device.
		} USB_NODE_CONNECTION_NAME, *PUSB_NODE_CONNECTION_NAME;

		//--------------------------------------------------------------------------------
		typedef struct _USB_NODE_CONNECTION_DRIVERKEY_NAME 
		{
			unsigned long ConnectionIndex;
			unsigned long ActualLength;  
			wchar_t DriverKeyName[ 1 ];		// unicode name for the devnode
		} USB_NODE_CONNECTION_DRIVERKEY_NAME, *PUSB_NODE_CONNECTION_DRIVERKEY_NAME;

		//--------------------------------------------------------------------------------
		typedef struct _USB_HUB_CAPABILITIES 
		{
			// Unlike the USB_HUB_INFORMATION structure used by IOCTL_USB_GET_NODE_INFORMATION, this structure can be extended in the
			// future to accomodate more data.  The IOCTL will return only as much data as indicated by the size of the request buffer, to maintain
			// backward compatibility with older callers that don't know about the new data.

			unsigned long HubIs2xCapable:1;

		} USB_HUB_CAPABILITIES, *PUSB_HUB_CAPABILITIES;

		//--------------------------------------------------------------------------------
		typedef struct _USB_NODE_CONNECTION_ATTRIBUTES 
		{
			unsigned long ConnectionIndex;  // one based port number			
			USB_CONNECTION_STATUS ConnectionStatus; // current USB connect status for the port			
			unsigned long PortAttributes; // extended port attributes defined in usb.h
		} USB_NODE_CONNECTION_ATTRIBUTES, *PUSB_NODE_CONNECTION_ATTRIBUTES;

#pragma	__QCMP_END_PACK

		//--------------------------------------------------------------------------------
		class __QOR_INTERFACE( __WINQL ) CPortConnection
		{
		public:

			typedef nsCodeQOR::CTLRef< CPortConnection > ref_type;

			CPortConnection();
			CPortConnection( CUSBHub* pHub, unsigned long ulConnectionIndex );
			CPortConnection( const CPortConnection& src );			
			~CPortConnection();

			void Setup( CUSBHub* pHub, unsigned long ulConnectionIndex );

			byte GetDeviceClass( void );
			byte GetDeviceSubClass( void );
			byte GetDeviceProtocol( void );
			byte GetMaxPacketSize( void );
			unsigned short GetVendorID( void );
			unsigned short GetProductID( void );
			unsigned short GetBCDDevice( void );
			byte GetManufacturer( void );
			byte GetProduct( void );
			byte GetSerialNumber( void );
			byte GetNumberOfConfigurations( void );
			byte GetCurrentConfiguration( void );
			byte GetLowSpeed( void );
			bool IsHub( void );
			unsigned short GetDeviceAddress( void );
			unsigned long GetNumberOfOpenPipes( void );
			USB_CONNECTION_STATUS GetConnectionStatus( void );
			
			byte GetSpeed( void );

			USB_PROTOCOLS GetSupportedUsbProtocols( void );
			bool IsDeviceOperatingAtSuperSpeedOrHigher( void );
			bool IsDeviceSuperSpeedCapableOrHigher( void );

			bool IsPortUserConnectable( void );
			bool IsPortDebugCapable( void );
			unsigned short GetCompanionIndex( void );
			unsigned short GetCompanionPortNumber( void );
			CWString GetCompanionHubSymbolicLinkName( void );

			CWString GetName( void );
			CWString GetDriverKeyName( void );

			ref_type Ref( void )
			{
				return ref_type( this, false );
			}

		private:

			bool m_bInfo;
			bool ValidateInfo( void );
			bool GetInformation( void );

			bool m_bProperties;
			bool ValidateProperties( void );
			bool GetProperties( void );
			
			bool m_bInfoEx;
			bool ValidateInfoEx( void );
			bool GetInformationEx( void );

			bool m_bInfoExV2;
			bool ValidateInfoExV2( void );
			bool GetInformationExV2( void );
			
			bool m_bAttributes;
			bool ValidateAttributes( void );
			bool GetAttributes( void );

			USB_NODE_CONNECTION_INFORMATION	Info;
			std::vector< USB_PIPE_INFO > Pipes;
			USB_PORT_CONNECTOR_PROPERTIES ConnectorProperties;
			USB_NODE_CONNECTION_INFORMATION_EX InfoEx;
			USB_NODE_CONNECTION_INFORMATION_EX_V2 InfoExV2;
			CWString strName;
			CWString strDriverKeyName;
			USB_NODE_CONNECTION_ATTRIBUTES Attributes;

			CUSBHub* m_pHub;
			unsigned long m_ulConnectionIndex;

			
			CPortConnection& operator = ( const CPortConnection& src );
		};

		__QOR_DECLARE_OCLASS_ID( CUSBHub );

		static nsCodeQOR::CTExternalRegEntry< CUSBHub > RegEntry;

		__QCMP_STATIC_CONSTANT( unsigned long, File_Device_USB = 0x00000022 );

		__QCMP_STATIC_CONSTANT( int, USB_GET_NODE_INFORMATION                    = 258 );
		__QCMP_STATIC_CONSTANT( int, USB_GET_NODE_CONNECTION_INFORMATION         = 259 );
		__QCMP_STATIC_CONSTANT( int, USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION     = 260 );
		__QCMP_STATIC_CONSTANT( int, USB_GET_NODE_CONNECTION_NAME                = 261 );
		__QCMP_STATIC_CONSTANT( int, USB_DIAG_IGNORE_HUBS_ON                     = 262 );
		__QCMP_STATIC_CONSTANT( int, USB_DIAG_IGNORE_HUBS_OFF                    = 263 );
		__QCMP_STATIC_CONSTANT( int, USB_GET_NODE_CONNECTION_DRIVERKEY_NAME      = 264 );
		__QCMP_STATIC_CONSTANT( int, USB_GET_HUB_CAPABILITIES                    = 271 );
		__QCMP_STATIC_CONSTANT( int, USB_GET_NODE_CONNECTION_ATTRIBUTES          = 272 );
		__QCMP_STATIC_CONSTANT( int, USB_HUB_CYCLE_PORT                          = 273 );
		__QCMP_STATIC_CONSTANT( int, USB_GET_NODE_CONNECTION_INFORMATION_EX      = 274 );
		__QCMP_STATIC_CONSTANT( int, USB_RESET_HUB                               = 275 );
		__QCMP_STATIC_CONSTANT( int, USB_GET_HUB_CAPABILITIES_EX                 = 276 );
		__QCMP_STATIC_CONSTANT( int, USB_GET_HUB_INFORMATION_EX                  = 277 );
		__QCMP_STATIC_CONSTANT( int, USB_GET_PORT_CONNECTOR_PROPERTIES           = 278 );
		__QCMP_STATIC_CONSTANT( int, USB_GET_NODE_CONNECTION_INFORMATION_EX_V2   = 279 );

		CUSBHub();
		virtual ~CUSBHub();		

		virtual void SetPath( const mxTCHAR* szPath );

		CTString GetName( void );

		bool IsHub( void );
		bool IsBusPowered( void );
		byte NumberOfPorts( void );
		unsigned short MillisecondsToPowerUp( void );
		unsigned short MaximumControllerMilliAmps( void );
		CUSBHub::USB_HUB_TYPE GetType( void );
		unsigned short GetHighestPortNumber( void );
		byte GetPacketHeaderDecodeLatency( void );
		unsigned short GetAverageNanosecondHubDelay( void );
		LogicalPowerSwitchingMode GetLogcalPowerSwitchingMode( void );
		bool IsCompoundDevice( void );
		CUSBHub::OverCurrentProtectionMode GetOverCurrentProtectionMode( void );
		bool Is2xCapable( void );
		bool IsHighSpeedCapable( void );
		bool IsHighSpeed( void );
		bool CUSBHub::IsMultiTtCapable( void );
		bool IsMultiTt( void );
		bool IsRoot( void );
		bool IsArmedWakeOnConnect( void );
		bool IsBusPowerCapable( void );
				
		CPortConnection::ref_type GetPort( byte Port );
				
		bool GetDescriptorFromNodeConnection( void );
		

		//deprecated
		bool CyclePort( unsigned long ulConnectionIndex );
		bool Reset( void );

	private:

		bool m_bNodeInformation;
		bool ValidateNodeInformation( void );
		bool GetNodeInformation( void );

		bool m_bHubInformation;
		bool ValidateHubInformation( void );
		bool GetHubInformation( void );

		bool m_bCapabilities;
		bool ValidateCapabilities( void );
		bool GetCapabilities( void );

		bool m_bCapabilitiesEx;
		bool ValidateCapabilitiesEx( void );
		bool GetCapabilitiesEx( void );
		
		USB_NODE_INFORMATION m_HubInfo;
		USB_HUB_INFORMATION_EX m_HubInfoEx;
		USB_HUB_CAPABILITIES m_Capabilities;
		USB_HUB_CAPABILITIES_EX m_CapabilitiesEx;

		std::vector< CPortConnection > m_VecConnections;

		CTString m_strHubName;

		CUSBHub( const CUSBHub& src );
		CUSBHub& operator = ( const CUSBHub& src );
		
	};

}//nsWin32

#endif//WINQL_DEVICE_USBHUB_H_3

