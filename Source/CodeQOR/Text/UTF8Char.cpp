//UTF8Char.cpp

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "CompilerQOR.h"
#include "CodeQOR/Text/UTF8Char.h"
#include "AppocritaQOR/Event.h"

//------------------------------------------------------------------------------
namespace nsCodeQOR
{
	//--------------------------------------------------------------------------------
	CUTF8Char::CUTF8Char() : m_pChar( 0 )
	{
	}

	//--------------------------------------------------------------------------------
	CUTF8Char::CUTF8Char( CChar8* pChar ) : m_pChar( pChar )
	{
	}

	//--------------------------------------------------------------------------------
	CUTF8Char::CUTF8Char( const CUTF8Char& Src )
	{
		if( &Src != this )
		{
			*this = Src;
		}
	}
		
	//--------------------------------------------------------------------------------
	CUTF8Char& CUTF8Char::operator = ( const CUTF8Char& Src )
	{
		m_pChar = Src.m_pChar;
		return *this;
	}

	//--------------------------------------------------------------------------------
	bool CUTF8Char::operator == ( const CUTF8Char& Cmp ) const
	{
		return ToCodePoint() == Cmp.ToCodePoint();
	}

	//--------------------------------------------------------------------------------
	bool CUTF8Char::operator >= ( const CUTF8Char& Cmp ) const
	{
		return ToCodePoint() >= Cmp.ToCodePoint();
	}

	//--------------------------------------------------------------------------------
	bool CUTF8Char::operator <= ( const CUTF8Char& Cmp ) const
	{
		return ToCodePoint() <= Cmp.ToCodePoint();
	}

	//--------------------------------------------------------------------------------
	bool CUTF8Char::operator < ( const CUTF8Char& Cmp ) const
	{
		return ToCodePoint() < Cmp.ToCodePoint();
	}

	//--------------------------------------------------------------------------------
	CUTF8Char& CUTF8Char::operator++( void )
	{
		m_pChar = m_pChar + Len();
		return *this;
	}

	//--------------------------------------------------------------------------------
	CUTF8Char& CUTF8Char::operator--( void )
	{
		m_pChar = m_pChar - 1;
		while( ( m_pChar->m & 0xC0 ) == 0x80 )
		{
			m_pChar = m_pChar - 1;
		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	CUTF8Char& CUTF8Char::operator += ( unsigned short usOffset )
	{
		while( usOffset-- )
		{
			m_pChar = m_pChar + Len();
		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	CUTF8Char& CUTF8Char::operator -= ( unsigned short usOffset )
	{
		while( usOffset-- )
		{
			m_pChar = m_pChar - 1;
			while( ( m_pChar->m & 0xC0 ) == 0x80 )
			{
				m_pChar = m_pChar - 1;
			}
		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	CUTF8Char::operator CChar8*() const
	{
		return m_pChar;
	}

	//--------------------------------------------------------------------------------
	CChar8* CUTF8Char::operator -> () const
	{
		return m_pChar;
	}

	//--------------------------------------------------------------------------------
	CUTF8Char::~CUTF8Char()
    {
    }

	//--------------------------------------------------------------------------------
	void CUTF8Char::Dispose( void )
	{
		m_pChar = 0;
	}

	//--------------------------------------------------------------------------------
	void CUTF8Char::Attach( CChar8* p )
	{
		m_pChar = p;
	}

    //--------------------------------------------------------------------------------
    CChar8* CUTF8Char::Detach()
    {
		CChar8* pResult = m_pChar;
		m_pChar = 0;
		return pResult;
    }
	
	//--------------------------------------------------------------------------------
	bool CUTF8Char::IsNull() const
	{
		return m_pChar == 0 || m_pChar->m == 0;
	}

	//--------------------------------------------------------------------------------
	unsigned char CUTF8Char::Len() const
	{
		unsigned char ucResult = 0;
		if( !IsNull() )
		{			
			byte B1 = m_pChar->m;

			if( B1 < 0x80 )
			{
				ucResult = 1;
			}
			else if( B1 < 0xC2 )
			{
			}
			else if( B1 < 0xE0 )
			{
				ucResult = 2;
			}
			else if( B1 < 0xF0 )
			{
				ucResult = 3;
			}
			else if( B1 < 0xF5 )
			{
				ucResult = 4;
			}
		}
		return ucResult;
	}

	//--------------------------------------------------------------------------------
	bool CUTF8Char::IsInvalid()
	{
		unsigned char ucLen = Len();
		switch (ucLen)
		{
		case 0:
			return true;
		case 1:
			if( m_pChar->m > 0x7F )
			{
				return true;
			}
			break;
		case 2:
			if( m_pChar[ 0 ].m > 0xDF || m_pChar[ 1 ].m > 0xBF )
			{
				return true;
			}
			break;
		case 3:
			if( m_pChar[ 0 ].m > 0xEF || m_pChar[ 1 ].m > 0xBF || m_pChar[ 2 ].m >0xBF )
			{
				return true;
			}
			break;
		case 4:
			if( m_pChar[ 0 ].m > 0xF7 || m_pChar[ 1 ].m > 0xBF || m_pChar[ 2 ].m >0xBF || m_pChar[ 3 ].m >0xBF )
			{
				return true;
			}
			break;
		default:
			return true;
		}
		return false;
	}

	//------------------------------------------------------------------------------
	unsigned int CUTF8Char::ToCodePoint( void ) const
	{
		switch( Len() )
		{
		case 0:
			return 0;
		case 1:
			return static_cast< unsigned int >( m_pChar->m );
		case 2:
			return static_cast< unsigned int >( ( m_pChar[ 0 ].m << 6 ) + m_pChar[ 1 ].m - 0x3080 );
		case 3:
			return static_cast< unsigned int >( ( m_pChar[ 0 ].m << 12 ) + ( m_pChar[ 1 ].m << 6 ) + m_pChar[ 2 ].m - 0xE2080 );
		case 4:
			return static_cast< unsigned int >( ( m_pChar[ 0 ].m << 18 ) + ( m_pChar[ 1 ].m << 12 ) + ( m_pChar[ 2 ].m << 6 ) + m_pChar[ 3 ].m - 0x3C820280 );
		default:
			return 0;
		}
	}

	//------------------------------------------------------------------------------
	CChar8::eUnicodeVersion CUTF8Char::CurrentUnicodeVersion( void )
	{
		return CChar8::UNICODE_DATA_VERSION;
	}

	//--------------------------------------------------------------------------------
	CChar8::eCategory CUTF8Char::Category() const
	{
		return static_cast< CChar8::eCategory >( UnicodeGetProp( ToCodePoint() )->category );
	}

	//--------------------------------------------------------------------------------
	CChar8::eDirection CUTF8Char::Direction() const
	{
		return static_cast< CChar8::eDirection >( UnicodeGetProp( ToCodePoint() )->direction );
	}

	//--------------------------------------------------------------------------------
	CChar8::eJoining CUTF8Char::Joining() const
	{
		return static_cast< CChar8::eJoining >( UnicodeGetProp( ToCodePoint() )->joining );
	}

	//--------------------------------------------------------------------------------
	bool CUTF8Char::HasMirrored() const
	{
		return UnicodeGetProp( ToCodePoint() )->mirrorDiff != 0;
	}

	//--------------------------------------------------------------------------------
	unsigned char CUTF8Char::CombiningClass() const
	{
		return (unsigned char) UnicodeGetProp( ToCodePoint())->combiningClass;
	}

	//--------------------------------------------------------------------------------
	int CUTF8Char::DigitValue() const
	{
		return UnicodeGetProp( ToCodePoint() )->digitValue;
	}

	//--------------------------------------------------------------------------------
	CChar8::eUnicodeVersion CUTF8Char::UnicodeVersion() const
	{
		return static_cast< CChar8::eUnicodeVersion >( UnicodeGetProp( ToCodePoint() )->unicodeVersion );
	}

	//--------------------------------------------------------------------------------
	bool CUTF8Char::IsPrint() const
	{
		const int test = Flag( CChar8::Other_Control ) | Flag( CChar8::Other_NotAssigned );
		return !( Flag( UnicodeGetProp( ToCodePoint() )->category ) & test );
	}

	//--------------------------------------------------------------------------------
	bool CUTF8Char::IsPunct() const
	{
		const int test = Flag( CChar8::Punctuation_Connector ) | Flag( CChar8::Punctuation_Dash ) | Flag( CChar8::Punctuation_Open ) | Flag( CChar8::Punctuation_Close ) | Flag( CChar8::Punctuation_InitialQuote ) |
							Flag( CChar8::Punctuation_FinalQuote ) | Flag( CChar8::Punctuation_Other );
		return Flag( UnicodeGetProp( ToCodePoint() )->category) & test ? true : false;
	}

	//--------------------------------------------------------------------------------
	bool CUTF8Char::IsSpace() const
	{
		unsigned int ucs4 = ToCodePoint();
		if( ucs4 >= 9 && ucs4 <= 13 )
		{
			return true;
		}
		const int test = Flag( CChar8::Separator_Space ) | Flag( CChar8::Separator_Line ) | Flag( CChar8::Separator_Paragraph );
		return Flag( UnicodeGetProp( ucs4 )->category ) & test ? true : false;
	}

	//--------------------------------------------------------------------------------
	bool CUTF8Char::IsMark() const
	{
		const int test = Flag( CChar8::Mark_NonSpacing ) | Flag( CChar8::Mark_SpacingCombining ) | Flag( CChar8::Mark_Enclosing );
		return Flag( UnicodeGetProp( ToCodePoint() )->category ) & test ? true : false;
	}

	//--------------------------------------------------------------------------------
	bool CUTF8Char::IsLetter() const
	{
		const int test = Flag( CChar8::Letter_Uppercase ) | Flag( CChar8::Letter_Lowercase ) | Flag( CChar8::Letter_Titlecase ) | Flag( CChar8::Letter_Modifier ) | Flag( CChar8::Letter_Other );
		return Flag( UnicodeGetProp( ToCodePoint() )->category ) & test ? true : false;
	}

	//--------------------------------------------------------------------------------
	bool CUTF8Char::IsNumber() const
	{
		const int test = Flag( CChar8::Number_DecimalDigit ) | Flag( CChar8::Number_Letter ) | Flag( CChar8::Number_Other );
		return Flag( UnicodeGetProp( ToCodePoint() )->category ) & test ? true : false;
	}

	//--------------------------------------------------------------------------------
	bool CUTF8Char::IsLetterOrNumber() const
	{
		const int test = Flag( CChar8::Letter_Uppercase) | Flag( CChar8::Letter_Lowercase) | Flag( CChar8::Letter_Titlecase) | Flag( CChar8::Letter_Modifier) | Flag(CChar8::Letter_Other) | Flag(CChar8::Number_DecimalDigit) |
							Flag(CChar8::Number_Letter) | Flag(CChar8::Number_Other);
		return Flag( UnicodeGetProp( ToCodePoint() )->category ) & test ? true : false;
	}

	//--------------------------------------------------------------------------------
	bool CUTF8Char::IsDigit() const
	{
		return ( UnicodeGetProp( ToCodePoint() )->category == CChar8::Number_DecimalDigit );
	}

	//--------------------------------------------------------------------------------
	bool CUTF8Char::IsSymbol() const
	{
		const int test = Flag(CChar8::Symbol_Math) | Flag(CChar8::Symbol_Currency) | Flag(CChar8::Symbol_Modifier) | Flag(CChar8::Symbol_Other); 
		return Flag( UnicodeGetProp( ToCodePoint() )->category ) & test ? true : false;
	}

	//--------------------------------------------------------------------------------
	inline bool CUTF8Char::IsLower() const
	{
		return Category() == CChar8::Letter_Lowercase;
	}

	//--------------------------------------------------------------------------------
	inline bool CUTF8Char::IsUpper() const
	{
		return Category() == CChar8::Letter_Uppercase;
	}

	//--------------------------------------------------------------------------------
	inline bool CUTF8Char::IsTitleCase() const
	{
		return Category() == CChar8::Letter_Titlecase;
	}

	//--------------------------------------------------------------------------------
	CChar8::eDecomposition CUTF8Char::DecompositionTag() const
	{
		unsigned int ucs4 = ToCodePoint();
		const unsigned short index = GET_DECOMPOSITION_INDEX( ucs4 );
		if( index == 0xffff )
		{
			return CChar8::NoDecomposition;
		}
		return static_cast< CChar8::eDecomposition >( uc_decomposition_map[ index ] & 0xff );
	}

}//nsCodeQOR
