//WinQLServiceApplication.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/Application/WinQLServiceApplication.h"
#include "WinQL/System/EventLogging/WinQLEventLog.h"
#include "WinQL/System/WinQLSystem.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	__QOR_IMPLEMENT_OCLASS_LUID( CWin32Service );

	//--------------------------------------------------------------------------------
	CWin32Service::CWin32Service( CTString& strName, bool bCanStop, bool bCanShutdown, bool bCanPauseContinue ) : CWin32Application()
	{
		m_strName = strName;
		m_StatusHandle = 0;
		m_Status.dwServiceType = Service_Own_Process;
		m_Status.dwCurrentState = eStartPending;

		// The accepted commands of the service. 
		unsigned long ulControlsAccepted = 0; 
		if( bCanStop )
		{
			ulControlsAccepted |= Service_Accept_Stop; 
		}

		if( bCanShutdown )
		{
			ulControlsAccepted |= Service_Accept_Shutdown; 
		}

		if( bCanPauseContinue )
		{
			ulControlsAccepted |= Service_Accept_Pause_Continue; 
		}

		m_Status.dwControlsAccepted = ulControlsAccepted;  
		m_Status.dwWin32ExitCode = NoError; 
		m_Status.dwServiceSpecificExitCode = 0; 
		m_Status.dwCheckPoint = 0; 
		m_Status.dwWaitHint = 0; 
		SetRole( eService );
	}

	//--------------------------------------------------------------------------------
	CWin32Service::~CWin32Service()
	{
	}

	//--------------------------------------------------------------------------------
	void __QCMP_STDCALLCONVENTION CWin32Service::ServiceMain( unsigned long ulArgc, TCHAR** pszArgv )
	{
		refType TheService = TheWin32Application();

		TheService.As<CWin32Service>()->m_StatusHandle = CSystem::TheSystem()->Services( QOR_PP_SHARED_OBJECT_ACCESS ).RegisterCtrlHandler( TheService.As<CWin32Service>()->m_strName, ServiceCtrlHandler );

		if( TheService.As<CWin32Service>()->m_StatusHandle == 0 )
		{
			//TODO: Raise error
		}
		else
		{
			TheService.As<CWin32Service>()->Start( ulArgc, pszArgv );
		}
	}

	//--------------------------------------------------------------------------------
	void __QCMP_STDCALLCONVENTION CWin32Service::ServiceCtrlHandler( unsigned long ulCtrl )
	{
		refType TheService = TheWin32Application();

		switch( ulCtrl )
		{
		case eServiceControlStop:
			TheService.As<CWin32Service>()->Stop();
			break;
		case eServiceControlPause:
			TheService.As<CWin32Service>()->Pause();
			break;
		case eServiceControlContinue:
			TheService.As<CWin32Service>()->Continue();
			break;
		case eServiceControlShutdown:
			TheService.As<CWin32Service>()->Shutdown();
			break;
		case eServiceControlInterrogate:
			break;
		default:
			break;
		}
	}

	//--------------------------------------------------------------------------------
	bool CWin32Service::Run()
	{
		SERVICE_TABLE_ENTRY serviceTable[] =
		{
			{ m_strName.GetBuffer(), ServiceMain },
			{ 0, 0 }
		};

		return CSystem::TheSystem()->Services( QOR_PP_SHARED_OBJECT_ACCESS ).StartCtrlDispatcher( serviceTable );
	}


	//--------------------------------------------------------------------------------  
	void CWin32Service::Start( unsigned long ulArgc, TCHAR** pszArgv ) 
	{ 
		try 
		{ 
			SetServiceStatus( eStartPending );			// Tell SCM that the service is starting. 
 			OnStart( ulArgc, pszArgv );					// Perform service-specific initialization. 
			SetServiceStatus( eRunning );				// Tell SCM that the service is started. 
		} 
		catch( unsigned long ulError ) 
		{ 			
			WriteErrorLogEntry( _TXT( "Service Start" ).c_str(), ulError );		// Log the error. 			
			SetServiceStatus( eStopped, ulError );						// Set the service status to be stopped. 
		} 
		catch( ... ) 
		{ 			
			WriteEventLogEntry( _TXT( "Service failed to start." ).c_str(), EventLog_Error_Type );		// Log the error. 			
			SetServiceStatus( eStopped );														// Set the service status to be stopped. 
		} 
	}
 
 
	//--------------------------------------------------------------------------------  
	void CWin32Service::OnStart( unsigned long dwArgc, TCHAR** pszArgv) 
	{ 
	} 
 
 
	//--------------------------------------------------------------------------------  
	void CWin32Service::Stop() 
	{ 
		unsigned long dwOriginalState = m_Status.dwCurrentState; 
		try 
		{ 			
			SetServiceStatus( eStopPending );				// Tell SCM that the service is stopping. 			
			OnStop();										// Perform service-specific stop operations. 			
			SetServiceStatus( eStopped );					// Tell SCM that the service is stopped. 
		} 
		catch( unsigned long ulError ) 
		{ 			
			WriteErrorLogEntry( _TXT( "Service Stop" ).c_str(), ulError );		// Log the error. 			 
			SetServiceStatus( dwOriginalState );						// Set the orginal service status.
		} 
		catch( ... ) 
		{ 			
			WriteEventLogEntry( _TXT( "Service failed to stop." ).c_str(), EventLog_Error_Type );		// Log the error. 
			SetServiceStatus( dwOriginalState );												// Set the orginal service status. 
		} 
	} 
 
 
	//--------------------------------------------------------------------------------  
	void CWin32Service::OnStop() 
	{ 
	} 
 

	//--------------------------------------------------------------------------------  
	void CWin32Service::Pause() 
	{ 
		try 
		{ 			
			SetServiceStatus( ePausePending );		// Tell SCM that the service is pausing. 			
			OnPause();								// Perform service-specific pause operations. 			
			SetServiceStatus( ePaused );			// Tell SCM that the service is paused. 
		} 
		catch( unsigned long ulError ) 
		{ 			
			WriteErrorLogEntry( _TXT( "Service Pause" ), ulError );		// Log the error. 
			SetServiceStatus( eRunning );								// Tell SCM that the service is still running. 
		} 
		catch( ... ) 
		{ 			
			WriteEventLogEntry( _TXT( "Service failed to pause." ), EventLog_Error_Type );		// Log the error. 			
			SetServiceStatus( eRunning );														// Tell SCM that the service is still running. 
		}
	}
 

	//--------------------------------------------------------------------------------  
	void CWin32Service::OnPause() 
	{ 
	} 
 

	//--------------------------------------------------------------------------------  
	void CWin32Service::Continue() 
	{ 
		try 
		{ 			
			SetServiceStatus( eContinuePending );			// Tell SCM that the service is resuming. 			
			OnContinue();									// Perform service-specific continue operations. 			
			SetServiceStatus( eRunning );					// Tell SCM that the service is running. 
		} 
		catch( unsigned long ulError ) 
		{ 			
			WriteErrorLogEntry( _TXT( "Service Continue" ), ulError );	// Log the error.  			
			SetServiceStatus( ePaused );								// Tell SCM that the service is still paused. 
		} 
		catch (...) 
		{ 			
			WriteEventLogEntry( _TXT( "Service failed to resume." ), EventLog_Error_Type );			// Log the error. 			
			SetServiceStatus( ePaused );															// Tell SCM that the service is still paused.  
		} 
	}
 

	//--------------------------------------------------------------------------------  
	void CWin32Service::OnContinue() 
	{ 
	} 
 
	//--------------------------------------------------------------------------------  
	void CWin32Service::Shutdown() 
	{ 
		try 
		{ 			
			OnShutdown();					// Perform service-specific shutdown operations. 			
			SetServiceStatus( eStopped );	// Tell SCM that the service is stopped. 
		} 
		catch( unsigned long ulError ) 
		{ 
			// Log the error. 
			WriteErrorLogEntry( _TXT( "Service Shutdown" ), ulError ); 
		} 
		catch (...) 
		{ 
			// Log the error. 
			WriteEventLogEntry( _TXT( "Service failed to shut down." ), EventLog_Error_Type ); 
		} 
	} 
 
 
	//-------------------------------------------------------------------------------- 
	void CWin32Service::OnShutdown() 
	{ 
	} 
 
 
	//-------------------------------------------------------------------------------- 
	void CWin32Service::SetServiceStatus( unsigned long ulCurrentState, unsigned long ulWin32ExitCode, unsigned long ulWaitHint ) 
	{ 
		static unsigned long ulCheckPoint = 1; 
 
		// Fill in the SERVICE_STATUS structure of the service. 
 
		m_Status.dwCurrentState = ulCurrentState; 
		m_Status.dwWin32ExitCode = ulWin32ExitCode; 
		m_Status.dwWaitHint = ulWaitHint; 
 
		m_Status.dwCheckPoint =  ( ( ulCurrentState == eRunning ) ||  ( ulCurrentState == eStopped ) ) ?  0 : ulCheckPoint++; 
 
		// Report the status of the service to the SCM.
		CSystem::TheSystem()->Services( QOR_PP_SHARED_OBJECT_ACCESS ).SetStatus( m_StatusHandle, &m_Status );
	} 
 
	//-------------------------------------------------------------------------------- 
	void CWin32Service::WriteEventLogEntry( const TCHAR* szMessage, unsigned short usType ) 
	{ 
		//void* hEventSource = 0; 
		const TCHAR* lpszStrings[2] = { 0, 0 }; 
 
		CEventLogServer EventLog( 0, m_strName.GetBuffer() );

		m_strName.ReleaseBuffer();

		lpszStrings[0] = m_strName.GetBuffer(); 
		lpszStrings[1] = szMessage;
 
		EventLog.Report( usType, 0, 0, 0, 2, 0, &lpszStrings[ 0 ], 0 );
 
		m_strName.ReleaseBuffer();
	} 
 
	//--------------------------------------------------------------------------------
	void CWin32Service::WriteErrorLogEntry( const TCHAR* szFunction, unsigned long ulError ) 
	{ 
		CTString strMessage;
		strMessage.FormatV( _TXT( "%s failed w/err 0x%08lx" ), szFunction, ulError );
		WriteEventLogEntry( szFunction, EventLog_Error_Type ); 
	} 

	//--------------------------------------------------------------------------------
	void CWin32Service::Install( CTString& strDisplayName, unsigned long ulStartType, CTString& strDependencies, CTString& strAccount, CTString& strPassword )
	{
		CTString strPath = ( dynamic_cast< CProcess* >( CProcess::ThisProcess() ) )->GetFileName();
      
		// Open the local default service control manager database 
		CServiceControlSession::refType ServiceControlSession = CSystem::TheSystem()->Services( QOR_PP_SHARED_OBJECT_ACCESS ).OpenSession(
			CTString( _TXT( "" ) ), CTString( _TXT( "" ) ), SCManagerConnect | SCManagerCreate );
		
		// Install the service into SCM by calling CreateService 
		CServiceController::refType ServiceController = ServiceControlSession->Create( 
			m_strName, strDisplayName, Service_Query_Status, Service_Own_Process, ulStartType, eServiceErrorNormal, strPath, CTString( _TXT( "" ) ), 0, strDependencies, strAccount, strPassword );
	}

	//--------------------------------------------------------------------------------
	void CWin32Service::Uninstall( void )
	{
		//Open the local default service control manager database 
		CServiceControlSession::refType ServiceControlSession = CSystem::TheSystem()->Services( QOR_PP_SHARED_OBJECT_ACCESS ).OpenSession( CTString( _TXT( "" ) ), CTString( _TXT( "" ) ), SCManagerConnect );

		SERVICE_STATUS ssSvcStatus = {}; 
 
		//Open the service with delete, stop, and query status permissions 
		CServiceController::refType ServiceController = ServiceControlSession->Open( m_strName, Service_Stop | Service_Query_Status | Delete );
 
		// Try to stop the service 
		if( ServiceController->Control( eServiceControlStop, &ssSvcStatus ) )
		{
			//wprintf( L"Stopping %s.", m_strName ); 
			
			GetCurrentWin32Thread()->Sleep( 1000 );

			while( ServiceController->QueryStatus( &ssSvcStatus ) )
			{ 
				if( ssSvcStatus.dwCurrentState == eStopPending ) 
				{ 
					//wprintf(L"."); 
					GetCurrentWin32Thread()->Sleep( 1000 );
				} 
				else break; 
			} 
 
			/*
			if( ssSvcStatus.dwCurrentState == eStopped ) 
			{ 
				wprintf( L"\n%s is stopped.\n", m_strName ); 
			} 
			else 
			{ 
				wprintf( L"\n%s failed to stop.\n", m_strName ); 
			} 
			*/
		}

		// Now remove the service by calling DeleteService. 
		if( !ServiceController->Delete() )
		{
			//wprintf( L"DeleteService failed w/err 0x%08lx\n", ThisProcess()->ErrorSystem().GetLastError() );         
		} 
		else
		{
			//wprintf( L"%s is removed.\n", m_strName ); 
		}
	}

}//nsWin32

