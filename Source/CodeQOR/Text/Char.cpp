//Char.cpp

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "CompilerQOR.h"
#include "CodeQOR/Text/Char.h"
#include "CodeQOR/Text/TString.h"
#include "AppocritaQOR/Event.h"

#define FLAG( x ) ( 1 << ( x ) )
//------------------------------------------------------------------------------
namespace nsCodeQOR
{
	//------------------------------------------------------------------------------
    __QOR_INTERFACE( __CODEQOR ) int CharInt( CChar8 c )
	{
		return c.m;
	}

	//------------------------------------------------------------------------------
    __QOR_INTERFACE( __CODEQOR ) int CharInt( CChar16 c )
	{
		return c.m;
	}

	//------------------------------------------------------------------------------
    __QOR_INTERFACE( __CODEQOR ) int CharInt( CChar32 c )
	{
		return c.m;
	}

	//------------------------------------------------------------------------------
	__QOR_INTERFACE( __CODEQOR ) int CharInt( char c )
	{
		return static_cast< int >( c );
	}

	//------------------------------------------------------------------------------
	__QOR_INTERFACE( __CODEQOR ) int CharInt( wchar_t c )
	{
		return static_cast< int >( c );
	}

	//------------------------------------------------------------------------------
	__QOR_INTERFACE( __CODEQOR ) int CharInt( byte c )
	{
		return static_cast< int >( c );
	}

	//------------------------------------------------------------------------------
	__QOR_INTERFACE( __CODEQOR ) const nsUnicodeTables::Properties* UnicodeGetProp( unsigned int ucs4 )
	{
		int index = GET_PROP_INDEX( ucs4 );
		return uc_properties + index;
	}

	//------------------------------------------------------------------------------
	__QOR_INTERFACE( __CODEQOR ) const nsUnicodeTables::Properties* UnicodeGetProp( unsigned short ucs2 )
	{
		int index = GET_PROP_INDEX_UCS2(ucs2);
		return uc_properties + index;
	}

	//------------------------------------------------------------------------------
	__QOR_INTERFACE( __CODEQOR ) const nsUnicodeTables::Properties* __QCMP_FASTCALL nsUnicodeTables::properties( unsigned int ucs4 )
	{
		int index = GET_PROP_INDEX(ucs4);
		return uc_properties + index;
	}

	//------------------------------------------------------------------------------
	__QOR_INTERFACE( __CODEQOR ) const nsUnicodeTables::Properties* __QCMP_FASTCALL nsUnicodeTables::properties( unsigned short ucs2 )
	{
		int index = GET_PROP_INDEX_UCS2(ucs2);
		return uc_properties + index;
	}

	//------------------------------------------------------------------------------
	__QOR_INTERFACE( __CODEQOR ) nsUnicodeTables::LineBreakClass __QCMP_FASTCALL nsUnicodeTables::lineBreakClass( unsigned int ucs4 )
	{
		return (nsUnicodeTables::LineBreakClass)UnicodeGetProp(ucs4)->line_break_class;
	}

	//------------------------------------------------------------------------------
	__QOR_INTERFACE( __CODEQOR ) int __QCMP_FASTCALL nsUnicodeTables::script( unsigned int ucs4 )
	{
		if( ucs4 > 0xffff )
		{
			return Common;
		}
		int script = uc_scripts[ ucs4 >> 7 ];
		if( script < ScriptSentinel )
		{
			return script;
		}
		script = ( ( ( script - ScriptSentinel ) * UnicodeBlockSize ) + UnicodeBlockCount );
		script = uc_scripts[ script + ( ucs4 & 0x7f ) ];
		return script;
	}

	//------------------------------------------------------------------------------
	enum CChar16::eHangul __cdecl operator + ( enum CChar16::eHangul const& h1, enum CChar16::eHangul const& h2 )
	{
		return static_cast< enum CChar16::eHangul >( static_cast< unsigned int >( h1 ) + static_cast< unsigned int >( h2 ) );
	}

	//------------------------------------------------------------------------------
	const unsigned short* __QCMP_FASTCALL DecompositionHelper( unsigned int ucs4, int* length, int* tag, unsigned short* buffer )
	{
		*length = 0;
		if (ucs4 > UNICODE_LAST_CODEPOINT)
			return 0;
		if( ucs4 >= CChar16::Hangul_SBase && ucs4 < static_cast< unsigned int >( CChar16::Hangul_SBase + CChar16::Hangul_SCount ) ) 
		{
			int SIndex = ucs4 - CChar16::Hangul_SBase;
			buffer[ 0 ] = static_cast< unsigned short >( CChar16::Hangul_LBase + SIndex / CChar16::Hangul_NCount ); // L
			buffer[1] = CChar16::Hangul_VBase + (SIndex % CChar16::Hangul_NCount) / CChar16::Hangul_TCount; // V
			buffer[2] = CChar16::Hangul_TBase + SIndex % CChar16::Hangul_TCount; // T
			*length = buffer[ 2 ] == CChar16::Hangul_TBase ? 2 : 3;
			*tag = CChar16::Canonical;
			return buffer;
		}

		const unsigned short index = GET_DECOMPOSITION_INDEX( ucs4 );
		if( index == 0xffff )
		{
			return 0;
		}
		const unsigned short* decomposition = uc_decomposition_map + index;
		*tag = (*decomposition) & 0xff;
		*length = (*decomposition) >> 8;
		return decomposition + 1;
	}

	//------------------------------------------------------------------------------
	static inline bool IsHighSurrogate( unsigned int ucs4 ) 
	{
		return ( ( ucs4 & 0xfffffc00 ) == 0xd800 ) ? true : false;
	}

	//------------------------------------------------------------------------------
	static inline bool IsLowSurrogate( unsigned int ucs4 ) 
	{
		return ( ( ucs4 & 0xfffffc00 ) == 0xdc00 ) ? true : false;
	}

	//------------------------------------------------------------------------------
	static inline bool RequiresSurrogates( unsigned int ucs4 ) 
	{
		return ( ucs4 >= 0x10000 ) ? true : false;
	}

	//------------------------------------------------------------------------------
	static inline unsigned int SurrogateToUcs4( unsigned short high, unsigned short low ) 
	{
		return (unsigned int(high) << 10 ) + low - 0x35fdc00;
	}

	//------------------------------------------------------------------------------
	static inline unsigned int SurrogateToUcs4( CChar16 high, CChar16 low)
	{
		return ( unsigned int( high.m ) << 10 ) + low.m - 0x35fdc00;
	}

	//------------------------------------------------------------------------------
	static inline unsigned short HighSurrogate( unsigned int ucs4 ) 
	{
		return unsigned short( ( ucs4 >> 10 ) + 0xd7c0 );
	}

	//------------------------------------------------------------------------------
	static inline unsigned short LowSurrogate( unsigned int ucs4 ) 
	{
		return unsigned short( ucs4 % 0x400 + 0xdc00 );
	}

	//--------------------------------------------------------------------------------
	static inline unsigned short FoldCase( unsigned short ch )
	{
		return ch + UnicodeGetProp(ch)->caseFoldDiff;
	}

	//--------------------------------------------------------------------------------
	static inline unsigned int FoldCase( unsigned int ch, unsigned int &last )
	{
		unsigned int c = ch;
		if( CChar16(c).IsLowSurrogate() && CChar16(last).IsHighSurrogate() )
		{
			c = SurrogateToUcs4( static_cast< unsigned short >( last ), static_cast< unsigned short >( c ) );
		}
		last = ch;
		return ch + UnicodeGetProp(c)->caseFoldDiff;
	}

	//--------------------------------------------------------------------------------
	static inline unsigned int FoldCase( const unsigned short* ch, const unsigned short* start)
	{
		unsigned int c = *ch;
		if( CChar16(c).IsLowSurrogate() && ch > start && CChar16(*(ch - 1)).IsHighSurrogate() )
		{
			c = SurrogateToUcs4( static_cast< unsigned short >( *(ch - 1) ), static_cast< unsigned short >( c ) );
		}
		return *ch + UnicodeGetProp(c)->caseFoldDiff;
	}

	//--------------------------------------------------------------------------------
	struct UCS2Pair 
	{
		unsigned short u1;
		unsigned short u2;
	};

	//--------------------------------------------------------------------------------
	inline bool operator < ( unsigned short u1, const UCS2Pair &ligature )
	{ 
		return u1 < ligature.u1; 
	}

	//--------------------------------------------------------------------------------
	inline bool operator < ( const UCS2Pair& ligature, unsigned short u1 )
	{ 
		return ligature.u1 < u1; 
	}

	//--------------------------------------------------------------------------------
	/*
	static unsigned short LigatureHelper( unsigned short u1, unsigned short u2 )
	{
		// hangul L-V pair
		int LIndex = u1 - CChar16::Hangul_LBase;
		if( 0 <= LIndex && LIndex < CChar16::Hangul_LCount ) 
		{
			int VIndex = u2 - CChar16::Hangul_VBase;
			if( 0 <= VIndex && VIndex < CChar16::Hangul_VCount )
			{
				return static_cast< unsigned short >( CChar16::Hangul_SBase + ( LIndex * CChar16::Hangul_VCount + VIndex ) * CChar16::Hangul_TCount );
			}
		}

		// hangul LV-T pair
		int SIndex = u1 - CChar16::Hangul_SBase;
		if( 0 <= SIndex && SIndex < CChar16::Hangul_SCount && ( SIndex % CChar16::Hangul_TCount ) == 0 ) 
		{
			int TIndex = u2 - CChar16::Hangul_TBase;
			if( 0 <= TIndex && TIndex <= CChar16::Hangul_TCount )
			{
				return static_cast< unsigned short >( u1 + TIndex );
			}
		}

		const unsigned short index = GET_LIGATURE_INDEX( u2 );
		
		if (index == 0xffff)
		{
			return 0;
		}

		const unsigned short *ligatures = uc_ligature_map+index;
		
		unsigned short length = *ligatures++;
		{
			const UCS2Pair* data = reinterpret_cast<const UCS2Pair *>(ligatures);
			const UCS2Pair* r = data;
			while( r != data + length && r->u1 != u1 )
			{
				r++;
			}
			//const UCS2Pair* r = qBinaryFind(data, data + length, u1);
			if( r != data + length )
			{
				return r->u2;
			}
		}

		return 0;
	}
	*/
	//--------------------------------------------------------------------------------
	/*
	static void ComposeHelper( CString<CChar16>* str, CChar16::eUnicodeVersion version, int from)
	{
		CString<CChar16>& s = *str;

		if( s.Len() - from < 2 )
		{
			return;
		}

		// the loop can partly ignore high Unicode as all ligatures are in the BMP
		int starter = 0;
		int lastCombining = 0;
		int pos = from;
		while (pos < s.Len() ) 
		{
			unsigned int uc = s.At( static_cast< unsigned short >( pos ) ).Unicode();
			if( IsHighSurrogate( uc ) && pos < s.Len() - 1 ) 
			{
				unsigned short low = s.At( static_cast< unsigned short >( pos + 1 ) ).Unicode();
				if( IsLowSurrogate( low ) ) 
				{
					uc = SurrogateToUcs4( static_cast< unsigned short >( uc ), low );
					++pos;
				}
			}
			const nsUnicodeTables::Properties* p = UnicodeGetProp( uc );
			if( p->unicodeVersion == CChar16::Unicode_Unassigned || p->unicodeVersion > version ) 
			{
				starter = -1; // to prevent starter == pos - 1
				lastCombining = 0;
				++pos;
				continue;
			}
			int combining = p->combiningClass;
			if( starter == pos - 1 || combining > lastCombining )
			{
				// allowed to form ligature with S
				CChar16 ligature = LigatureHelper( s.At( static_cast< unsigned short >( starter ) ).Unicode(), static_cast< unsigned short >( uc ) );
				if( ligature.Unicode() ) 
				{
					s.Set( static_cast< unsigned short >( starter ), ligature );
					s.Remove( static_cast< unsigned short >( pos ), 1 );
					continue;
				}
			}
			if( !combining )
			{
				starter = pos;
			}
			lastCombining = combining;
			++pos;
		}
	}
	*/
	//------------------------------------------------------------------------------
	/*
	static void CanonicalOrderHelper( CString* str, CChar16::eUnicodeVersion version, int from )
	{
		CString& s = *str;
		const int l = s.length() - 1;
		int pos = from;
		while( pos < l ) 
		{
			int p2 = pos + 1;
			unsigned int u1 = s.at( pos ).unicode();

			if( QChar( u1 ).IsHighSurrogate() ) 
			{
				ushort low = s.at(p2).Unicode();
				if (QChar(low).isLowSurrogate()) {
					u1 = QChar::surrogateToUcs4(u1, low);
					if (p2 >= l)
						break;
					++p2;
				}
			}
			unsigned int u2 = s.at(p2).unicode();

			if( QChar( u2 ).IsHighSurrogate() && p2 < l ) 
			{
				unsigned short low = s.at( p2 + 1 ).Unicode();
				if( QChar( low ).IsLowSurrogate() ) 
				{
					u2 = QChar::surrogateToUcs4( u2, low );
					++p2;
				}
			}

			unsigned short c2 = 0;
			{
				const nsUnicodeTables::Properties* p = UnicodeGetProp( u2 );
				if( p->unicodeVersion != QChar::Unicode_Unassigned && p->unicodeVersion <= version )
				{
					c2 = p->combiningClass;
				}
			}

			if( c2 == 0 ) 
			{
				pos = p2+1;
				continue;
			}

			unsigned short c1 = 0;
			{
				const nsUnicodeTables::Properties* p = UnicodeGetProp( u1 );
				if( p->unicodeVersion != QChar::Unicode_Unassigned && p->unicodeVersion <= version )
				{
					c1 = p->combiningClass;
				}
			}

			if( c1 > c2 ) 
			{
				QChar* uc = s.data();
				int p = pos;
				// exchange characters
				if( !QChar::RequiresSurrogates( u2 ) ) 
				{
					uc[ p++ ] = u2;
				} 
				else 
				{
					uc[ p++ ] = QChar::HighSurrogate( u2 );
					uc[ p++ ] = QChar::LowSurrogate(u2);
				}

				if( !QChar::RequiresSurrogates( u1 ) ) 
				{
					uc[ p++ ] = u1;
				} 
				else 
				{
					uc[ p++ ] = QChar::HighSurrogate( u1 );
					uc[ p++ ] = QChar::LowSurrogate( u1 );
				}

				if( pos > 0 )
				{
					--pos;
				}

				if( pos > 0 && s.at( pos ).IsLowSurrogate() )
				{
					--pos;
				}

			} 
			else 
			{
				++pos;
				if( QChar::RequiresSurrogates( u1 ) )
				{
					++pos;
				}
			}
		}
	}
	*/

}//nsCodeQOR

#undef FLAG
