//BfSocket.h

// Copyright Querysoft Limited 2016
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//An Abstract Socket

#ifndef BLUEFOOT_SOCKET_H_3
#define BLUEFOOT_SOCKET_H_3

#include "CompilerQOR.h"
#include "CodeQOR/Traits/ReferenceTraits.h"
#include "CodeQOR/DataStructures/TRef.h"
#include "CodeQOR/Tracing/FunctionContextBase.h"
#include "AppocritaQOR/Event.h"
#include "BluefootQOR/BfPlug.h"

//------------------------------------------------------------------------------
//Forward declare the ISocket class and its reference type
__QOR_DECLARE_REF(nsBluefoot, __BLUEFOOTQOR, ISocket, CTRef);

//------------------------------------------------------------------------------
namespace nsBluefoot
{
	//------------------------------------------------------------------------------
	class __QOR_INTERFACE(__BLUEFOOTQOR) CSocketWriteError_Event : public nsQOR::CEvent
	{
	public:
		CSocketWriteError_Event() : nsQOR::CEvent(*TheApplication()){}
	};

	//------------------------------------------------------------------------------
	class __QOR_INTERFACE(__BLUEFOOTQOR) CSocketWriteSuccess_Event : public nsQOR::CEvent
	{
	public:
		CSocketWriteSuccess_Event() : nsQOR::CEvent(*TheApplication()){}
	};
	
	//------------------------------------------------------------------------------
	class __QOR_INTERFACE(__BLUEFOOTQOR) ISocket
	{
	public:

		//--------------------------------------------------------------------------------
		enum eType
		{
			Sock_Stream = 1,
			Sock_DGram,
			Sock_Raw,
			Sock_ReliablyDeliveredMessage,
			Sock_SeqPacket,
		};

		//--------------------------------------------------------------------------------
		enum eAddressFamily
		{
			AF_Unspecified = 0,			// unspecified
			AF_Unix = 1,				// local to host (pipes, portals)
			AF_INet = 2,				// internetwork: UDP, TCP, etc.
			AF_ImpLink = 3,             // arpanet imp addresses
			AF_Pup = 4,					// pup protocols: e.g. BSP
			AF_Chaos = 5,               // mit CHAOS protocols
			AF_Ns = 6,					// XEROX NS protocols
			AF_Ipx = AF_Ns,				// IPX protocols: IPX, SPX, etc.
			AF_Iso = 7,					// ISO protocols
			AF_Osi = AF_Iso,			// OSI is ISO
			AF_Ecma = 8,				// European computer manufacturers
			AF_DataKit = 9,             // datakit protocols
			AF_Ccitt = 10,              // CCITT protocols, X.25 etc
			AF_Sna = 11,				// IBM SNA
			AF_DecNet = 12,             // DECnet
			AF_Dli = 13,				// Direct data link interface
			AF_Lat = 14,				// LAT
			AF_HYLink = 15,             // NSC Hyperchannel
			AF_AppleTalk = 16,          // AppleTalk
			AF_NetBIOS = 17,            // NetBios-style addresses
			AF_VoiceView = 18,          // VoiceView
			AF_FireFox = 19,            // Protocols from Firefox
			AF_Unknown1 = 20,           // Somebody is using this!
			AF_Ban = 21,				// Banyan
			AF_Atm = 22,				// Native ATM Services
			AF_INet6 = 23,              // Internetwork Version 6
			AF_Cluster = 24,            // Microsoft Wolfpack
			AF_1284_4 = 25,              // IEEE 1284.4 WG AF
			AF_Irda = 26,				// IrDA
			AF_NetDes = 28,             // Network Designers OSI & gateway
			AF_TcnProcess = 29,
			AF_TcnMessage = 30,
			AF_IclFxbm = 31,
			AF_Bth = 32,				// Bluetooth RFCOMM/L2CAP protocols
			AF_Link = 33,
			AF_Max = 34,
		};

		//--------------------------------------------------------------------------------
		enum eProtocol
		{
			IPProto_IP = 0,					// dummy for IP 
			IPProto_ICMP = 1,				// control message protocol 
			IPProto_IGMP = 2,				// group management protocol
			IPProto_GGP = 3,				// gateway^2 (deprecated) 
			BTHProto_RFCOMM = 3,			// Bluetooth RFCOMM protocol
			IPProto_TCP = 6,				// tcp 
			IPProto_PUP = 12,				// pup 
			IPProto_UDP = 17,				// user datagram protocol 
			IPProto_IDP = 22,				// xns idp 
			IPProto_ND = 77,				// UNOFFICIAL net disk proto 
			IPProto_RAW = 255,				// raw IP packet 
			IPProto_MAX = 256,
		};
#pragma pack(push,1)
		//--------------------------------------------------------------------------------		
		class __QOR_INTERFACE(__BLUEFOOTQOR) Address
		{
		public:
			
			static const int byte_size = 30;
			
			Address();
			Address( unsigned short AddressFamily );
			
			unsigned short sa_family;

			union
			{
				char sa_data[byte_size];
				
				struct 
				{
					Cmp_unsigned__int64		btAddr;         // Bluetooth device address
					nsCodeQOR::GUID			serviceClassId; // [OPTIONAL] system will query SDP for port
					unsigned long			port;           // RFCOMM channel or L2CAP PSM
				}BluetoothAddress;
				
				struct
				{
					unsigned char  irdaDeviceID[4];
					char	irdaServiceName[25];
				}IrDaAddress;

				struct
				{
					unsigned short sin_port;
					struct
					{
						union
						{
							struct
							{
								unsigned char s_b1, s_b2, s_b3, s_b4;
							} S_un_b;
							struct
							{
								unsigned short s_w1, s_w2;
							} S_un_w;
							unsigned long S_addr;
						} S_un;
					}sin_addr;
					char sin_zero[8];
				}IPAddress;				
			}data;
		};

#pragma pack( pop )

		__QOR_DECLARE_REF_TYPE(ISocket);
		__QOR_DECLARE_OCLASS_ID(ISocket);

		ISocket() {};
		virtual ~ISocket() {};
		ISocket(const ISocket& src) { *this = src; }
		ISocket& operator = (const ISocket& src) { return *this; }

		virtual void Create( eAddressFamily AF, eType Type, eProtocol Protocol) = 0;
		virtual int Bind(const Address& Address) = 0;
		virtual int Listen(int iBacklog) = 0;
		virtual ISocket::ref_type Accept( Address& Address ) = 0;
		virtual int Connect(const Address& Address) = 0;
		virtual int GetPeerName(Address& Address) = 0;
		virtual int GetSockName(Address& Address) = 0;
		virtual int GetSockOpt(int iLevel, int iOptName, char* pOptVal, int* pOptLen) = 0;
		virtual int SetSockOpt(int iLevel, int iOptName, const char* pOptVal, int iOptLen) = 0;
		virtual int AsyncReceive(char* pBuffer, int iLen, void* pSyncObject) = 0;
		virtual int Receive(char* buf, int len, int flags) = 0;
		virtual int ReceiveFrom(char* Buffer, int iLen, int iFlags, Address& From ) = 0;
		virtual int AsyncSend(char* Buffer, int iLen, void* pSyncObject) = 0;
		virtual int Send(const char* Buffer, int iLen) = 0;
		virtual int SendTo(const char* Buffer, int iLen, int iFlags, const Address& To ) = 0;
		virtual int Shutdown(int iHow) = 0;
		virtual Cmp_uint_ptr ID(void) = 0;
		virtual  int GetLastError(void) = 0;

	protected:

	};

	//------------------------------------------------------------------------------
	class __QOR_INTERFACE(__BLUEFOOTQOR) CSocket : public ISocket
	{
	public:

		CSocket();
		CSocket(ISocket::ref_type Impl);
		virtual ~CSocket();
		CSocket(const CSocket& src);
		CSocket& operator = (const CSocket& src);

		virtual void Create(eAddressFamily AF, eType Type, eProtocol Protocol);
		virtual int Bind(const Address& Name);
		virtual int Listen(int iBacklog);
		virtual ISocket::ref_type Accept( Address& Address );
		virtual int Connect(const Address& Address );
		virtual int GetPeerName(Address& Address);
		virtual int GetSockName(Address& Address);
		virtual int GetSockOpt(int iLevel, int iOptName, char* pOptVal, int* pOptLen);
		virtual int SetSockOpt(int iLevel, int iOptName, const char* pOptVal, int iOptLen);
		virtual int AsyncReceive(char* pBuffer, int iLen, void* pSyncObject);
		virtual int Receive(char* buf, int len, int flags);
		virtual int ReceiveFrom(char* Buffer, int iLen, int iFlags, Address& From );
		virtual int AsyncSend(char* Buffer, int iLen, void* pSyncObject);
		virtual int Send(const char* Buffer, int iLen);
		virtual int SendTo(const char* Buffer, int iLen, int iFlags, const Address& To );
		virtual int Shutdown(int iHow);
		virtual Cmp_uint_ptr ID(void);
		virtual  int GetLastError(void);

	protected:

		ISocket::ref_type m_Impl;

		eProtocol m_Protocol;
		eType m_Type;

		Address m_Address;
	};

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE(__BLUEFOOTQOR) CSocketConnector : public CPlug
	{
	public:

		__QOR_DECLARE_OCLASS_ID(CSocketConnector);

		CSocketConnector( CConnectionPool* pPool = 0 );
		virtual ~CSocketConnector();

		//Plug interface
		virtual bool Connect();													//Device specific connection
		virtual void Disconnect(void);											//Device specific disconnection
		virtual bool HandlePendingConnectionResult(bool bConnected);			//Handling device specific pending connection states for async connections

																				//Socket properties
		void SetType(ISocket::eType Type);
		ISocket::eType GetType(void);

		void SetAddressFamily(ISocket::eAddressFamily);
		ISocket::eAddressFamily GetAddressFamily(void);

		void SetProtocol( ISocket::eProtocol );
		ISocket::eProtocol GetProtocol(void);

		void SetAddress( const ISocket::Address& Addr);
		virtual ISocket::ref_type Socket(void) { return m_Socket; }					//The underlying Socket wrapper

	protected:

		ISocket::ref_type m_Socket;
		ISocket::eType m_Type;
		ISocket::eAddressFamily m_AddressFamily;
		ISocket::eProtocol m_iProtocol;
		ISocket::Address m_Address;
	};

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE(__BLUEFOOTQOR) CIOSource : public CSource
	{
	public:

		typedef nsCodeQOR::CTLRef< CIOSource > refSourceType;

		//--------------------------------------------------------------------------------
		CIOSource(CPlug* pConnector = 0) : CSource()
		, m_pIOSourceConnector(pConnector)
		{
		}

		//--------------------------------------------------------------------------------
		virtual ~CIOSource()
		{
			m_pIOSourceConnector = 0;
		}

		//--------------------------------------------------------------------------------
		refSourceType SourceRef(void)
		{
			refSourceType ref(this, false);
			return ref;
		}

		//--------------------------------------------------------------------------------
		CPlug* GetSourceConnector(void)
		{
			return m_pIOSourceConnector;
		}

		//--------------------------------------------------------------------------------
		void SetSourceConnector(CPlug* pIOConnector)
		{
			m_pIOSourceConnector = pIOConnector;
		}

		virtual bool Read(unsigned long& ulNumberOfUnitsRead, unsigned long ulNumberOfUnitsToRead = 1) = 0;

	protected:

		CPlug* m_pIOSourceConnector;
	};

	//--------------------------------------------------------------------------------
	//A general Bluefoot source which reads from a Socket connection
	class __QOR_INTERFACE(__BLUEFOOTQOR) CSocketSource : public CIOSource
	{
	public:

		__QOR_DECLARE_OCLASS_ID(CSocketSource);

		CSocketSource(CSocketConnector* pSocketConnector);
		virtual ~CSocketSource();

		virtual bool Read(unsigned long& ulNumberOfUnitsRead, unsigned long ulNumberOfUnitsToRead = 1);
		virtual bool IsAtEnd(void);
	};

	//--------------------------------------------------------------------------------
	//A generic data sink, possibly but not necessarily representing a device.
	//Derived classes handle output to specific devices
	class __QOR_INTERFACE(__BLUEFOOTQOR) CIOSink : public CSink
	{
	public:

		typedef nsCodeQOR::CTLRef< CIOSink > refSinkType;

		//--------------------------------------------------------------------------------
		CIOSink(CPlug* pConnector = 0) : CSink()
		, m_pIOSinkConnector(pConnector)
		{
		}

		//--------------------------------------------------------------------------------
		virtual ~CIOSink()
		{
			m_pIOSinkConnector = 0;
		}

		//--------------------------------------------------------------------------------
		refSinkType SinkRef(void)
		{
			refSinkType ref(this, false);
			return ref;
		}

		//--------------------------------------------------------------------------------
		CPlug* GetSinkConnector(void)
		{
			return m_pIOSinkConnector;
		}

		//--------------------------------------------------------------------------------
		void SetSinkConnector(CPlug* pIOConnector)
		{
			m_pIOSinkConnector = pIOConnector;
		}

		virtual bool Write(unsigned long& ulNumberOfUnitsWritten, unsigned long ulNumberOfUniteToWrite) = 0;
		virtual bool Flush(void) = 0;

	protected:

		CPlug* m_pIOSinkConnector;
	};

	//--------------------------------------------------------------------------------
	//A general Bluefoot Sink which writes to a Socket Connection
	class __QOR_INTERFACE(__BLUEFOOTQOR) CSocketSink : public CIOSink
	{
	public:

		__QOR_DECLARE_OCLASS_ID(CSocketSink);

		CSocketSink(CSocketConnector* pSocketConnector);
		virtual ~CSocketSink();

		virtual bool Write(unsigned long& ulNumberOfUnitsWritten, unsigned long ulNumberOfUnitsToWrite );
		virtual bool Flush(void);
		
		CSocketWriteError_Event WriteError;
		CSocketWriteSuccess_Event WriteSuccess;

	protected:

		bool AsyncWrite(unsigned long& ulNumberOfBytesWritten, unsigned long ulNumberOfUnitsToWrite, ISocket::ref_type Socket, void* pSyncObject);
		bool SyncWrite(unsigned long& ulNumberOfUnitsWritten, unsigned long ulNumberOfUnitsToWrite, ISocket::ref_type Socket);

	};

}//nsBluefoot

#endif//BLUEFOOT_SOCKET_H_3
