//clang4.h

// Copyright Querysoft Limited 2016
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//clang 4 common base

#include "CompilerQOR/Compilers/clang/clang.h"

// Branch prediction hints
#if defined(__has_builtin)
#	if __has_builtin(__builtin_expect)
#		define QOR_LIKELY(x) __builtin_expect(x, 1)
#		define QOR_UNLIKELY(x) __builtin_expect(x, 0)
#	endif
#endif

//--------------------------------------------------------------------------------
//Module Interface declarations
#if !defined(_WIN32) && !defined(__WIN32__) && !defined(WIN32)
#	define __QCMP_EXPORT	__attribute__((__visibility__("default")))	//declare an item as exported from the module
#	define __QCMP_IMPORT	//declare an item as imported from another module
#	define __QCMP_LOCAL		__attribute__((__visibility__("hidden")))//declare an item as being local to a module
#endif

// The QOR_FALLTHROUGH macro can be used to annotate implicit fall-through
// between switch labels.
#if __cplusplus >= 201103L && defined(__has_warning)
#  if __has_feature(cxx_attributes) && __has_warning("-Wimplicit-fallthrough")
#    define QOR_FALLTHROUGH [[clang::fallthrough]]
#  endif
#endif

// Unused attribute:
#if defined(__GNUC__) && (__GNUC__ >= 4)
#  define QOR_ATTRIBUTE_UNUSED __attribute__((unused))
#endif

#	define __QCMP_VC6_MESSAGE( _X )

//--------------------------------------------------------------------------------
#if		( __QCMP_REPORTDEFECITS == __QCS_YES_ )
#	if		( __QOR_PERFORMANCE == __QCS_MAX_PERFORMANCE_ )
#		define TODO(_Message) comment( user, "Incomplete code" )
#	else//!( __QOR_PERFORMANCE == __QCS_MAX_PERFORMANCE_ )
#		define TODO(_Message) message( __FILE__ "(" __QCMP_STRINGIZEA(__LINE__) "): TODO: " ##_Message)
#	endif//( __QOR_PERFORMANCE == __QCS_MAX_PERFORMANCE_ )
#else//!( __QCMP_REPORTDEFECITS == __QCS_YES_ )
#	define TODO(_Message)
#endif//( __QCMP_REPORTDEFECITS == __QCS_YES_ )


#define QOR_COMP_SUPPORTED_ARCHITECTURES (QOR_ARCH_ALPHA)(QOR_ARCH_IA64)(QOR_ARCH_MIPS)\
(QOR_ARCH_PPC)(QOR_ARCH_X86_32)


//--------------------------------------------------------------------------------
//predefined macro support
#define __QCMP_SUPPORTS__FUNCSIG__	1
#define __QCMP_FUNCSIG__( _X ) __FUNCSIG__

//--------------------------------------------------------------------------------
//extensions
#define Unicode_Const_Str_Conversion_QCMPSUPPORTED		1	//MSVC 6 has L## builtin macro
#define Structured_Exceptions_QCMPSUPPORTED				1	//SEH support
#define SizeSuffixes_QCMPSUPPORTED						1
#define MIBSizedInts_QCMPSUPPORTED						1	//Has Microsoft/Intel/Borland style sized integers e.g. __int16
#ifdef _CPPUNWIND
#	define Exceptions_QCMPSUPPORTED						1	//C++ exception support
#endif
#ifdef _CPPRTTI
#	define RunTimeTypeInformation_QCMPSUPPORTED			1	//RTTI supported
#	pragma __QCMP_VC6_MESSAGE( "Compiler runtime type information enabled." )
#endif
#ifdef _MT
#	define MultiThreadingCompilerAssistance_QCMPSUPPORTED	1
#	pragma __QCMP_VC6_MESSAGE( "Compiler multiple threading support enabled." )
#endif

//--------------------------------------------------------------------------------
//type suffixes
#define	__QCMP_LONG_SUFFIX( _X )			_X##l
#define	__QCMP_UNSIGNED_SUFFIX( _X )		_X##u
#define	__QCMP_UNSIGNEDLONG_SUFFIX( _X )	_X##ul
#define	__QCMP_LONGLONG_SUFFIX( _X )		_X##ll
#define	__QCMP_FLOAT_SUFFIX( _X )			_X##f
#define __QCMP_i64_SUFFIX( _X )				_X##i64
#define __QCMP_ui64_SUFFIX( _X )			_X##ui64

//--------------------------------------------------------------------------------
//emulation of missing fundamental types
#if ( !__QCMP_SUPPORTS( __QCMP_FEATURE_NATIVEWCHARTSUPPORT ) )
	typedef unsigned short	wchar_t;
#endif


//--------------------------------------------------------------------------------
//warnings

#define __QCMP_WARN_MACRO_REDEFINITION					4005
#define __QCMP_WARN_COND_EXPR_IS_CONST					4127
#define __QCMP_WARN_UNARY_MINUS_APPLIED_TO_UNSIGNED		4146
#define __QCMP_WARN_EXTENSION_USED_ZERO_SIZED_ARRAY		4200
#define __QCMP_WARN_NAMELESS_STRUCTUNION				4201
#define __QCMP_WARN_EXTENSION_EXTERN_TEMPLATE_INSTANCE	4231
#define __QCMP_WARN_CONV_FROM_LONG_DOUBLE_TO_DOUBLE		4244
#define __QCMP_WARN_CLASS_NEEDS_TO_HAVE_DLL_INTERFACE	4251
#define __QCMP_WARN_NON_EXPORTED_BASE_FOR_EXPORT		4275
#define __QCMP_WARN_EXCEPTION_SPEC_IGNORED				4290
#define __QCMP_WARN_TRUNCATION_FROM_DOUBLE_TO_FLOAT		4305
#define __QCMP_WARN_STRUCTURE_PADDED_DUE_TO_ALIGN		4324
#define __QCMP_WARN_THIS_USED_IN_BASE_INIT_LIST			4355
#define __QCMP_WARN_NO_DEFINITION_FOR_TEMPLATE_INST_REQ	4661
#define __QCMP_WARN_UNREF_LOCAL_FUNCTION				4505
#define __QCMP_WARN_UNINIT_LOCAL_VAR_USED				4700
#define __QCMP_WARN_ASSIGNMENT_WITHIN_COND_EXPR			4706


#if ! (defined(lint) || defined(RC_INVOKED))
#	if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#		pragma warning(disable:4103)
#		if !(defined( MIDL_PASS )) || defined( __midl )
#			define __QCMP_PACK( _N ) pack(push,_N)
#			define __QCMP_END_PACK pack(pop)
#		else
#			define __QCMP_PACK( _N ) pack(_N)
#			define __QCMP_END_PACK pack()
#		endif
#	else
#		define __QCMP_END_PACK pack()
#	endif
#endif /* ! (defined(lint) || defined(RC_INVOKED)) */

//--------------------------------------------------------------------------------
namespace nsCompiler
{
	//--------------------------------------------------------------------------------
	namespace EH
	{
		struct UnwindMapEntry;
		struct TryBlockMapEntry;
	}//EH

	//--------------------------------------------------------------------------------
    class __QOR_INTERFACE( __QCMP ) CclangCompiler4
	{
	public:

		CclangCompiler4(){};
		virtual ~CclangCompiler4(){};

		//Name the supported basic types with single tokens

		typedef void					mxc_void;
		typedef const void				mxc_c_void;
		typedef volatile void			mxc_v_void;
		typedef bool					mxc_bool;
		typedef const bool				mxc_c_bool;
		typedef volatile bool			mxc_v_bool;
		typedef char					mxc_char;
		typedef const char				mxc_c_char;
		typedef volatile char			mxc_v_char;
		typedef short					mxc_short;
		typedef const short				mxc_c_short;
		typedef volatile short			mxc_v_short;
		typedef int						mxc_int;
		typedef const int				mxc_c_int;
		typedef volatile int			mxc_v_int;
		typedef long					mxc_long;
		typedef const long				mxc_c_long;
		typedef volatile long			mxc_v_long;
		typedef float					mxc_float;
		typedef const float				mxc_c_float;
		typedef volatile float			mxc_v_float;
		typedef	double					mxc_double;
		typedef	const double			mxc_c_double;
		typedef	volatile double			mxc_v_double;
		typedef signed char				mxc_signed_char;
		typedef const signed char		mxc_c_signed_char;
		typedef volatile signed char	mxc_v_signed_char;
		typedef unsigned char			mxc_unsigned_char;
		typedef const unsigned char		mxc_c_unsigned_char;
		typedef volatile unsigned char	mxc_v_unsigned_char;
		typedef short					mxc_signed_short;
		typedef const short				mxc_c_signed_short;
		typedef volatile short			mxc_v_signed_short;
		typedef unsigned short			mxc_unsigned_short;
		typedef const unsigned short	mxc_c_unsigned_short;
		typedef volatile unsigned short	mxc_v_unsigned_short;
		typedef int						mxc_signed_int;
		typedef const int				mxc_c_signed_int;
		typedef volatile int			mxc_v_signed_int;
		typedef unsigned int			mxc_unsigned_int;
		typedef const unsigned int		mxc_c_unsigned_int;
		typedef volatile unsigned int	mxc_v_unsigned_int;
		typedef long					mxc_signed_long;
		typedef const long				mxc_c_signed_long;
		typedef volatile long			mxc_v_signed_long;
		typedef unsigned long			mxc_unsigned_long;
		typedef const unsigned long		mxc_c_unsigned_long;
		typedef volatile unsigned long	mxc_v_unsigned_long;
		typedef long double				mxc_long_double;
		typedef const long double		mxc_c_long_double;
		typedef volatile long double	mxc_v_long_double;

		//Fake long long type where long long is not supported
		typedef __int64						mxc_long_long;
		typedef const __int64				mxc_c_long_long;
		typedef volatile __int64			mxc_v_long_long;
		typedef unsigned __int64			mxc_unsigned_long_long;
		typedef const unsigned __int64		mxc_c_unsigned_long_long;
		typedef volatile unsigned __int64	mxc_v_unsigned_long_long;

#if ( __QCMP_SUPPORTS( __QCMP_FEATURE_NATIVEWCHARTSUPPORT ) )
		typedef wchar_t						mxc_wchar_t;
		typedef const wchar_t				mxc_c_wchar_t;
		typedef volatile wchar_t			mxc_v_wchar_t;
#	else
		typedef mxc_unsigned_short			mxc_wchar_t;
		typedef mxc_c_unsigned_short		mxc_c_wchar_t;
		typedef mxc_v_unsigned_short		mxc_v_wchar_t;
#	endif

		typedef unsigned __int8				mxc_unsigned__int8;
		typedef const unsigned __int8		mxc_c_unsigned__int8;
		typedef volatile unsigned __int8	mxc_v_unsigned__int8;
		typedef unsigned __int16			mxc_unsigned__int16;
		typedef const unsigned __int16		mxc_c_unsigned__int16;
		typedef volatile unsigned __int16	mxc_v_unsigned__int16;
		typedef unsigned __int32			mxc_unsigned__int32;
		typedef const unsigned __int32		mxc_c_unsigned__int32;
		typedef volatile unsigned __int32	mxc_v_unsigned__int32;
		typedef unsigned __int64			mxc_unsigned__int64;
		typedef const unsigned __int64		mxc_c_unsigned__int64;
		typedef volatile unsigned __int64	mxc_v_unsigned__int64;
		typedef signed __int8				mxc_signed__int8;
		typedef const signed __int8			mxc_c_signed__int8;
		typedef volatile signed __int8		mxc_v_signed__int8;
		typedef signed __int16				mxc_signed__int16;
		typedef const signed __int16		mxc_c_signed__int16;
		typedef volatile signed __int16		mxc_v_signed__int16;
		typedef signed __int32				mxc_signed__int32;
		typedef const signed __int32		mxc_c_signed__int32;
		typedef volatile signed __int32		mxc_v_signed__int32;
		typedef signed __int64				mxc_signed__int64;
		typedef const signed __int64		mxc_c_signed__int64;
		typedef volatile signed __int64		mxc_v_signed__int64;
		typedef __int8						mxc__int8;
		typedef const __int8				mxc_c__int8;
		typedef volatile __int8				mxc_v__int8;
		typedef __int16						mxc__int16;
		typedef const __int16				mxc_c__int16;
		typedef volatile __int16			mxc_v__int16;
		typedef __int32						mxc__int32;
		typedef const __int32				mxc_c__int32;
		typedef volatile __int32			mxc_v__int32;
		typedef __int64						mxc__int64;
		typedef const __int64				mxc_c__int64;
		typedef volatile __int64			mxc_v__int64;
		typedef mxc_int						mxc_int_ptr, *pmxc_int_ptr;
		typedef mxc_unsigned_int			mxc_uint_ptr, *pmxc_uint_ptr;
		typedef mxc_long					mxc_long_ptr, *pmxc_long_ptr;
		typedef mxc_unsigned_long			mxc_ulong_ptr, *pmxc_ulong_ptr;
		typedef mxc__int32					mxc__int3264;

		//--------------------------------------------------------------------------------
		struct FuncInfo
		{
			unsigned int magicNumber;
			int maxState;
			const EH::UnwindMapEntry* pUnwindMap;
			unsigned int nTryBlocks;
			const EH::TryBlockMapEntry* pTryBlockMap;
			unsigned int nIPMapEntries;
			void* pIPtoStateMap;
		};

		__QCMP_STATIC_CONSTANT( unsigned int, EH_MAGIC					= 0x19930520 );		//Magic number for exception supprt
		__QCMP_STATIC_CONSTANT( unsigned int, VTABLE_FUNCTION_BASE		= 0 );				//vtable decoding constants
		__QCMP_STATIC_CONSTANT( unsigned int, VTABLE_FUNCTION_STRIDE	= 1 );

		//--------------------------------------------------------------------------------
		//Compiler compatible non-virtual function address lookup
		template< typename TGenFuncPtrType, typename TActualFP >
		static TGenFuncPtrType GetNonVirtualMemberFunctionAddress( TActualFP fp )
		{
			union
			{
				struct
				{
					TGenFuncPtrType p;
				} mfp_structure;
				TActualFP fp;
			} conv;

			conv.fp = fp;
			return conv.mfp_structure.p;
		}

		//--------------------------------------------------------------------------------
		template< int s > static bool is_virtual_func( unsigned char* func )
		{
			if (*func == 0xE9)
			{
				return is_virtual_func< 0 >( func + 5 + *(unsigned int*)( func + 1 ) );
			}
			else
			{
				switch( *(unsigned int*)func )
				{ // mov ecx, this; jump [eax + v/Ib/Iw]
				case 0x20ff018b:
				case 0x60ff018b:
				case 0xA0ff018b: return true;
				default: return false;
				}
			}
		}

		//--------------------------------------------------------------------------------
		template< typename T > static bool is_virtual( T t )
		{
			union
			{
				T t;
				unsigned long value;
			} conv;
			conv.t = t;
			return is_virtual_func< 0 >( (unsigned char*)conv.value );
		}

		//--------------------------------------------------------------------------------
		void Init()
		{

		}
	};

}//nsCompiler
