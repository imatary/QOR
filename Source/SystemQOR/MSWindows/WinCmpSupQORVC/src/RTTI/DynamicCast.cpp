//DynamicCast.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/WinQL.h"
#include "SystemQOR.h"
#include "WinQL/Application/Threading/WinQLCriticalSection.h"
#include "../Source/SystemQOR/MSWindows/WinCmpSupQORVC/include/RTTI/RTTI.h"
#include <algorithm>
#include <typeinfo>
#include "../Source/SystemQOR/MSWindows/WinCmpSupQORVC/include/Exceptions/SEH/excpt.h"
#if defined(_WIN64) && !defined(_M_CEE_PURE)
#	include "WinQAPI/Kernel32.h"
#endif

#define BCD_NOTVISIBLE              0x00000001 
#define BCD_AMBIGUOUS               0x00000002
#define BCD_PRIVORPROTBASE			0x00000008

using namespace std;


static ptrdiff_t __QCMP_CALLCON PMDtoOffset(void* pThis, const PMD& pmd);

//--------------------------------------------------------------------------------
class MatchSIDownCast
{
public:

	//--------------------------------------------------------------------------------
	MatchSIDownCast( TypeDescriptor* pTargetType ): m_pTargetType( pTargetType )
	{
	}

	//--------------------------------------------------------------------------------
	int operator()( const BaseClassDescriptor* pBase )
	{
		return ( *( pBase->pTypeDescriptor ) == *m_pTargetType && ( pBase->attributes & 1 ) == 0 );
	}

private:

	TypeDescriptor * m_pTargetType;
};

//--------------------------------------------------------------------------------
class MatchCrossCast
{
public:

	//--------------------------------------------------------------------------------
	MatchCrossCast( TypeDescriptor* pTargetType ) : m_pTargetType( pTargetType )
	{
	}

	int operator()( const BaseClassDescriptor* pBase );

private:

	TypeDescriptor* m_pTargetType;
};

//--------------------------------------------------------------------------------
class MatchSubBase
{
public:

	//--------------------------------------------------------------------------------
	MatchSubBase( TypeDescriptor* pSrcType, void* pCompleteObject, Cmp__int3264 SrcOffset ): m_pSrcType( pSrcType ), m_pCompleteObject( pCompleteObject ), m_SrcOffset( SrcOffset )
	{
	}

	int operator()( const BaseClassDescriptor* pSubBase );

private:

	TypeDescriptor* m_pSrcType;
	void* m_pCompleteObject;
	Cmp__int3264 m_SrcOffset;
};

//--------------------------------------------------------------------------------
class MatchMIDownCast
{
public:

	//--------------------------------------------------------------------------------
	MatchMIDownCast( TypeDescriptor* pTargetType, TypeDescriptor* pSrcType, void* pCompleteObject, Cmp__int3264 SrcOffset ): m_pTargetType( pTargetType ), m_MatchSubBase( pSrcType, pCompleteObject, SrcOffset )
	{
	}

	int operator()( const BaseClassDescriptor* const * pBasePtr );

private:

	TypeDescriptor * m_pTargetType;
	MatchSubBase m_MatchSubBase;
};

//--------------------------------------------------------------------------------
int MatchCrossCast::operator()( const BaseClassDescriptor* pBase )
{
	return ( *( pBase->pTypeDescriptor ) == *m_pTargetType && ( pBase->attributes & 1 ) == 0 && ( pBase->attributes & 2 ) == 0 );
}

//--------------------------------------------------------------------------------
int MatchSubBase::operator()( const BaseClassDescriptor* pSubBase )
{
	if ( *( pSubBase->pTypeDescriptor ) == *m_pSrcType )
	{
		return ( AdjustPointer( m_pCompleteObject, pSubBase->where ) == ( unsigned char* )m_pCompleteObject + m_SrcOffset );
	}
	return false;
}

//--------------------------------------------------------------------------------
int MatchMIDownCast::operator()( const BaseClassDescriptor* const * pBasePtr )
{
	desc_ptr const pBase = *pBasePtr;
	if ( *( pBase->pTypeDescriptor ) == *m_pTargetType )
	{
		desc_ptr_ptr const pSubBegin = pBasePtr + 1;
		desc_ptr_ptr const pSubEnd = pSubBegin + pBase->numContainedBases;
		desc_ptr_ptr const pSubBasePtr = find_if( pSubBegin, pSubEnd, m_MatchSubBase );
		return ( pSubBasePtr != pSubEnd );
	}

	return false;
}

//--------------------------------------------------------------------------------
void* FindCompleteObject( void* pObject, CompleteObjectLocator* pCompleteLocator )
{
	unsigned char* pCompleteObject = ( unsigned char* )pObject - pCompleteLocator->offset;
	if ( pCompleteLocator->cdOffset != 0 )
	{
		pCompleteObject += *( unsigned long* )( ( unsigned char* )pObject - pCompleteLocator->cdOffset );
	}
	return pCompleteObject;
}

//--------------------------------------------------------------------------------
static void* __QCMP_CALLCON FindCompleteObject(void** inptr)           // Pointer to polymorphic object
{
	CompleteObjectLocator* pCompleteLocator = (*(CompleteObjectLocator***)inptr)[-1];
	// Ptr to CompleteObjectLocator should be stored at vfptr[-1]
	//CompleteObjectLocator* pCompleteLocator = (CompleteObjectLocator *)((*((void***)inptr))[-1]);
	char *pCompleteObject = (char *)inptr - pCompleteLocator->offset;

	// Adjust by construction displacement, if any
	if (pCompleteLocator->cdOffset)
	{
		pCompleteObject -= *(int *)((char *)inptr - pCompleteLocator->cdOffset );
	}
	return (void*)pCompleteObject;
}

//--------------------------------------------------------------------------------
const BaseClassDescriptor* FindSITargetTypeInstance( void* /*pCompleteObject*/, const CompleteObjectLocator* pCompleteLocator, TypeDescriptor* /*pSrcType*/, Cmp__int3264 /*SrcOffset*/, TypeDescriptor* pTargetType )
{
	typedef const BaseClassDescriptor* const* desc_ptr_ptr;
	typedef const BaseClassDescriptor* desc_ptr;

	desc_ptr_ptr const pBegin = ( const desc_ptr_ptr )(pCompleteLocator->pClassDescriptor->pBaseClassArray->arrayOfBaseClassDescriptors);
	desc_ptr_ptr const pEnd =  pBegin + pCompleteLocator->pClassDescriptor->numBaseClasses;
	desc_ptr_ptr const pBasePtr = find_if( pBegin, pEnd, MatchSIDownCast( pTargetType ) );
	return ( pBasePtr != pEnd ? *pBasePtr : 0 );
}

//--------------------------------------------------------------------------------
const BaseClassDescriptor*  FindMITargetTypeInstance( void* pCompleteObject, const CompleteObjectLocator* pCompleteLocator, TypeDescriptor* pSrcType, Cmp__int3264 SrcOffset, TypeDescriptor* pTargetType )
{
	desc_ptr_ptr const pBegin =  ( const desc_ptr_ptr )(pCompleteLocator->pClassDescriptor->pBaseClassArray->arrayOfBaseClassDescriptors);
	desc_ptr_ptr const pEnd = pBegin + pCompleteLocator->pClassDescriptor->numBaseClasses;
	desc_ptr_ptr pBasePtr = find_if_ptr( pBegin, pEnd, MatchMIDownCast( pTargetType, pSrcType, pCompleteObject, SrcOffset ) );
	if ( pBasePtr != pEnd )
	{
		return *pBasePtr;
	}
	pBasePtr = find_if( pBegin, pEnd, MatchCrossCast( pTargetType ) );
	return ( pBasePtr != pEnd ? *pBasePtr : 0 );
}

//--------------------------------------------------------------------------------
static BaseClassDescriptor * __QCMP_CALLCON FindMITargetTypeInstance(
	void* pCompleteObject,                  // pointer to complete object
	CompleteObjectLocator *pCOLocator, // pointer to Locator of complete object
	TypeDescriptor *pSrcTypeID,        // pointer to TypeDescriptor of source object
	ptrdiff_t SrcOffset,                    // offset of source object in complete object
	TypeDescriptor *pTargetTypeID      // pointer to TypeDescriptor of result of cast
#if defined(_WIN64) && !defined(_M_CEE_PURE)
	, unsigned __int64 _ImageBase
#endif
	)
{
	BaseClassDescriptor *pBCD;
	BaseClassDescriptor *pTargetBCD = nullptr;
	BaseClassDescriptor *pSourceBCD = nullptr;
	BaseClassDescriptor *pSourceInTargetBCD;
	BaseClassArray *pBaseClassArray = pCOLocator->pClassDescriptor->pBaseClassArray;
	BaseClassArray *pTargetBaseClassArray;
	unsigned long i;
	unsigned long nCompleteObjectBases = pCOLocator->pClassDescriptor->numBaseClasses;
	unsigned long nTargetBases = 0;
	unsigned long iTarget = (unsigned long)-1;

	// Walk the BaseClassArray, which lists the complete object's base class
	// hierarchy in depth-first left-to-right base class order, with the type
	// of the complete object at pBaseClassArray[0].  Look for down-casts
	// (5.2.7/8 bullet 1) and cross-casts (bullet 2) in a single pass through
	// the array.  If we've got an up-cast that wasn't resolved statically
	// because the target base was inaccessible or ambiguous within the derived
	// source, we'll detect it as a failed cross-cast since the target will also
	// be inaccessible or ambiguous within the complete object.
	//
	// With multiple inheritance, we can stop our walk as soon as we've seen
	// both the source and target types, since for MI down-casts, an ambiguous
	// target isn't possible (thanks to the unambiguous path from the source
	// sub-object to the most derived object), and for cross-cast, all instances
	// of the target type will be marked ambiguous if there are more than one.
	// Compare that with the corresponding walk in the virtual inheritance case,
	// where we may have to walk the entire hierarchy.

	for (i = 0; i < nCompleteObjectBases; i++)
	{
		pBCD = (BaseClassDescriptor*)( pBaseClassArray->arrayOfBaseClassDescriptors[i] );

		// Test if we've found an instance of the target class.  We can skip
		// the type-id check while walking through any base classes of the
		// target class.

		if( i - iTarget > nTargetBases && ( *pBCD->pTypeDescriptor == *pTargetTypeID ) )
		{
			// If we've already found the source class instance, then we must
			// have either a cross-cast or an up-cast.  The target must be
			// public and unambiguous in the complete object, and the source
			// must be public in the complete object, or the cast fails.  The
			// cast will always fail in the up-cast case, otherwise a runtime
			// check would not have been generated by the compiler.

			if (pSourceBCD != nullptr)
			{
				if (( pBCD->attributes & (BCD_NOTVISIBLE | BCD_AMBIGUOUS)) ||
					( pSourceBCD->attributes & BCD_NOTVISIBLE))
				{
					return nullptr;
				}
				else
				{
					return pBCD;
				}
			}

			// Remember where we found the most recent instance of the target
			// class, as well as how many base classes of that target we will
			// encounter.

			pTargetBCD = pBCD;
			iTarget = i;
			nTargetBases = pBCD->numContainedBases;
		}

		// Test if we've found the proper instance of the source class.

		if( ( *pBCD->pTypeDescriptor == *pSrcTypeID ) && PMDtoOffset( pCompleteObject, pBCD->where ) == SrcOffset )
		{
			// If we've already found an instance of the target class, check
			// if we're within the base classes of that target instance.  If
			// yes, we've got a down-cast, otherwise we've got a cross-cast or
			// failed up-cast.

			if (pTargetBCD != nullptr)
			{
				if (i - iTarget <= nTargetBases)
				{
					// It's a down-cast.  The source class must be a public
					// base of the target class, or the cast fails.

					if (!( pTargetBCD->attributes & ( 1 << 2 )/*BCD_HASPCHD*/))
					{
						// We've got an older form of the RTTI data without the
						// link to the class hierarchy descriptor.  We can only
						// test public visibility of the source within the
						// target if we're casting to the complete object's type
						// (when iTarget is zero), otherwise allow the cast to
						// succeed.

						if (iTarget == 0 && pBCD->attributes & BCD_NOTVISIBLE )
						{
							return nullptr;
						}
						else
						{
							return pTargetBCD;
						}
					}

					// Check the target class' class hierarchy descriptor to
					// determine if the source class is publicly visible from
					// the target class.  We index into the BaseClassArray of
					// the target type, which will be layed out in the same
					// depth-first, left-to-right order as the corresponding
					// subset of the complete object's BaseClassArray from
					// pBaseClassArray[iTarget .. iTarget+nTargetBases].

					pTargetBaseClassArray = (BaseClassArray*)(pTargetBCD->pClassHierarchyDescriptor->pBaseClassArray);
					pSourceInTargetBCD = (BaseClassDescriptor*)( pTargetBaseClassArray->arrayOfBaseClassDescriptors[i - iTarget] );

					if ( pSourceInTargetBCD->attributes & BCD_NOTVISIBLE)
					{
						return nullptr;
					}
					else
					{
						return pTargetBCD;
					}
				}
				else
				{
					// It's a cross-cast or (failed) up-cast.  The target must
					// be public and unambiguous in the complete object, and the
					// source must be public in the complete object.

					if ( ( pTargetBCD->attributes & (BCD_NOTVISIBLE | BCD_AMBIGUOUS ) ) || ( pBCD->attributes & BCD_NOTVISIBLE))
					{
						return nullptr;
					}
					else
					{
						return pTargetBCD;
					}
				}
			}

			// Remember that we've found the source class instance

			pSourceBCD = pBCD;
		}
	}

	// Either the complete object does not contain any instances of the target
	// class, or we never found the source instance (which only happens if
	// we've got corrupted RTTI info or the source pointer we were passed was
	// mistyped).  In either case, the cast fails.

	return nullptr;
}

//--------------------------------------------------------------------------------
const BaseClassDescriptor* FindVITargetTypeInstance( void* pCompleteObject, const CompleteObjectLocator* pCompleteLocator, TypeDescriptor* pSrcType, Cmp__int3264 SrcOffset, TypeDescriptor* pTargetType )
{
	desc_ptr_ptr const pBegin = ( const desc_ptr_ptr )(pCompleteLocator->pClassDescriptor->pBaseClassArray->arrayOfBaseClassDescriptors);
	desc_ptr_ptr const pEnd = pBegin + pCompleteLocator->pClassDescriptor->numBaseClasses;

	desc_ptr pResult = 0;
	{
		for( desc_ptr_ptr pBasePtr = pBegin; pBasePtr != pEnd; ++pBasePtr )
		{
			desc_ptr const pBase = *pBasePtr;
			if ( *( pBase->pTypeDescriptor ) == *pTargetType )
			{
				desc_ptr_ptr const pSubBegin = pBasePtr + 1;
				desc_ptr_ptr const pSubEnd = pSubBegin + pBase->numContainedBases;

				for( desc_ptr_ptr pSubBasePtr = pSubBegin; pSubBasePtr != pSubEnd; ++pSubBasePtr )
				{
					desc_ptr const pSubBase = *pSubBasePtr;

					if ( *( pSubBase->pTypeDescriptor ) == *pSrcType )
					{
						if ( AdjustPointer( pCompleteObject, pSubBase->where ) == ( unsigned char* )pCompleteObject + SrcOffset )
						{
							if ( pResult )
							{
								if ( AdjustPointer( pCompleteObject, pResult->where ) != AdjustPointer( pCompleteObject, pBase->where ) )
								{
									return 0;
								}
							}
							pResult = pBase;
						}
					}
				}
			}
		}
	}

	if ( pResult )
	{
		return pResult;
	}

	desc_ptr_ptr pBasePtr = find_if( pBegin, pEnd, MatchCrossCast( pTargetType ) );
	return ( pBasePtr != pEnd ? *pBasePtr : 0 );
}

//--------------------------------------------------------------------------------
static BaseClassDescriptor * __QCMP_CALLCON FindVITargetTypeInstance( void* pCompleteObject,                  // pointer to complete object
	CompleteObjectLocator *pCOLocator, // pointer to Locator of complete object
	TypeDescriptor *pSrcTypeID,        // pointer to TypeDescriptor of source object
	ptrdiff_t SrcOffset,                    // offset of source object in complete object
	TypeDescriptor *pTargetTypeID      // pointer to TypeDescriptor of result of cast
#if defined(_WIN64) && !defined(_M_CEE_PURE)
	, unsigned __int64 _ImageBase
#endif
	)
{
	BaseClassDescriptor *pBCD;
	BaseClassDescriptor *pDownCastResultBCD = nullptr;
	BaseClassDescriptor *pCrossCastSourceBCD = nullptr;
	BaseClassDescriptor *pCrossCastTargetBCD = nullptr;
	BaseClassDescriptor *pTargetBCD = nullptr;
	BaseClassDescriptor *pSourceInTargetBCD;
	BaseClassArray *pBaseClassArray = pCOLocator->pClassDescriptor->pBaseClassArray;
	BaseClassArray *pTargetBaseClassArray;
	unsigned long i;
	unsigned long nCompleteObjectBases = pCOLocator->pClassDescriptor->numBaseClasses;
	unsigned long nTargetBases = 0;
	unsigned long iTarget = (unsigned long)-1;
	bool fDownCastAllowed = true;
	bool fDirectlyPublic;
	ptrdiff_t offsetTarget;
	ptrdiff_t offsetDownCastResult = -1;

	// Walk the BaseClassArray, which lists the complete object's base class
	// hierarchy in depth-first left-to-right base class order, with the type
	// of the complete object at pBaseClassArray[0].  Look for down-casts
	// (5.2.7/8 bullet 1) and cross-casts (bullet 2) in a single pass through
	// the array.  If we've got an up-cast that wasn't resolved statically
	// because the target base was inaccessible or ambiguous within the derived
	// source, we'll detect it as cross-cast, which may or may not succeed (see
	// the comments above in __RTDynamicCast).
	//
	// For virtual inheritance, we may have to walk the entire hierarchy even
	// after we see both the source and target types.  That's to detect a
	// down-cast to an ambiguous target because of an intervening virtual
	// derivation, e.g. dynamic_cast from A* to B* in this E hierarchy:
	//       A
	//      / \
	    //     B   B
//     |   |
//     C   D
//      \ /
//       E

	for (i = 0; i < nCompleteObjectBases; i++)
	{
		pBCD = (BaseClassDescriptor*)(pBaseClassArray->arrayOfBaseClassDescriptors[i]);

		// Test if we've found an instance of the target class.  We can skip
		// the type-id check while walking through any base classes of the
		// target class.

		if( i - iTarget > nTargetBases && ( *pBCD->pTypeDescriptor == *pTargetTypeID ) )
		{
			// If this target instance is public and unambiguous within the
			// complete object, remember it as a potential target of a
			// cross-cast.

			if (!(pBCD->attributes & (BCD_NOTVISIBLE | BCD_AMBIGUOUS)))
			{
				pCrossCastTargetBCD = pBCD;
			}

			// Remember where we found the most recent instance of the target
			// class, as well as how many base classes of that target we will
			// encounter.

			pTargetBCD = pBCD;
			iTarget = i;
			nTargetBases = pBCD->numContainedBases;
		}

		// Test if we've found the proper instance of the source class.

		if( ( *pBCD->pTypeDescriptor == *pSrcTypeID ) && PMDtoOffset( pCompleteObject, pBCD->where ) == SrcOffset )
		{
			// If we're within the base classes of a previously-seen instance
			// of the target class, then we've got a down-cast.

			if (i - iTarget <= nTargetBases)
			{
				// We can skip down-cast checking if we've previously
				// determined that a down-cast isn't allowed, while examining
				// an earlier instance of the source class sub-object which was
				// virtually derived, because that source instance wasn't
				// publicly visible from the target class.

				if (fDownCastAllowed)
				{
					// A potential down-cast is valid if the source class is
					// public within the target class, and if only one instance
					// of the target class derives from the source instance.
					// First check for public visibility of the source.

					if (!( pTargetBCD->attributes & ( 1 << 2 )/*BCD_HASPCHD*/))
					{
						// We've got an older form of the RTTI data without the
						// link to the class hierarchy descriptor.  We can only
						// test public visibility of the source within the
						// target if we're casting to the complete object's type
						// (when iTarget is zero), otherwise allow the cast to
						// succeed.

						if (iTarget == 0 && ( pBCD->attributes & BCD_NOTVISIBLE))
						{
							fDownCastAllowed = false;
						}

						// If BCD_HASPCHD wasn't set, then BCD_PRIVORPROTBASE
						// won't be, either.

						fDirectlyPublic = true;
					}
					else
					{
						// Check the target class' class hierarchy descriptor
						// to determine if the source class is publicly visible
						// from the target class.  We index into the
						// BaseClassArray of the target type, which will be
						// layed out in the same depth-first, left-to-right
						// order as the corresponding subset of the complete
						// object's BaseClassArray from pBaseClassArray[iTarget
						// .. iTarget+nTargetBases].

						pTargetBaseClassArray = (BaseClassArray*)(pTargetBCD->pClassHierarchyDescriptor->pBaseClassArray);
						pSourceInTargetBCD = (BaseClassDescriptor*)(pTargetBaseClassArray->arrayOfBaseClassDescriptors[i - iTarget]);

						if ( pSourceInTargetBCD->attributes & BCD_NOTVISIBLE )
						{
							fDownCastAllowed = false;
						}

						// The above check for source visibility in the target
						// may be wrong, thanks to incorrect compiler-generated
						// RTTI data in cases where a base class is both
						// virtually and non-virtually inherited in a class
						// hierarchy.  E.g.:
						//
						//        A
						//        |
						//        B   A
						//       / \ /
						//      C   D
						//       \ /
						//        E
						//
						// If the virtual base at B::A is private from E, but
						// the non-virtual D::A is public from E, the RTTI data
						// can incorrectly state that both instances of A are
						// visible.  We can work around some cases of this by
						// checking if the source instance is directly inherited
						// non-publicly.  Given dynamic_cast<C*>((A*)(B*)new E),
						// we can properly fail the cast when B -> A is private
						// (and everything else public) by checking
						// BCD_PRIVORPROTBASE, but will still incorrectly allow
						// the cast to succeed when C -> B and D -> B are both
						// virtual private (and everything else public).

						fDirectlyPublic = !( pSourceInTargetBCD->attributes & BCD_PRIVORPROTBASE);
					}

					if (fDownCastAllowed && fDirectlyPublic)
					{
						// The source instance is visible within the target, so
						// now check if a different target instance has already
						// been seen in a previous down-cast.

						offsetTarget = PMDtoOffset(pCompleteObject, pTargetBCD->where );
						if (pDownCastResultBCD != nullptr &&
							offsetDownCastResult != offsetTarget)
						{
							// The source instance can down-cast to multiple
							// separate instances of the target class, so
							// down-casting fails.  But this also means the
							// target type is ambiguous within the complete
							// object, so cross-casting fails as well, and we
							// can fail early.

							return nullptr;
						}

						// We have an unambiguous target, so a down-cast is possible
						// (so far).

						pDownCastResultBCD = pTargetBCD;
						offsetDownCastResult = offsetTarget;
					}
				}
			}
			else
			{
				// If we're not within the base classes of a target instance,
				// then this source instance is a possible cross-cast source.
				// We do not check for a cross-cast if it's also a possible
				// down-cast.  First, it's not necessary - if a down-cast was
				// not possible because of accessibility, then the source
				// instance along the path through the target instance would
				// also not be public within the complete object, and not a
				// valid cross-cast source.  Second, testing in this order works
				// around a bug in the C++ compiler's generated RTTI data.
				// Consider this hierarchy:
				//
				//      struct A { virtual void a(); };
				//      struct B : virtual private A { virtual void b(); };
				//      struct C : public A { virtual void c(); };
				//      struct D : public B, public C { virtual void d(); };
				//
				//      A   A
				//      !   |
				//      B   C
				//       \ /
				//        D
				//
				// The virtual A at D::B::A is not accessible from D.  But the
				// RTTI info says it is accessible, because D::C::A is visible,
				// even though those are two different instances of A.
				//
				// As for the down-cast case (see the comments before setting
				// fDirectlyPublic above), we can check BCD_PRIVORPROTBASE to
				// work around the bad RTTI data in some, but not all, cases.

				if (!( pBCD->attributes & (BCD_NOTVISIBLE | BCD_PRIVORPROTBASE)))
				{
					// If this source instance is public within the complete object,
					// remember it as a potential source of a cross-cast.

					pCrossCastSourceBCD = pBCD;
				}
			}
		}
	}

	// A down-cast is preferred to a cross-cast/up-cast, so check for that
	// first.

	if (fDownCastAllowed && pDownCastResultBCD != nullptr)
	{
		return pDownCastResultBCD;
	}

	// Return a successful cast if we've found both sides of a cross-cast.

	if (pCrossCastSourceBCD != nullptr && pCrossCastTargetBCD != nullptr)
	{
		return pCrossCastTargetBCD;
	}

	// Otherwise we didn't find both sides of a cross-cast which were legally
	// reachable from the complete object (possibly a failed up-cast that
	// generated a runtime check).

	return nullptr;
}

//--------------------------------------------------------------------------------
/*
__QCMP_LINKAGE_C void* __RTDynamicCast( void* inptr, long VfDelta, void* SrcType, void* TargetType, int isReference ) throw(...)
{
	typedef const BaseClassDescriptor* ( *FindTargetTypeInstance )( void* pCompleteObject, const CompleteObjectLocator* pCompleteLocator, TypeDescriptor* pSrcType, Cmp__int3264 SrcOffset, TypeDescriptor* pTargetType );

	if ( inptr == 0 )
	{
		return 0;
	}

	CompleteObjectLocator* pCompleteLocator = ( *( CompleteObjectLocator*** )inptr )[-1];
	void* pCompleteObject = FindCompleteObject( inptr, pCompleteLocator );
	inptr = ( unsigned char* )inptr - VfDelta;
	Cmp__int3264 inptr_delta = ( unsigned char* )inptr - ( unsigned char* )pCompleteObject;
	const BaseClassDescriptor* pBaseClass = 0;
	FindTargetTypeInstance Find = 0;

	if ( ( pCompleteLocator->pClassDescriptor->attributes & 1 ) == 0 )
	{
		Find = FindSITargetTypeInstance;
	}
	else if ( ( pCompleteLocator->pClassDescriptor->attributes & 2 ) == 0 )
	{
		Find = FindMITargetTypeInstance;
	}
	else
	{
		Find = FindVITargetTypeInstance;
	}

	pBaseClass = Find( pCompleteObject, pCompleteLocator, ( TypeDescriptor* )SrcType, inptr_delta, ( TypeDescriptor* )TargetType );

	if ( pBaseClass == 0 )
	{
		if ( isReference )
		{
			throw bad_cast();
		}
		return 0;
	}

	return AdjustPointer( pCompleteObject, pBaseClass->where );
}
*/

//--------------------------------------------------------------------------------
// PMDtoOffset - Calculate member offset from PMD & this
// Output: The offset of the base within the complete object.
static ptrdiff_t __QCMP_CALLCON PMDtoOffset(
	void* pThis,            // ptr to complete object
	const PMD& pmd)         // pointer-to-member-data structure
{
	ptrdiff_t RetOff = 0;

	if (pmd.pdisp >= 0) 
	{
		// if base is in the virtual part of class
		RetOff = pmd.pdisp;
		RetOff += *(__int32*)((char*)*(ptrdiff_t*)((char*)pThis + RetOff) + pmd.vdisp);
	}

	RetOff += pmd.mdisp;

	return RetOff;
}

#if defined(_WIN64) && !defined(_M_CEE_PURE)
//--------------------------------------------------------------------------------
static unsigned __int64 GetImageBase( void* pCallerPC )
{
	unsigned __int64 _ImageBase;
	_ImageBase = (unsigned __int64)nsWinQAPI::CKernel32::RtlPcToFileHeader( pCallerPC, (void**)&_ImageBase);
	return _ImageBase;
}
#endif

//--------------------------------------------------------------------------------
static BaseClassDescriptor * __QCMP_CALLCON FindSITargetTypeInstance(
	CompleteObjectLocator *pCOLocator, // pointer to Locator of complete object
	TypeDescriptor *pSrcTypeID,        // pointer to TypeDescriptor of source object
	TypeDescriptor *pTargetTypeID      // pointer to TypeDescriptor of result of cast
#if defined(_WIN64) && !defined(_M_CEE_PURE)
	, unsigned __int64 _ImageBase
#endif
	)
{
	BaseClassDescriptor *pBCD, *pSourceBCD;
	BaseClassArray *pBaseClassArray = pCOLocator->pClassDescriptor->pBaseClassArray;
	unsigned long nCompleteObjectBases = pCOLocator->pClassDescriptor->numBaseClasses;
	unsigned long i, j;

	// Walk the BaseClassArray, which for single inheritance lists the complete
	// object and its base classes in order from most to least derived,
	// searching for the desired target type.

	for (i = 0; i < nCompleteObjectBases; i++)
	{
		pBCD = (BaseClassDescriptor*)(pBaseClassArray->arrayOfBaseClassDescriptors[i]);
		//pBCD = CHD_PBCD(BCA_BCDA(*pBaseClassArray)[i]);

		if( *pBCD->pTypeDescriptor == *pTargetTypeID )
		{
			// Single inheritance implies no ambiguous bases, so we know we've
			// found the desired target.  Now search base classes of the target
			// sub-object looking for the desired source type.  Since we've got
			// single inheritance, the target's base classes are simply the
			// remaining base classes in the complete object's hierarchy.

			for (j = i + 1; j < nCompleteObjectBases; j++)
			{
				pSourceBCD = (BaseClassDescriptor*)(pBaseClassArray->arrayOfBaseClassDescriptors[j]);// CHD_PBCD(BCA_BCDA(*pBaseClassArray)[j]);

				if( pSourceBCD->attributes & BCD_PRIVORPROTBASE)
				{
					// If we find any non-public derivation between the target
					// and source types, the cast fails.

					return nullptr;
				}

				if( *pSourceBCD->pTypeDescriptor == *pSrcTypeID )
				{
					// We found the accessible source instance, the down-cast
					// succeeds.

					return pBCD;
				}
			}

			// We did not find the source as a base of the target, which means
			// we do not have a down-cast.  Since we can't have cross-casts
			// with single inheritance, this was either a failed up-cast to a
			// non-public base (else the compiler would statically cast), or
			// a cast from a type not in the complete object's hierarachy (which
			// could happen if someone is playing games with reinterpret_cast).
			// In either case, the cast fails.

			return nullptr;
		}
	}

	// We never found the target type in the complete object's hierarchy, so
	// the cast fails.

	return nullptr;
}

//--------------------------------------------------------------------------------
__QCMP_LINKAGE_C void* __QCMP_CALLCON __RTDynamicCast(
	void* inptr,            // Pointer to polymorphic object
	long VfDelta,           // Offset of vfptr in object
	void* SrcType,          // Static type of object pointed to by inptr
	void* TargetType,       // Desired result of cast
	int isReference)       // TRUE if input is reference, FALSE if input is ptr
	throw(...)
{
	void* pResult = nullptr;
	BaseClassDescriptor *pBaseClass;

	if (inptr == nullptr)
	{
		return nullptr;
	}

	__try 
	{

		void* pCompleteObject = FindCompleteObject((void**)inptr);
		CompleteObjectLocator *pCompleteLocator = (CompleteObjectLocator *)((*((void***)inptr))[-1]);

#if defined(_WIN64) && !defined(_M_CEE_PURE)
		unsigned __int64 _ImageBase;
		if ( pCompleteLocator->signature == 1/*COL_SIG_REV0*/) 
		{
			_ImageBase = GetImageBase((void*)pCompleteLocator);
		}
		else 
		{
			_ImageBase = GetImageBase((void*)pCompleteLocator);
			//_ImageBase = ((unsigned __int64)pCompleteLocator - (unsigned __int64)COL_SELF(*pCompleteLocator));
		}
#endif

		// Adjust by vfptr displacement, if any
		inptr = (void**)((char *)inptr - VfDelta);

		// Calculate offset of source object in complete object
		ptrdiff_t inptr_delta = (char *)inptr - (char *)pCompleteObject;

		if (!( pCompleteLocator->pClassDescriptor->attributes & /*CHD_MULTINH*/ 0x00000001 ) )
		{
			// if not multiple inheritance
			pBaseClass = FindSITargetTypeInstance( pCompleteLocator, (TypeDescriptor *)SrcType, (TypeDescriptor *)TargetType
#if defined(_WIN64) && !defined(_M_CEE_PURE)
				, _ImageBase
#endif
				);
		}
		else if( !( pCompleteLocator->pClassDescriptor->attributes & /*CHD_VIRTINH*/0x00000002 ) ) 
		{
			// if multiple, but not virtual, inheritance
			pBaseClass = FindMITargetTypeInstance( pCompleteObject, pCompleteLocator, (TypeDescriptor *)SrcType, inptr_delta,
				(TypeDescriptor *)TargetType
#if defined(_WIN64) && !defined(_M_CEE_PURE)
				, _ImageBase
#endif
				);
		}
		else 
		{
			// if virtual inheritance
			pBaseClass = FindVITargetTypeInstance( pCompleteObject, pCompleteLocator, (TypeDescriptor *)SrcType,
				inptr_delta,
				(TypeDescriptor *)TargetType
#if defined(_WIN64) && !defined(_M_CEE_PURE)
				, _ImageBase
#endif
				);
		}

		if (pBaseClass != nullptr) 
		{
			// Calculate ptr to result base class from pBaseClass->where
			pResult = ((char *)pCompleteObject) + PMDtoOffset( pCompleteObject, pBaseClass->where );
		}
		else 
		{
			pResult = nullptr;
			if (isReference)
			{
				throw std::bad_cast();// __construct_from_string_literal("Bad dynamic_cast!");
			}
		}

	}
	__except( GetExceptionCode() ==  ((unsigned long)0xC0000005L) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )
	{
		pResult = nullptr;
		throw std::bad_cast();// __non_rtti_object::__construct_from_string_literal("Access violation - no RTTI data!");
	}

	return pResult;
}
