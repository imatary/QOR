//TLazy.h

// Copyright Querysoft Limited 2017
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef CODEQOR_DATASTRUCTS_TLAZY_H
#define CODEQOR_DATASTRUCTS_TLAZY_H

#include "CompilerQOR.h"

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "CodeQOR/Traits/MemoryTraits.h"
#include "CodeQOR/Traits/ReferenceTraits.h"
#include "CodeQOR/DataStructures/TRef.h"
#include "CodeQOR/DataStructures/TLRef.h"
#include "CodeQOR/DataStructures/TSyncRef.h"
#include <functional>

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
	//--------------------------------------------------------------------------------	
	template< class T, class P = CPolicy > class CTLazyAdaptor
	{

	public:

		typedef typename reference_type< T >::type ref;

		//--------------------------------------------------------------------------------
		CTLazyAdaptor() : m_p(), mp_f(nullptr)
		{
		}

		//--------------------------------------------------------------------------------
		CTLazyAdaptor(const std::function <T*()>& _f) : m_p(), mp_f( &_f)
		{
		}

		//--------------------------------------------------------------------------------
		CTLazyAdaptor(CTLazyAdaptor< T >&& Src)
		{
			m_p = Src.m_p;
			mp_f = Src.mp_f;
			Src.m_p = nullptr;
			Src.mp_f = nullptr;
		}

		//--------------------------------------------------------------------------------
		CTLazyAdaptor& operator = (CTLazyAdaptor< T >&& Src)
		{
			m_p = Src.m_p;
			mp_f = Src.mp_f;
			Src.m_p = nullptr;
			Src.mp_f = nullptr;
		}

		//--------------------------------------------------------------------------------
		~CTLazyAdaptor()
		{
			Free<ref>();
		}

		//--------------------------------------------------------------------------------
		bool IsNull(void) const
		{
			return m_p == nullptr;
		}

		//--------------------------------------------------------------------------------
		T& operator()(void)
		{
			Instance();
			return m_p();
		}

		//--------------------------------------------------------------------------------
		bool Configure(ref pConf, bool bConferOwnership = false)
		{
			bool bResult = false;
			if (m_p != nullptr)
			{
				Free<ref>();
			}
			if (pConf != nullptr)
			{
				m_p = pConf;
				bResult = true;
				m_bOwner = bConferOwnership;
			}
			return bResult;
		}

	private:

		//--------------------------------------------------------------------------------
		void Instance(void)
		{
			if (m_p.IsNull())
			{
				Allocate<ref>();
			}
		}

		//--------------------------------------------------------------------------------
		template< typename r_type >
		void Allocate(void)
		{
			m_bOwner = true;
		}

		//--------------------------------------------------------------------------------
		template<> 
		void Allocate< CTLRef< T > >(void)
		{
			m_bOwner = true;
			if (mp_f == nullptr)
			{
				m_p = CTLRef<T>(new (mem_traits< T >::CTAllocator::RawAllocate())T(), true);
			}
			else
			{
				m_p = CTLRef< T >((*mp_f)(), true);
			}
		}

		//--------------------------------------------------------------------------------
		template<>
		void Allocate< CTRef< T > >(void)
		{
			m_bOwner = true;
			m_p = (new CTCSharedRef<T>())->Ref();
		}

		//--------------------------------------------------------------------------------
		template< typename r_type >
		void Free( void )
		{
			m_bOwner = false;
		}

		//--------------------------------------------------------------------------------
		template<>
		void Free< CTLRef< T > >( void )
		{
			if (m_bOwner)
			{				
				m_p.Dispose();
				m_bOwner = false;
			}
		}

		//--------------------------------------------------------------------------------
		template<>
		void Free< CTRef< T > >( void )
		{
			if (m_bOwner)
			{				
				m_p.Dispose();
				m_bOwner = false;
			}
		}

		ref m_p;
		bool m_bOwner;
		const std::function <T*()>* mp_f;
	};

}//nsCodeQOR

#endif//CODEQOR_DATASTRUCTS_TLAZY_H
