//WinQLStreamDevice.h

// Copyright Querysoft Limited 2013, 2016
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef WINQL_FILESYSTEM_STREAMDEVICE_H_3
#define WINQL_FILESYSTEM_STREAMDEVICE_H_3

#include <stdio.h>
#include <errno.h>
#include "WinQL/WinQL.h"
#include "WinQL/Application/Threading/WinQLCriticalSection.h"
#include "WinQL/Application/Threading/WinQLSynchronization.h"
#include "WinQL/System/FileSystem/WinQLFile.h"
#include "WinQL/System/FileSystem/WinQLFile.h"
#include "WinQL/Application/Comms/IPC/Pipe/WinQLPipe.h"
#include "WinQL/Application/ErrorSystem/WinQLErrorHandling.h"
#include "WinQL/System/FileSystem/WinQLFileManagement.h"
#include "WinQL/System/FileSystem/WinQLIOBuffer.h"
#include "WinQL/Application/ErrorSystem/WinQLDOSError.h"

//------------------------------------------------------------------------------
namespace nsWin32
{
	//------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CStreamDevice
	{
		//Abstract base for StreamDevices

		//Open, Close, Read, Write

	public:

		//------------------------------------------------------------------------------
		CStreamDevice()
		{
		}

		//------------------------------------------------------------------------------
		virtual ~CStreamDevice()
		{
		}

		//------------------------------------------------------------------------------
		CStreamDevice( const CStreamDevice& src )
		{
		}

		//------------------------------------------------------------------------------
		CStreamDevice& operator = ( const CStreamDevice& src )
		{
			return *this;
		}

		//------------------------------------------------------------------------------
		virtual unsigned long Commit( void )
		{
			return 0;
		}

		//------------------------------------------------------------------------------
		virtual void Open( const wchar_t* path, unsigned long fileaccess, unsigned long fileshare, SECURITY_ATTRIBUTES* lpSecurityAttributes, unsigned long filecreate, unsigned long fileattrib, unsigned long fileflags )
		{			
		}

		//------------------------------------------------------------------------------
		virtual int Close( void )
		{
			return 0;
		}

		//------------------------------------------------------------------------------
		virtual Cmp__int64 Tell()
		{
			return 0;
		}

		//------------------------------------------------------------------------------
		virtual Cmp__int64 Seek( Cmp__int64 pos, int mthd )
		{
			return 0;
		}

		//------------------------------------------------------------------------------
		virtual bool SetEndOfFile( void )
		{
			return false;
		}

		//------------------------------------------------------------------------------
		virtual bool Read( void* lpBuffer, unsigned int uiNumberOfBytesToRead, unsigned long* pulBytesRead, nsWin32::LPOVERLAPPED lpOverlapped )
		{
			return false;
		}

		//------------------------------------------------------------------------------
		virtual unsigned long Write( const byte* Buffer, unsigned int uiByteCount, unsigned long& ulDOSRetVal )
		{
			return 0;
		}

		//------------------------------------------------------------------------------
		virtual bool Write( const void* lpBuffer, unsigned long nNumberOfBytesToWrite, unsigned long* lpNumberOfBytesWritten, nsWin32::LPOVERLAPPED lpOverlapped )
		{
			return false;
		}

		//------------------------------------------------------------------------------
		virtual unsigned long GetType( void )
		{
			return File_Type_Unknown;
		}
		/*
		static CStreamDevice* Create( const char* lpFileName, unsigned long& dwDesiredAccess, unsigned long dwShareMode, nsWin32::LPSECURITY_ATTRIBUTES lpSecurityAttributes, unsigned long dwCreationDisposition, unsigned long dwFlagsAndAttributes, void* hTemplateFile );

		static CDeviceFile* Create( const wchar_t* lpFileName, unsigned long& dwDesiredAccess, unsigned long dwShareMode, nsWin32::LPSECURITY_ATTRIBUTES lpSecurityAttributes, unsigned long dwCreationDisposition, unsigned long dwFlagsAndAttributes, void* hTemplateFile )
		{
			CDeviceFile* pDeviceFile = 0;
			CErrorHelper ErrorHelper;

			CDeviceHandle Handle = CKernel32::CreateFileW( lpFileName, dwDesiredAccess, dwShareMode, reinterpret_cast< ::LPSECURITY_ATTRIBUTES >( lpSecurityAttributes ), dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile );

			if( Handle.IsInvalid() )
			{
				if( ( dwDesiredAccess & ( Generic_Read | Generic_Write ) ) == ( Generic_Read | Generic_Write ) && ( oflag & OWriteOnly ) )
				{
					//We just failed on CreateFile(), because we might be trying open something for read while it cannot be read (eg. pipes or devices).
					//So try again with GENERIC_WRITE and we will have to use the default encoding.  We won't be able to determine the encoding from reading the BOM.

					dwDesiredAccess &= ~Generic_Read;
					Handle = CKernel32::CreateFileW( lpFileName, dwDesiredAccess, dwShareMode, reinterpret_cast<::LPSECURITY_ATTRIBUTES>( lpSecurityAttributes ), dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile );
					if( Handle.IsInvalid() )
					{
						return pDeviceFile;
					}
				}
				else
				{
					return pDeviceFile;
				}
			}
			
			switch( CKernel32::GetFileType( Handle.Use() ) )
			{
			case File_Type_Unknown:
			{
				unsigned long dwLastError = ErrorHelper.GetLastError();
				if( dwLastError == Success )
				{
					pDeviceFile = new CDeviceFile( Handle );
				}
				break;
			}
			case File_Type_Char:
				pDeviceFile = new CDeviceFile( Handle );
				break;
			case File_Type_Pipe:
				pDeviceFile = new CPipe( Handle );
				break;
			case File_Type_Disk:
				pDeviceFile = new CFile( Handle );
				break;
			default:
				pDeviceFile = new CDeviceFile( Handle );
				break;
			}
			return pDeviceFile;
		}
		*/
	};


	//------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CStreamFile : public CStreamDevice
	{
		//Open, Close, Read, Write, Seek, Tell, Commit, EOF
	public:

		__QCMP_STATIC_CONSTANT( int, m_scuiByteCountOfTranslationBuffer = 1025 );				// size of LF translation buffer

		__QCMP_STATIC_CONSTANT( unsigned char, LF = 10 );					// line feed
		__QCMP_STATIC_CONSTANT( unsigned char, CR = 13 );					// carriage return
		__QCMP_STATIC_CONSTANT( unsigned char, CTRLZ = 26 );					// ctrl-z means eof for text

		CStreamFile();
		virtual ~CStreamFile();
		CStreamFile( const CStreamFile& );
		CStreamFile& operator = ( const CStreamFile& );

		//------------------------------------------------------------------------------
		unsigned long Commit( void )
		{
			unsigned long ulResult = 0;
			if( !m_pFile->FlushBuffers() )
			{
				ulResult = m_ErrorHelper.GetLastError();
			}
			return ulResult;
		}

		//------------------------------------------------------------------------------
		void Open( const wchar_t* path, unsigned long fileaccess, unsigned long fileshare, SECURITY_ATTRIBUTES* lpSecurityAttributes, unsigned long filecreate, unsigned long fileattrib, unsigned long fileflags )
		{
			m_pFile = new CFile( path, fileaccess, fileshare, lpSecurityAttributes, filecreate, fileattrib | fileflags, 0 );
		}

		//------------------------------------------------------------------------------
		int Close( void )
		{
			delete m_pFile;
			m_pFile = 0;
			CDOSError::MapError( m_ErrorHelper.GetLastError() );
			return 0;
		}

		//------------------------------------------------------------------------------
		Cmp__int64 Tell()
		{
			return Seek( 0, File_Current );
		}

		//------------------------------------------------------------------------------
		Cmp__int64 Seek( Cmp__int64 pos, int mthd )
		{
			LARGE_INTEGER newpos;       // new file position

			if( !m_pFile || m_pFile->Handle()->IsInvalid() )
			{
				errno = EBADF;
				//_ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
				return( -1i64 );
			}


			if( !m_pFile->SetPointerEx( *(LARGE_INTEGER*)&pos, &newpos, mthd ) )
			{
				CDOSError::MapError( m_ErrorHelper.GetLastError() );
				return( -1i64 );
			}

			return( newpos.QuadPart );		// return
		}

		//------------------------------------------------------------------------------
		bool SetEndOfFile( void )
		{
			return m_pFile->SetEOF();
		}

		//------------------------------------------------------------------------------
		unsigned long Write( const byte* Buffer, unsigned int uiByteCount, unsigned long& ulDOSRetVal )
		{
			unsigned long ulWritten = 0;

			// binary mode, no translation
			if( m_pFile->Write( Buffer, uiByteCount, &ulWritten, 0 ) )
			{
				ulDOSRetVal = 0;
			}
			else
			{
				ulDOSRetVal = m_ErrorHelper.GetLastError();
			}
			return ulWritten;
		}

		//------------------------------------------------------------------------------
		unsigned long WriteTextANSI( const byte* Buffer, unsigned int uiByteCount, unsigned long& ulDOSRetVal )
		{
			int lfcount = 0;								// count of line feeds
			unsigned long ulByteCount = 0;
			unsigned long ulWritten = 0;
			char ch;                    // current character
			char* p = nullptr, *q = nullptr;  // pointers into buf and lfbuf resp.
			char lfbuf[ m_scuiByteCountOfTranslationBuffer ];
			p = (char *)Buffer;        // start at beginning of buffer
			while( (unsigned)( p - (char *)Buffer ) < uiByteCount )
			{
				q = lfbuf;      // start at beginning of lfbuf 

								// fill the lf buf, except maybe last char
				while( q - lfbuf < sizeof( lfbuf ) - 1 && (unsigned)( p - (char *)Buffer ) < uiByteCount )
				{
					ch = *p++;
					if( ch == LF )
					{
						++lfcount;
						*q++ = CR;
					}
					*q++ = ch;
				}

				// write the lf buf and update total
				if( m_pFile->Write( lfbuf, (int)( q - lfbuf ), reinterpret_cast<unsigned long*>( &ulWritten ), 0 ) )
				{
					ulByteCount += ulWritten;
					if( ulWritten < (unsigned long)(q - lfbuf) )
					{
						break;
					}
				}
				else
				{
					ulDOSRetVal = m_ErrorHelper.GetLastError();
					break;
				}
			}
			return ulByteCount;
		}

		//------------------------------------------------------------------------------
		unsigned long WriteTextUTF16( const byte* Buffer, unsigned int uiByteCount, unsigned long& ulDOSRetVal )
		{
			int lfcount = 0;								// count of line feeds
			unsigned long ulByteCount = 0;
			unsigned long ulWritten = 0;
			char lfbuf[ m_scuiByteCountOfTranslationBuffer ];
			wchar_t wch;            // current wide char
			wchar_t *pu = (wchar_t *)Buffer;
			wchar_t *qu = NULL;

			while( (unsigned)( (char *)pu - (char *)Buffer ) < uiByteCount )
			{
				qu = (wchar_t *)lfbuf; // start at beginning of lfbuf

									   // fill the lf buf, except maybe last wchar_t
				while( ( ( (char *)qu - lfbuf ) < ( sizeof( lfbuf ) - 2 ) ) && ( (unsigned)( (char *)pu - (char *)Buffer ) < uiByteCount ) )
				{
					wch = *pu++;
					if( wch == LF )
					{
						lfcount += 2;
						*qu++ = CR;
					}
					*qu++ = wch;
				}

				// write the lf buf and update total
				if( m_pFile->Write( lfbuf, (int)( (char*)qu - lfbuf ), reinterpret_cast<unsigned long*>( &ulWritten ), 0 ) )
				{
					ulByteCount += ulWritten;
					if( ulWritten < (unsigned long)( (char *)qu - lfbuf ) )
					{
						break;
					}
				}
				else
				{
					ulDOSRetVal = m_ErrorHelper.GetLastError();
					break;
				}
			}
			return ulByteCount;
		}

		//------------------------------------------------------------------------------
		unsigned long WriteTextUTF8( const byte* Buffer, unsigned int uiByteCount, unsigned long& ulDOSRetVal )
		{
			unsigned long ulByteCount = 0;
			unsigned long ulWritten = 0;

			char utf8_buf[ ( m_scuiByteCountOfTranslationBuffer * 2 ) / 3 ];
			wchar_t utf16_buf[ m_scuiByteCountOfTranslationBuffer / 6 ];

			wchar_t wch;            // current wide char
			wchar_t* pu = (wchar_t*)Buffer;
			wchar_t* qu = nullptr;

			pu = (wchar_t *)Buffer;
			while( (unsigned)( (char *)pu - (char *)Buffer ) < uiByteCount )
			{
				int bytes_converted = 0;
				qu = utf16_buf; // start at beginning of lfbuf

				while( ( ( (char *)qu - (char *)utf16_buf ) < ( sizeof( utf16_buf ) - 2 ) ) && ( (unsigned)( (char *)pu - (char *)Buffer ) < uiByteCount ) )
				{
					wch = *pu++;
					if( wch == LF )
					{
						// no need to count the linefeeds here: we calculate the written chars in another way
						*qu++ = CR;
					}
					*qu++ = wch;
				}

				bytes_converted = m_StringHelper.WideCharToMultiByte( CCodePage::UTF8, 0, utf16_buf, ( (int)( (char *)qu - (char *)utf16_buf ) ) / 2, utf8_buf, sizeof( utf8_buf ), 0, 0 );

				if( bytes_converted == 0 )
				{
					ulDOSRetVal = m_ErrorHelper.GetLastError();
					break;
				}
				else
				{
					// Here we need to make every attempt to write all the converted characters. 
					//The resaon behind this is incase half the bytes of a UTF8 character is written, it may currupt whole of the stream or file.
					// The loop below will make sure we exit only if all the bytes converted are written (which makes sure no partial MBCS is written) or there was some error in the stream.
					int bytes_written = 0;
					do
					{
						if( m_pFile->Write( utf8_buf + bytes_written, bytes_converted - bytes_written, reinterpret_cast<unsigned long*>( &ulWritten ), 0 ) )
						{
							bytes_written += ulWritten;
						}
						else
						{
							ulDOSRetVal = m_ErrorHelper.GetLastError();
							break;
						}
					} while( bytes_converted > bytes_written );

					// Only way the condition below could be true is if there was en error. 
					//In case of error we need to break this loop as well.

					if( bytes_converted > bytes_written )
					{
						break;
					}
					// if this chunk has been committed successfully, update charcount
					ulByteCount = (unsigned long)( (char *)pu - (char *)Buffer );
				}
			}
			return ulByteCount;
		}

		//------------------------------------------------------------------------------
		unsigned long GetType( void )
		{
			return m_pFile->GetType();
		}

	private:

		CFile* m_pFile;					//WinQL layer file object
		CErrorHelper m_ErrorHelper;		//WinQL Error helper
		CStringHelper m_StringHelper;	//WinQL string and character conversion helper
										//CFileHelper m_FileHelper;		//WinQL File system helper

	};

}//nsWin32

#endif//WINQL_FILESYSTEM_STREAMDEVICE_H_3
