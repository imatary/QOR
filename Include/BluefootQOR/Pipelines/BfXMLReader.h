//BfXMLReader.h

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef BLUEFOOT_PIPELINES_XMLREADER_H_3
#define BLUEFOOT_PIPELINES_XMLREADER_H_3

//Defines a Bluefoot XML reader pipeline

#include "BluefootQOR/PipeLines/BfTextReader.h"
#include "BluefootQOR/XML/SAX/BfXmlEntityResolver.h"
#include "BluefootQOR/XML/SAX/BfXmlDTDHandler.h"
#include "BluefootQOR/XML/SAX/BfXmlContentHandler.h"
#include "BluefootQOR/XML/SAX/BfXmlErrorHandler.h"
#include "BluefootQOR/XML/SAX/BfXmlLexicalHandler.h"
#include "BluefootQOR/XML/SAX/BfXmlDeclHandler.h"
#include "BluefootQOR/XML/SAX/BfXmlLocator.h"
#include "BluefootQOR/XML/SAX/BfXmlParseException.h"
#include "BluefootQOR/XML/SAX/BfXmlAttributes.h"
#include "BluefootQOR/XML/SAX/BfXmlNamespaceSupport.h"

#include <stack>
#include <map>

//------------------------------------------------------------------------------
namespace nsBluefoot
{
	//------------------------------------------------------------------------------
	class __QOR_INTERFACE( __BLUEFOOTQOR ) CXMLReader : public CTextReader
	{
	public:

		typedef nsCodeQOR::CUCS2String CXMLString;

		__QOR_DECLARE_OCLASS_ID( CXMLReader );

		CXMLReader( CSource* pSource );
		virtual ~CXMLReader();
		CXMLReader(const CXMLReader& src);
		CXMLReader& operator = (const CXMLReader& src);

		virtual void Run( void );

		virtual bool Feature( const CXMLString& name, bool *ok = 0 ) const;
		virtual void SetFeature( const CXMLString& name, bool value );
		virtual bool HasFeature( const CXMLString& name ) const;

		virtual void* Property( const CXMLString& name, bool *ok = 0 ) const;
		virtual void SetProperty( const CXMLString& name, void* value );
		virtual bool HasProperty( const CXMLString& name ) const;

		virtual bool Parse( bool incremental = false );
		virtual bool ParseContinue();

		nsCodeQOR::CSTMember< CXmlEntityResolver > EntityResolver;
		nsCodeQOR::CSTMember< CXmlDTDHandler > DTDHandler;
		nsCodeQOR::CSTMember< CXmlContentHandler > ContentHandler;
		nsCodeQOR::CSTMember< CXmlErrorHandler > ErrorHandler;
		nsCodeQOR::CSTMember< CXmlLexicalHandler > LexicalHandler;
		nsCodeQOR::CSTMember< CXmlDeclHandler > DeclHandler;

		__QCMP_STATIC_CONSTANT( unsigned short, EndOfData		= 0xFFFE );
		__QCMP_STATIC_CONSTANT( unsigned short, EndOfDocument	= 0xFFFF );

		//------------------------------------------------------------------------------
		enum NameChar 
		{ 
			NameBeginning, 
			NameNotBeginning, 
			NotName 
		};

	private:

		//------------------------------------------------------------------------------
		// used for standalone declaration
		enum Standalone 
		{ 
			Yes, 
			No, 
			Unknown 
		};

		std::stack< CXMLString > m_Tags;

		// flags for features support
		bool m_bUseNamespaces;
		bool m_bUseNamespacePrefixes;
		bool m_bReportWhitespaceCharData;
		bool m_bReportEntities;
		
		CXMLString m_Doctype; // only used for the doctype
		CXMLString m_XmlVersion; // only used to store the version information
		CXMLString m_Encoding; // only used to store the encoding
		Standalone m_Standalone; // used to store the value of the standalone declaration

		CXMLString m_PublicId; // used by parseExternalID() to store the public ID
		CXMLString m_SystemId; // used by parseExternalID() to store the system ID
		
		bool m_bStartDTDwasReported; // used in parseDoctype()
				
		signed char m_Done; // used in parseString()

		// error string
		CXMLString m_Error;

		//------------------------------------------------------------------------------
		struct ParseState // for incremental parsing
		{
			typedef bool (CXMLReader::*ParseFunction)();
			ParseFunction m_Function;
			int m_iState;
		};

		std::stack< ParseState >* m_pParseStack;

		//------------------------------------------------------------------------------
		// used by parseReference() and parsePEReference()
		enum EntityRecognitionContext 
		{ 
			InContent, 
			InAttributeValue, 
			InEntityValue, 
			InDTD 
		};

		typedef bool( CXMLReader::*ParseFunction ) ();

		//------------------------------------------------------------------------------
		// used for entity declarations
		struct ExternParameterEntity
		{
			ExternParameterEntity() {}
			ExternParameterEntity( const CXMLString& p, const CXMLString& s ) : m_PublicId(p), m_SystemId(s) {}

			CXMLString m_PublicId;
			CXMLString m_SystemId;

		    bool operator == ( const ExternParameterEntity& ) const 
			{
				//qWarning("ExternParameterEntity::operator==(const ExternParameterEntity&) was called");
				return false;
			}
		};

		//------------------------------------------------------------------------------
		struct ExternEntity
		{
			ExternEntity() {}
			ExternEntity( const CXMLString& p, const CXMLString& s, const CXMLString& n) : m_PublicId(p), m_SystemId(s), m_Notation(n) {}

			CXMLString m_PublicId;
			CXMLString m_SystemId;
			CXMLString m_Notation;

			bool operator == ( const ExternEntity& ) const 
			{
				//qWarning("ExternEntity::operator==(const ExternEntity&) was called");
				return false;
			}
		};

		//------------------------------------------------------------------------------
		// used for parsing of entity references
		struct XmlRef 
		{
			XmlRef() : m_Index(0) {}
			XmlRef( const CXMLString& _name, const CXMLString& _value ) : m_Name( _name ), m_Value( _value ), m_Index(0) {}
			
			//------------------------------------------------------------------------------
			bool isEmpty() const 
			{ 
				return m_Index == m_Value.Len(); 
			}
			
			//------------------------------------------------------------------------------
			CXMLString::char_type next() 
			{ 
				return m_Value.At(static_cast< unsigned short >( m_Index++ )); 
			}

			CXMLString m_Name;
			CXMLString m_Value;
			int m_Index;
		};

		std::stack< XmlRef > m_XmlRefStack;

		std::map< const CXMLString, ExternParameterEntity > m_ExternParameterEntities;
		std::map< const CXMLString, CXMLString > m_ParameterEntities;
		std::map< const CXMLString, ExternEntity > m_ExternEntities;
		std::map< const CXMLString, CXMLString > m_Entities;

		// arguments for parse functions (this is needed to allow incremental parsing)
		bool m_bParsePI_xmldecl;
		bool m_bParseName_useRef;
		bool m_bParseReference_charDataRead;
		EntityRecognitionContext m_ParseReference_context;
		bool m_bParseExternalID_allowPublicID;
		EntityRecognitionContext m_ParsePEReference_context;
		CXMLString m_ParseString_s;

		CXMLString thisPublicId;
		CXMLString thisSystemId;

		CXMLString::char_type m_StringArray[256]; // used for any other strings that are parsed
		CXMLString m_StringValue; // used for any other strings that are parsed
		int     m_iStringArrayPos;
		int     m_iStringValueLen;
		CXMLString m_EmptyStr;

		CXMLString::char_type   m_NameArray[256]; // only used for names
		CXMLString m_NameValue; // only used for names
		int     m_iNameArrayPos;
		int     m_iNameValueLen;

		CXMLString::char_type   m_RefArray[256]; // only used for references
		CXMLString m_RefValue; // only used for references
		int     m_iRefArrayPos;
		int     m_iRefValueLen;

		CXMLString m_AttDeclEName; // use by parseAttlistDecl()
		CXMLString m_AttDeclAName; // use by parseAttlistDecl()

		bool m_bSkippedEntityInContent;

		CXmlNamespaceSupport m_NamespaceSupport;
		
		CXmlAttributes m_AttList;	// used to build the attribute list

		// used in parseProlog()
		bool m_bXmldecl_possible;
		bool m_bDoctype_read;

		// used in ParseContent() to decide whether character data was read
		bool m_bContentCharDataRead;


		int	m_iLineNr; // number of line
		int	m_iColumnNr; // position in line

		nsCodeQOR::CTLRef< CXmlLocator > m_Locator;

		CXMLString::char_type m_C; // the character at reading position

		friend class CBFXMLReaderLocator;

		void InitIncrementalParsing( void );
		void Init( void );
		void InitData( void );
		void Next( void );
		CXMLString::char_type NextChar( void );
		void ReportParseError( const CXMLString& Error );
		bool ParseBeginOrContinue( int iState, bool bIncremental );
		bool ParseProlog( void );
		bool ParseElement( void );
		bool ParseMisc( void );
		bool ParseDoctype( void );
		bool ParseComment( void );
		bool ParsePI( void );
		bool ProcessElementETagBegin2( void );
		bool ProcessElementAttribute( void );
		bool ParseName( void );
		bool ParseContent( void );
		bool ProcessElementEmptyTag( void );
		bool ParseAttribute( void );
		bool ParseString( void );
		bool ParseExternalID( void );
		bool ParsePEReference( void );
		bool ParseMarkupdecl( void );
		bool ReportEndEntities( void );
		bool ParseReference( void );
		bool ParseAttValue( void );
		bool ParseAttlistDecl( void );
		bool ParseElementDecl( void );
		bool ParseEntityDecl( void );
		bool ParseNotationDecl( void );
		bool ProcessReference( void );
		bool ParseAttType( void );
		bool ParseChoiceSeq( void );
		bool ParseEntityValue( void );
		bool ParseNmtoken( void );

		bool EntityExist( const CXMLString& e) const;
		void UnexpectedEof( ParseFunction where, int state );
		void ParseFailed( ParseFunction where, int state );
		bool InsertXmlRef( const CXMLString& data, const CXMLString& name, bool inLiteral );

		const CXMLString& string( void );
		const CXMLString& name( void );

		//------------------------------------------------------------------------------
		const CXMLString& Ref( void )
		{
			UpdateValue( m_RefValue, m_RefArray, m_iRefArrayPos, m_iRefValueLen );
			return m_RefValue;
		}

		//------------------------------------------------------------------------------
		inline bool atEnd()
		{
			return (m_C.Unicode()|0x0001) == 0xffff;
		}

		//------------------------------------------------------------------------------
		//This private function pushes the function pointer and state to the parse stack. This is used when you are doing an incremental parsing and reach the end of file too early.
		// Only call this function when d->parseStack!=0.
		void PushParseState( ParseFunction function, int state )
		{
			ParseState ps;
			ps.m_Function = function;
			ps.m_iState = state;
			m_pParseStack->push( ps );
		}

		//------------------------------------------------------------------------------
		/*This private function moves the cursor to the next non-whitespace character.
		  This function does not move the cursor if the actual cursor position is a
		  non-whitespace charcter.

		  Returns false when you use incremental parsing and this function reaches EOF
		  with reading only whitespace characters. In this case it also poplulates the
		  parseStack with useful information. In all other cases, this function returns
		  true.*/
		__QCMP_INLINE bool eat_ws()
		{
			while (!atEnd()) 
			{
				if (!m_C.IsSpace() ) 
				{
					return true;
				}
				Next();
			}

			if ( m_pParseStack != 0) 
			{
				UnexpectedEof(&CXMLReader::eat_ws, 0);
				return false;
			}
			return true;
		}

		//------------------------------------------------------------------------------
		__QCMP_INLINE bool next_eat_ws()
		{
			Next();
			return eat_ws();
		}

		//------------------------------------------------------------------------------
		__QCMP_INLINE void StringAddC( CXMLReader::CXMLString::char_type ch )
		{
			if( m_iStringArrayPos == 256 )
			{
				UpdateValue( m_StringValue, m_StringArray, m_iStringArrayPos, m_iStringValueLen );
			}
			m_StringArray[ m_iStringArrayPos++ ] = ch;
		}

		//------------------------------------------------------------------------------
		__QCMP_INLINE void StringAddC( void ) 
		{ 
			StringAddC( m_C ); 
		}

		//------------------------------------------------------------------------------
		__QCMP_INLINE void RefAddC( CXMLString::char_type ch )
		{
			if( m_iRefArrayPos == 256 )
			{
				UpdateValue( m_RefValue, m_RefArray, m_iRefArrayPos, m_iRefValueLen );
			}
			m_RefArray[ m_iRefArrayPos++ ] = ch;
		}

		//------------------------------------------------------------------------------
		__QCMP_INLINE void RefAddC( void ) 
		{ 
			RefAddC( m_C ); 
		}

		//------------------------------------------------------------------------------
		__QCMP_INLINE void NameAddC( CXMLString::char_type ch )
		{
			if( m_iNameArrayPos == 256 )
			{
				UpdateValue( m_NameValue, m_NameArray, m_iNameArrayPos, m_iNameValueLen );
			}
			m_NameArray[ m_iNameArrayPos++ ] = ch;
		}

		//------------------------------------------------------------------------------
		__QCMP_INLINE void NameAddC( void )
		{
			NameAddC( m_C );
		}

		//------------------------------------------------------------------------------
		__QCMP_INLINE void StringClear()
		{
			m_iStringValueLen = 0; m_iStringArrayPos = 0;
		}

		//------------------------------------------------------------------------------
		__QCMP_INLINE void NameClear()
		{
			m_iNameValueLen = 0; m_iNameArrayPos = 0;
		}

		//------------------------------------------------------------------------------
		__QCMP_INLINE void RefClear()
		{
			m_iRefValueLen = 0; m_iRefArrayPos = 0;
		}

		//------------------------------------------------------------------------------
		__QCMP_INLINE static void UpdateValue( CXMLString& value, const CXMLString::char_type* array, int& arrayPos, int& valueLen )
		{
			memcpy( value.GetBufferSetLength( static_cast< unsigned short >( valueLen + arrayPos ) ) + valueLen, array, arrayPos * sizeof( CXMLString::char_type ) );
			valueLen += arrayPos;
			value.ValidateBuffer( static_cast< unsigned short >( valueLen ) );
			arrayPos = 0;
		}

	};


	//------------------------------------------------------------------------------
	class CBFXMLReaderLocator : public CXmlLocator
	{

	public:

		__QOR_DECLARE_OCLASS_ID( CBFXMLReaderLocator );

		CBFXMLReaderLocator( CXMLReader* pParent );
		virtual ~CBFXMLReaderLocator();

		int ColumnNumber() const;
		int LineNumber() const;

	private:

		CXMLReader* m_pReader;

		CBFXMLReaderLocator();
	};

}//nsBluefoot

#endif//BLUEFOOT_PIPELINES_XMLREADER_H_3
