//BfSocketInterface.h

// Copyright Querysoft Limited 2016
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//An Abstract Socket Interface

#ifndef BLUEFOOT_SOCKETINTERFACE_H_3
#define BLUEFOOT_SOCKETINTERFACE_H_3

#include "CompilerQOR.h"
#include "AppocritaQOR/Event.h"

//------------------------------------------------------------------------------
//Forward declare the ISocket class and its reference type
__QOR_DECLARE_REF(nsBluefoot, __BLUEFOOTQOR, ISocket, CTRef);

//------------------------------------------------------------------------------
namespace nsBluefoot
{
	//------------------------------------------------------------------------------
	class __QOR_INTERFACE(__BLUEFOOTQOR) CSocketWriteError_Event : public nsQOR::CEvent
	{
	public:
		CSocketWriteError_Event() : nsQOR::CEvent(*TheApplication()) {}
	};

	//------------------------------------------------------------------------------
	class __QOR_INTERFACE(__BLUEFOOTQOR) CSocketWriteSuccess_Event : public nsQOR::CEvent
	{
	public:
		CSocketWriteSuccess_Event() : nsQOR::CEvent(*TheApplication()) {}
	};

	//------------------------------------------------------------------------------
	class __QOR_INTERFACE(__BLUEFOOTQOR) ISocket
	{
	public:

		//--------------------------------------------------------------------------------
		enum eType
		{
			Sock_Stream = 1,
			Sock_DGram,
			Sock_Raw,
			Sock_ReliablyDeliveredMessage,
			Sock_SeqPacket,
		};

		//--------------------------------------------------------------------------------
		enum eAddressFamily
		{
			AF_Unspecified = 0,			// unspecified
			AF_Unix = 1,				// local to host (pipes, portals)
			AF_INet = 2,				// internetwork: UDP, TCP, etc.
			AF_ImpLink = 3,             // arpanet imp addresses
			AF_Pup = 4,					// pup protocols: e.g. BSP
			AF_Chaos = 5,               // mit CHAOS protocols
			AF_Ns = 6,					// XEROX NS protocols
			AF_Ipx = AF_Ns,				// IPX protocols: IPX, SPX, etc.
			AF_Iso = 7,					// ISO protocols
			AF_Osi = AF_Iso,			// OSI is ISO
			AF_Ecma = 8,				// European computer manufacturers
			AF_DataKit = 9,             // datakit protocols
			AF_Ccitt = 10,              // CCITT protocols, X.25 etc
			AF_Sna = 11,				// IBM SNA
			AF_DecNet = 12,             // DECnet
			AF_Dli = 13,				// Direct data link interface
			AF_Lat = 14,				// LAT
			AF_HYLink = 15,             // NSC Hyperchannel
			AF_AppleTalk = 16,          // AppleTalk
			AF_NetBIOS = 17,            // NetBios-style addresses
			AF_VoiceView = 18,          // VoiceView
			AF_FireFox = 19,            // Protocols from Firefox
			AF_Unknown1 = 20,           // Somebody is using this!
			AF_Ban = 21,				// Banyan
			AF_Atm = 22,				// Native ATM Services
			AF_INet6 = 23,              // Internetwork Version 6
			AF_Cluster = 24,            // Microsoft Wolfpack
			AF_1284_4 = 25,              // IEEE 1284.4 WG AF
			AF_Irda = 26,				// IrDA
			AF_NetDes = 28,             // Network Designers OSI & gateway
			AF_TcnProcess = 29,
			AF_TcnMessage = 30,
			AF_IclFxbm = 31,
			AF_Bth = 32,				// Bluetooth RFCOMM/L2CAP protocols
			AF_Link = 33,
			AF_Max = 34,
		};

		//--------------------------------------------------------------------------------
		enum eProtocol
		{
			IPProto_IP = 0,					// dummy for IP 
			IPProto_ICMP = 1,				// control message protocol 
			IPProto_IGMP = 2,				// group management protocol
			IPProto_GGP = 3,				// gateway^2 (deprecated) 
			BTHProto_RFCOMM = 3,			// Bluetooth RFCOMM protocol
			IPProto_TCP = 6,				// tcp 
			IPProto_PUP = 12,				// pup 
			IPProto_UDP = 17,				// user datagram protocol 
			IPProto_IDP = 22,				// xns idp 
			IPProto_ND = 77,				// UNOFFICIAL net disk proto 
			IPProto_RAW = 255,				// raw IP packet 
			IPProto_MAX = 256,
		};
#pragma pack(push,1)
		//--------------------------------------------------------------------------------		
		class __QOR_INTERFACE(__BLUEFOOTQOR) Address
		{
		public:

			static const int byte_size = 30;

			Address();
			Address(unsigned short AddressFamily);

			unsigned short sa_family;

			union
			{
				char sa_data[byte_size];

				struct
				{
					Cmp_unsigned__int64		btAddr;         // Bluetooth device address
					nsCodeQOR::GUID			serviceClassId; // [OPTIONAL] system will query SDP for port
					unsigned long			port;           // RFCOMM channel or L2CAP PSM
				}BluetoothAddress;

				struct
				{
					unsigned char  irdaDeviceID[4];
					char	irdaServiceName[25];
				}IrDaAddress;

				struct
				{
					unsigned short sin_port;
					struct
					{
						union
						{
							struct
							{
								unsigned char s_b1, s_b2, s_b3, s_b4;
							} S_un_b;
							struct
							{
								unsigned short s_w1, s_w2;
							} S_un_w;
							unsigned long S_addr;
						} S_un;
					}sin_addr;
					char sin_zero[8];
				}IPAddress;
			}data;
		};

#pragma pack( pop )

		__QOR_DECLARE_REF_TYPE(ISocket);
		__QOR_DECLARE_OCLASS_ID(ISocket);

		ISocket() {};
		virtual ~ISocket() {};
		ISocket(const ISocket& src) { *this = src; }
		ISocket& operator = (const ISocket& src) { return *this; }

		virtual void Create(eAddressFamily AF, eType Type, eProtocol Protocol) = 0;
		virtual int Bind(const Address& Address) = 0;
		virtual int Listen(int iBacklog) = 0;
		virtual ISocket::ref_type Accept(Address& Address) = 0;
		virtual int Connect(const Address& Address) = 0;
		virtual int GetPeerName(Address& Address) = 0;
		virtual int GetSockName(Address& Address) = 0;
		virtual int GetSockOpt(int iLevel, int iOptName, char* pOptVal, int* pOptLen) = 0;
		virtual int SetSockOpt(int iLevel, int iOptName, const char* pOptVal, int iOptLen) = 0;
		virtual int AsyncReceive(char* pBuffer, int iLen, void* pSyncObject) = 0;
		virtual int Receive(char* buf, int len, int flags) = 0;
		virtual int ReceiveFrom(char* Buffer, int iLen, int iFlags, Address& From) = 0;
		virtual int AsyncSend(char* Buffer, int iLen, void* pSyncObject) = 0;
		virtual int Send(const char* Buffer, int iLen) = 0;
		virtual int SendTo(const char* Buffer, int iLen, int iFlags, const Address& To) = 0;
		virtual int Shutdown(int iHow) = 0;
		virtual Cmp_uint_ptr ID(void) = 0;
		virtual  int GetLastError(void) = 0;

	protected:

	};

}//nsBluefoot

#endif//BLUEFOOT_SOCKETINTERFACE_H_3
