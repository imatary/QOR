//WinQLSetLoc.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <errno.h>
#include "SystemQOR/System.h"
#include "WinQL/Application/ErrorSystem/WinQLErrorHandling.h"
#include "WinQL/Application/Threading/WinQLThread.h"
#include "WinQL/CodeServices/Locale/WinQLSetLoc.h"
#include "WinQL/CodeServices/Locale/WinQLLocale.h"
#include "WinQL/System/WinQLSystem.h"
#include "WinQL/CodeServices/Locale/WinQLLocaleUpdate.h"

namespace nsWin32
{	

	//--------------------------------------------------------------------------------
	//  unsigned short's of locales of nondefault languages
	const unsigned short CSetLoc::s_aLangIdNotDefault[] =
	{
		MakeLangID( Lang_French, Sublang_FRENCH_CANADIAN ),
		MakeLangID( Lang_Serbian, Sublang_SERBIAN_CYRILLIC ),
		MakeLangID( Lang_German, Sublang_GERMAN_LUXEMBOURG ),
		MakeLangID( Lang_Afrikaans, Sublang_Default ),
		MakeLangID( Lang_French, Sublang_FRENCH_BELGIAN ),
		MakeLangID( Lang_Basque, Sublang_Default ),
		MakeLangID( Lang_Catalan, Sublang_Default ),
		MakeLangID( Lang_French, Sublang_FRENCH_SWISS ),
		MakeLangID( Lang_Italian, Sublang_ITALIAN_SWISS ),
		MakeLangID( Lang_Swedish, Sublang_SWEDISH_FINLAND )
	};

	CLocaleHelper CSetLoc::s_LocaleHelper;

	//--------------------------------------------------------------------------------
	void CSetLoc::GetLcidFromLangCountry()
	{
		//  initialize static variables for callback use
		m_bAbbrevLanguage = strlen( m_pchLanguage ) == 3;
		m_bAbbrevCountry = strlen( m_pchCountry ) == 3;
		m_lcidLanguage = 0;
		m_iPrimaryLen = m_bAbbrevLanguage ? 2 : GetPrimaryLen( m_pchLanguage );
		//TODO:API
		s_LocaleHelper.EnumSystemLocalesA( (nsWin32::LocaleEnumCallbackA)LangCountryEnumProc, CLocale::LcId_Installed );

		//  locale value is invalid if the language was not installed or the language was not available for the country specified
		if( !( m_iLcidState & CLocale::__LCID_LANGUAGE ) || !( m_iLcidState & CLocale::__LCID_EXISTS ) || !( m_iLcidState & ( CLocale::__LCID_FULL | CLocale::__LCID_PRIMARY | CLocale::__LCID_DEFAULT ) ) )
		{
			m_iLcidState = 0;
		}
	}

	//--------------------------------------------------------------------------------
	bool CSetLoc::LangCountryEnumProc( char* lpLcidString )
	{
		CSetLoc* pSetLocData = &( CLocale::_getptd()->Data().SetLocData() );
		unsigned long    lcid = LcidFromHexString( lpLcidString );
		CAString rgcInfo;
		rgcInfo.Reserve( 120 );

		//  test locale country against input value
		//TODO: API
		if ( s_LocaleHelper.GetLocaleInfoA( lcid, pSetLocData->m_bAbbrevCountry ? CLocale::Locale_SAbbrevCtryName : CLocale::Locale_SEngCountry, rgcInfo() ) == 0 )
		{
			//  set error condition and exit
			pSetLocData->m_iLcidState = 0;
			return 1;
		}

		if ( !_stricmp( pSetLocData->m_pchCountry, rgcInfo ) )
		{
			//TODO: API
			//  country matched - test for language match
			if ( s_LocaleHelper.GetLocaleInfoA( lcid, pSetLocData->m_bAbbrevLanguage ? CLocale::Locale_SAbbrevLangName : CLocale::Locale_SEngLanguage, rgcInfo() ) == 0 )
			{
				//  set error condition and exit
				pSetLocData->m_iLcidState = 0;
				return true;
			}

			if ( !_stricmp( pSetLocData->m_pchLanguage, rgcInfo ) )
			{
				//  language matched also - set state and value
				pSetLocData->m_iLcidState |= ( CLocale::__LCID_FULL | CLocale::__LCID_LANGUAGE | CLocale::__LCID_EXISTS );
				pSetLocData->m_lcidLanguage = pSetLocData->m_lcidCountry = lcid;
			}

			//  test if match already for primary langauage
			else if( !( pSetLocData->m_iLcidState & CLocale::__LCID_PRIMARY ) )
			{
				//  if not, use pSetLocData->iPrimaryLen to partial match language string
				if ( pSetLocData->m_iPrimaryLen && !_strnicmp( pSetLocData->m_pchLanguage, rgcInfo, pSetLocData->m_iPrimaryLen ) )
				{
					//  primary language matched - set state and country unsigned long
					pSetLocData->m_iLcidState |= CLocale::__LCID_PRIMARY;
					pSetLocData->m_lcidCountry = lcid;

					//  if language is primary only (no subtype), set language unsigned long
					if ( (int)strlen( pSetLocData->m_pchLanguage ) == pSetLocData->m_iPrimaryLen )
					{
						pSetLocData->m_lcidLanguage = lcid;
					}
				}
				//  test if default language already defined
				else if( !( pSetLocData->m_iLcidState & CLocale::__LCID_DEFAULT ) )
				{
					//  if not, test if locale language is default for country
					if( pSetLocData->TestDefaultCountry( lcid ) )
					{
						//  default language for country - set state, value
						pSetLocData->m_iLcidState |= CLocale::__LCID_DEFAULT;
						pSetLocData->m_lcidCountry = lcid;
					}
				}
			}
		}
		//  test if input language both exists and default primary language defined
		if( ( pSetLocData->m_iLcidState & ( CLocale::__LCID_LANGUAGE | CLocale::__LCID_EXISTS ) ) != ( CLocale::__LCID_LANGUAGE | CLocale::__LCID_EXISTS ) )
		{
			//  test language match to determine whether it is installed
			//TODO: API
			if ( s_LocaleHelper.GetLocaleInfoA( lcid, pSetLocData->m_bAbbrevLanguage ? CLocale::Locale_SAbbrevLangName : CLocale::Locale_SEngLanguage, rgcInfo() ) == 0 )
			{
				//  set error condition and exit
				pSetLocData->m_iLcidState = 0;
				return true;
			}

			if ( !_stricmp( pSetLocData->m_pchLanguage, rgcInfo ) )
			{
				//  language matched - set bit for existance
				pSetLocData->m_iLcidState |= CLocale::__LCID_EXISTS;

				if ( pSetLocData->m_bAbbrevLanguage )
				{
					//  abbreviation - set state
					//  also set language unsigned long if not set already
					pSetLocData->m_iLcidState |= CLocale::__LCID_LANGUAGE;
					if ( !pSetLocData->m_lcidLanguage )
					{
						pSetLocData->m_lcidLanguage = lcid;
					}
				}
				//  test if language is primary only (no sublanguage)
				else if ( pSetLocData->m_iPrimaryLen && ( (int)strlen( pSetLocData->m_pchLanguage ) == pSetLocData->m_iPrimaryLen ) )
				{
					//  primary language only - test if default unsigned long
					if ( pSetLocData->TestDefaultLanguage( lcid, true ) )
					{
						//  default primary language - set state
						//  also set unsigned long if not set already
						pSetLocData->m_iLcidState |= CLocale::__LCID_LANGUAGE;
						if ( !pSetLocData->m_lcidLanguage )
						{
							pSetLocData->m_lcidLanguage = lcid;
						}
					}
				}
				else
				{
					//  language with sublanguage - set state
					//  also set unsigned long if not set already
					pSetLocData->m_iLcidState |= CLocale::__LCID_LANGUAGE;
					if ( !pSetLocData->m_lcidLanguage )
					{
						pSetLocData->m_lcidLanguage = lcid;
					}
				}
			}
			else if ( !pSetLocData->m_bAbbrevLanguage && pSetLocData->m_iPrimaryLen && !_stricmp( pSetLocData->m_pchLanguage, rgcInfo ) )
			{
				//  primary language match - test for default language only
				if ( pSetLocData->TestDefaultLanguage( lcid, false ) )
				{
					//  default primary language - set state
					//  also set unsigned long if not set already
					pSetLocData->m_iLcidState |= CLocale::__LCID_LANGUAGE;
					if ( !pSetLocData->m_lcidLanguage )
					{
						pSetLocData->m_lcidLanguage = lcid;
					}
				}
			}
		}

		//  if LOCALE_FULL set, return 0 to stop enumeration,
		//  else return 1 to continue
		return ( pSetLocData->m_iLcidState & CLocale::__LCID_FULL ) == 0;
	}


	//--------------------------------------------------------------------------------
	void CSetLoc::GetLcidFromLanguage ()
	{
		//  initialize static variables for callback use
		m_bAbbrevLanguage = strlen( m_pchLanguage ) == 3;
		m_iPrimaryLen = m_bAbbrevLanguage ? 2 : GetPrimaryLen( m_pchLanguage );

		s_LocaleHelper.EnumSystemLocalesA( (nsWin32::LocaleEnumCallbackA)LanguageEnumProc, CLocale::LcId_Installed );//TODO:API

		//  locale value is invalid if the language was not installed
		//  or the language was not available for the country specified
		if( !( m_iLcidState & CLocale::__LCID_FULL ) )
		{
			m_iLcidState = 0;
		}
	}

	//--------------------------------------------------------------------------------
	bool CSetLoc::LanguageEnumProc( char* lpLcidString )
	{
		CSetLoc* pSetLocData = &( CLocale::_getptd()->Data().SetLocData() );
		unsigned long    lcid = LcidFromHexString( lpLcidString );
		CAString rgcInfo;
		rgcInfo.Reserve( 120 );

		//  test locale for language specified
		//TODO:API
		if( s_LocaleHelper.GetLocaleInfoA( lcid, pSetLocData->m_bAbbrevLanguage ? CLocale::Locale_SAbbrevLangName : CLocale::Locale_SEngLanguage, rgcInfo() ) == 0 )
		{
			//  set error condition and exit
			pSetLocData->m_iLcidState = 0;
			return true;
		}

		if( !_stricmp( pSetLocData->m_pchLanguage, rgcInfo ) )
		{
			//  language matched - test if locale country is default
			//  or if locale is implied in the language string
			if( pSetLocData->m_bAbbrevLanguage || pSetLocData->TestDefaultLanguage( lcid, true ) )
			{
				//  this locale has the default country
				pSetLocData->m_lcidLanguage = pSetLocData->m_lcidCountry = lcid;
				pSetLocData->m_iLcidState |= CLocale::__LCID_FULL;
			}
		}
		else if( !pSetLocData->m_bAbbrevLanguage && pSetLocData->m_iPrimaryLen && !_stricmp( pSetLocData->m_pchLanguage, rgcInfo ) )
		{
			//  primary language matched - test if locale country is default
			if ( pSetLocData->TestDefaultLanguage( lcid, false ) )
			{
				//  this is the default country
				pSetLocData->m_lcidLanguage = pSetLocData->m_lcidCountry = lcid;
				pSetLocData->m_iLcidState |= CLocale::__LCID_FULL;
			}
		}

		return ( pSetLocData->m_iLcidState & CLocale::__LCID_FULL ) == 0;
	}

	//--------------------------------------------------------------------------------
	void CSetLoc::GetLcidFromCountry ()
	{
		m_bAbbrevCountry = strlen( m_pchCountry ) == 3;

		s_LocaleHelper.EnumSystemLocalesA( (nsWin32::LocaleEnumCallbackA)CountryEnumProc, CLocale::LcId_Installed );//TODO:API

		//  locale value is invalid if the country was not defined or
		//  no default language was found
		if ( !( m_iLcidState & CLocale::__LCID_FULL ) )
		{
			m_iLcidState = 0;
		}
	}

	//--------------------------------------------------------------------------------
	bool CSetLoc::CountryEnumProc( char* lpLcidString )
	{
		CSetLoc* pSetLocData = &( CLocale::_getptd()->Data().SetLocData() );
		unsigned long    lcid = LcidFromHexString( lpLcidString );
		CAString rgcInfo;
		rgcInfo.Reserve( 120 );

		//  test locale country against input value
		if ( s_LocaleHelper.GetLocaleInfoA( lcid, pSetLocData->m_bAbbrevCountry ? CLocale::Locale_SAbbrevCtryName : CLocale::Locale_SEngCountry, rgcInfo() ) == 0 )
		{
			//  set error condition and exit
			pSetLocData->m_iLcidState = 0;
			return true;
		}

		if ( !_stricmp( pSetLocData->m_pchCountry, rgcInfo ) )
		{
			//  country matched - test for language match
			//TODO:API
			if ( s_LocaleHelper.GetLocaleInfoA( lcid, pSetLocData->m_bAbbrevLanguage ? CLocale::Locale_SAbbrevLangName : CLocale::Locale_SEngLanguage, rgcInfo() ) == 0 )
			{
				//  set error condition and exit
				pSetLocData->m_iLcidState = 0;
				return true;
			}

			if ( !_stricmp( pSetLocData->m_pchLanguage, rgcInfo ) )
			{
				//  language matched also - set state and value
				pSetLocData->m_iLcidState |= ( CLocale::__LCID_FULL | CLocale::__LCID_LANGUAGE | CLocale::__LCID_EXISTS );
				pSetLocData->m_lcidLanguage = pSetLocData->m_lcidCountry = lcid;
			}
			//  test if match already for primary langauage
			else if( !( pSetLocData->m_iLcidState & CLocale::__LCID_PRIMARY ) )
			{
				//  if not, use pSetLocData->iPrimaryLen to partial match language string
				if ( pSetLocData->m_iPrimaryLen && !_strnicmp( pSetLocData->m_pchLanguage, rgcInfo, pSetLocData->m_iPrimaryLen ) )
				{
					//  primary language matched - set state and country unsigned long
					pSetLocData->m_iLcidState |= CLocale::__LCID_PRIMARY;
					pSetLocData->m_lcidCountry = lcid;

					//  if language is primary only (no subtype), set language unsigned long
					if ( (int)strlen( pSetLocData->m_pchLanguage ) == pSetLocData->m_iPrimaryLen )
					{
						pSetLocData->m_lcidLanguage = lcid;
					}
				}
				//  test if default language already defined
				else if ( !( pSetLocData->m_iLcidState & CLocale::__LCID_DEFAULT ) )
				{
					//  if not, test if locale language is default for country
					if ( pSetLocData->TestDefaultCountry( lcid ) )
					{
						//  default language for country - set state, value
						pSetLocData->m_iLcidState |= CLocale::__LCID_DEFAULT;
						pSetLocData->m_lcidCountry = lcid;
					}
				}
			}
		}

		//  test if input language both exists and default primary language defined
		if( ( pSetLocData->m_iLcidState & ( CLocale::__LCID_LANGUAGE | CLocale::__LCID_EXISTS ) ) != ( CLocale::__LCID_LANGUAGE | CLocale::__LCID_EXISTS ) )
		{
			//  test language match to determine whether it is installed
			//TODO:API
			if ( s_LocaleHelper.GetLocaleInfoA( lcid, pSetLocData->m_bAbbrevLanguage ? CLocale::Locale_SAbbrevLangName : CLocale::Locale_SEngLanguage, rgcInfo() ) == 0 )
			{
				//  set error condition and exit
				pSetLocData->m_iLcidState = 0;
				return true;
			}

			if( !_stricmp( pSetLocData->m_pchLanguage, rgcInfo ) )
			{
				//  language matched - set bit for existance
				pSetLocData->m_iLcidState |= CLocale::__LCID_EXISTS;

				if ( pSetLocData->m_bAbbrevLanguage )
				{
					//  abbreviation - set state
					//  also set language unsigned long if not set already
					pSetLocData->m_iLcidState |= CLocale::__LCID_LANGUAGE;
					if ( !pSetLocData->m_lcidLanguage )
					{
						pSetLocData->m_lcidLanguage = lcid;
					}
				}
				//  test if language is primary only (no sublanguage)
				else if ( pSetLocData->m_iPrimaryLen && ( (int)strlen( pSetLocData->m_pchLanguage ) == pSetLocData->m_iPrimaryLen ) )
				{
					//  primary language only - test if default unsigned long
					if ( pSetLocData->TestDefaultLanguage( lcid, 1 ) )
					{
						//  default primary language - set state
						//  also set unsigned long if not set already
						pSetLocData->m_iLcidState |= CLocale::__LCID_LANGUAGE;
						if( !pSetLocData->m_lcidLanguage )
						{
							pSetLocData->m_lcidLanguage = lcid;
						}
					}
				}
				else
				{
					//  language with sublanguage - set state
					//  also set unsigned long if not set already
					pSetLocData->m_iLcidState |= CLocale::__LCID_LANGUAGE;
					if ( !pSetLocData->m_lcidLanguage )
					{
						pSetLocData->m_lcidLanguage = lcid;
					}
				}
			}
			else if( !pSetLocData->m_bAbbrevLanguage && pSetLocData->m_iPrimaryLen && !_stricmp( pSetLocData->m_pchLanguage, rgcInfo ) )
			{
				//  primary language match - test for default language only
				if ( pSetLocData->TestDefaultLanguage( lcid, 0 ) )
				{
					//  default primary language - set state
					//  also set unsigned long if not set already
					pSetLocData->m_iLcidState |= CLocale::__LCID_LANGUAGE;
					if ( !pSetLocData->m_lcidLanguage )
					{
						pSetLocData->m_lcidLanguage = lcid;
					}
				}
			}
		}

		//  if LOCALE_FULL set, return 0 to stop enumeration,
		//  else return 1 to continue
		return ( pSetLocData->m_iLcidState & CLocale::__LCID_FULL ) == 0;
	}

	//--------------------------------------------------------------------------------
	void CSetLoc::GetLcidFromDefault ()
	{
		m_iLcidState |= ( CLocale::__LCID_FULL | CLocale::__LCID_LANGUAGE );
		m_lcidLanguage = m_lcidCountry = s_LocaleHelper.GetUserDefaultLCID();
	}


	//--------------------------------------------------------------------------------
	int CSetLoc::ProcessCodePage ( char* lpCodePageStr )
	{
		CAString chCodePage;
		chCodePage.Reserve( 8 );

		if( !lpCodePageStr || !*lpCodePageStr || !strcmp( lpCodePageStr, "ACP" ) )
		{
			//  get ANSI codepage for the country unsigned long
			//TODO:API
			if ( s_LocaleHelper.GetLocaleInfoA( m_lcidCountry, CLocale::Locale_IDefaultANSICodePage, chCodePage() ) == 0 )
			{
				return 0;
			}
			lpCodePageStr = chCodePage.GetBuffer();
		}
		else if( !strcmp( lpCodePageStr, "OCP" ) )
		{
			//  get OEM codepage for the country unsigned long
			//TODO:API
			if ( s_LocaleHelper.GetLocaleInfoA( m_lcidCountry, CLocale::Locale_IDefaultCodePage, chCodePage() ) == 0 )
			{
				return 0;
			}
			lpCodePageStr = chCodePage.GetBuffer();
		}

		//  convert decimal string to numeric value
		int iResult = (int)atol( lpCodePageStr );
		chCodePage.ReleaseBuffer();
		return iResult;
	}

	//--------------------------------------------------------------------------------
	bool CSetLoc::TestDefaultLanguage( unsigned long lcid, bool bTestPrimary )
	{
		CAString rgcInfo;
		rgcInfo.Reserve( 120 );
		unsigned long	lcidDefault = MakeLcId( MakeLangID( CLocale::PrimaryLangID( LangIdFromLcId( lcid ) ), Sublang_Default ), CLocale::Sort_Default );

		//TODO:API
		if ( s_LocaleHelper.GetLocaleInfoA( lcidDefault, CLocale::Locale_ILanguage, rgcInfo() ) == 0 )
		{
			return false;
		}

		if ( lcid != LcidFromHexString( rgcInfo ) )
		{
			//  test if string contains an implicit sublanguage by
			//  having a character other than upper/lowercase letters.
			if ( bTestPrimary && GetPrimaryLen( m_pchLanguage ) == (int)strlen( m_pchLanguage ) )
			{
				return false;
			}
		}
		return true;
	}

	//--------------------------------------------------------------------------------
	bool CSetLoc::TranslateName ( const CLocaleTab* lpTable, int iHigh, const char** ppchName )
	{
		int	i;
		int	iCmp = 1;
		int	iLow = 0;

		//  typical binary search - do until no more to search or match
		while ( iLow <= iHigh && iCmp != 0 )
		{
			i = ( iLow + iHigh ) / 2;
			iCmp = _stricmp( *ppchName, (const char *) ( *(lpTable + i)).szName );

			if ( iCmp == 0 )
			{
				*ppchName = ( *(lpTable + i) ).chAbbrev;
			}
			else if ( iCmp < 0 )
			{
				iHigh = i - 1;
			}
			else
			{
				iLow = i + 1;
			}
		}

		return !iCmp;
	}

	//--------------------------------------------------------------------------------
	bool CSetLoc::GetQualifiedLocale( const CLC_STRINGS* lpInStr, CLC_ID* lpOutId, CLC_STRINGS* lpOutStr )
	{
		int	iCodePage;
		unsigned int osplatform = 0;
		//CSetLoc* _psetloc_data = &_getptd()->_setloc_data;

		//  initialize pointer to call locale info routine based on operating system

		if ( !lpInStr )
		{
			//  if no input defined, just use default unsigned long
			GetLcidFromDefault();
		}
		else
		{
			m_pchLanguage = const_cast< char* >( lpInStr->m_szLanguage );

			//  convert non-NLS country strings to three-letter abbreviations
			m_pchCountry = const_cast< char* >( lpInStr->m_szCountry );
			if ( m_pchCountry && *m_pchCountry )
			{
				TranslateName( reinterpret_cast< const CLocaleTab* >( CLocale::s_aCountry ), CLocale::s_NumCountries/*sizeof(s_aCountry) / sizeof(CLOCALETAB) - 1*/, const_cast< const char** >( &m_pchCountry ) );
			}

			m_iLcidState = 0;

			if ( m_pchLanguage && *m_pchLanguage )
			{
				if ( m_pchCountry && *m_pchCountry )
				{
					//  both language and country strings defined
					GetLcidFromLangCountry();
				}
				else
				{
					//  language string defined, but country string undefined
					GetLcidFromLanguage();
				}

				if ( !m_iLcidState ) 
				{
					//  first attempt failed, try substituting the language name
					//  convert non-NLS language strings to three-letter abbrevs
					if ( TranslateName( reinterpret_cast< const CLocaleTab* >( CLocale::s_aLanguage ), CLocale::s_NumLangs /*sizeof(s_aLanguage) / sizeof(CLOCALETAB) - 1*/, const_cast<const char**>(&m_pchLanguage) ) )
					{
						if ( m_pchCountry && *m_pchCountry )
						{
							GetLcidFromLangCountry();
						}
						else
						{
							GetLcidFromLanguage();
						}
					}
				}
			}
			else
			{
				if ( m_pchCountry && *m_pchCountry )
				{
					//  country string defined, but language string undefined
					GetLcidFromCountry();
				}
				else
				{
					//  both language and country strings undefined
					GetLcidFromDefault();
				}
			}
		}

		//  test for error in unsigned long processing
		if ( !m_iLcidState )
		{
			return false;
		}

		//  process codepage value
		iCodePage = ProcessCodePage( lpInStr ? const_cast< char* >( lpInStr->m_szCodePage ): NULL );

		//  verify codepage validity
		if ( !iCodePage || iCodePage == CCodePage::UTF7 || iCodePage == CCodePage::UTF8 || !s_LocaleHelper.IsValidCodePage( (unsigned short)iCodePage ) )
		{
			return false;
		}

		//  verify locale is installed
		if ( !s_LocaleHelper.IsValidLocale( m_lcidLanguage, CLocale::LcId_Installed ) )
		{
			return false;
		}

		//  set numeric unsigned long and codepage results
		if ( lpOutId )
		{
			lpOutId->wLanguage = LangIdFromLcId( m_lcidLanguage );
			lpOutId->wCountry = LangIdFromLcId( m_lcidCountry );
			lpOutId->wCodePage = (unsigned short)iCodePage;
		}

		//  set string language, country, and codepage results
		if ( lpOutStr )
		{
			CAString strLanguage;
			strLanguage.Reserve( CLC_ID::MAX_LANG_LEN );
			// Norwegian-Nynorsk is special case because Langauge and country pair
			// for Norwegian-Nynorsk and Norwegian is same ie. Norwegian_Norway
			if ( lpOutId->wLanguage ==  0x0814 )
			{
				//TODO://_ERRCHECK(strcpy_s(lpOutStr->szLanguage, _countof(lpOutStr->szLanguage), "Norwegian-Nynorsk"));
				strcpy/*_s*/( lpOutStr->m_szLanguage/*, _countof( lpOutStr->m_szLanguage )*/, "Norwegian-Nynorsk" );
			}//TODO:API
			else if ( s_LocaleHelper.GetLocaleInfoA( m_lcidLanguage, CLocale::Locale_SEngLanguage, strLanguage()/*, CLC_ID::MAX_LANG_LEN*/ ) == 0 )
			{
				return 0;
			}
			else
			{
				strncpy( lpOutStr->m_szLanguage, strLanguage.GetBuffer(), CLC_ID::MAX_LANG_LEN );
			}

			CAString strCountry;
			//TODO:API
			if ( s_LocaleHelper.GetLocaleInfoA( m_lcidCountry, CLocale::Locale_SEngCountry, strCountry()/*, CLC_ID::MAX_CTRY_LEN*/ ) == 0 )
			{
				return 0;
			}
			else if( strCountry.Len() > 0 )
			{
				strncpy( lpOutStr->m_szCountry, strCountry.GetBuffer(), CLC_ID::MAX_CTRY_LEN );
			}

			_itoa_s( (int)iCodePage, (char *)lpOutStr->m_szCodePage, CLC_ID::MAX_CP_LEN, 10 );
		}
		return 1;
	}

	//--------------------------------------------------------------------------------
	bool CSetLoc::TestDefaultCountry( unsigned long lcid )
	{
		unsigned short langid = LangIdFromLcId( lcid );
		int     i;

		for ( i = 0; i < sizeof( CSetLoc::s_aLangIdNotDefault ) / sizeof( unsigned short ); i++ )
		{
			if ( langid == CSetLoc::s_aLangIdNotDefault[ i ] )
			{
				return false;
			}
		}
		return true;
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::_stricmp ( const char* dst, const char* src )
	{
		if ( TheSystem().As< nsWin32::CSystem >()->Locale()().LocaleChanged() == false )
		{				
			//_VALIDATE_RETURN(dst != NULL, EINVAL, _NLSCMPERROR);
			//_VALIDATE_RETURN(src != NULL, EINVAL, _NLSCMPERROR);

			return __ascii_stricmp( dst, src );
		}
		else
		{
			return _stricmp_l( dst, src, 0 );
		}
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::_stricmp_l ( const char* dst, const char* src, CLocaleThreadData* plocinfo )
	{
		int f,l;
		CLocaleUpdate _loc_update( plocinfo );

		// validation section
		//_VALIDATE_RETURN(dst != NULL, EINVAL, _NLSCMPERROR);
		//_VALIDATE_RETURN(src != NULL, EINVAL, _NLSCMPERROR);

		if ( _loc_update.GetLocaleT()->LocaleInfoPtr()->Handles()[ CLocale::LCCTYPE ] == CLocale::_CLOCALEHANDLE )
		{
			return __ascii_stricmp( dst, src );
		}
		else
		{
			do
			{
				f = _tolower_l( (unsigned char)( *( dst++ ) ), _loc_update.GetLocaleT() );
				l = _tolower_l( (unsigned char)( *( src++ ) ), _loc_update.GetLocaleT() );
			} while ( f && ( f == l ) );
		}

		return( f - l );
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::_strnicmp ( const char* dst, const char* src, size_t count )
	{

		if ( TheSystem().As< nsWin32::CSystem >()->Locale()().LocaleChanged() == false )
		{
			// validation section
			//_VALIDATE_RETURN(dst != NULL, EINVAL, _NLSCMPERROR);
			//_VALIDATE_RETURN(src != NULL, EINVAL, _NLSCMPERROR);
			//_VALIDATE_RETURN(count <= INT_MAX, EINVAL, _NLSCMPERROR);

			return __ascii_strnicmp( dst, src, count );
		}
		else
		{
			return _strnicmp_l( dst, src, count, 0 );
		}
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::__ascii_strnicmp ( const char* first, const char* last, size_t count )
	{
		if( count )
		{
			int f = 0;
			int l = 0;

			do
			{
				if ( ( ( f = (unsigned char)( *( first++ ) ) ) >= 'A' ) && ( f <= 'Z' ) )
				{
					f -= 'A' - 'a';
				}

				if ( ( ( l = (unsigned char)( *( last++ ) ) ) >= 'A' ) && ( l <= 'Z' ) )
				{
					l -= 'A' - 'a';
				}
			}
			while ( --count && f && ( f == l ) );

			return ( f - l );
		}
		else
		{
			return 0;
		}
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::_strnicmp_l ( const char* dst, const char* src, size_t count, CLocaleThreadData* plocinfo )
	{
		int f, l;

		if ( count )
		{
			CLocaleUpdate _loc_update( plocinfo );

			// validation section
			//_VALIDATE_RETURN(dst != NULL, EINVAL, _NLSCMPERROR);
			//_VALIDATE_RETURN(src != NULL, EINVAL, _NLSCMPERROR);
			//_VALIDATE_RETURN(count <= INT_MAX, EINVAL, _NLSCMPERROR);

			if ( _loc_update.GetLocaleT()->LocaleInfoPtr()->Handles()[ CLocale::LCCTYPE ] == CLocale::_CLOCALEHANDLE )
			{
				return __ascii_strnicmp( dst, src, count );
			}
			else
			{
				do
				{
					f = _tolower_l( (unsigned char)( *( dst++ ) ), _loc_update.GetLocaleT() );
					l = _tolower_l( (unsigned char)( *( src++ ) ), _loc_update.GetLocaleT() );
				}
				while ( --count && f && ( f == l ) );
			}
			return( f - l );
		}

		return( 0 );
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::_tolower_l ( int c, CLocaleThreadData* plocinfo )
	{
		int size;
		unsigned char inbuffer[ 3 ];
		CAString outbuffer;
		outbuffer.Reserve( 3 );
		CLocaleUpdate _loc_update( plocinfo );

		// if checking case of c does not require API call, do it
		if ( (unsigned)c < 256 )
		{
			if ( _ischartype_l( c, nsWin32::Upper , _loc_update.GetLocaleT() ) )
			{
				return _loc_update.GetLocaleT()->LocaleInfoPtr()->CLMap()[ c ];
			}
			else
			{
				return c;
			}
		}

		// convert int c to multibyte string
		if( _loc_update.GetLocaleT()->LocaleInfoPtr()->MBCurMax() > 1 && _isleadbyte_l( c >> 8 & 0xff, _loc_update.GetLocaleT() ) )
		{
			inbuffer[ 0 ] = ( c >> 8 & 0xff ); // put lead-byte at start of str
			inbuffer[ 1 ] = (unsigned char)c;
			inbuffer[ 2 ] = 0;
			size = 2;
		} 
		else 
		{
			// this is an undefined behavior, should probably use towlower instead
			errno = EILSEQ;
			inbuffer[ 0 ] = (unsigned char)c;
			inbuffer[ 1 ] = 0;
			size = 1;
		}

		// convert to lowercase
		if( 0 == ( size = __crtLCMapStringA( _loc_update.GetLocaleT(), _loc_update.GetLocaleT()->LocaleInfoPtr()->Handles()[ CLocale::LCCTYPE ], LCMap_LowerCase, (const char*)inbuffer, size, outbuffer(), /*3,*/ _loc_update.GetLocaleT()->LocaleInfoPtr()->CodePage(), 1 ) ) )
		{
			return c;
		}

		// construct integer return value
		if ( size == 1 )
		{
			return ( (int)outbuffer[ 0 ] );
		}
		else
		{
			return ( (int)outbuffer[ 1 ] | ( (int)outbuffer[ 0 ] << 8 ) );
		}
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::__crtLCMapStringA( CLocaleThreadData* plocinfo, unsigned long Locale, unsigned long dwMapFlags, const char* lpSrcStr, int cchSrc, CAStringRef lpDestStr, CCodePage& code_page, int bError )
	{
		CLocaleUpdate _loc_update(plocinfo);

		return __crtLCMapStringA_stat( _loc_update.GetLocaleT(), Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, code_page, bError );
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::__crtLCMapStringA_stat( CLocaleThreadData* plocinfo, unsigned long Locale, unsigned long dwMapFlags, const char* lpSrcStr, int cchSrc, CAStringRef lpDestStr, CCodePage& code_page, int bError )
	{
		static int f_use = 0;
		nsWin32::CErrorHelper ErrorHelper;

		/*Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
		 * Must actually call the function to ensure it's not a stub.
		 * (Always try wide version first so WinNT can process codepage correctly.)
		 */

		if( 0 == f_use ) 
		{
			if( 0 != s_LocaleHelper.LCMapStringW( 0, LCMap_LowerCase, L"\0", 1, NULL ) )
			{
				f_use = USE_W;
			}
			else if( ErrorHelper.GetLastError() == ErrorCallNotImplemented )
			{
				f_use = USE_A;
			}
		}

		/*LCMapString will map past NULL. Must find NULL if in string
		 * before cchSrc characters.
		 */

		if( cchSrc > 0 ) 
		{
			int cchSrcCnt = CLocale::strncnt( lpSrcStr, cchSrc );
			//Include NULL in cchSrc if lpSrcStr terminated within cchSrc bytes.
			if( cchSrcCnt < cchSrc ) 
			{
				cchSrc = cchSrcCnt + 1;
			} 
			else 
			{
				cchSrc = cchSrcCnt;
			}
		}

		// Use "A" version

		if( USE_A == f_use || f_use == 0 ) 
		{
			char *cbuffer = NULL;
			CAString cbuffer1;
			char *cbuffer2 = NULL;
			int ret;
			CCodePage AnsiCP( 0 );
			int buff_size;

			if( 0 == Locale )
			{
				Locale = plocinfo->LocaleInfoPtr()->Handles()[ CLocale::LCCTYPE ];
			}

			if ( 0 == code_page.ID() )
			{
				code_page = plocinfo->LocaleInfoPtr()->CodePage();
			}

			if ( -1 == ( AnsiCP = __ansicp( Locale ) ) )
			{
				return 0;
			}
			/* LCMapStringA uses ANSI code page to map the string. Check if
			 * codepage is ansi, if not convert the input string to ansi
			 * codepage then map to a temporary string and then convert temp
			 * string to DestStr.
			 */
			if ( AnsiCP != code_page )
			{
				cbuffer = code_page.Convert( AnsiCP, lpSrcStr, &cchSrc, NULL, 0 );
				if( cbuffer == NULL )
				{
					return 0;
				}

				lpSrcStr = cbuffer;
				if( 0 == ( buff_size = s_LocaleHelper.LCMapStringA( Locale, dwMapFlags, lpSrcStr, cchSrc, 0 ) ) )
				{
					ret = 0;
				}
				else
				{
					cbuffer1.Reserve( static_cast< unsigned short >( buff_size ) );

					if( 0 == ( buff_size = s_LocaleHelper.LCMapStringA( Locale, dwMapFlags, lpSrcStr, cchSrc, cbuffer1() ) ) )
					{
						ret = 0;
					} 
					else 
					{
						if ( 0 == ( cbuffer2 = AnsiCP.Convert( code_page, cbuffer1, &buff_size, lpDestStr->GetBufferSetLength( buff_size ), buff_size ) ) )
						{
							ret = 0;
						}
						else
						{
							lpDestStr->ValidateBuffer( buff_size );
							ret = buff_size;
						}
					}
				}
			} 
			else
			{
				ret = s_LocaleHelper.LCMapStringA( Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr/*, cchDest*/ );
			}

			if ( cbuffer != NULL )
			{
				delete [] cbuffer;
			}
			if ( ( cbuffer2 != NULL ) && ( lpDestStr->operator const char *() != cbuffer2 ) )
			{
				 delete [] cbuffer2;
			}
			return ret;
		}

		/* Use "W" version */

		if( USE_W == f_use )
		{
			int retval = 0;
			int inbuff_size;
			int outbuff_size;
			wchar_t *inwbuffer = NULL;
			wchar_t *outwbuffer = NULL;

			/*
			 * Convert string and return the requested information. Note that
			 * we are converting to a wide string so there is not a
			 * one-to-one correspondence between number of wide chars in the
			 * input string and the number of *bytes* in the buffer. However,
			 * there had *better be* a one-to-one correspondence between the
			 * number of wide characters and the number of multibyte characters
			 * or the resulting mapped string will be worthless to the user.
			 */

			//Use __lc_codepage for conversion if code_page not specified

			if ( 0 == code_page.ID() )
			{
				code_page = plocinfo->LocaleInfoPtr()->CodePage();
			}

			// find out how big a buffer we need (includes NULL if any)
			if ( 0 == ( inbuff_size = code_page.MultiByteToWideChar( bError ? MB_Precomposed | MB_Err_Invalid_Chars : MB_Precomposed, lpSrcStr, cchSrc, NULL, 0 ) ) )
			{
				return 0;
			}

			// allocate enough space for wide chars
			inwbuffer = new wchar_t[ inbuff_size ];
			if ( inwbuffer == NULL ) 
			{
				return 0;
			}

			// do the conversion 
			if ( 0 == code_page.MultiByteToWideChar( MB_Precomposed, lpSrcStr, cchSrc, inwbuffer, inbuff_size ) )
			{
				goto error_cleanup;
			}

			// get size required for string mapping
			if ( 0 == ( retval = s_LocaleHelper.LCMapStringW( Locale, dwMapFlags, inwbuffer, inbuff_size, NULL ) ) )
			{
				goto error_cleanup;
			}

			if ( dwMapFlags & LCMap_SortKey ) 
			{
				/*TODO:
				// retval is size in BYTES
				if( 0 != lpDestStr->Allocation() ) 
				{
					if( retval > lpDestStr->Allocation() )
					{
						goto error_cleanup;
					}

					// do string mapping
					if ( 0 == s_LocaleHelper.LCMapStringW( Locale, dwMapFlags, inwbuffer, inbuff_size, lpDestStr ) )
					{
						goto error_cleanup;
					}
				}
				*/
			}
			else 
			{
				// retval is size in wide chars

				outbuff_size = retval;

				CWString outwbuffer;
				outwbuffer.Reserve( static_cast< unsigned short >( outbuff_size ) );

				// do string mapping
				if( 0 == s_LocaleHelper.LCMapStringW( Locale, dwMapFlags, inwbuffer, inbuff_size, outwbuffer() ) )
				{
					goto error_cleanup;
				}

				if( 0 == lpDestStr->Allocation() ) 
				{
					// get size required
					if ( 0 == (retval = code_page.WideCharToMultiByte( 0, outwbuffer, outbuff_size, NULL, 0, NULL, NULL ) ) )
					{
						goto error_cleanup;
					}
				}
				else 
				{
					// convert mapping
					if ( 0 == ( retval = code_page.WideCharToMultiByte( 0, outwbuffer, outbuff_size, lpDestStr->GetBuffer(), lpDestStr->Allocation(), NULL, NULL ) ) )
					{
						goto error_cleanup;
					}
					lpDestStr->ValidateBuffer( retval );
				}
			}

	error_cleanup:

			if ( outwbuffer != 0 )
			{
				delete [] outwbuffer;
			}

			delete [] inwbuffer;

			return retval;
		}
		else   // f_use is neither USE_A nor USE_W
		{
			return 0;
		}
	}
	
	//--------------------------------------------------------------------------------
	int CSetLoc::_chvalidchk_l( int _Char, int _Flag, CLocaleThreadData* _Locale )
	{
		return ( _Locale == 0 ? _chvalidator( _Char, _Flag ) : _Locale->LocaleInfoPtr()->CType()[ _Char ] & ( _Flag ) );
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::_ischartype_l( int c, int _Flag, CLocaleThreadData* _Locale )
	{
		return ( ( ( _Locale ) != 0 && ( _Locale->LocaleInfoPtr()->MBCurMax() ) > 1 ) ? _isctype_l( c, _Flag, _Locale ) : _chvalidchk_l( c, _Flag, _Locale ) );
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::_isleadbyte_l ( int c, CLocaleThreadData* plocinfo )
	{
		CLocaleUpdate _loc_update( plocinfo );
		return ( _loc_update.GetLocaleT()->LocaleInfoPtr()->CType()[ (unsigned char)(c) ] & CharData::E_LEADBYTE );
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::__ansicp( int lcid )
	{
		CAString ch;
		ch.Reserve( 7 );
		int ret;
		//ch[6 ] = 0;

		if ( !s_LocaleHelper.GetLocaleInfoA( lcid, CLocale::Locale_IDefaultANSICodePage, ch() ) )
		{
			ret = -1;
		}
		else
		{
			ret = atol( ch );
		}
		return ret;
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::_isctype_l ( int c, int mask, CLocaleThreadData* plocinfo )
	{
		int size;
		unsigned short chartype;
		char buffer[ 3 ];
		CLocaleUpdate _loc_update( plocinfo );

		// c valid between -1 and 255
		if ( c >= -1 && c <= 255 )
		{
			return _loc_update.GetLocaleT()->LocaleInfoPtr()->CType()[ c ] & mask;
		}

		if ( _isleadbyte_l( c >> 8 & 0xff, _loc_update.GetLocaleT() ) )
		{
			buffer[ 0 ] = ( c >> 8 & 0xff ); // put lead-byte at start of str
			buffer[ 1 ] = (char)c;
			buffer[ 2 ] = 0;
			size = 2;
		} 
		else 
		{
			buffer[ 0 ] = (char)c;
			buffer[ 1 ] = 0;
			size = 1;
		}

		if( 0 == __crtGetStringTypeA( _loc_update.GetLocaleT(), CT_CType1, buffer, size, &chartype, _loc_update.GetLocaleT()->LocaleInfoPtr()->CodePage(), _loc_update.GetLocaleT()->LocaleInfoPtr()->Handles()[ CLocale::LCCTYPE ], 1 ) )
		{
			return 0;
		}

		return (int)( chartype & mask );
	}

	//--------------------------------------------------------------------------------
	bool CSetLoc::__crtGetStringTypeA( CLocaleThreadData* plocinfo, unsigned long dwInfoType, const char* lpSrcStr, int cchSrc, unsigned short* lpCharType, CCodePage& code_page, int lcid, int bError )
	{
		CLocaleUpdate _loc_update(plocinfo);

		return __crtGetStringTypeA_stat( _loc_update.GetLocaleT(), dwInfoType, lpSrcStr, cchSrc, lpCharType, code_page, lcid, bError );
	}

	//--------------------------------------------------------------------------------
	bool CSetLoc::__crtGetStringTypeW( CLocaleThreadData* plocinfo, unsigned long dwInfoType, const wchar_t* lpSrcStr, int cchSrc, unsigned short* lpCharType, CCodePage& code_page, int lcid )
	{
		CLocaleUpdate _loc_update( plocinfo );

		return __crtGetStringTypeW_stat( _loc_update.GetLocaleT(), dwInfoType, lpSrcStr, cchSrc, lpCharType, code_page, lcid );
	}

	//--------------------------------------------------------------------------------
	bool CSetLoc::__crtGetStringTypeA_stat( CLocaleThreadData* plocinfo, unsigned long dwInfoType, const char* lpSrcStr, int cchSrc, unsigned short* lpCharType, CCodePage& code_page, int lcid, int bError )
	{
		static int f_use = 0;
		nsWin32::CStringHelper StringHelper;
		nsWin32::CErrorHelper ErrorHelper;
		/*Look for unstubbed 'preferred' flavor. Otherwise use available
		 * flavor. Must actually call the function to ensure it's not a stub.
		 * (Always try wide version first so WinNT can process codepage correctly.)
		 */

		if( 0 == f_use )
		{
			unsigned short dummy;

			if( 0 != StringHelper.GetStringTypeW( CT_CType1, L"\0", 1, &dummy ) )
			{
				f_use = USE_W;
			}
			else if( ErrorHelper.GetLastError() == ErrorCallNotImplemented )
			{
				f_use = USE_A;
			}
		}

		// Use "A" version

		if( USE_A == f_use || f_use == 0 )
		{
			char* cbuffer = NULL;
			int ret;
			CCodePage AnsiCP( 0 );

			if( 0 == lcid )
			{
				lcid = plocinfo->LocaleInfoPtr()->Handles()[ CLocale::LCCTYPE ];
			}
			if( 0 == code_page.ID() )
			{
				code_page = plocinfo->LocaleInfoPtr()->CodePage();
			}

			if ( -1 == ( AnsiCP = __ansicp( lcid ) ) )
			{
				return 0;
			}
			/* If current code-page is not ansi code page, convert it to ansi code page
			 * as GetStringTypeA uses ansi code page to find the strig type.
			 */
			if ( AnsiCP != code_page )
			{
				cbuffer = code_page.Convert( AnsiCP, lpSrcStr, &cchSrc, NULL, 0 );
				if ( cbuffer == NULL )
				{
					return 0;
				}
				lpSrcStr = cbuffer;
			}

			ret = StringHelper.GetStringTypeA( lcid, dwInfoType, lpSrcStr, cchSrc, lpCharType );
			if ( cbuffer != NULL )
			{
				delete [] cbuffer;
			}
			return ret;
		}

		// Use "W" version

		if( USE_W == f_use )
		{
			int retval1;
			int buff_size;
			wchar_t* wbuffer;
			int retval2 = 0;

			/* Convert string and return the requested information. Note that
			 * we are converting to a wide character string so there is not a
			 * one-to-one correspondence between number of multibyte chars in the
			 * input string and the number of wide chars in the buffer. However,
			 * there had *better be* a one-to-one correspondence between the
			 * number of multibyte characters and the number of WORDs in the
			 * return buffer.
			 */

			//Use __lc_codepage for conversion if code_page not specified
			 
			if( 0 == code_page.ID() )
			{
				code_page = plocinfo->LocaleInfoPtr()->CodePage();
			}

			// find out how big a buffer we need
			if( 0 == ( buff_size = code_page.MultiByteToWideChar( bError ? MB_Precomposed | MB_Err_Invalid_Chars : MB_Precomposed, lpSrcStr, cchSrc, NULL, 0 ) ) )
			{
				return 0;
			}

			// allocate enough space for wide chars
			wbuffer = new wchar_t[ buff_size ];
			if ( wbuffer == NULL ) 
			{
				return 0;
			}
			(void)memset( wbuffer, 0, sizeof(wchar_t) * buff_size );

			// do the conversion
			if ( 0 != ( retval1 = code_page.MultiByteToWideChar( MB_Precomposed, lpSrcStr, cchSrc, wbuffer, buff_size ) ) )
			{
				// obtain result
				retval2 = StringHelper.GetStringTypeW( dwInfoType, wbuffer, retval1, lpCharType );
			}

			delete [] wbuffer;

			return retval2;
		}
		else   // f_use is neither USE_A nor USE_W
		{
			return 0;
		}
	}

	//--------------------------------------------------------------------------------
	bool CSetLoc::__crtGetStringTypeW_stat( CLocaleThreadData* plocinfo, unsigned long dwInfoType, const wchar_t* lpSrcStr, int cchSrc, unsigned short* lpCharType, CCodePage& code_page, int lcid )
	{
		static int f_use = 0;
		nsWin32::CStringHelper StringHelper;
		nsWin32::CErrorHelper ErrorHelper;

		// Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
		// Must actually call the function to ensure it's not a stub.

		if( cchSrc < -1 )
		{
			return false;
		}

		if( 0 == f_use )
		{
			unsigned short dummy;

			if( 0 != StringHelper.GetStringTypeW( CT_CType1, L"\0", 1, &dummy ) )
			{
				f_use = USE_W;
			}
			else if ( ErrorHelper.GetLastError() == ErrorCallNotImplemented )
			{
				f_use = USE_A;
			}
		}

		//Use "W" version

		if( USE_W == f_use )
		{
			return StringHelper.GetStringTypeW( dwInfoType, lpSrcStr, cchSrc, lpCharType );
		}

		// Use "A" version

		if( USE_A == f_use || f_use == 0 )
		{
			int buff_size;
			bool retbool = false;
			unsigned char* buffer;
			unsigned short* pwCharInfo;
			//int malloc_flag1 = 0;
			//int malloc_flag2 = 0;
			CCodePage AnsiCP( 0 );

			/* Convert string and return the requested information. Note that
			 * we are converting to a multibyte string so there is not a
			 * one-to-one correspondence between number of wide chars in the
			 * input string and the number of *bytes* in the buffer. However,
			 * there had *better be* a one-to-one correspondence between the
			 * number of wide characters and the number of WORDs in the
			 * return buffer.
			 */

			//Use __lc_codepage for conversion if code_page not specified

			if( 0 == lcid )
			{
				lcid = plocinfo->LocaleInfoPtr()->Handles()[ CLocale::LCCTYPE ];
			}

			if( 0 == code_page.ID() )
			{
				code_page = plocinfo->LocaleInfoPtr()->CodePage();
			}

			// Always use Ansi codepage with Ansi WinAPI because they use Ansi codepage
			 
			if( code_page != ( AnsiCP = __ansicp( lcid ) ) )
			{
				if( AnsiCP != -1 )
				{
					code_page = AnsiCP;
				}
			}

			// find out how big a buffer we need
			if( 0 == ( buff_size = code_page.WideCharToMultiByte( 0, lpSrcStr, cchSrc, NULL, 0, NULL, NULL ) ) )
			{
				return false;
			}

			// allocate enough space for chars
			buffer = new unsigned char[ buff_size ];
			if ( buffer == NULL ) 
			{
				return false;
			}

			(void)memset( buffer, 0, sizeof(char) * buff_size );

			// do the conversion
			if ( 0 == code_page.WideCharToMultiByte( 0, lpSrcStr, cchSrc, (char *)buffer, buff_size, NULL, NULL ) )
			{
				goto error_cleanup;
			}

			// allocate enough space for result (+1 for sanity check)
			pwCharInfo = new unsigned short[ ( buff_size + 1 ) ];

			if ( pwCharInfo == NULL ) 
			{
				goto error_cleanup;
			}

			// do we use default lcid 
			if( 0 == lcid )
			{
				lcid = plocinfo->LocaleInfoPtr()->Handles()[ CLocale::LCCTYPE ];
			}

			// set to known value
			pwCharInfo[ cchSrc - 1 ] = pwCharInfo[ cchSrc ] = 0xFFFF;

			// obtain result
			retbool = StringHelper.GetStringTypeA( lcid, dwInfoType, (const char *)buffer, buff_size, pwCharInfo );

			/* GetStringTypeA does not reveal how many WORDs have been
			 * modifed - to be safe we use another buffer and then
			 * verify that EXACTLY cchSrc WORDs were modified. Note that
			 * not all multibyte unsigned long/codepage combos are guaranteed to work.
			 */

			if( ( pwCharInfo[ cchSrc - 1 ] == 0xFFFF ) || ( pwCharInfo[ cchSrc ] != 0xFFFF ) )
			{
				retbool = false;
			}
			else
			{
				memmove( lpCharType, pwCharInfo, cchSrc * sizeof( unsigned short ) );
			}

			delete [] pwCharInfo;

	error_cleanup:

			delete [] buffer;

			return retbool;
		}
		else   // f_use is neither USE_A nor USE_W
		{
			return false;
		}
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::__crtLCMapStringW( CLocaleThreadData* plocinfo, unsigned long Locale, unsigned long dwMapFlags, const wchar_t* lpSrcStr, int cchSrc, CWStringRef lpDestStr, CCodePage& code_page )
	{
		CLocaleUpdate _loc_update( plocinfo );

		return __crtLCMapStringW_stat( _loc_update.GetLocaleT(), Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, code_page );
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::wcsncnt ( const wchar_t* string, int cnt )
	{
		int n = cnt;
		wchar_t* cp = const_cast< wchar_t* >( string );

		while( n-- && *cp )
		{
				cp++;
		}

		return cnt - n - 1;
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::__crtLCMapStringW_stat( CLocaleThreadData* plocinfo, unsigned long Locale, unsigned long dwMapFlags, const wchar_t* lpSrcStr, int cchSrc, CWStringRef lpDestStr, CCodePage& code_page )
	{
		static int f_use = 0;
		nsWin32::CErrorHelper ErrorHelper;

		// Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
		// Must actually call the function to ensure it's not a stub.

		if( 0 == f_use ) 
		{
			if ( 0 != s_LocaleHelper.LCMapStringW( 0, LCMap_LowerCase, L"\0", 1, NULL/*, 0*/ ) )
			{
				f_use = USE_W;
			}
			else if ( ErrorHelper.GetLastError() == ErrorCallNotImplemented )
			{
				f_use = USE_A;
			}
		}

		// LCMapString will map past NULL. Must find NULL if in string
		// before cchSrc wide characters.
		 
		if( cchSrc > 0 )
		{
			cchSrc = wcsncnt( lpSrcStr, cchSrc );
		}

		// Use "W" version

		if ( USE_W == f_use ) 
		{
			return s_LocaleHelper.LCMapStringW( Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr/*, cchDest*/ );
		}

		// Use "A" version

		if ( USE_A == f_use || f_use == 0 ) 
		{
			int retval = 0;
			int inbuff_size;
			int outbuff_size;
			unsigned char *inbuffer = NULL;
			CAString outbuffer;
			int AnsiCP = 0;

			/* Convert string and return the requested information. Note that
			 * we are converting to a multibyte string so there is not a
			 * one-to-one correspondence between number of wide chars in the
			 * input string and the number of *bytes* in the buffer. However,
			 * there had *better be* a one-to-one correspondence between the
			 * number of wide characters and the number of multibyte characters
			 * (enforced by WC_SEPCHARS) in the buffer or the resulting mapped
			 * string will be worthless to the user.
			 */

			//Use __lc_codepage for conversion if code_page not specified			 

			if( 0 == Locale )
			{
				Locale = plocinfo->LocaleInfoPtr()->Handles()[ CLocale::LCCTYPE ];
			}

			if( 0 == code_page.ID() )
			{
				code_page = plocinfo->LocaleInfoPtr()->CodePage();
			}

			//Always use Ansi codepage with Ansi WinAPI because they use Ansi codepage
			 
			if( code_page != ( AnsiCP = __ansicp( Locale ) ) )
			{
				if( AnsiCP != -1 )
				{
					code_page = AnsiCP;
				}
			}

			// find out how big a buffer we need (includes NULL if any)
			if( 0 == ( inbuff_size = code_page.WideCharToMultiByte( 0, lpSrcStr, cchSrc, NULL, 0, NULL, NULL ) ) )
			{
				return 0;
			}

			// allocate enough space for chars
			inbuffer = new unsigned char[ inbuff_size ];

			if( inbuffer == NULL ) 
			{
				return 0;
			}

			// do the conversion
			if( 0 ==  code_page.WideCharToMultiByte( 0, lpSrcStr, cchSrc, (char *)inbuffer, inbuff_size, NULL, NULL ) )
			{
				goto error_cleanup;
			}

			// get size required for string mapping
			if( 0 == ( outbuff_size = s_LocaleHelper.LCMapStringA( Locale, dwMapFlags, (const char *)inbuffer, inbuff_size, NULL/*, 0*/ ) ) )
			{
				goto error_cleanup;
			}

			// allocate enough space for chars and NULL
			outbuffer.Reserve( outbuff_size );

			// do string mapping
			if( 0 == s_LocaleHelper.LCMapStringA( Locale, dwMapFlags, (const char *)inbuffer, inbuff_size, outbuffer() ) )
			{
				goto error_cleanup;
			}

			if( dwMapFlags & LCMap_SortKey ) 
			{
				// outbuff_size > cchDest is allowed
				retval = outbuff_size;

				if( 0 != lpDestStr->Allocation() )
				{
					// SORTKEY returns BYTES, just copy
					//_ERRCHECK(strncpy_s( (char *)lpDestStr, cchDest, (char *)outbuffer, cchDest <= outbuff_size ? cchDest - 1 : outbuff_size ) );
					::strncpy( (char *)(lpDestStr->GetBuffer())/*, cchDest*/, (const char *)outbuffer, lpDestStr->Allocation() <= outbuff_size ? lpDestStr->Allocation() - 1 : outbuff_size );
				}
			}
			else 
			{
				if ( 0 == lpDestStr->Allocation() ) 
				{
					// get size required
					if( 0 == ( retval = code_page.MultiByteToWideChar( MB_Precomposed, (const char *)outbuffer, outbuff_size, NULL, 0 ) ) )
					{
						goto error_cleanup;
					}
				}
				else 
				{
					// convert mapping
					if ( 0 == ( retval = code_page.MultiByteToWideChar( MB_Precomposed, (const char *)outbuffer, outbuff_size, lpDestStr->GetBuffer(), lpDestStr->Allocation() ) ) )
					{
						goto error_cleanup;
					}
				}
			}

	error_cleanup:

			if ( outbuffer != NULL )
			{
				delete [] outbuffer;
			}

			delete [] inbuffer;

			return retval;
		}
		else   // f_use is neither USE_A nor USE_W
		{
			return 0;
		}
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::_chvalidator( int c, int mask )
	{
			//_ASSERTE((unsigned)(c + 1) <= 256);
			return _chvalidator_l( 0, c, mask );
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::_chvalidator_l( CLocaleThreadData* plocinfo, int c, int mask )
	{
		CLocaleUpdate _loc_update( plocinfo );

		//_ASSERTE((unsigned)(c + 1) <= 256);
		if ( c >= -1 && c <= 255 )
		{
			return ( _loc_update.GetLocaleT()->LocaleInfoPtr()->CType()[ c ] & mask );
		}
		else
		{
			return ( _loc_update.GetLocaleT()->LocaleInfoPtr()->CType()[ -1 ] & mask );
		}
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::_itoa_s ( int val, char* buf, size_t sizeInChars, int radix )
	{
		int e = 0;

		if( radix == 10 && val < 0 )
		{
			e = xtox_s( (unsigned long)val, buf, sizeInChars, radix, 1 );
		}
		else
		{
			e = xtox_s( (unsigned long)(unsigned int)val, buf, sizeInChars, radix, 0 );
		}

		return e;
	}

	//--------------------------------------------------------------------------------
	int CSetLoc::xtox_s( unsigned long val, char* buf, size_t sizeInChars, unsigned radix, int is_neg )
	{
		char* p;                /* pointer to traverse string */
		char* firstdig;         /* pointer to first digit */
		char temp;              /* temp char */
		unsigned digval;         /* value of digit */
	
		size_t length;           /* current length of the string */

		// validation section
		//_VALIDATE_RETURN_ERRCODE(buf != NULL, EINVAL);
		//_VALIDATE_RETURN_ERRCODE(sizeInTChars > 0, EINVAL);
		//_RESET_STRING(buf, sizeInTChars);
		//_VALIDATE_RETURN_ERRCODE(sizeInTChars > (size_t)(is_neg ? 2 : 1), ERANGE);
		//_VALIDATE_RETURN_ERRCODE(2 <= radix && radix <= 36, EINVAL);
		length = 0;

		p = buf;

		if( is_neg ) 
		{
			// negative, so output '-' and negate
			*p++ = '-';	
			length++;
			val = (unsigned long)(-(long)val);
		}

		firstdig = p;           // save pointer to first digit

		do 
		{
			digval = (unsigned) (val % radix);
			val /= radix;       // get next digit

			// convert to ascii and store
			if( digval > 9 )
			{
				*p++ = (char) ( digval - 10 + 'a' );  // a letter
			}
			else
			{
				*p++ = (char) ( digval + '0' );       // a digit
			}
			length++;
		} while( val > 0 && length < sizeInChars );

		// Check for buffer overrun
		if( length >= sizeInChars )
		{
			buf[ 0 ] = '\0';
			//_VALIDATE_RETURN_ERRCODE(length < sizeInTChars, ERANGE);
		}
		// We now have the digit of the number in the buffer, but in reverse
		// order.  Thus we reverse them now.

		*p-- = '\0';            // terminate string; p points to last digit

		do 
		{
			temp = *p;
			*p = *firstdig;
			*firstdig = temp;   // swap *p and *firstdig
			--p;
			++firstdig;         // advance to next two digits
		} while( firstdig < p ); // repeat until halfway

		return 0;
	}

}//nsWin32
