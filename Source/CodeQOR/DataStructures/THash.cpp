//THash.cpp

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.


#include <stdlib.h>
#include "AppocritaQOR/Event.h"
#include "CodeQOR/DataStructures/THash.h"

/*#include <qbitarray.h>
#include <qstring.h>
#include <qglobal.h>
#include <qbytearray.h>
#include <qdatetime.h>
#include <qbasicatomic.h>
#include <private/qsimd_p.h>

#ifndef QT_BOOTSTRAPPED
#include <qcoreapplication.h>
#endif // QT_BOOTSTRAPPED

#ifdef Q_OS_UNIX
#include <stdio.h>
#include "private/qcore_unix_p.h"
#endif // Q_OS_UNIX
*/
#include <limits.h>

//------------------------------------------------------------------------------
namespace nsCodeQOR
{
	/*
		The Java's hashing algorithm for strings is a variation of D. J. Bernstein
		hashing algorithm appeared here http://cr.yp.to/cdb/cdb.txt
		and informally known as DJB33XX - DJB's 33 Times Xor.
		Java uses DJB31XA, that is, 31 Times Add.

		The original algorithm was a loop around
			(h << 5) + h ^ c
		(which is indeed h*33 ^ c); it was then changed to
			(h << 5) - h ^ c
		(so h*31^c: DJB31XX), and the XOR changed to a sum:
			(h << 5) - h + c
		(DJB31XA), which can save some assembly instructions.

		Still, we can avoid writing the multiplication as "(h << 5) - h"
		-- the compiler will turn it into a shift and an addition anyway
		(for instance, gcc 4.4 does that even at -O0).
	*/

	//------------------------------------------------------------------------------
	static inline bool hasFastCrc32()
	{
		return false;
	}
	/*
	//------------------------------------------------------------------------------
	static unsigned int crc32(...)
	{
		//Q_UNREACHABLE();
		return 0;
	}
	*/
	//------------------------------------------------------------------------------
	static inline unsigned int hash( const unsigned char* p, int len, unsigned int seed ) __QCMP_NO_THROW
	{
		unsigned int h = seed;

		for( int i = 0; i < len; ++i )
		{
			h = 31 * h + p[i];
		}

		return h;
	}

	//------------------------------------------------------------------------------
	unsigned int qHashBits(const void *p, size_t len, unsigned int seed) __QCMP_NO_THROW
	{
		return hash( static_cast< const unsigned char* >( p ), int( len ), seed );
	}

	//------------------------------------------------------------------------------
	static inline unsigned int hash( const Char* p, int len, unsigned int seed) __QCMP_NO_THROW
	{
		unsigned int h = seed;

		for (int i = 0; i < len; ++i)
		{
			h = 31 * h + p[i].Unicode();
		}

		return h;
	}
		/*
	//------------------------------------------------------------------------------
	unsigned int qHash(const QByteArray &key, unsigned int seed) __QCMP_NO_THROW
	{
		return hash(reinterpret_cast<const unsigned char *>(key.constData()), key.size(), seed);
	}

	//------------------------------------------------------------------------------
	unsigned int qHash(const QString &key, unsigned int seed) __QCMP_NO_THROW
	{
		return hash(key.unicode(), key.size(), seed);
	}

	//------------------------------------------------------------------------------
	unsigned int qHash(const QStringRef &key, unsigned int seed) __QCMP_NO_THROW
	{
		return hash(key.unicode(), key.size(), seed);
	}

	//------------------------------------------------------------------------------
	unsigned int qHash(const QBitArray &bitArray, unsigned int seed) __QCMP_NO_THROW
	{
		int m = bitArray.d.size() - 1;
		unsigned int result = hash(reinterpret_cast<const unsigned char *>(bitArray.d.constData()), qMax(0, m), seed);

		// deal with the last 0 to 7 bits manually, because we can't trust that
		// the padding is initialized to 0 in bitArray.d
		int n = bitArray.size();
		if (n & 0x7)
		{
			result = ((result << 4) + bitArray.d.at(m)) & ((1 << n) - 1);
		}
		return result;
	}

	//------------------------------------------------------------------------------
	unsigned int qHash(QLatin1String key, unsigned int seed) __QCMP_NO_THROW
	{
		return hash(reinterpret_cast<const unsigned char *>(key.data()), key.size(), seed);
	}
	*/
	/*!
		\internal

		Creates the CTHash random seed from various sources.
		In order of decreasing precedence:
		- under Unix, it attemps to read from /dev/urandom;
		- under Unix, it attemps to read from /dev/random;
		- under Windows, it attempts to use rand_s;
		- as a general fallback, the application's PID, a timestamp and the
		  address of a stack-local variable are used.
	*/
	static unsigned int qt_create_qhash_seed()
	{
		unsigned int seed = 0;
		/*
	#ifndef QT_BOOTSTRAPPED
		QByteArray envSeed = qgetenv("QT_HASH_SEED");
		if (!envSeed.isNull())
			return envSeed.toUInt();

	#ifdef Q_OS_UNIX
		int randomfd = qt_safe_open("/dev/urandom", O_RDONLY);
		if (randomfd == -1)
			randomfd = qt_safe_open("/dev/random", O_RDONLY | O_NONBLOCK);
		if (randomfd != -1) {
			if (qt_safe_read(randomfd, reinterpret_cast<char *>(&seed), sizeof(seed)) == sizeof(seed)) {
				qt_safe_close(randomfd);
				return seed;
			}
			qt_safe_close(randomfd);
		}
	#endif // Q_OS_UNIX

	#if defined(Q_OS_WIN32) && !defined(Q_CC_GNU)
	*/
		errno_t err;
		err = rand_s(&seed);
		/*
		if (err == 0)
			return seed;
		
	#endif // Q_OS_WIN32

		// general fallback: initialize from the current timestamp, pid,
		// and address of a stack-local variable
		Cmp_unsigned__int64 timestamp = QDateTime::currentMSecsSinceEpoch();
		seed ^= timestamp;
		seed ^= (timestamp >> 32);

		Cmp_unsigned__int64 pid = QCoreApplication::applicationPid();
		seed ^= pid;
		seed ^= (pid >> 32);

		Cmp_uint_ptr seedPtr = reinterpret_cast<Cmp_uint_ptr>(&seed);
		seed ^= seedPtr;
	#if QT_POINTER_SIZE == 8
		seed ^= (seedPtr >> 32);
	#endif
	#endif // QT_BOOTSTRAPPED
	*/
		return seed;
	}

	/*
		The CTHash seed itself.
	*/
	__QOR_INTERFACE( __CODEQOR ) int qt_qhash_seed = -1;
	//__QOR_INTERFACE( __CODEQOR ) QBasicAtomicInt qt_qhash_seed = Q_BASIC_ATOMIC_INITIALIZER(-1);

	/*!
		\internal

		Seed == -1 means it that it was not initialized yet.

		We let qt_create_qhash_seed return any unsigned integer,
		but convert it to signed in order to initialize the seed.

		We don't actually care about the fact that different calls to
		qt_create_qhash_seed() might return different values,
		as long as in the end everyone uses the very same value.
	*/
	static void qt_initialize_qhash_seed()
	{
		if (qt_qhash_seed/*.load()*/ == -1) {
			int x(qt_create_qhash_seed() & INT_MAX);
			qt_qhash_seed = x /*.testAndSetRelaxed(-1, x)*/;
		}
	}

	//--------------------------------------------------------------------------------
	/*!
		\internal

		Private copy of the implementation of the Qt 4 qHash algorithm for strings,
		(that is, QChar-based arrays, so all QString-like classes),
		to be used wherever the result is somehow stored or reused across multiple
		Qt versions. The public qHash implementation can change at any time,
		therefore one must not rely on the fact that it will always give the same
		results.

		The qt_hash functions must *never* change their results.
	*/
	/*
	static unsigned int qt_hash( const Char* p, int n ) __QCMP_NO_THROW
	{
		unsigned int h = 0;

		while (n--) 
		{
			h = (h << 4) + (*p++).Unicode();
			h ^= (h & 0xf0000000) >> 23;
			h &= 0x0fffffff;
		}
		return h;
	}
	*/
	/*
	//--------------------------------------------------------------------------------
	unsigned int qt_hash(const QString &key) __QCMP_NO_THROW
	{
		return qt_hash(key.unicode(), key.size());
	}

	//--------------------------------------------------------------------------------
	unsigned int qt_hash(const QStringRef &key) __QCMP_NO_THROW
	{
		return qt_hash(key.unicode(), key.size());
	}
	*/

	//--------------------------------------------------------------------------------
	/*
		The prime_deltas array contains the difference between a power
		of two and the next prime number:

		prime_deltas[i] = nextprime(2^i) - 2^i

		Basically, it's sequence A092131 from OEIS, assuming:
		- nextprime(1) = 1
		- nextprime(2) = 2
		and
		- left-extending it for the offset 0 (A092131 starts at i=1)
		- stopping the sequence at i = 28 (the table is big enough...)
	*/

	//--------------------------------------------------------------------------------
	static const unsigned char prime_deltas[] = 
	{
		0,  0,  1,  3,  1,  5,  3,  3,  1,  9,  7,  5,  3, 17, 27,  3,
		1, 29,  3, 21,  7, 17, 15,  9, 43, 35, 15,  0,  0,  0,  0,  0
	};


	//--------------------------------------------------------------------------------
	// The primeForNumBits() function returns the prime associated to a power of two. For example, primeForNumBits(8) returns 257.
	static inline int primeForNumBits(int numBits)
	{
		return (1 << numBits) + prime_deltas[numBits];
	}

	//--------------------------------------------------------------------------------
	//Returns the smallest integer n such that primeForNumBits(n) >= hint.
	static int countBits(int hint)
	{
		int numBits = 0;
		int bits = hint;

		while (bits > 1) 
		{
			bits >>= 1;
			numBits++;
		}

		if (numBits >= (int)sizeof(prime_deltas)) 
		{
			numBits = sizeof(prime_deltas) - 1;
		} 
		else if (primeForNumBits(numBits) < hint) 
		{
			++numBits;
		}
		return numBits;
	}

	// A CTHash has initially around pow(2, MinNumBits) buckets. For example, if MinNumBits is 4, it has 17 buckets.
	const int MinNumBits = 4;

	//--------------------------------------------------------------------------------
	const CHashData* CHashData::shared_null() 
	{
		static const CHashData shNull{
			0, 0, -1/*Q_REFCOUNT_INITIALIZE_STATIC*/, 0, 0, MinNumBits, 0, 0, 0, true, false, 0 };
		return &shNull;
	};

	//--------------------------------------------------------------------------------
	void *CHashData::allocateNode(int nodeAlign)
	{
		void* ptr = malloc( nodeSize );
		//void *ptr = strictAlignment ? qMallocAligned(nodeSize, nodeAlign) : malloc(nodeSize);
		//Q_CHECK_PTR(ptr);
		return ptr;
	}

	//--------------------------------------------------------------------------------
	void CHashData::freeNode(void *node)
	{
		/*if (strictAlignment)
			qFreeAligned(node);
		else*/
			free(node);
	}

	//--------------------------------------------------------------------------------
	CHashData *CHashData::detach_helper(void (*node_duplicate)(Node *, void *), void (*node_delete)(Node *), int inodeSize, int nodeAlign)
	{
		union 
		{
			CHashData *d;
			Node *e;
		};
		if (this == shared_null() )
			qt_initialize_qhash_seed();
		d = new CHashData;
		d->fakeNext = 0;
		d->buckets = 0;
		d->ref = 1;//.initializeOwned();
		d->size = size;
		d->nodeSize = inodeSize;
		d->userNumBits = userNumBits;
		d->numBits = numBits;
		d->numBuckets = numBuckets;
		d->seed = unsigned int(qt_qhash_seed/*.load()*/);
		d->sharable = true;
		d->strictAlignment = nodeAlign > 8;
		d->reserved = 0;

		if (numBuckets) 
		{
			try
			{
				d->buckets = new Node *[numBuckets];
			} 
			catch(...) 
			{
				// restore a consistent state for d
				d->numBuckets = 0;
				// roll back
				d->free_helper(node_delete);
				throw;
			}

			Node *this_e = reinterpret_cast<Node *>(this);
			for (int i = 0; i < numBuckets; ++i) 
			{
				Node **nextNode = &d->buckets[i];
				Node *oldNode = buckets[i];
				while (oldNode != this_e) 
				{
					try
					{
						Node *dup = static_cast<Node *>(allocateNode(nodeAlign));

						try
						{
							node_duplicate(oldNode, dup);
						} 
						catch(...) 
						{
							freeNode( dup );
							throw;
						}

						*nextNode = dup;
						nextNode = &dup->next;
						oldNode = oldNode->next;
					} 
					catch(...) 
					{
						// restore a consistent state for d
						*nextNode = e;
						d->numBuckets = i+1;
						// roll back
						d->free_helper(node_delete);
						throw;
					}
				}
				*nextNode = e;
			}
		}
		return d;
	}

	//--------------------------------------------------------------------------------
	void CHashData::free_helper( void (*node_delete)(Node *) )
	{
		if (node_delete) 
		{
			Node *this_e = reinterpret_cast<Node *>(this);
			Node **bucket = reinterpret_cast<Node **>(this->buckets);

			int n = numBuckets;
			while (n--) 
			{
				Node *cur = *bucket++;
				while (cur != this_e) 
				{
					Node *next = cur->next;
					node_delete(cur);
					freeNode(cur);
					cur = next;
				}
			}
		}
		delete [] buckets;
		delete this;
	}

	//--------------------------------------------------------------------------------
	CHashData::Node* CHashData::nextNode( Node* node )
	{
		union 
		{
			Node* next;
			Node* e;
			CHashData* d;
		};
		next = node->next;
		//Q_ASSERT_X(next, "CTHash", "Iterating beyond end()");
		if( next->next )
		{
			return next;
		}

		int start = ( node->h % d->numBuckets ) + 1;
		Node** bucket = d->buckets + start;
		int n = d->numBuckets - start;
		while( n-- ) 
		{
			if( *bucket != e )
			{
				return *bucket;
			}
			++bucket;
		}
		return e;
	}

	//--------------------------------------------------------------------------------
	CHashData::Node* CHashData::previousNode( Node* node )
	{
		union 
		{
			Node* e;
			CHashData* d;
		};

		e = node;
		while( e->next )
		{
			e = e->next;
		}

		int start;
		if( node == e )
		{
			start = d->numBuckets - 1;
		}
		else
		{
			start = node->h % d->numBuckets;
		}

		Node* sentinel = node;
		Node** bucket = d->buckets + start;
		while( start >= 0 ) 
		{
			if( *bucket != sentinel ) 
			{
				Node* prev = *bucket;
				while( prev->next != sentinel )
				{
					prev = prev->next;
				}
				return prev;
			}

			sentinel = e;
			--bucket;
			--start;
		}
		//Q_ASSERT_X(start >= 0, "CTHash", "Iterating backward beyond begin()");
		return e;
	}

	//--------------------------------------------------------------------------------
	// If hint is negative, -hint gives the approximate number of buckets that should be used for the hash table. If hint is
	//  nonnegative, (1 << hint) gives the approximate number of buckets that should be used.
	void CHashData::rehash( int hint )
	{
		if( hint < 0 ) 
		{
			hint = countBits( -hint );
			if( hint < MinNumBits )
			{
				hint = MinNumBits;
			}
			userNumBits = static_cast< short >( hint );
			while( primeForNumBits( hint ) < ( size >> 1 ) )
			{
				++hint;
			}
		} 
		else if( hint < MinNumBits ) 
		{
			hint = MinNumBits;
		}

		if( numBits != hint ) 
		{
			Node* e = reinterpret_cast< Node* >( this );
			Node** oldBuckets = buckets;
			int oldNumBuckets = numBuckets;

			int nb = primeForNumBits( hint );
			buckets = new Node*[nb];
			numBits = static_cast< short >( hint );
			numBuckets = nb;
			for( int i = 0; i < numBuckets; ++i )
			{
				buckets[ i ] = e;
			}

			for( int i = 0; i < oldNumBuckets; ++i ) 
			{
				Node* firstNode = oldBuckets[ i ];
				while( firstNode != e ) 
				{
					unsigned int h = firstNode->h;
					Node* lastNode = firstNode;
					while( lastNode->next != e && lastNode->next->h == h )
					{
						lastNode = lastNode->next;
					}
					Node* afterLastNode = lastNode->next;
					Node** beforeFirstNode = &buckets[ h % numBuckets ];
					while( *beforeFirstNode != e )
					{
						beforeFirstNode = &(*beforeFirstNode)->next;
					}
					lastNode->next = *beforeFirstNode;
					*beforeFirstNode = firstNode;
					firstNode = afterLastNode;
				}
			}
			delete [] oldBuckets;
		}
	}

	//--------------------------------------------------------------------------------
	unsigned int qHash( float key, unsigned int seed ) __QCMP_NO_THROW
	{
		return key != 0.0f ? hash( reinterpret_cast< const unsigned char* >( &key ), sizeof( key ), seed ) : seed ;
	}

	//--------------------------------------------------------------------------------
	unsigned int qHash( double key, unsigned int seed ) __QCMP_NO_THROW
	{
		return key != 0.0  ? hash( reinterpret_cast< const unsigned char* >( &key ), sizeof( key ), seed) : seed ;
	}

	//--------------------------------------------------------------------------------
	unsigned int qHash( long double key, unsigned int seed ) __QCMP_NO_THROW
	{
		return key != 0.0L ? hash( reinterpret_cast< const unsigned char* >( &key ), sizeof( key ), seed ) : seed ;
	}


}//nsCodeQOR

