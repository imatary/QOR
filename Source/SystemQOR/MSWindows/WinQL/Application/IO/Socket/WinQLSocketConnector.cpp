//WinQLSocketConnector.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/Application/IO/Socket/WinQLSocketConnector.h"
#include "WinQL/Application/Threading/WinQLEvent.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	__QOR_IMPLEMENT_OCLASS_LUID( CSocketConnector );

	//--------------------------------------------------------------------------------
	CSocketConnector::CSocketConnector( nsBluefoot::CBFConnectionPool* pPool ) : nsBluefoot::CBFPlug( pPool )
	,	m_Type( CSocket::Sock_Stream )
	,	m_AddressFamily( CSocket::AF_INet )
	,	m_iProtocol( CSocket::IPProto_TCP )
	,	m_AddressSize( 0 )
	,	m_pProtocolInfo( 0 )
	,	m_uiGroup( 0 )
	,	m_ulFlags( 0 )
	{
		_WINQ_FCONTEXT( "CSocketConnector::CSocketConnector" );
		memset( &m_Address, 0, sizeof( CSocket::Address ) );
	}

	//--------------------------------------------------------------------------------
	CSocketConnector::~CSocketConnector()
	{
		_WINQ_FCONTEXT( "CSocketConnector::~CSocketConnector" );
		if( m_bConnected )
		{
			Disconnect();
		}		
	}

	//--------------------------------------------------------------------------------
	void CSocketConnector::SetAddress( CSocket::Internet_SocketAddress& Addr )
	{
		m_AddressFamily = static_cast< CSocket::eAddressFamily >( Addr.sin_family );
		memcpy( &m_Address.sa_data, &Addr.sin_port, 6 );
		m_AddressSize = 16;
	}

	//--------------------------------------------------------------------------------
	void CSocketConnector::SetAddress( byte* pAddress, unsigned int uiByteCount )
	{
		if( uiByteCount > 60 ) 
		{
			uiByteCount = 60;
		}

		//m_AddressSize = uiByteCount + 2;
		memcpy( &m_Address.sa_data, pAddress, uiByteCount );
	}

	//--------------------------------------------------------------------------------
	void CSocketConnector::SetType( CSocket::eType Type )
	{
		m_Type = Type;
	}

	//--------------------------------------------------------------------------------
	CSocket::eType CSocketConnector::GetType( void )
	{
		return m_Type;
	}

	//--------------------------------------------------------------------------------
	void CSocketConnector::SetAddressFamily( CSocket::eAddressFamily AddressFamily )
	{
		m_AddressFamily = AddressFamily;
	}

	//--------------------------------------------------------------------------------
	CSocket::eAddressFamily CSocketConnector::GetAddressFamily( void )
	{
		return m_AddressFamily;
	}

	//--------------------------------------------------------------------------------
	void CSocketConnector::SetProtocol( int iProtocol )
	{
		m_iProtocol = iProtocol;
	}

	//--------------------------------------------------------------------------------
	int CSocketConnector::GetProtocol( void )
	{
		return m_iProtocol;
	}

	//--------------------------------------------------------------------------------
	void CSocketConnector::SetProtocolInfo( WSAProtocolInfo* pInfo )
	{
		m_pProtocolInfo = pInfo;
	}

	//--------------------------------------------------------------------------------
	WSAProtocolInfo* CSocketConnector::GetProtocolInfo( void )
	{
		return m_pProtocolInfo;
	}

	//--------------------------------------------------------------------------------
	void CSocketConnector::SetGroup( unsigned int uiGroup )
	{
		m_uiGroup = uiGroup;
	}

	//--------------------------------------------------------------------------------
	unsigned int CSocketConnector::GetGroup( void )
	{
		return m_uiGroup;
	}

	//--------------------------------------------------------------------------------
	void CSocketConnector::SetFlags( unsigned long ulFlags )
	{
		m_ulFlags = ulFlags;
	}

	//--------------------------------------------------------------------------------
	unsigned long CSocketConnector::GetFlags( void )
	{
		return m_ulFlags;
	}

	//--------------------------------------------------------------------------------
	bool CSocketConnector::Connect()
	{
		_WINQ_FCONTEXT( "CSocketConnector::Connect" );
		
		m_Socket.Create( m_AddressFamily, m_Type, m_iProtocol, m_pProtocolInfo, m_uiGroup, m_ulFlags  );

		if( m_Socket.ID() != 0 && m_Socket.ID() != (Cmp_uint_ptr)(-1) )
		{
			m_Address.sa_family = static_cast< unsigned short >( m_AddressFamily );
			m_bConnected = m_Socket.Connect( &m_Address, 16 ) == 0 ? true : false;

			if( !AsyncConnection() )
			{
				m_bConnected ? OnConnected() : OnConnectionError();
			}
		}
		return m_bConnected;
	}

	//--------------------------------------------------------------------------------
	void CSocketConnector::Disconnect()
	{
		_WINQ_FCONTEXT( "CSocketConnector::Disconnect" );

		m_Socket.Shutdown( 0 );

		m_bConnected = false;
		if( !AsyncConnection() )
		{
			//bClosed ? OnDisconnected() : OnDisconnectionError();
		}
	}

	//--------------------------------------------------------------------------------
	bool CSocketConnector::HandlePendingConnectionResult( bool bConnected )
	{
		_WINQ_FCONTEXT( "CSocketConnector::HandlePendingConnectionResult" );

		if( bConnected ) 
		{			
			return true;
		}

		return false;
		/*
		switch( m_ErrorHelper.GetLastError() ) 
		{ 
		// The overlapped connection in progress. 
		case ErrorIOPending: 
			bPendingIO = true; 
			break; 
   
		// Client is already connected, so signal an event.    
		case ErrorPipeConnected: 
			{
				OVERLAPPED* pOverlapped = reinterpret_cast< OVERLAPPED* >( GetSyncObject() );
				CSyncHandle tmpHandle( pOverlapped->hEvent, true ); 
				CEvent tmpEvent( tmpHandle );
				if( tmpEvent.Set() ) 
				{
					tmpHandle.Drop();
					break; 
				}
			}   
		// If an error occurs during the connect operation... 
		default: 
			{
				//printf("ConnectNamedPipe failed with %d.\n", GetLastError());
				return false;
			}
		} 

		return bPendingIO;		
		*/
	}


}//nsWin32

