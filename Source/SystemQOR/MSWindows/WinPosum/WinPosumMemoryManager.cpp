//WinPosumMemoryManager.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Posum Memory Manager for Windows

//sbrk implementation for Windows from Joerg Walter http://www.genesys-e.org/jwalter/mix4win.htm

#include "PosumQOR.h"
#include "SystemQOR.h"
#include "PosumQOR/MSWindows/WinMemoryManager.h"
#include "WinQL/Application/Threading/WinQLThread.h"

//--------------------------------------------------------------------------------
namespace nsWinPosum
{
	//--------------------------------------------------------------------------------
	__QOR_IMPLEMENT_OCLASS_LUID( CMemoryManager );

	long CMemoryManager::g_sl = 0;

	//--------------------------------------------------------------------------------
	CMemoryManager::CMemoryManager()
	{
	}

	//--------------------------------------------------------------------------------
	CMemoryManager::~CMemoryManager()
	{
	}

	//--------------------------------------------------------------------------------
	// Wait for spin lock
	long CMemoryManager::slwait( long* sl ) 
	{
		while( m_InterlockedHelper.CompareExchange( sl, 1, 0 ) != 0 ) 
		{
			nsWin32::CThread::GetCurrent()->Sleep( 0 );
		}
		return 0;
	}

	//--------------------------------------------------------------------------------
	// Release spin lock
	long CMemoryManager::slrelease( long* sl ) 
	{
		m_InterlockedHelper.Exchange( sl, 0 );
		return 0;
	}


	//--------------------------------------------------------------------------------
	// Allocate and link a region entry in the region list
	int CMemoryManager::region_list_append( region_list_entry** last, void* base_reserved, long reserve_size ) 
	{
		region_list_entry* next = reinterpret_cast< region_list_entry* >( m_Win32Allocator.Allocate( sizeof( region_list_entry ), 0 ) );
		if( !next )
		{
			return 0;
		}
		next->top_allocated = (char *) base_reserved;
		next->top_committed = (char *) base_reserved;
		next->top_reserved = (char *) base_reserved + reserve_size;
		next->reserve_size = reserve_size;
		next->previous = *last;
		*last = next;
		return 1;
	}

	//--------------------------------------------------------------------------------
	// Free and unlink the last region entry from the region list
	int CMemoryManager::region_list_remove( region_list_entry** last ) 
	{
		region_list_entry *previous = (*last)->previous;
		m_Win32Allocator.Free( *last );
		*last = previous;
		return 1;
	}
	
	//--------------------------------------------------------------------------------
	long CMemoryManager::getpagesize( void ) 
	{
		static long g_pagesize = 0;
		if (! g_pagesize) 
		{
			nsWin32::SystemInfo system_info;
			m_SystemInfo.GetSystemInfo( &system_info );			
			g_pagesize = system_info.dwPageSize;
		}
		return g_pagesize;
	}

	//--------------------------------------------------------------------------------
	long CMemoryManager::getregionsize( void ) 
	{
		static long g_regionsize = 0;
		if (! g_regionsize) 
		{
			nsWin32::SystemInfo system_info;
			m_SystemInfo.GetSystemInfo( &system_info );			
			g_regionsize = system_info.dwAllocationGranularity;
		}
		return g_regionsize;
	}

#define CEIL(size,to)	(((size)+(to)-1)&~((to)-1))
#define FLOOR(size,to)	((size)&~((to)-1))
#define SBRK_SCALE  0

	//--------------------------------------------------------------------------------
	void* CMemoryManager::SetBreak( long size )
	{

		static long g_pagesize, g_my_pagesize;
		static long g_regionsize, g_my_regionsize;
		static region_list_entry *g_last;
		void* result = (void*)-1;//TODO: SBRK_FAILURE;

		// Wait for spin lock
		slwait( &g_sl );

		// First time initialization
		if( !g_pagesize ) 
		{
			g_pagesize = getpagesize ();
			g_my_pagesize = g_pagesize << SBRK_SCALE;
		}

		if( !g_regionsize ) 
		{
			g_regionsize = getregionsize ();
			g_my_regionsize = g_regionsize << SBRK_SCALE;
		}

		if( !g_last) 
		{
			if( !region_list_append( &g_last, 0, 0 ) ) 
			goto sbrk_exit;
		}

		// Allocation requested?
		if( size >= 0 ) 
		{
	        // Allocation size is the requested size
			long allocate_size = size;
			// Compute the size to commit
			long to_reserve = (char *) g_last->top_allocated + allocate_size - (char *) g_last->top_reserved;
			// Do we reach the commit limit?
			if( to_reserve > 0 ) 
			{
				// Now we are going to search and reserve.
				int contiguous = -1;
				int found = 0;
				nsWin32::MEMORY_BASIC_INFORMATION memory_info;
				void *base_reserved;
				long reserve_size;
				do 
				{
					// Assume contiguous memory
					contiguous = 1;
					// Round size to reserve
					reserve_size = CEIL (to_reserve, g_my_regionsize);
					// Start with the current region's top 
					memory_info.BaseAddress = g_last->top_reserved;
					while( m_VirtualMemHelper.Query( memory_info.BaseAddress, &memory_info, sizeof( memory_info ) ) ) 
					{
						// Region is free, well aligned and big enough: we are done
						if( memory_info.State == m_VirtualMemHelper.MemFree && (unsigned) memory_info.BaseAddress % g_regionsize == 0 && memory_info.RegionSize >= (unsigned) reserve_size ) 
						{
							found = 1;
							break;
						}

						// From now on we can't get contiguous memory!
						contiguous = 0;
						// Recompute size to reserve
						reserve_size = CEIL( allocate_size, g_my_regionsize );
						memory_info.BaseAddress = (char*)memory_info.BaseAddress + memory_info.RegionSize;
					}
                
					// Search failed?
					if(!found) 
					{
						goto sbrk_exit;
					}
                
					// Try to reserve this
					base_reserved = m_VirtualMemHelper.Alloc( memory_info.BaseAddress, reserve_size, m_VirtualMemHelper.MemReserve | m_VirtualMemHelper.MemCommit, m_VirtualMemHelper.PageReadWrite );
					if( !base_reserved ) 
					{
						int rc = m_ErrorHelper.GetLastError ();
						if( rc != nsWin32::ErrorInvalidAddress ) 
						{
							goto sbrk_exit;
						}
					}

					// A null pointer signals (hopefully) a race condition with another thread.
					// In this case, we try again.
				} while( !base_reserved );

				// Check returned pointer for consistency
				if( memory_info.BaseAddress && base_reserved != memory_info.BaseAddress )
				{
					goto sbrk_exit;
				}

				// Did we get contiguous memory?
				if( contiguous ) 
				{
					long start_size = (char*)g_last->top_reserved - (char*)g_last->top_allocated;
					// Adjust allocation size
					allocate_size -= start_size;
					// Adjust the regions allocation top
					g_last->top_allocated = g_last->top_reserved;
				} 
            
				// Append the new region to the list
				if( !region_list_append( &g_last, base_reserved, reserve_size ) )
				{
					goto sbrk_exit;
				}
			} 

			// Adjust the regions allocation top
			g_last->top_allocated = (char*)g_last->top_allocated + allocate_size;
			result = (char*)g_last->top_allocated - size;
		// Deallocation requested?
		} 
		else if( size < 0 ) 
		{
			long deallocate_size = - size;
			// As long as we have a region to release
			while( (char*)g_last->top_allocated - deallocate_size < (char*)g_last->top_reserved - g_last->reserve_size ) 
			{
				// Get the size to release
				long release_size = g_last->reserve_size;
				// Get the base address
				void* base_reserved = (char*)g_last->top_reserved - release_size;
				// Release this
				int rc = m_VirtualMemHelper.Free( base_reserved, 0, m_VirtualMemHelper.MemRelease );

				// Check returned code for consistency 
				if( !rc )
				{
					goto sbrk_exit;
				}
				// Adjust deallocation size
				deallocate_size -= (char *) g_last->top_allocated - (char *) base_reserved;
				// Remove the old region from the list
				if( !region_list_remove( &g_last ) )
				{
					goto sbrk_exit;
				}
			}

			// Adjust regions allocate top
			g_last->top_allocated = (char*)g_last->top_allocated - deallocate_size;
			// Check for underflow
			if( (char*)g_last->top_reserved - g_last->reserve_size > (char*)g_last->top_allocated || g_last->top_allocated > g_last->top_reserved ) 
			{
				// Adjust regions allocate top 
				g_last->top_allocated = (char*)g_last->top_reserved - g_last->reserve_size;
				goto sbrk_exit;
			}
			result = g_last->top_allocated;
		}

		sbrk_exit:
		// Release spin lock
		slrelease( &g_sl );
		return result;
	}

}//nsWinPosum

