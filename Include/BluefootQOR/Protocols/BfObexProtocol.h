//BfObexProtocol.h

// Copyright Querysoft Limited 2016
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef BLUEFOOT_OBEXPROTOCOL_H_3
#define BLUEFOOT_OBEXPROTOCOL_H_3

//Defines an Obex protocol

#include "CodeQOR/Text/TString.h"
#include "CodeQOR/Text/Char16.h"
#include "AppocritaQOR/Workflow.h"
#include "BluefootQOR/BfProtocol.h"
#include "BluefootQOR/Protocols/OBEX/ObexSession.h"
#include "arpa/inet.h"

//------------------------------------------------------------------------------
namespace nsBluefoot
{
	//------------------------------------------------------------------------------
	//A common base class for all Obex Protocol States
	class __QOR_INTERFACE(__BLUEFOOTQOR) CObexState : public nsQOR::CState
	{
	public:

		//------------------------------------------------------------------------------
		CObexState(nsQOR::IWorkflow::ref_type pWorkflow) : nsQOR::CState(pWorkflow)
		{
			m_ulBytesToRead = 0;
			m_ulBytesToWrite = 0;
		}

		//------------------------------------------------------------------------------
		virtual void OnEnter(nsQOR::IEvent::ref_type _event)
		{
			m_ulBytesToRead = GetTotalBytesToRead();
			m_ulBytesToWrite = GetTotalBytesToWrite();
		}

		virtual void ProcessReadSequence(nsQOR::IEvent::ref_type _event, byte* pSequence, unsigned long ulBytes) = 0;

		//------------------------------------------------------------------------------
		bool operator()(nsQOR::IEvent::ref_type _event, int iCookie)
		{
			switch (iCookie)
			{
			case CProtocol::CProtocolState::ReadSuccess:
			{
				CBuffer* pBuffer = m_pWorkflow.As< CProtocol >()->GetInPipe()->GetSource()->GetBuffer();

				unsigned long ulBytes = m_ulBytesToRead;
				byte* pSequence = pBuffer->ReadRequest(ulBytes);
				//CObexHeaderReadProtocol* pHeaderReadProtocol = m_pWorkflow.As< CObexHeaderReadProtocol >();

				if (ulBytes == m_ulBytesToRead)
				{
					pBuffer->ReadAcknowledge(ulBytes);
					ProcessReadSequence(_event, pSequence, ulBytes);
					return true;
				}
			}
			break;
			case CProtocol::CProtocolState::WriteSuccess:
			{

			}
			break;
			}
			return false;
		}

		//------------------------------------------------------------------------------
		virtual unsigned long GetNextReadCount(void) { return m_ulBytesToRead; }
		//------------------------------------------------------------------------------
		virtual unsigned long GetNextWriteCount(void) { return m_ulBytesToWrite; }
		//------------------------------------------------------------------------------
		virtual unsigned long GetTotalBytesToRead(void) const {	return 0; }
		//------------------------------------------------------------------------------
		virtual unsigned long GetTotalBytesToWrite(void) const { return 0; }

	protected:

		unsigned long m_ulBytesToRead;
		unsigned long m_ulBytesToWrite;
	};

	//------------------------------------------------------------------------------
	class CSetMode : public nsQOR::CEvent
	{
	public:

		//------------------------------------------------------------------------------
		CSetMode() : CEvent()
		{
		}

		void Mode(nsOBEX::mode Mode) 
		{ m_Mode = Mode; }


	protected:

		nsOBEX::mode m_Mode;
		friend class CObexProtocol;
	};

	//------------------------------------------------------------------------------
	class CCommandConnect : public nsQOR::CEvent
	{
	public:

		//------------------------------------------------------------------------------
		CCommandConnect() : CEvent()
		{
		}

	protected:

		friend class CObexProtocol;
	};

	//------------------------------------------------------------------------------
	class __QOR_INTERFACE(__BLUEFOOTQOR) CObexProtocol : public CProtocol//Workflow
	{
	public:

		//--------------------------------------------------------------------------------
		enum eObexSessionEvents
		{
			eSetMode = 100,
			eConnect,
		};

		CSetMode m_SetMode;

		//------------------------------------------------------------------------------
		//Initial
		class InitialState : public nsQOR::CState
		{
		public:
			InitialState(IWorkflow::ref_type pWorkflow) : nsQOR::CState(pWorkflow) {}

			virtual bool operator()(nsQOR::IEvent::ref_type _event, int iCookie)
			{
				CObexProtocol* pObexProtocol = m_pWorkflow.As<CObexProtocol>();
				switch (iCookie)
				{
				case eSetMode:
				{
					pObexProtocol->SetMode(_event);
				}
				break;
				}
			}
			virtual void OnEnter(nsQOR::IEvent::ref_type pEvent) {}
			virtual void OnLeave(nsQOR::IEvent::ref_type pEvent) {}
			virtual void OnSuspend(nsQOR::IEvent::ref_type pEvent) {}
			virtual void OnResume(nsQOR::IEvent::ref_type pEvent) {}

		}m_InitialState;

		//------------------------------------------------------------------------------
		//Client
		class ClientState : public nsQOR::CState
		{
		public:
			ClientState(IWorkflow::ref_type pWorkflow) : nsQOR::CState(pWorkflow) {}

			//------------------------------------------------------------------------------
			virtual bool operator()(nsQOR::IEvent::ref_type _event, int iCookie)
			{
				//Handle events corresponding to the client commands

				CObexProtocol* pObexProtocol = m_pWorkflow.As<CObexProtocol>();
				switch (iCookie)
				{
				case eConnect:

					pObexProtocol->Connect(_event);

				}
				/*	CMD_CONNECT	= 0x00,
					CMD_DISCONNECT	= 0x01,
					CMD_PUT		= 0x02,
					CMD_GET		= 0x03,
					CMD_SETPATH	= 0x05,
					CMD_ACTION		= 0x06,
					CMD_SESSION	= 0x07, //< used for reliable session support
					CMD_ABORT = 0x7f,
				*/
			}
			virtual void OnEnter(nsQOR::IEvent::ref_type pEvent) {}
			virtual void OnLeave(nsQOR::IEvent::ref_type pEvent) {}
			virtual void OnSuspend(nsQOR::IEvent::ref_type pEvent)
			{
				//not listening to commands any more 
				//possibly still process them but queue them up
			}
			virtual void OnResume(nsQOR::IEvent::ref_type pEvent)
			{
				//process any queued commands
			}

			//------------------------------------------------------------------------------
			virtual unsigned long GetNextReadCount(void) { return 0; }
			//------------------------------------------------------------------------------
			virtual unsigned long GetNextWriteCount(void) { return 0; }
		}m_ClientState;

			//------------------------------------------------------------------------------
			class ClientConnectingState : public nsQOR::CState
			{
			public:
				ClientConnectingState(IWorkflow::ref_type pWorkflow) : nsQOR::CState(pWorkflow) {}

				//------------------------------------------------------------------------------
				virtual bool operator()(nsQOR::IEvent::ref_type _event, int iCookie)
				{
				}
				virtual void OnEnter(nsQOR::IEvent::ref_type pEvent) 
				{
					CProtocol* pProtocol = m_pWorkflow.As< CProtocol >();
					pProtocol->PushState( pProtocol->m_WritingState.Ref(), pEvent);
				}
				virtual void OnLeave(nsQOR::IEvent::ref_type pEvent) {}
				virtual void OnSuspend(nsQOR::IEvent::ref_type pEvent)
				{
				}
				virtual void OnResume(nsQOR::IEvent::ref_type pEvent)
				{
				}

				//------------------------------------------------------------------------------
				virtual unsigned long GetNextReadCount(void) { return 0; }
				//------------------------------------------------------------------------------
				virtual unsigned long GetNextWriteCount(void) { return 0; }
			}m_ClientConnectingState;

			//nsQOR::State m_ClientSendingState;
			//Client_Sending
				//Initial
				//Object Begin
				//Header Begin
				//Header
				//Body Begin
				//Body
			//nsQOR::State m_ClientRecievingState;
			//Client_Recieving
				//Inital
				//uint8Header
				//uint32Header
				//UNICODEHeader
				//UNICODEHeaderData
				//BytesHeader
				//BytesHeaderData
		//------------------------------------------------------------------------------
		//Server
		class ServerState : public nsQOR::CState
		{
		public:
			ServerState(IWorkflow::ref_type pWorkflow) : nsQOR::CState(pWorkflow) {}

			virtual bool operator()(nsQOR::IEvent::ref_type _event, int iCookie);
			virtual void OnEnter(nsQOR::IEvent::ref_type pEvent);
			virtual void OnLeave(nsQOR::IEvent::ref_type pEvent);
			virtual void OnSuspend(nsQOR::IEvent::ref_type pEvent);
			virtual void OnResume(nsQOR::IEvent::ref_type pEvent);

		}m_ServerState;
			//Listening
			//Connecting
			//Reading
			//Writing

		CObexProtocol() = delete;
		CObexProtocol(nsQOR::IApplication::ref_type Application) : CProtocol(Application), m_InitialState(Ref()) {}
		virtual ~CObexProtocol() {}
		CObexProtocol(const CObexProtocol& src) : m_InitialState(Ref()) { *this = src; }
		CObexProtocol& operator = (const CObexProtocol& src) { return *this; }

		//------------------------------------------------------------------------------
		virtual nsQOR::IState::ref_type InitialState(void) const
		{
			return m_InitialState.Ref();
		}

		virtual void GetNextReadCount(void) { CurrentState().As< CObexState >()->GetNextReadCount(); }
		virtual void GetNextWriteCount(void) {}

		//------------------------------------------------------------------------------
		void SetMode(nsQOR::IEvent::ref_type pEvent)
		{
			if( m_SetMode.m_Mode == nsOBEX::MODE_CLIENT )
			{
				m_Session.InitializeClientSession();
				SetState(m_ClientState.Ref(), pEvent);
			}
			else if( m_SetMode.m_Mode == nsOBEX::MODE_SERVER )
			{
				m_Session.InitializeServerSession();
				SetState(m_ServerState.Ref(), pEvent);
			}
		}

		//------------------------------------------------------------------------------
		void Connect(nsQOR::IEvent::ref_type pEvent)
		{
			m_Session.Connect();
			PushState(m_ClientConnectingState.Ref(), pEvent);
		}

	private:

		nsOBEX::CSession m_Session;
	};



	/*
	//------------------------------------------------------------------------------
	class __QOR_INTERFACE(__BLUEFOOTQOR) CObexHeaderReadProtocol : public CProtocolWorkflow
	{
	public:

		//------------------------------------------------------------------------------
		class CObexReadState: public CProtocolWorkflow::State
		{
		public:

			//------------------------------------------------------------------------------
			CObexReadState(IWorkflow::ref_type pWorkflow) : CProtocolWorkflow::State(pWorkflow)
			{
				m_ulBytesToRead = 0;
			}

			//------------------------------------------------------------------------------
			void OnEnter(nsQOR::IEvent::ref_type _event)
			{
				m_ulBytesToRead = GetTotalBytesToRead();
			}

			virtual void ProcessSequenceToHeaderData(nsQOR::IEvent::ref_type _event, byte* pSequence, unsigned long ulBytes) = 0;

			//------------------------------------------------------------------------------
			bool operator()(nsQOR::IEvent::ref_type _event, int iCookie)
			{
				if (iCookie == CProtocol::CProtocolState::ReadSuccess)
				{	
					CBuffer* pBuffer = m_pWorkflow.As< CProtocolWorkflow >()->GetProtocol()->GetInPipe()->GetSource()->GetBuffer();

					unsigned long ulBytes = m_ulBytesToRead;
					byte* pSequence = pBuffer->ReadRequest(ulBytes);
					CObexHeaderReadProtocol* pHeaderReadProtocol = m_pWorkflow.As< CObexHeaderReadProtocol >();

					if (ulBytes == m_ulBytesToRead)
					{
						pBuffer->ReadAcknowledge(ulBytes);
						ProcessSequenceToHeaderData(_event, pSequence, ulBytes);
						return true;
					}
				}
				return false;
			}

			//------------------------------------------------------------------------------
			virtual unsigned long GetNextReadCount(void) { return m_ulBytesToRead; }
			//------------------------------------------------------------------------------
			virtual unsigned long GetNextWriteCount(void) { return 0; }

			virtual unsigned long GetTotalBytesToRead(void) const = 0;

		protected:

			unsigned long m_ulBytesToRead;

		};

		//------------------------------------------------------------------------------
		class CUInt32HeaderReadState : public CObexReadState
		{
		public:

			//------------------------------------------------------------------------------
			CUInt32HeaderReadState(IWorkflow::ref_type pWorkflow) : CObexReadState(pWorkflow) {}

			//------------------------------------------------------------------------------
			virtual void ProcessSequenceToHeaderData(nsQOR::IEvent::ref_type _event, byte* pSequence, unsigned long ulBytes)
			{								
				CObexHeaderReadProtocol* pHeaderReadProtocol = m_pWorkflow.As< CObexHeaderReadProtocol >();
				pHeaderReadProtocol->m_HeaderData.data.bq4 = *(reinterpret_cast<uint32_t*>(pSequence));
				pHeaderReadProtocol->AddHeaderFromInput(_event);
			}

			//------------------------------------------------------------------------------
			virtual unsigned long GetTotalBytesToRead(void) const
			{
				return sizeof(uint32_t);
			}


		}m_UInt32HeaderReadState;

		//------------------------------------------------------------------------------
		class CUInt8HeaderReadState : public CObexReadState
		{
		public:

			//------------------------------------------------------------------------------
			CUInt8HeaderReadState(IWorkflow::ref_type pWorkflow) : CObexReadState(pWorkflow) {}

			//------------------------------------------------------------------------------
			virtual void ProcessSequenceToHeaderData(nsQOR::IEvent::ref_type _event, byte* pSequence, unsigned long ulBytes)
			{
				CObexHeaderReadProtocol* pHeaderReadProtocol = m_pWorkflow.As< CObexHeaderReadProtocol >();
				pHeaderReadProtocol->m_HeaderData.data.bq1 = pSequence[ 0 ];
				pHeaderReadProtocol->AddHeaderFromInput(_event);
			}

			//------------------------------------------------------------------------------
			virtual unsigned long GetTotalBytesToRead(void) const
			{
				return sizeof(uint8_t);
			}

		}m_UInt8HeaderReadState;

		//------------------------------------------------------------------------------
		class CBytesHeaderReadState : public CObexReadState
		{
		public:

			//------------------------------------------------------------------------------
			CBytesHeaderReadState(IWorkflow::ref_type pWorkflow) : CObexReadState(pWorkflow) {}

			//------------------------------------------------------------------------------
			virtual void ProcessSequenceToHeaderData(nsQOR::IEvent::ref_type _event, byte* pSequence, unsigned long ulBytes)
			{
				CObexHeaderReadProtocol* pHeaderReadProtocol = m_pWorkflow.As< CObexHeaderReadProtocol >();
				uint16_t hSize = *(reinterpret_cast<uint16_t*>(pSequence));
				pHeaderReadProtocol->m_HeaderData.size = ntohs(hSize) - 3;
				pHeaderReadProtocol->m_HeaderData.data.bs = pSequence + 2;
				m_pWorkflow->SetState(pHeaderReadProtocol->m_BytesReadState.Ref(), _event);
			}

			//------------------------------------------------------------------------------
			virtual unsigned long GetTotalBytesToRead(void) const
			{
				return sizeof(uint16_t);
			}
		}m_BytesHeaderReadState;

		//------------------------------------------------------------------------------
		class CUnicodeHeaderReadState : public CObexReadState
		{
		public:

			//------------------------------------------------------------------------------
			CUnicodeHeaderReadState(IWorkflow::ref_type pWorkflow) : CObexReadState(pWorkflow){}

			//------------------------------------------------------------------------------
			virtual void ProcessSequenceToHeaderData(nsQOR::IEvent::ref_type _event, byte* pSequence, unsigned long ulBytes)
			{
				CObexHeaderReadProtocol* pHeaderReadProtocol = m_pWorkflow.As< CObexHeaderReadProtocol >();
				uint16_t hSize = *(reinterpret_cast<uint16_t*>(pSequence));
				pHeaderReadProtocol->m_HeaderData.size = ntohs(hSize) - 3;
				pHeaderReadProtocol->m_HeaderData.data.bs = pSequence + 2;
				//Move on to the ReadString state
				m_pWorkflow->SetState(pHeaderReadProtocol->m_UnicodeStringReadState.Ref(), _event);
			}

			//------------------------------------------------------------------------------
			virtual unsigned long GetTotalBytesToRead(void) const
			{
				return sizeof(uint16_t);
			}

		}m_UnicodeHeaderReadState;

		//------------------------------------------------------------------------------
		class CUnicodeStringReadState : public CObexReadState
		{
		public:

			//------------------------------------------------------------------------------
			CUnicodeStringReadState(IWorkflow::ref_type pWorkflow) : CObexReadState(pWorkflow) {}

			//------------------------------------------------------------------------------
			virtual void ProcessSequenceToHeaderData(nsQOR::IEvent::ref_type _event, byte* pSequence, unsigned long ulBytes)
			{
				CObexHeaderReadProtocol* pHeaderReadProtocol = m_pWorkflow.As< CObexHeaderReadProtocol >();
				nsCodeQOR::CUCS2String strData(const_cast< const nsCodeQOR::CChar16* >(reinterpret_cast< nsCodeQOR::CChar16* >(pSequence)), ulBytes / sizeof(nsCodeQOR::CChar16));
				pHeaderReadProtocol->m_CurrentObject.AddHeader(new nsOBEX::CDescriptionHeader(pHeaderReadProtocol->m_HeaderData, strData));				
			}

			//------------------------------------------------------------------------------
			virtual unsigned long GetTotalBytesToRead(void) const
			{
				CObexHeaderReadProtocol* pHeaderReadProtocol = m_pWorkflow.As< CObexHeaderReadProtocol >();
				return pHeaderReadProtocol->m_HeaderData.size;
			}

		}m_UnicodeStringReadState;

		//------------------------------------------------------------------------------
		class CBytesReadState : public CObexReadState
		{
		public:

			//------------------------------------------------------------------------------
			CBytesReadState(IWorkflow::ref_type pWorkflow) : CObexReadState(pWorkflow) {}

			//------------------------------------------------------------------------------
			virtual void ProcessSequenceToHeaderData(nsQOR::IEvent::ref_type _event, byte* pSequence, unsigned long ulBytes)
			{
				CObexHeaderReadProtocol* pHeaderReadProtocol = m_pWorkflow.As< CObexHeaderReadProtocol >();
				pHeaderReadProtocol->m_HeaderData.data.bs = pSequence;
				pHeaderReadProtocol->AddHeaderFromInput(_event);
			}

			//------------------------------------------------------------------------------
			virtual unsigned long GetTotalBytesToRead(void) const
			{
				CObexHeaderReadProtocol* pHeaderReadProtocol = m_pWorkflow.As< CObexHeaderReadProtocol >();
				return pHeaderReadProtocol->m_HeaderData.size;
			}
		
		}m_BytesReadState;

		//------------------------------------------------------------------------------
		class CInitialState : public CObexReadState
		{
		public:

			//------------------------------------------------------------------------------
			CInitialState(IWorkflow::ref_type pWorkflow) : CObexReadState(pWorkflow)
			{
			}

			//------------------------------------------------------------------------------
			virtual void ProcessSequenceToHeaderData(nsQOR::IEvent::ref_type _event, byte* pSequence, unsigned long ulBytes)
			{
				CObexHeaderReadProtocol* pHeaderReadProtocol = m_pWorkflow.As< CObexHeaderReadProtocol >();
				pHeaderReadProtocol->m_HeaderData.id = static_cast<nsOBEX::obex_hdr_id>(pSequence[0] & nsOBEX::HDR_ID_MASK);
				pHeaderReadProtocol->m_HeaderData.type = static_cast<nsOBEX::obex_hdr_type>(pSequence[0] & nsOBEX::HDR_TYPE_MASK);

				switch (pHeaderReadProtocol->m_HeaderData.type)
				{
				case nsOBEX::HDR_TYPE_UNICODE:
					pHeaderReadProtocol->SetState(pHeaderReadProtocol->m_UnicodeHeaderReadState.Ref(), _event);
					break;
				case nsOBEX::HDR_TYPE_BYTES:
					pHeaderReadProtocol->SetState(pHeaderReadProtocol->m_BytesHeaderReadState.Ref(), _event);
					break;
				case nsOBEX::HDR_TYPE_UINT8:
					pHeaderReadProtocol->SetState(pHeaderReadProtocol->m_UInt8HeaderReadState.Ref(), _event);
					break;
				case nsOBEX::HDR_TYPE_UINT32:
					pHeaderReadProtocol->SetState(pHeaderReadProtocol->m_UInt32HeaderReadState.Ref(), _event);
					break;
				default:
					break;
				}
			}

			virtual unsigned long GetTotalBytesToRead(void) const { return 1; }

		}m_InitialState;

		CObexHeaderReadProtocol() = delete;
		CObexHeaderReadProtocol(nsQOR::IApplication::ref_type Application) : CProtocolWorkflow(Application), m_InitialState( Ref() ) {}
		virtual ~CObexHeaderReadProtocol() {}
		CObexHeaderReadProtocol(const CObexHeaderReadProtocol& src) : m_InitialState( Ref() ) { *this = src; }
		CObexHeaderReadProtocol& operator = (const CObexHeaderReadProtocol& src) { return *this; }

		//------------------------------------------------------------------------------
		virtual nsQOR::IState::ref_type InitialState(void) const
		{
			return m_InitialState.Ref();
		}

		virtual unsigned long GetNextReadCount(void) { return CurrentState().As< CObexReadState >()->GetNextReadCount(); }
		virtual unsigned long GetNextWriteCount(void) { return 0; }

		//------------------------------------------------------------------------------
		virtual void AddHeaderFromInput(nsQOR::IEvent::ref_type _event)
		{
			switch (m_HeaderData.type)
			{
			case nsOBEX::HDR_ID_COUNT:					//Construct a CountHeader out of the header data
				m_CurrentObject.AddHeader(new nsOBEX::CCountHeader(m_HeaderData, m_HeaderData.data.bq4));
				break;
			case nsOBEX::HDR_ID_LENGTH:					// Total length of object			
				m_CurrentObject.AddHeader(new nsOBEX::CLengthHeader(m_HeaderData, m_HeaderData.data.bq4));
				break;
			case nsOBEX::HDR_ID_CONNECTION:				// Connection identifier			
				m_CurrentObject.AddHeader(new nsOBEX::CConnectionIDHeader(m_HeaderData, m_HeaderData.data.bq4));
				break;
			case nsOBEX::HDR_ID_TYPE:					// ASCII Type of the object - mime type hurrah!
				m_CurrentObject.AddHeader(new nsOBEX::CMIMETypeHeader(m_HeaderData, m_HeaderData.data.bs));
				break;
			case nsOBEX::HDR_ID_TIME:					// Last modification time of (ISO8601)
				break;
			case nsOBEX::HDR_ID_TARGET:					// Identifies the target for the object - Well known Sequence?
				break;
			case nsOBEX::HDR_ID_HTTP:					// An HTTP 1.x header
				break;
			case nsOBEX::HDR_ID_WHO:					// Identifies the sender of the object
				break;
			case nsOBEX::HDR_ID_APPARAM:				// Application parameters - Tag-Length-Value, Higher Level Protocol
				break;
			case nsOBEX::HDR_ID_AUTHCHAL:				// Authentication challenge - Tag-Length-Value, Higher Level Protocol
				break;
			case nsOBEX::HDR_ID_AUTHRESP:				// Authentication response - Tag-Length-Value, Higher Level Protocol
				break;
			case nsOBEX::HDR_ID_CREATOR:				// indicates the creator of an object - Unknown?
				break;
			case nsOBEX::HDR_ID_WANUUID:				// uniquely identifies the network client (OBEX server) - Unknown? presumably 128 bits
				break;
			case nsOBEX::HDR_ID_OBJECTCLASS:			// OBEX Object class of object - Unknown?
				break;
			case nsOBEX::HDR_ID_SESSIONPARAM:			// Parameters used in session commands/responses - Unknown?
				break;
			case nsOBEX::HDR_ID_SESSIONSEQ:				// Sequence number used in each OBEX packet for reliability - Unknwown?
				break;
			case nsOBEX::HDR_ID_ACTION_ID:				// Specifies the action for the ACTION command - Unknown?
				break;
			case nsOBEX::HDR_ID_DESTNAME:				// Destination object name - Unknown?
				break;
			case nsOBEX::HDR_ID_PERMISSIONS:			// bit mask for setting permissions - Unknown?
				break;
			case nsOBEX::HDR_ID_SRM:					// response mode selection
				break;
			case nsOBEX::HDR_ID_SRM_FLAGS:				// flags for single response mode
				break;

												
												//BODY		OBEX_HDR_ID_BODY = 8,				// Data part of the object
												//BODY-END	OBEX_HDR_ID_BODY_END = 9,			// Last data part of the object
												

			}

			memset(&m_HeaderData, 0, sizeof(nsOBEX::obex_headerdata_t));
		}		

	protected:

		nsOBEX::obex_headerdata_t m_HeaderData;
		nsOBEX::CObject m_CurrentObject;
	};
	*/
}//nsBluefoot

#endif//BLUEFOOT_OBEXPROTOCOL_H_3
