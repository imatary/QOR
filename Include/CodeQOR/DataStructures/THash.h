//THash.h

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Hash template

#ifndef CODEQOR_DATASTRUCTS_HASH_H_3
#define CODEQOR_DATASTRUCTS_HASH_H_3

#include "CompilerQOR.h"

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "CodeQOR/Traits/Policy.h"
#include "CodeQOR/Text/Char.h"
#include <limits>
#include <list>

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
	//--------------------------------------------------------------------------------
	__QOR_INTERFACE( __CODEQOR )  unsigned int qHashBits( const void* p, size_t size, unsigned int seed = 0 ) __QCMP_NO_THROW;

	//--------------------------------------------------------------------------------
	__QCMP_INLINE unsigned int qHash( char key, unsigned int seed = 0 ) __QCMP_NO_THROW 
	{ 
		return unsigned int(key) ^ seed; 
	}

	//--------------------------------------------------------------------------------
	__QCMP_INLINE unsigned int qHash( unsigned char key, unsigned int seed = 0) __QCMP_NO_THROW 
	{ 
		return unsigned int(key) ^ seed; 
	}

	//--------------------------------------------------------------------------------
	__QCMP_INLINE unsigned int qHash( signed char key, unsigned int seed = 0 ) __QCMP_NO_THROW 
	{ 
		return unsigned int(key) ^ seed; 
	}

	//--------------------------------------------------------------------------------
	__QCMP_INLINE unsigned int qHash( unsigned short key, unsigned int seed = 0 ) __QCMP_NO_THROW 
	{ 
		return unsigned int(key) ^ seed; 
	}

	//--------------------------------------------------------------------------------
	__QCMP_INLINE unsigned int qHash(short key, unsigned int seed = 0) __QCMP_NO_THROW 
	{ 
		return unsigned int(key) ^ seed; 
	}

	//--------------------------------------------------------------------------------
	__QCMP_INLINE unsigned int qHash( unsigned int key, unsigned int seed = 0 ) __QCMP_NO_THROW 
	{ 
		return key ^ seed; 
	}

	//--------------------------------------------------------------------------------
	__QCMP_INLINE unsigned int qHash( int key, unsigned int seed = 0 ) __QCMP_NO_THROW 
	{ 
		return unsigned int(key) ^ seed; 
	}

	//--------------------------------------------------------------------------------
	__QCMP_INLINE unsigned int qHash( unsigned long key, unsigned int seed = 0) __QCMP_NO_THROW
	{
		return (sizeof(unsigned long) > sizeof(unsigned int))
			? (unsigned int(((key >> (8 * sizeof(unsigned int) - 1)) ^ key) & (~0U)) ^ seed)
			: (unsigned int(key & (~0U)) ^ seed);
	}

	//--------------------------------------------------------------------------------
	__QCMP_INLINE unsigned int qHash( long key, unsigned int seed = 0 ) __QCMP_NO_THROW 
	{ 
		return qHash( unsigned long(key), seed); 
	}

	//--------------------------------------------------------------------------------
	__QCMP_INLINE unsigned int qHash( Cmp_unsigned__int64 key, unsigned int seed = 0) __QCMP_NO_THROW
	{
		return unsigned int(((key >> (8 * sizeof(unsigned int) - 1)) ^ key) & (~0U)) ^ seed;
	}

	//--------------------------------------------------------------------------------
	__QCMP_INLINE unsigned int qHash( Cmp_signed__int64 key, unsigned int seed = 0) __QCMP_NO_THROW 
	{ 
		return qHash(Cmp_unsigned__int64(key), seed); 
	}

	__QOR_INTERFACE( __CODEQOR )  unsigned int qHash( float key, unsigned int seed = 0 ) __QCMP_NO_THROW;
	__QOR_INTERFACE( __CODEQOR )  unsigned int qHash( double key, unsigned int seed = 0 ) __QCMP_NO_THROW;
	__QOR_INTERFACE( __CODEQOR )  unsigned int qHash( long double key, unsigned int seed = 0 ) __QCMP_NO_THROW;

	//--------------------------------------------------------------------------------
	__QCMP_INLINE unsigned int qHash( const Char key, unsigned int seed = 0 ) __QCMP_NO_THROW 
	{ 
		return qHash(key.Unicode(), seed); 
	}

	//--------------------------------------------------------------------------------
	template< class T > __QCMP_INLINE unsigned int qHash( const T* key, unsigned int seed = 0 ) __QCMP_NO_THROW
	{
		return qHash( reinterpret_cast< Cmp_uint_ptr >( key ), seed );
	}

	//--------------------------------------------------------------------------------
	template<typename T> __QCMP_INLINE unsigned int qHash( const T& t, unsigned int seed )
	{ 
		return (qHash(t) ^ seed); 
	}

	//--------------------------------------------------------------------------------
	template< typename T1, typename T2 > __QCMP_INLINE unsigned int qHash( const std::pair< T1, T2 > &key, unsigned int seed = 0 )
	{
		unsigned int h1 = qHash(key.first, seed);
		unsigned int h2 = qHash(key.second, seed);
		return ((h1 << 16) | (h1 >> 16)) ^ h2 ^ seed;
	}


	//--------------------------------------------------------------------------------
	struct __QOR_INTERFACE( __CODEQOR ) CHashData
	{
		//--------------------------------------------------------------------------------
		struct __QOR_INTERFACE( __CODEQOR ) Node 
		{
			Node* next;
			unsigned int h;
		};

		Node* fakeNext;
		Node** buckets;
		long ref;
		int size;
		int nodeSize;
		short userNumBits;
		short numBits;
		int numBuckets;
		unsigned int seed;
		unsigned int sharable : 1;
		unsigned int strictAlignment : 1;
		unsigned int reserved : 30;

		void* allocateNode( int nodeAlign );
		void freeNode( void* node );
		CHashData* detach_helper( void (*node_duplicate)( Node*, void * ), void (*node_delete)( Node* ), int nodeSize, int nodeAlign );
		bool willGrow();
		void hasShrunk();
		void rehash( int hint );
		void free_helper( void (*node_delete)( Node* ) );
		Node* firstNode();

		static Node* nextNode( Node* node );
		static Node* previousNode( Node* node );
		static const CHashData* shared_null( void );
	};

	//--------------------------------------------------------------------------------
	__QCMP_INLINE bool CHashData::willGrow()
	{
		if( size >= numBuckets ) 
		{
			rehash( numBits + 1 );
			return true;
		} 
		else 
		{
			return false;
		}
	}

	//--------------------------------------------------------------------------------
	__QCMP_INLINE void CHashData::hasShrunk()
	{
		if( size <= ( numBuckets >> 3 ) && numBits > userNumBits ) 
		{
			rehash( std::max( int( numBits ) - 2, int( userNumBits ) ) );
		}
	}

	//--------------------------------------------------------------------------------
	__QCMP_INLINE CHashData::Node* CHashData::firstNode()
	{
		Node* e = reinterpret_cast< Node* >( this );
		Node** bucket = buckets;
		int n = numBuckets;
		while( n-- ) 
		{
			if( *bucket != e )
			{
				return *bucket;
			}
			++bucket;
		}
		return e;
	}

	//--------------------------------------------------------------------------------
	struct CHashDummyValue
	{
	};

	//--------------------------------------------------------------------------------
	__QCMP_INLINE bool operator == ( const CHashDummyValue & , const CHashDummyValue & )
	{
		return true;
	}

	//--------------------------------------------------------------------------------
	template< class Key, class T >
	struct CHashNode
	{
		CHashNode* next;
		const unsigned int h;
		const Key key;
		T value;

		//--------------------------------------------------------------------------------
		__QCMP_INLINE CHashNode( const Key& key0, const T& value0, unsigned int hash, CHashNode* n ) : next( n )
		, h( hash )
		, key( key0 )
		, value( value0 ) 
		{
		}

		//--------------------------------------------------------------------------------
		__QCMP_INLINE bool same_key( unsigned int h0, const Key& key0 ) const 
		{ 
			return h0 == h && key0 == key; 
		}

	private:

		__QCS_DECLARE_NONCOPYABLE( CHashNode );
	};

	//--------------------------------------------------------------------------------
	// Specialize for CHashDummyValue in order to save some memory
	template< class Key >
	struct CHashNode< Key, CHashDummyValue >
	{
		//--------------------------------------------------------------------------------
		union 
		{
			CHashNode* next;
			CHashDummyValue value;
		};

		const unsigned int h;
		const Key key;

		//--------------------------------------------------------------------------------
		__QCMP_INLINE CHashNode( const Key &key0, const CHashDummyValue &, unsigned int hash, CHashNode *n ) : next(n), h(hash), key(key0) 
		{
		}

		//--------------------------------------------------------------------------------
		__QCMP_INLINE bool same_key(unsigned int h0, const Key &key0) const 
		{ 
			return h0 == h && key0 == key; 
		}

	private:

		__QCS_DECLARE_NONCOPYABLE( CHashNode );
	};


	//--------------------------------------------------------------------------------
	template< class Key, class T >
	class CTHash
	{
		typedef CHashNode< Key, T > Node;

		//--------------------------------------------------------------------------------
		union 
		{
			CHashData* d;
			CHashNode< Key, T >* e;
		};

		//--------------------------------------------------------------------------------
		static __QCMP_INLINE Node* concrete( CHashData::Node* node ) 
		{
			return reinterpret_cast< Node* >( node );
		}

		//--------------------------------------------------------------------------------
		static __QCMP_INLINE int alignOfNode() 
		{ 
			return std::max( sizeof(void*), __QCMP_ALIGNOF(Node) ); 
		}

	public:
    
		//--------------------------------------------------------------------------------
		__QCMP_INLINE CTHash() : d( const_cast< CHashData* >( CHashData::shared_null() ) ) 
		{ 
		}

		//--------------------------------------------------------------------------------
		__QCMP_INLINE CTHash( const CTHash< Key, T >& other ) : d( other.d ) 
		{ 
			d->ref.ref(); 
			if( !d->sharable )
			{
				detach(); 
			}
		}

		//--------------------------------------------------------------------------------
		__QCMP_INLINE ~CTHash() 
		{ 
			if( !(--d->ref)/*.deref()*/ ) 
			{
				freeData(d); 
			}
		}

		CTHash<Key, T>& operator = ( const CTHash< Key, T >& other );

		//--------------------------------------------------------------------------------
		__QCMP_INLINE void swap( CTHash< Key, T >& other ) 
		{ 
			qSwap( d, other.d ); 
		}
	
		bool operator == ( const CTHash< Key, T >& other ) const;

		//--------------------------------------------------------------------------------
		__QCMP_INLINE bool operator != ( const CTHash< Key, T > &other) const 
		{ 
			return !(*this == other); 
		}

		//--------------------------------------------------------------------------------
		__QCMP_INLINE int size() const 
		{ 
			return d->size; 
		}

		//--------------------------------------------------------------------------------
		__QCMP_INLINE bool isEmpty() const 
		{ 
			return d->size == 0; 
		}

		//--------------------------------------------------------------------------------
		__QCMP_INLINE int capacity() const 
		{ 
			return d->numBuckets; 
		}

		void reserve(int size);

		//--------------------------------------------------------------------------------
		__QCMP_INLINE void squeeze() 
		{ 
			reserve(1); 
		}

		//--------------------------------------------------------------------------------
		__QCMP_INLINE void detach() 
		{ 
			if( d->ref.isShared() ) 
			{
				detach_helper(); 
			}
		}

		//--------------------------------------------------------------------------------
		__QCMP_INLINE bool isDetached() const 
		{ 
			return !d->ref.isShared(); 
		}

		__QCMP_INLINE bool isSharedWith(const CTHash<Key, T> &other) const { return d == other.d; }

		void clear();

		int remove(const Key &key);
		T take(const Key &key);

		bool contains(const Key &key) const;
		const Key key(const T &value) const;
		const Key key(const T &value, const Key &defaultKey) const;
		const T value(const Key &key) const;
		const T value(const Key &key, const T &defaultValue) const;
		T &operator[](const Key &key);
		const T operator[](const Key &key) const;

		std::list< Key > uniqueKeys() const;
		std::list< Key > keys() const;
		std::list< Key > keys(const T &value) const;
		std::list< T > values() const;
		std::list< T > values(const Key &key) const;
		int count(const Key &key) const;

		class const_iterator;

		//--------------------------------------------------------------------------------
		class iterator
		{
			friend class const_iterator;
			friend class CTHash< Key, T >;
			CHashData::Node* i;

		public:

			typedef std::bidirectional_iterator_tag iterator_category;
			typedef Cmp_int_ptr difference_type;
			typedef T value_type;
			typedef T* pointer;
			typedef T& reference;

			//--------------------------------------------------------------------------------
			__QCMP_INLINE iterator() : i( 0 ) 
			{ 
			}

			//--------------------------------------------------------------------------------
			explicit __QCMP_INLINE iterator( void* node ) : i( reinterpret_cast< CHashData::Node* >( node ) ) 
			{ 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE const Key &key() const 
			{ 
				return concrete(i)->key; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE T &value() const 
			{ 
				return concrete(i)->value; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE T &operator*() const 
			{ 
				return concrete(i)->value; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE T *operator->() const 
			{ 
				return &concrete(i)->value; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE bool operator==(const iterator &o) const 
			{ 
				return i == o.i; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE bool operator!=(const iterator &o) const 
			{ 
				return i != o.i; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE iterator &operator++() 
			{
				i = CHashData::nextNode(i);
				return *this;
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE iterator operator++(int) 
			{
				iterator r = *this;
				i = CHashData::nextNode(i);
				return r;
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE iterator &operator--() 
			{
				i = CHashData::previousNode(i);
				return *this;
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE iterator operator--(int) 
			{
				iterator r = *this;
				i = CHashData::previousNode(i);
				return r;
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE iterator operator+(int j) const
			{ 
				iterator r = *this; 
				if (j > 0) while (j--) ++r; 
				else while (j++) --r; 
				return r; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE iterator operator-(int j) const 
			{ 
				return operator+(-j); 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE iterator &operator+=(int j) 
			{ 
				return *this = *this + j; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE iterator &operator-=(int j) 
			{ 
				return *this = *this - j; 
			}

		public:

			//--------------------------------------------------------------------------------
			__QCMP_INLINE bool operator==(const const_iterator &o) const
			{ 
				return i == o.i; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE bool operator!=(const const_iterator &o) const
			{ 
				return i != o.i; 
			}
		};

		friend class iterator;

		//--------------------------------------------------------------------------------
		class const_iterator
		{
			friend class iterator;
			CHashData::Node *i;

		public:

			typedef std::bidirectional_iterator_tag iterator_category;
			typedef Cmp_int_ptr difference_type;
			typedef T value_type;
			typedef const T *pointer;
			typedef const T &reference;

			//--------------------------------------------------------------------------------
			__QCMP_INLINE const_iterator() : i(0) 
			{ 
			}

			//--------------------------------------------------------------------------------
			explicit __QCMP_INLINE const_iterator(void *node) : i(reinterpret_cast<CHashData::Node *>(node)) 
			{ 
			}


			//--------------------------------------------------------------------------------
			__QCMP_INLINE const_iterator(const iterator &o)
			{ 
				i = o.i; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE const Key &key() const 
			{ 
				return concrete(i)->key; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE const T &value() const 
			{ 
				return concrete(i)->value; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE const T &operator*() const 
			{ 
				return concrete(i)->value; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE const T *operator->() const 
			{ 
				return &concrete(i)->value; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE bool operator==(const const_iterator &o) const 
			{ 
				return i == o.i; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE bool operator!=(const const_iterator &o) const 
			{ 
				return i != o.i; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE const_iterator &operator++() 
			{
				i = CHashData::nextNode(i);
				return *this;
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE const_iterator operator++(int) 
			{
				const_iterator r = *this;
				i = CHashData::nextNode(i);
				return r;
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE const_iterator &operator--() 
			{
				i = CHashData::previousNode(i);
				return *this;
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE const_iterator operator--(int) 
			{
				const_iterator r = *this;
				i = CHashData::previousNode(i);
				return r;
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE const_iterator operator+(int j) const
			{ 
				const_iterator r = *this; if (j > 0) while (j--) ++r; else while (j++) --r; return r; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE const_iterator operator-(int j) const 
			{ 
				return operator+(-j); 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE const_iterator &operator+=(int j) 
			{ 
				return *this = *this + j; 
			}

			//--------------------------------------------------------------------------------
			__QCMP_INLINE const_iterator &operator-=(int j) 
			{ 
				return *this = *this - j; 
			}

		};

		friend class const_iterator;

		// STL style
		//--------------------------------------------------------------------------------
		__QCMP_INLINE iterator begin() 
		{ 
			detach(); 
			return iterator(d->firstNode()); 
		}

		//--------------------------------------------------------------------------------
		__QCMP_INLINE const_iterator begin() const 
		{ 
			return const_iterator(d->firstNode()); 
		}

		//--------------------------------------------------------------------------------
		__QCMP_INLINE const_iterator cbegin() const 
		{ 
			return const_iterator(d->firstNode()); 
		}

		//--------------------------------------------------------------------------------
		__QCMP_INLINE const_iterator constBegin() const 
		{ 
			return const_iterator(d->firstNode()); 
		}

		//--------------------------------------------------------------------------------
		__QCMP_INLINE iterator end() 
		{ 
			detach(); return iterator(e); 
		}

		//--------------------------------------------------------------------------------
		__QCMP_INLINE const_iterator end() const 
		{ 
			return const_iterator(e); 
		}

		//--------------------------------------------------------------------------------
		__QCMP_INLINE const_iterator cend() const 
		{ 
			return const_iterator(e); 
		}

		//--------------------------------------------------------------------------------
		__QCMP_INLINE const_iterator constEnd() const 
		{ 
			return const_iterator(e); 
		}

		iterator erase(iterator it);

		// more
		typedef iterator Iterator;
		typedef const_iterator ConstIterator;

		//--------------------------------------------------------------------------------
		__QCMP_INLINE int count() const 
		{ 
			return d->size; 
		}

		iterator find(const Key &key);
		const_iterator find(const Key &key) const;
		const_iterator constFind(const Key &key) const;
		iterator insert(const Key &key, const T &value);
		iterator insertMulti(const Key &key, const T &value);
		CTHash<Key, T> &unite(const CTHash<Key, T> &other);

		// STL compatibility
		typedef T mapped_type;
		typedef Key key_type;
		typedef Cmp_int_ptr difference_type;
		typedef int size_type;

		//--------------------------------------------------------------------------------
		__QCMP_INLINE bool empty() const 
		{ 
			return isEmpty(); 
		}

	private:

		void detach_helper();
		void freeData( CHashData* d );
		Node** findNode( const Key& key, unsigned int* hp = 0 ) const;
		Node* createNode( unsigned int h, const Key& key, const T& value, Node** nextNode );
		void deleteNode( Node* node );
		static void deleteNode2( CHashData::Node* node );

		static void duplicateNode( CHashData::Node* originalNode, void* newNode );

		//--------------------------------------------------------------------------------
		bool isValidIterator(const iterator &it) const
		{
			__QCS_UNUSED(it);
			return true;
		}

	};

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE void CTHash<Key, T>::deleteNode(Node *node)
	{
		deleteNode2(reinterpret_cast<CHashData::Node*>(node));
		d->freeNode(node);
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE void CTHash<Key, T>::deleteNode2(CHashData::Node *node)
	{
		//#ifdef Q_CC_BOR
		//concrete(node)->~CHashNode<Key, T>();
		concrete(node)->~Node();
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE void CTHash<Key, T>::duplicateNode(CHashData::Node *node, void *newNode)
	{
		Node *concreteNode = concrete(node);
		new (newNode) Node(concreteNode->key, concreteNode->value, concreteNode->h, 0);
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE typename CTHash<Key, T>::Node *
	CTHash<Key, T>::createNode(unsigned int ah, const Key &akey, const T &avalue, Node **anextNode)
	{
		Node *node = new (d->allocateNode(alignOfNode())) Node(akey, avalue, ah, *anextNode);
		*anextNode = node;
		++d->size;
		return node;
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE CTHash<Key, T> &CTHash<Key, T>::unite(const CTHash<Key, T> &other)
	{
		CTHash<Key, T> copy(other);
		const_iterator it = copy.constEnd();
		while (it != copy.constBegin()) 
		{
			--it;
			insertMulti(it.key(), it.value());
		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	void CTHash<Key, T>::freeData(CHashData *x)
	{
		x->free_helper(deleteNode2);
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE void CTHash<Key, T>::clear()
	{
		*this = CTHash<Key,T>();
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	void CTHash<Key, T>::detach_helper()
	{
		CHashData *x = d->detach_helper(duplicateNode, deleteNode2, sizeof(Node), alignOfNode());
		if (!d->ref.deref())
			freeData(d);
		d = x;
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE CTHash<Key, T> &CTHash<Key, T>::operator=(const CTHash<Key, T> &other)
	{
		if (d != other.d) {
			CHashData *o = other.d;
			o->ref.ref();
			if (!d->ref.deref())
				freeData(d);
			d = o;
			if (!d->sharable)
				detach_helper();
		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE const T CTHash<Key, T>::value(const Key &akey) const
	{
		Node *node;
		if (d->size == 0 || (node = *findNode(akey)) == e) {
			return T();
		} else {
			return node->value;
		}
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE const T CTHash<Key, T>::value(const Key &akey, const T &adefaultValue) const
	{
		Node *node;
		if (d->size == 0 || (node = *findNode(akey)) == e) {
			return adefaultValue;
		} else {
			return node->value;
		}
	}

	//--------------------------------------------------------------------------------
	template< class Key, class T >
	std::list< Key > CTHash< Key, T >::uniqueKeys() const
	{
		std::list< Key > res;
		res.reserve( size() ); // May be too much, but assume short lifetime
		const_iterator i = begin();
		if (i != end()) 
		{
			for (;;) 
			{
				const Key &aKey = i.key();
				res.append(aKey);
				do 
				{
					if( ++i == end() )
					{
						goto break_out_of_outer_loop;
					}
				} while( aKey == i.key() );
			}
		}
	break_out_of_outer_loop:
		return res;
	}

	//--------------------------------------------------------------------------------
	template< class Key, class T >
	std::list< Key > CTHash< Key, T >::keys() const
	{
		std::list< Key > res;
		res.reserve( size() );
		const_iterator i = begin();
		while( i != end() ) 
		{
			res.append( i.key() );
			++i;
		}
		return res;
	}

	//--------------------------------------------------------------------------------
	template< class Key, class T >
	std::list< Key > CTHash< Key, T >::keys( const T& avalue ) const
	{
		std::list< Key > res;
		const_iterator i = begin();
		while( i != end() ) 
		{
			if( i.value() == avalue )
			{
				res.append( i.key() );
			}
			++i;
		}
		return res;
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	const Key CTHash<Key, T>::key(const T &avalue) const
	{
		return key(avalue, Key());
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	const Key CTHash<Key, T>::key(const T &avalue, const Key &defaultValue) const
	{
		const_iterator i = begin();
		while (i != end()) {
			if (i.value() == avalue)
				return i.key();
			++i;
		}

		return defaultValue;
	}

	//--------------------------------------------------------------------------------
	template< class Key, class T >
	std::list< T > CTHash< Key, T >::values() const
	{
		std::list< T > res;
		res.reserve( size() );
		const_iterator i = begin();
		while( i != end() ) 
		{
			res.append( i.value() );
			++i;
		}
		return res;
	}

	//--------------------------------------------------------------------------------
	template< class Key, class T >
	std::list< T > CTHash<Key, T >::values( const Key& akey ) const
	{
		std::list< T > res;
		Node* node = *findNode( akey );
		if (node != e) 
		{
			do 
			{
				res.append(node->value);
			} while( ( node = node->next ) != e && node->key == akey );
		}
		return res;
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	int CTHash<Key, T>::count(const Key &akey) const
	{
		int cnt = 0;
		Node *node = *findNode(akey);
		if (node != e) {
			do {
				++cnt;
			} while ((node = node->next) != e && node->key == akey);
		}
		return cnt;
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE const T CTHash<Key, T>::operator[](const Key &akey) const
	{
		return value(akey);
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE T &CTHash<Key, T>::operator[](const Key &akey)
	{
		detach();

		unsigned int h;
		Node **node = findNode(akey, &h);
		if (*node == e) {
			if (d->willGrow())
				node = findNode(akey, &h);
			return createNode(h, akey, T(), node)->value;
		}
		return (*node)->value;
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE typename CTHash<Key, T>::iterator CTHash<Key, T>::insert(const Key &akey, const T &avalue)
	{
		detach();

		unsigned int h;
		Node **node = findNode(akey, &h);
		if (*node == e) {
			if (d->willGrow())
				node = findNode(akey, &h);
			return iterator(createNode(h, akey, avalue, node));
		}

		if (!QtPrivate::is_same<T, CHashDummyValue>::value)
			(*node)->value = avalue;
		return iterator(*node);
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE typename CTHash<Key, T>::iterator CTHash<Key, T>::insertMulti(const Key &akey, const T &avalue)
	{
		detach();
		d->willGrow();

		unsigned int h;
		Node **nextNode = findNode(akey, &h);
		return iterator(createNode(h, akey, avalue, nextNode));
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	int CTHash<Key, T>::remove(const Key &akey)
	{
		if (isEmpty()) // prevents detaching shared null
			return 0;
		detach();

		int oldSize = d->size;
		Node **node = findNode(akey);
		if (*node != e) {
			bool deleteNext = true;
			do {
				Node *next = (*node)->next;
				deleteNext = (next != e && next->key == (*node)->key);
				deleteNode(*node);
				*node = next;
				--d->size;
			} while (deleteNext);
			d->hasShrunk();
		}
		return oldSize - d->size;
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	 T CTHash<Key, T>::take(const Key &akey)
	{
		if (isEmpty()) // prevents detaching shared null
			return T();
		detach();

		Node **node = findNode(akey);
		if (*node != e) {
			T t = (*node)->value;
			Node *next = (*node)->next;
			deleteNode(*node);
			*node = next;
			--d->size;
			d->hasShrunk();
			return t;
		}
		return T();
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	typename CTHash<Key, T>::iterator CTHash<Key, T>::erase(iterator it)
	{
		Q_ASSERT_X(isValidIterator(it), "CTHash::erase", "The specified iterator argument 'it' is invalid");

		if (it == iterator(e))
			return it;

		if (d->ref.isShared()) {
			int bucketNum = (it.i->h % d->numBuckets);
			iterator bucketIterator(*(d->buckets + bucketNum));
			int stepsFromBucketStartToIte = 0;
			while (bucketIterator != it) {
				++stepsFromBucketStartToIte;
				++bucketIterator;
			}
			detach();
			it = iterator(*(d->buckets + bucketNum));
			while (stepsFromBucketStartToIte > 0) {
				--stepsFromBucketStartToIte;
				++it;
			}
		}

		iterator ret = it;
		++ret;

		Node *node = concrete(it.i);
		Node **node_ptr = reinterpret_cast<Node **>(&d->buckets[node->h % d->numBuckets]);
		while (*node_ptr != node)
			node_ptr = &(*node_ptr)->next;
		*node_ptr = node->next;
		deleteNode(node);
		--d->size;
		return ret;
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE void CTHash<Key, T>::reserve(int asize)
	{
		detach();
		d->rehash(-qMax(asize, 1));
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE typename CTHash<Key, T>::const_iterator CTHash<Key, T>::find(const Key &akey) const
	{
		return const_iterator(*findNode(akey));
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE typename CTHash<Key, T>::const_iterator CTHash<Key, T>::constFind(const Key &akey) const
	{
		return const_iterator(*findNode(akey));
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE typename CTHash<Key, T>::iterator CTHash<Key, T>::find(const Key &akey)
	{
		detach();
		return iterator(*findNode(akey));
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE bool CTHash<Key, T>::contains(const Key &akey) const
	{
		return *findNode(akey) != e;
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	 typename CTHash<Key, T>::Node **CTHash<Key, T>::findNode(const Key &akey,
																				unsigned int *ahp) const
	{
		Node **node;
		unsigned int h = 0;

		if (d->numBuckets || ahp) 
		{
			h = qHash(akey, d->seed);
			if (ahp)
				*ahp = h;
		}

		if (d->numBuckets) 
		{
			node = reinterpret_cast<Node **>(&d->buckets[h % d->numBuckets]);
			Q_ASSERT(*node == e || (*node)->next);
			while (*node != e && !(*node)->same_key(h, akey))
				node = &(*node)->next;
		} 
		else 
		{
			node = const_cast<Node **>(reinterpret_cast<const Node * const *>(&e));
		}
		return node;
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	bool CTHash<Key, T>::operator==(const CTHash<Key, T> &other) const
	{
		if (size() != other.size())
			return false;
		if (d == other.d)
			return true;

		const_iterator it = begin();

		while (it != end()) {
			const Key &akey = it.key();

			const_iterator it2 = other.find(akey);
			do {
				if (it2 == other.end() || !(it2.key() == akey))
					return false;
				if (!(it.value() == it2.value()))
					return false;
				++it;
				++it2;
			} while (it != end() && it.key() == akey);
		}
		return true;
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	class CTMultiHash : public CTHash<Key, T>
	{
	public:
		CTMultiHash() {}

		CTMultiHash(const CTHash<Key, T> &other) : CTHash<Key, T>(other) {}
		__QCMP_INLINE void swap(CTMultiHash<Key, T> &other) { CTHash<Key, T>::swap(other); } // prevent CTMultiHash<->CTHash swaps

		__QCMP_INLINE typename CTHash<Key, T>::iterator replace(const Key &key, const T &value)
		{ return CTHash<Key, T>::insert(key, value); }

		__QCMP_INLINE typename CTHash<Key, T>::iterator insert(const Key &key, const T &value)
		{ return CTHash<Key, T>::insertMulti(key, value); }

		__QCMP_INLINE CTMultiHash &operator+=(const CTMultiHash &other)
		{ this->unite(other); return *this; }
		__QCMP_INLINE CTMultiHash operator+(const CTMultiHash &other) const
		{ CTMultiHash result = *this; result += other; return result; }

	#if !defined(Q_NO_USING_KEYWORD) && !defined(Q_CC_RVCT)
		// RVCT compiler doesn't handle using-keyword right when used functions are overloaded in child class
		using CTHash<Key, T>::contains;
		using CTHash<Key, T>::remove;
		using CTHash<Key, T>::count;
		using CTHash<Key, T>::find;
		using CTHash<Key, T>::constFind;
	#else
		__QCMP_INLINE bool contains(const Key &key) const
		{ return CTHash<Key, T>::contains(key); }
		__QCMP_INLINE int remove(const Key &key)
		{ return CTHash<Key, T>::remove(key); }
		__QCMP_INLINE int count(const Key &key) const
		{ return CTHash<Key, T>::count(key); }
		__QCMP_INLINE int count() const
		{ return CTHash<Key, T>::count(); }
		__QCMP_INLINE typename CTHash<Key, T>::iterator find(const Key &key)
		{ return CTHash<Key, T>::find(key); }
		__QCMP_INLINE typename CTHash<Key, T>::const_iterator find(const Key &key) const
		{ return CTHash<Key, T>::find(key); }
		__QCMP_INLINE typename CTHash<Key, T>::const_iterator constFind(const Key &key) const
		{ return CTHash<Key, T>::constFind(key); }
	#endif

		bool contains(const Key &key, const T &value) const;

		int remove(const Key &key, const T &value);

		int count(const Key &key, const T &value) const;

		typename CTHash<Key, T>::iterator find(const Key &key, const T &value) {
			typename CTHash<Key, T>::iterator i(find(key));
			typename CTHash<Key, T>::iterator end(this->end());
			while (i != end && i.key() == key) {
				if (i.value() == value)
					return i;
				++i;
			}
			return end;
		}
		typename CTHash<Key, T>::const_iterator find(const Key &key, const T &value) const {
			typename CTHash<Key, T>::const_iterator i(constFind(key));
			typename CTHash<Key, T>::const_iterator end(CTHash<Key, T>::constEnd());
			while (i != end && i.key() == key) {
				if (i.value() == value)
					return i;
				++i;
			}
			return end;
		}
		typename CTHash<Key, T>::const_iterator constFind(const Key &key, const T &value) const
			{ return find(key, value); }
	private:
		T &operator[](const Key &key);
		const T operator[](const Key &key) const;
	};

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE bool CTMultiHash<Key, T>::contains(const Key &key, const T &value) const
	{
		return constFind(key, value) != CTHash<Key, T>::constEnd();
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE int CTMultiHash<Key, T>::remove(const Key &key, const T &value)
	{
		int n = 0;
		typename CTHash<Key, T>::iterator i(find(key));
		typename CTHash<Key, T>::iterator end(CTHash<Key, T>::end());
		while (i != end && i.key() == key) {
			if (i.value() == value) {
				i = this->erase(i);
				++n;
			} else {
				++i;
			}
		}
		return n;
	}

	//--------------------------------------------------------------------------------
	template <class Key, class T>
	__QCMP_INLINE int CTMultiHash<Key, T>::count(const Key &key, const T &value) const
	{
		int n = 0;
		typename CTHash<Key, T>::const_iterator i(constFind(key));
		typename CTHash<Key, T>::const_iterator end(CTHash<Key, T>::constEnd());
		while (i != end && i.key() == key) {
			if (i.value() == value)
				++n;
			++i;
		}
		return n;
	}

}// nsCodeQOR

#endif//CODEQOR_DATASTRUCTS_HASH_H_3
