//WinQLDeviceInstanceEnumerator.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/CodeServices/WinQLPolicy.h"
#include "WinQL/Application/Threading/WinQLCriticalSection.h"
#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "WinQL/CodeServices/Text/WinString.h"
#include "WinQL/System/Devices/SetupClasses/WinQLDeviceClassCollection.h"
#include "WinQL/System/Devices/SetupClasses/WinQLDeviceList.h"
#include "WinQL/System/Devices/SetupClasses/WinQLDeviceSetupClass.h"
#include "WinQL/System/Devices/Instances/WinQLDeviceInstanceEnumerator.h"
#include "WinQL/Definitions/Constants.h"
#include "WinQL/GUI/Window.h"
#include "WinQL/System/WinQLSystem.h"
#include "WinQAPI/Kernel32.h"
#include "WinQAPI/SetupAPI.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	using namespace nsWinQAPI;

	//--------------------------------------------------------------------------------
	__QOR_IMPLEMENT_OCLASS_LUID( CDeviceInstanceEnumerator );

	//--------------------------------------------------------------------------------
	CDeviceInstanceEnumerator::CDeviceInstanceEnumerator() : nsQOR::CController(), CSetupAPIBase()
	{		
		//SetModelType( CDeviceInstanceCM::ClassID() );		//The associated Model is a DeviceInstance Collection Model
	}

	//--------------------------------------------------------------------------------
	CDeviceInstanceEnumerator::CDeviceInstanceEnumerator( const CDeviceInstanceEnumerator& src ) : nsQOR::CController( src ), CSetupAPIBase( src )
	{
	}

	//--------------------------------------------------------------------------------
	CDeviceInstanceEnumerator& CDeviceInstanceEnumerator::operator = ( const CDeviceInstanceEnumerator& src )
	{
		if( &src != this )
		{
			nsQOR::CController::operator = ( src );
		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	CDeviceInstanceEnumerator::~CDeviceInstanceEnumerator()
	{
	}

	//--------------------------------------------------------------------------------
	//Enumerate Device Instances given a bus enumerator name
	void CDeviceInstanceEnumerator::Enumerate( CTString& strEnumID )
	{
		/*
		unsigned long ulRequiredSize = 0;
		CDeviceInstanceCM& model( m_Model().As< CDeviceInstanceCM >() );		
		bool bRemote = model.IsRemote();
		const mxTCHAR* szMachineName = bRemote ? model.m_szMachineName : 0;
			
		if( bRemote )
		{
			m_Handle = m_Library.SetupDiGetClassDevsEx( 0, strEnumID, 0, DIGCF_ALLCLASSES | DIGCF_PRESENT, 0, szMachineName );
		}
		else
		{
			m_Handle = m_Library.SetupDiGetClassDevs( 0, strEnumID, 0, DIGCF_ALLCLASSES | DIGCF_PRESENT );
		}
		m_Handle.Attach( this );
		Init();
		*/
	}

	//--------------------------------------------------------------------------------
	//Enumerate Device Instances given a SetupClass identifier
	void CDeviceInstanceEnumerator::Enumerate( nsCodeQOR::mxGUID* pSetupClassID )
	{
		/*
		CDeviceInstanceCM& model( m_Model().As< CDeviceInstanceCM >() );		
		bool bRemote = model.IsRemote();
		const mxTCHAR* szMachineName = bRemote ? model.m_szMachineName : 0;

		m_Handle = m_Library.SetupDiCreateDeviceInfoListEx(  reinterpret_cast< const ::GUID* >( pSetupClassID ), 0, szMachineName, 0 );
		m_Handle.Attach( this );
		Init();

		if( !m_Handle.IsInvalid() )
		{
			m_Library.SetupDiGetClassDevsEx( reinterpret_cast< const ::GUID* >( pSetupClassID ), 0, 0, DIGCF_ALLCLASSES | DIGCF_PRESENT , reinterpret_cast< ::HDEVINFO >( m_Handle.Use() ), szMachineName );
			*/
			/*
			bool bEnumerated = false;
			unsigned int uiIndex = 0;
			do
			{	
				unsigned long ulError = 0;
				unsigned long ulResult = (unsigned long)(-1);
				m_DevInfo.cbSize = sizeof( ::SP_DEVINFO_DATA );
				m_DevInfo.ClassGuid = *pGuid;
				m_DevInfo.DevInst = 0;
				m_DevInfo.Reserved = 0;
				if( m_Library.SetupDiEnumDeviceInfo( reinterpret_cast< ::HDEVINFO >( m_Handle.Use() ), uiIndex, reinterpret_cast< ::PSP_DEVINFO_DATA >( &m_DevInfo ) ) )
				{
					ulResult = m_DevInfo.DevInst;
					if( ulResult > 0 && ulResult != (unsigned long)(-1) )
					{
						CTString strDeviceID;
						if( m_Library.CM_Get_Device_ID_Ex( static_cast< ::DEVINST >( m_DevInfo.DevInst ), strDeviceID.GetBufferSetLength( MaxDeviceIDLen + 1), MaxDeviceIDLen, 0, 0 ) != CR_SUCCESS )
						{
							ulError = ::GetLastError();
						}
						else
						{
							strDeviceID.ValidateBuffer();
							//Get the device instance ID and device data and add it to the global instance map
							CTString strDeviceInstance;
							unsigned long ulInstanceSize = 0;
							m_Library.SetupDiGetDeviceInstanceId( reinterpret_cast< ::HDEVINFO >( m_Handle.Use() ), reinterpret_cast< ::PSP_DEVINFO_DATA >( &m_DevInfo ), 0, 0, &ulInstanceSize );
							if( ulInstanceSize > 0 )
							{							
								m_Library.SetupDiGetDeviceInstanceId( m_Handle.Use(), reinterpret_cast< ::PSP_DEVINFO_DATA >( &m_DevInfo ), 
									strDeviceInstance.GetBufferSetLength( static_cast< unsigned short >( ulInstanceSize + 1 ) ), ulInstanceSize, &ulInstanceSize );
								strDeviceInstance.ValidateBuffer( static_cast< unsigned short >( ulInstanceSize ) );
							}
							else
							{
								ulError = ::GetLastError();
							}
							CDeviceInstance* pDeviceInstance = new CDeviceInstance( strDeviceID, this, m_DevInfo, uiIndex );

							m_ArrayDeviceInstances.Append( pDeviceInstance );
						}
						
						uiIndex++;
					}
					else
					{
						ulError = ::GetLastError();
						bEnumerated = true;
					}
				}
				else
				{
					ulError = ::GetLastError();
					bEnumerated = true;
				}
			}while( !bEnumerated );
			*/
		/*
		}
		*/
	}

}//nsWin32
