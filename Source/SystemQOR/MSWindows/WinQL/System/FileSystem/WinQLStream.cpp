//WinQLStream.cpp

// Copyright Querysoft Limited 2016
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <assert.h>
#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "WinQL/Application/ErrorSystem/WinQLErrDomain.h"
#include "WinQL/Application/WinQLApplication.h"
#include "WinQL/CodeServices/Locale/WinQLLocale.h"
#include "WinQL/Application/Subsystems/WinQLStandardIO.h"
#include "WinQL/Application/SubSystems/WinQLTerminal.h"
#include "WinQL/Application/Comms/IPC/Pipe/WinQLPipe.h"
#include "WinQL/System/FileSystem/WinQLStream.h"
#include "WinQAPI/Kernel32.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	using namespace nsWinQAPI;

	//--------------------------------------------------------------------------------
	__QOR_INTERFACE(__WINQL) char CStream::sachLookupTrailBytes[ 256 ] =
	{
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0
	};

	//------------------------------------------------------------------------------
	void* CStream::_stdbuf[ 2 ] = { NULL, NULL };

	//------------------------------------------------------------------------------
	CStream::CStream()
	{
		Reset();
	}

	//------------------------------------------------------------------------------
	CStream::CStream( const CStream& src )
	{
		*this = src;
	}

	//------------------------------------------------------------------------------
	CStream& CStream:: operator = ( const CStream& src )
	{
		if( &src != this )
		{
			CIOStream::operator=( src );
			m_lRefCount = src.m_lRefCount;
			m_pStreamDevice = src.m_pStreamDevice;
		}
		return *this;
	}

	//------------------------------------------------------------------------------
	//fopen constructor
	CStream::CStream( const char* filename, const char* mode )
	{
		Reset();

		if( *filename == '\0' )
		{
			errno = EINVAL;
		}
		else
		{
			_fsopen( filename, mode, _SH_DENYNO );
		}
	}

	//------------------------------------------------------------------------------
	CStream::~CStream()
	{
	}

	//------------------------------------------------------------------------------
	void CStream::Reset( void )
	{
		CIOStream::Reset();
		m_lRefCount = 0;	//Count of external references
		m_pStreamDevice = nullptr;	//File, Pipe or Device
	}

	//------------------------------------------------------------------------------
	CStream* CStream::_stdin( void )
	{
		nsQOR::IRole::ref_type Role = CWin32Application::TheWin32Application()->GetRole();
		CStandardIO* pStandardIO = Role->GetSubSystem( CStandardIO::ClassID() ).As< CStandardIO >();

		if( pStandardIO != 0 )
		{
			return pStandardIO->StreamFromID( 0 );
		}
		return nullptr;
	}

	//------------------------------------------------------------------------------
	CStream* CStream::_stdout( void )
	{
		nsQOR::IRole::ref_type Role = CWin32Application::TheWin32Application()->GetRole();
		CStandardIO* pStandardIO = Role->GetSubSystem( CStandardIO::ClassID() ).As< CStandardIO >();

		if( pStandardIO )
		{
			return pStandardIO->StreamFromID( 1 );
		}
		return nullptr;
	}

	//------------------------------------------------------------------------------
	CStream* CStream::_stderr( void )
	{
		nsQOR::IRole::ref_type Role = CWin32Application::TheWin32Application()->GetRole();
		CStandardIO* pStandardIO = Role->GetSubSystem( CStandardIO::ClassID() ).As< CStandardIO >();

		if( pStandardIO )
		{
			return pStandardIO->StreamFromID( 2 );
		}
		return nullptr;
	}

	//------------------------------------------------------------------------------
	CStream* CStream::fdopen( int, const char* )
	{
		return 0;//TODO:
	}

	//------------------------------------------------------------------------------
	CStream* CStream::fmemopen( void* __QCMP_RESTRICT, size_t, const char * )
	{
		return 0;//TODO:
	}

	//------------------------------------------------------------------------------
	CStream* CStream::freopen( const char* filename, const char* mode )
	{
		return 0;//TODO:
	}

	//------------------------------------------------------------------------------
	CStream* CStream::open_memstream( char**, size_t* )
	{
		return 0;//TODO:
	}

	//------------------------------------------------------------------------------
	CStream* CStream::popen( const char*, const char* )
	{
		return 0;//TODO:
	}

	//------------------------------------------------------------------------------
	CStream* CStream::_popen( const char* command, const char* mode )
	{
		return 0;//TODO:
	}

	//------------------------------------------------------------------------------
	CStream* CStream::tmpfile( void )
	{
		return 0;//TODO:
	}

	//------------------------------------------------------------------------------
	CStream* CStream::open_wmemstream( wchar_t**, size_t* )
	{
		return 0;//TODO:
	}

	//------------------------------------------------------------------------------
	CStream* CStream::_wpopen( const wchar_t* pCommand, const wchar_t* pMode )
	{
		return 0;//TODO:
	}

	//------------------------------------------------------------------------------
	CStream* CStream::_wfsopen( const wchar_t* pFilename, const wchar_t* pMode )
	{
		return 0;//TODO:
	}

	//------------------------------------------------------------------------------
	CStream* CStream::_wfreopen( const wchar_t* pFilename, const wchar_t* pMode )
	{
		return 0;//TODO:
	}

	//------------------------------------------------------------------------------
	CStream* CStream::_wfopen( const wchar_t* pFilename, const wchar_t* pMode )
	{
		return 0;//TODO:
	}

	//------------------------------------------------------------------------------
	long CStream::AddRef( void )
	{
		return ++m_lRefCount;
	}

	//------------------------------------------------------------------------------
	long CStream::Release( void )
	{
		long lResult = --m_lRefCount;
		if( lResult <= 0 )
		{
			fclose();
			delete this;
		}
		return lResult;
	}

	//------------------------------------------------------------------------------
	void CStream::clearerr()
	{
		clearerr_s();
	}

	//------------------------------------------------------------------------------
	errno_t CStream::clearerr_s( void )
	{
		if( this == NULL )
		{
			errno = EINVAL;
			return EINVAL;
		}

		CIOStream::Lock();

		__try
		{
			CIOStream::ClearErrorFlags();
		}
		__finally
		{
			CIOStream::Unlock();
		}

		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::feof( void )
	{
		if( this == 0 )
		{
			errno = EINVAL;
			return 0;
		}

		return CIOStream::IsBufferEOF();
	}

	//------------------------------------------------------------------------------
	int CStream::ferror( void )
	{
		if( this == 0 )
		{
			errno = EINVAL;
			return 0;
		}

		return CIOStream::IsBufferError();
	}

	//------------------------------------------------------------------------------
	int CStream::fileno( void )
	{
		return CIOStream::GetFileNumber();
	}

	//------------------------------------------------------------------------------
	int CStream::_fileno( void )
	{
		return CIOStream::GetFileNumber();
	}

	//------------------------------------------------------------------------------
	//file://D:\Develop\susv4\functions\pclose.html
	int CStream::pclose( void )//- close a pipe stream to or from a process
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	//file://D:\Develop\susv4\functions\fwide.html
	int CStream::fwide( int mode )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	void CStream::flockfile( void )
	{
		CIOStream::Lock();
	}

	//------------------------------------------------------------------------------
	int CStream::ftrylockfile( void )
	{
		return CIOStream::TryLock();
	}

	//------------------------------------------------------------------------------
	void CStream::funlockfile( void )
	{
		CIOStream::Unlock();
	}

	//------------------------------------------------------------------------------
	CStream* CStream::fopen( const char* file, const char* mode )
	{
		return( CStream::_fsopen( file, mode, _SH_DENYNO ) );
	}

	//------------------------------------------------------------------------------
	CStream* CStream::_fsopen( const char* file, const char* mode, int shflag )
	{
		CStream* stream = 0;

		if( file == NULL || mode == NULL || *mode == '\0' )
		{
			errno = EINVAL;
			return 0;
		}


		// Get a free stream
		// [NOTE: _getstream() returns a locked stream.]

		nsQOR::IRole::ref_type Role = CWin32Application::TheWin32Application()->GetRole();
		CStandardIO* pStandardIO = Role->GetSubSystem( CStandardIO::ClassID() ).As< CStandardIO >();

		if( pStandardIO )
		{
			stream =  pStandardIO->_getstream();
		}


		if( stream == NULL )
		{
			errno = EMFILE;
			return NULL;
		}

		return _fsopenEx( file, mode, shflag, stream );
	}

	//------------------------------------------------------------------------------
	CStream* CStream::_fsopenEx( const char* file, const char* mode, int shflag, CStream* stream )
	{
		__try
		{
			if( *file == '\0' )
			{
				errno = EINVAL;
				return nullptr;
			}
			else if( stream != nullptr )
			{
				stream->_openfile(file, mode, shflag, stream);
			}
		}
		__finally
		{
			if( stream != nullptr )
			{
				stream->funlockfile();
			}
		}

		return stream;
	}

	// set default file commit mode to commit
	//this must move to the StandardIO Subsystem object
	int _commode = CStream::_IOCOMMIT;

	//------------------------------------------------------------------------------
	void CStream::_openfile( const char* filename, const char* mode, int shflag, CStream* str )
	{
		int modeflag = 0;
		int streamflag = _commode;
		//int commodeset = 0;
		//int scanset = 0;
		int filedes;
		//bool encodingFlag = false;

		assert( filename != NULL );
		assert( mode != NULL );
		assert( str != NULL );

		/* Parse the user's specification string as set flags in
		(1) modeflag - system call flags word
		(2) streamflag - stream handle flags word. */

		ParseMode( mode, modeflag, streamflag );

		// Try to open the file.  Note that if neither 't' nor 'b' is specified, _sopen will use the default.

		if( _sopen_s( &filedes, filename, modeflag, shflag, _S_IREAD | _S_IWRITE ) != 0 )
		{
			return;
		}

		// Init pointers
		CIOStream::OpenBuffer( filedes, streamflag );
	}

	//------------------------------------------------------------------------------
	errno_t CStream::_sopen_s( int* pfh, const char* path, int oflag, int shflag, int pmode )
	{
		// Last parameter passed as 1 because we want to validate pmode from the secure open_s
		return _sopen_helper( path, oflag, shflag, pmode, pfh, 1 );
	}

	//------------------------------------------------------------------------------
	errno_t CStream::_sopen_helper( const char* path, int oflag, int shflag, int pmode, int * pfh, int bSecure )
	{
		errno_t retval = 0;
		int unlock_flag = 0;

		if( pfh == NULL )
		{
			errno = EINVAL;
			return EINVAL;
		}

		*pfh = -1;

		if( path == NULL )
		{
			errno = EINVAL;
			return EINVAL;
		}

		if( bSecure )
		{
			if( !( ( pmode & ( ~( _S_IREAD | _S_IWRITE ) ) ) == 0 ) )
			{
				errno = EINVAL;
				return EINVAL;
			}
		}

		__try
		{
			retval = _sopen_nolock( &unlock_flag, pfh, path, oflag, shflag, pmode, bSecure );
		}
		__finally
		{
			if( unlock_flag )
			{
				if( retval )
				{
					CIOStream::SetIsOpen( false );
				}
				funlockfile();
			}
		}

		// in error case, ensure *pfh is -1
		if( retval != 0 )
		{
			*pfh = -1;
		}

		return retval;
	}

	//------------------------------------------------------------------------------
	errno_t CStream::_sopen_nolock( int* punlock_flag, int* pfh, const char* path, int oflag, int shflag, int pmode, int bSecure )
	{
		wchar_t* pathw = 0;
		int retval;

		// At this point we know path is not null
		if( !__copy_path_to_wide_string( path, &pathw ) )
		{
			return -1;
		}

		// call the wide-char variant
		retval = _wsopen_nolock( punlock_flag, pfh, pathw, oflag, shflag, pmode, bSecure );

		free( pathw ); // _free_crt leaves errno alone if everything completes as expected

		return retval;
	}

	//------------------------------------------------------------------------------
	bool CStream::__copy_path_to_wide_string( const char* path, wchar_t** outPath )
	{
		int len;
		unsigned int codePage = CCodePage::ACP;

		if( path == NULL || outPath == NULL )
		{
			errno = EINVAL;
			return false;
		}

#if !defined (_CORESYS) && !defined (_CRT_APP)
		/*
		if( !true/__crtIsPackagedApp()/ && !m_FileHelper.AreApisANSI() )
		{
			codePage = CCodePage::OEMCP;
		}*/
#endif  /* !defined (_CORESYS) && !defined (_CRT_APP) */

		*outPath = NULL;

		// get the buffer size needed for conversion
		if( ( len = m_StringHelper.MultiByteToWideChar( codePage, 0 /* Use default flags */, path, -1, 0, 0 ) ) == 0 )
		{
			CDOSError::MapError( m_ErrorHelper.GetLastError() );
			return false;
		}

		// allocate enough space for path wide char
		if( ( *outPath = (wchar_t*)malloc( len * sizeof( wchar_t ) ) ) == NULL )
		{
			// malloc should set the errno
			return false;
		}

		// now do the conversion
		if( m_StringHelper.MultiByteToWideChar( codePage, 0 /* Use default flags */, path, -1, *outPath, len ) == 0 )
		{
			CDOSError::MapError( m_ErrorHelper.GetLastError() );
			free( *outPath );
			*outPath = NULL;
			return false;
		}

		return true;
	}

	//------------------------------------------------------------------------------
	errno_t CStream::_wsopen_nolock( int* punlock_flag, int* pfh, const wchar_t* path, int oflag, int shflag, int pmode, int bSecure )
	{
		Cmp__int64 filepos;						// length of file - 1
		wchar_t ch;								// character at end of file
		char fileflags;							// _osfile flags
		int fmode = 0;

		//void* osfh;								// OS handle of opened file
		unsigned long fileaccess;               // OS file access (requested)
		unsigned long fileshare;                // OS file sharing mode
		unsigned long filecreate = 0;           // OS method of opening/creating
		unsigned long fileattrib;               // OS file attributes 
		unsigned long fileattribflags;          // OS file flags

		SECURITY_ATTRIBUTES SecurityAttributes;
		char tmode = __IOINFO_TM_ANSI;			// textmode - ANSI/UTF-8/UTF-16
		errno_t retvalue = 0;

		SecurityAttributes.nLength = sizeof( SecurityAttributes );
		SecurityAttributes.lpSecurityDescriptor = NULL;

		if( oflag & ONoInherit )
		{
			SecurityAttributes.bInheritHandle = false;
			fileflags = FNOINHERIT;
		}
		else
		{
			SecurityAttributes.bInheritHandle = true;
			fileflags = 0;
		}

		nsQOR::IRole::ref_type Role = CWin32Application::TheWin32Application()->GetRole();
		CStandardIO* pStandardIO = Role->GetSubSystem( CStandardIO::ClassID() ).As< CStandardIO >();

		if( pStandardIO )
		{
			errno = pStandardIO->_get_fmode( &fmode );
		}

		if( errno != Success )
		{
			return errno;
		}

		// figure out binary/text mode
		if( ( oflag & OBinary ) == 0 )
		{
			if( oflag & ( OText | OWText | OU16Text | OU8Text ) )
			{
				fileflags |= FTEXT;
			}
			else if( fmode != OBinary )   // check default mode
			{
				fileflags |= FTEXT;
			}
		}

		//decode the access flags

		switch( oflag & ( OReadOnly | OWriteOnly | OReadWrite ) )
		{

		case OReadOnly:         // read access
			fileaccess = Generic_Read;
			break;

		case OWriteOnly:         // write access

								 // giving it read access as well because in append (a, not a+), we need to read the BOM to determine the encoding (ie. ANSI, UTF8, UTF16)
			if( ( oflag & OAppend ) && ( oflag & ( OWText | OU16Text | OU8Text ) ) != 0 )
			{
				fileaccess = Generic_Read | Generic_Write;
			}
			else
			{
				fileaccess = Generic_Write;
			}
			break;

		case OReadWrite:           // read and write access
			fileaccess = Generic_Read | Generic_Write;
			break;

		default:                // error, bad oflag
			_set_doserrno( 0 ); // not an OS error
			*pfh = -1;
			return EINVAL;
			//_VALIDATE_RETURN_ERRCODE(( "Invalid open flag" , 0 ), EINVAL);

		}

		//decode sharing flags

		switch( shflag )
		{

		case _SH_DENYRW:        // exclusive access
			fileshare = 0L;
			break;

		case _SH_DENYWR:        // share read access
			fileshare = File_Share_Read;
			break;

		case _SH_DENYRD:        // share write access
			fileshare = File_Share_Write;
			break;

		case _SH_DENYNO:        // share read and write access
			fileshare = File_Share_Read | File_Share_Write;
			break;

		case _SH_SECURE:       // share read access only if read-only
			if( fileaccess == Generic_Read )
				fileshare = File_Share_Read;
			else
				fileshare = 0L;
			break;

		default:               // error, bad shflag
			_set_doserrno( 0 ); // not an OS error
			*pfh = -1;
			return EINVAL;
			//_VALIDATE_RETURN_ERRCODE(( "Invalid sharing flag" , 0 ), EINVAL);
		}

		//decode open/create method flags

		switch( oflag & ( OCreate | OExclusive | OTruncate ) )
		{
		case 0:
		case OExclusive:                   // ignore EXCL w/o CREAT
			filecreate = Open_Existing;
			break;

		case OCreate:
			filecreate = Open_Always;
			break;

		case OCreate | OExclusive:
		case OCreate | OTruncate | OExclusive:
			filecreate = Create_New;
			break;

		case OTruncate:
		case OTruncate | OExclusive:        // ignore EXCL w/o CREAT
			filecreate = Truncate_Existing;
			break;

		case OCreate | OTruncate:
			filecreate = Create_Always;
			break;

		default:
			// this can't happen ... all cases are covered
			_set_doserrno( 0 );
			*pfh = -1;
			return EINVAL;
			//_VALIDATE_RETURN_ERRCODE(( "Invalid open flag" , 0 ), EINVAL);
		}

		//decode file attribute flags if _O_CREAT was specified

		fileattrib = File_Attribute_Normal; // default
		fileattribflags = 0;


		int iuMaskVal = 0;

		if( pStandardIO )
		{
			iuMaskVal = pStandardIO->_umaskval();
		}

		if( oflag & OCreate )
		{
			if( !( ( pmode & ~( iuMaskVal ) ) & _S_IWRITE ) )
			{
				fileattrib = File_Attribute_ReadOnly;
			}
		}

		//Set temporary file (delete-on-close) attribute if requested.
		if( oflag & OTemporary )
		{
			fileattribflags |= File_Flag_Delete_On_Close;//FILE_FLAG_DELETE_ON_CLOSE;
			fileaccess |= Delete;//DELETE;
			fileshare |= File_Share_Delete;//FILE_SHARE_DELETE;
		}

		//Set temporary file (delay-flush-to-disk) attribute if requested.

		if( oflag & OShortLived )
		{
			fileattrib |= File_Attribute_Temporary;//FILE_ATTRIBUTE_TEMPORARY;
		}

		//Set directory access attribute if requested.

		if( oflag & OObtainDir )
		{
			fileattribflags |= File_Flag_Backup_Semantics;//FILE_FLAG_BACKUP_SEMANTICS;
		}

		//Set sequential or random access attribute if requested.

		if( oflag & OSequential )
		{
			fileattribflags |= File_Flag_Sequential_Scan;//FILE_FLAG_SEQUENTIAL_SCAN;
		}
		else if( oflag & ORandom )
		{
			fileattribflags |= File_Flag_Random_Access;//FILE_FLAG_RANDOM_ACCESS;
		}

		/*get an available handle.
		*
		* multi-thread note: the returned handle is locked!
		*/
		/*
		if( ( *pfh = _alloc_osfhnd() ) == -1 )
		{
		_doserrno = 0L;         // not an OS error
		*pfh = -1;
		errno = EMFILE;
		return errno;          // return error to caller
		}
		*/
		/* Beyond this do not set *pfh = -1 on errors for MT.
		Because the caller needs to release the lock on the
		handle */

		*punlock_flag = 1;

		//try to open/create the file
		m_pStreamDevice = CreateDeviceFile( path, fileaccess, fileshare, &SecurityAttributes, filecreate, fileattrib | fileattribflags, 0, oflag );
		if( m_pStreamDevice == 0 )
		{
			CIOStream::SetIsOpen( false );
			CDOSError::MapError( m_ErrorHelper.GetLastError() );
			retvalue = errno;
			goto exit;
		}

		if( m_pStreamDevice->GetType() == File_Type_Char )
		{
			fileflags |= FDEV;
		}
		else if( m_pStreamDevice->GetType() == File_Type_Pipe )
		{
			fileflags |= FPIPE;
		}

		fileflags |= FOPEN;

		CIOStream::SetFlags( fileflags );
		CIOStream::SetTextMode( __IOINFO_TM_ANSI );// TextMode set to ANSI by default, if we find a BOM, then we reset it to the appropriate type below

		if( !( fileflags & ( FDEV | FPIPE ) ) && ( fileflags & FTEXT ) && ( oflag & OReadWrite ) )
		{
			/* We have a text mode file.  If it ends in CTRL-Z, we wish to remove the CTRL-Z character, so that appending will work.
			We do this by seeking to the end of file, reading the last byte, and shortening the file if it is a CTRL-Z. */

			if( ( filepos = _lseeki64_nolock( *pfh, -1, SEEK_END ) ) == -1 )
			{
				// OS error -- should ignore negative seek error, since that means we had a zero-length file.
				int err;
				_get_doserrno( &err );
				if( err != ErrorNegativeSeek )
				{
					_close_nolock( *pfh );
					retvalue = errno;
					goto exit;
				}
			}
			else
			{
				// Seek was OK, read the last char in file. The last char is a CTRL-Z if and only if _read returns 0 and ch ends up with a CTRL-Z.
				ch = 0;
				if( _read_nolock( *pfh, &ch, 1 ) == 0 && ch == 26 )
				{
					// read was OK and we got CTRL-Z! Wipe it out!
					if( _chsize_nolock( *pfh, filepos ) == -1 )
					{
						_close_nolock( *pfh );
						retvalue = errno;
						goto exit;
					}
				}

				// now rewind the file to the beginning
				if( ( filepos = _lseeki64_nolock( *pfh, 0, SEEK_SET ) ) == -1 )
				{
					_close_nolock( *pfh );
					retvalue = errno;
					goto exit;
				}
			}
		}

		if( fileflags & FTEXT )
		{

			int count;

			// Set default tmode per oflag. BOM will change the default.
			// If oflag does not specify file type get type from _fmode 
			if( ( oflag & ( OText | OWText | OU16Text | OU8Text ) ) == 0 )
			{
				// Type specified in default mode? 
				if( ( fmode & ( OText | OWText | OU16Text | OU8Text ) ) == 0 )
				{
					oflag |= OText; // default to ANSI
				}
				else
				{
					oflag |= fmode & ( OText | OWText | OU16Text | OU8Text );
				}
			}

			// Now oflags should be set to one of the text modes
			assert( ( oflag & ( OText | OWText | OU16Text | OU8Text ) ) != 0 );

			switch( oflag & ( OText | OWText | OU16Text | OU8Text ) )
			{
			case OText:
				tmode = __IOINFO_TM_ANSI;
				break;
			case OWText:
			case OWText | OText:
				if( ( oflag & ( OWriteOnly | OCreate | OTruncate ) ) == ( OWriteOnly | OCreate | OTruncate ) )
				{
					tmode = __IOINFO_TM_UTF16LE;
				}
				break;
			case OU16Text:
			case OU16Text | OText:
				tmode = __IOINFO_TM_UTF16LE;
				break;

			case OU8Text:
			case OU8Text | OText:
				tmode = __IOINFO_TM_UTF8;
				break;
			}

			/* If the file hasn't been opened with the UNICODE flags then we
			have nothing to do - textmode's already set to default specified in oflag */
			if( ( oflag & ( OWText | OU16Text | OU8Text ) ) != 0 )
			{

				int bom = 0;
				int bWriteBom = 0;
				int bCheckBom = 0;

				if( !( fileflags & FDEV ) )
				{
					switch( fileaccess & ( Generic_Read | Generic_Write ) )
					{

					case Generic_Read:
					{
						bCheckBom = 1;
						break;
					}

					case Generic_Write:
					{
						switch( filecreate )
						{
							// Write BOM if empty file
						case Open_Existing:
						case Open_Always:
						{
							/* Check if the file contains at least one byte */
							/* Fall through otherwise */
							if( _lseeki64_nolock( *pfh, 0, SEEK_END ) != 0 )
							{
								if( _lseeki64_nolock( *pfh, 0, SEEK_SET ) == -1 )
								{
									_close_nolock( *pfh );
									retvalue = errno;
									goto exit;
								}
								break;
							}
						}

						/* New or truncated file. Always write BOM */
						case Create_New:
						case Create_Always:
						case Truncate_Existing:
						{
							bWriteBom = 1;
							break;
						}

						}
						break;
					}

					case Generic_Read | Generic_Write:
					{
						switch( filecreate )
						{
							// Check for existing BOM, Write BOM if empty file 
						case Open_Existing:
						case Open_Always:
						{
							// Check if the file contains at least one byte
							// Fall through otherwise
							if( _lseeki64_nolock( *pfh, 0, SEEK_END ) != 0 )
							{
								if( _lseeki64_nolock( *pfh, 0, SEEK_SET ) == -1 )
								{
									_close_nolock( *pfh );
									retvalue = errno;
									goto exit;
								}
								bCheckBom = 1;
							}
							else
							{
								bWriteBom = 1; // reset if file is not zero size
							}
							break;
						}

						// New or truncated file. Always write BOM
						case Create_New:
						case Truncate_Existing:
						case Create_Always:
						{
							bWriteBom = 1;
							break;
						}

						}
						break;
					}
					}
				}

				if( bCheckBom )
				{
					count = _read_nolock( *pfh, &bom, UTF8_BOMLEN );

					//Internal Validation. This branch should never be taken if bWriteBom is 1 and count > 0

					if( count > 0 && bWriteBom == 1 )
					{
						assert( 0 && "Internal Error" );
						bWriteBom = 0;
					}

					switch( count )
					{
					case -1:
						_close_nolock( *pfh );
						retvalue = errno;
						goto exit;

					case UTF8_BOMLEN:
						if( bom == UTF8_BOM ) {
							tmode = __IOINFO_TM_UTF8;
							break;
						}

					case UTF16_BOMLEN:
						if( ( bom & BOM_MASK ) == UTF16BE_BOM )
						{
							_close_nolock( *pfh );
							assert( 0 && "Only UTF-16 little endian & UTF-8 is supported for reads" );
							retvalue = errno = EINVAL;
							goto exit;
						}

						if( ( bom & BOM_MASK ) == UTF16LE_BOM )
						{
							/* We have read 3 bytes, so we should seek back 1 byte */
							if( ( filepos = _lseeki64_nolock( *pfh, UTF16_BOMLEN, SEEK_SET ) ) == -1 )
							{
								_close_nolock( *pfh );
								retvalue = errno;
								goto exit;
							}
							tmode = __IOINFO_TM_UTF16LE;
							break;
						}

						// Fall through to default case to lseek to beginning of file

					default:
						if( ( filepos = _lseeki64_nolock( *pfh, 0, SEEK_SET ) ) == -1 )
						{
							// No BOM, so we should seek back to the beginning of the file
							_close_nolock( *pfh );
							retvalue = errno;
							goto exit;
						}
						break;
					}
				}

				if( bWriteBom )
				{
					int written = 0;
					int bomlen = 0;
					bom = 0;

					// If we are creating a new file, we write a UTF-16LE or UTF8 BOM
					switch( tmode )
					{
					case __IOINFO_TM_UTF16LE:
					{
						bom = UTF16LE_BOM;
						bomlen = UTF16_BOMLEN;
						break;
					}
					case __IOINFO_TM_UTF8:
					{
						bom = UTF8_BOM;
						bomlen = UTF8_BOMLEN;
						break;
					}
					}

					while( bomlen > written )
					{
						int tmp = 0;
						// Note that write may write less than bomlen characters, but not really fail. Retry till write fails or till we wrote all the characters.
						if( ( tmp = _write( *pfh, ( (char *)( &bom ) ) + written, bomlen - written ) ) == -1 )
						{
							_close_nolock( *pfh );
							retvalue = errno;
							goto exit;
						}
						written += tmp;
					}
				}
			}
		}

		CIOStream::SetTextMode( tmode );
		CIOStream::SetIsUnicode( ( ( oflag & OWText ) == 0 ) ? false : true );

		//Set FAPPEND flag if appropriate. Don't do this for devices or pipes.

		if( !( fileflags & ( FDEV | FPIPE ) ) && ( oflag & OAppend ) )
		{
			CIOStream::SetIsAppend( true );
		}

		//re-open the file with write access only if we opened the file with read access to read the BOM before
		if( ( fileaccess & ( Generic_Read | Generic_Write ) ) == ( Generic_Read | Generic_Write ) && ( oflag & OWriteOnly ) )
		{
			// we will have to reopen the file again with the write access (but not read)
			delete m_pStreamDevice;
			m_pStreamDevice = 0;

			fileaccess &= ~Generic_Read;
			// we want to use OPEN_EXISTING here, because the user can open the an non-existing
			// file for append with _O_EXCL flag
			filecreate = Open_Existing;
			m_pStreamDevice = CreateDeviceFile( path, fileaccess, fileshare, &SecurityAttributes, filecreate, fileattrib | fileattribflags, 0, oflag );
			if( m_pStreamDevice == nullptr )
			{
				/* OS call to open/create file failed! map the error, release
				* the lock, and return -1. Note that it's *necessary* to
				* call _free_osfhnd (unlike the situation before), because we have
				* already set the file handle in the _ioinfo structure
				*/
				CDOSError::MapError( m_ErrorHelper.GetLastError() );
				CIOStream::SetIsOpen( false );
				retvalue = errno;
				goto exit;
			}
			else
			{
				// We were able to open the file successfully, set the file
				// handle in the _ioinfo structure, then we are done.  All
				// the fileflags should have been set properly already.
				//_osfhnd(*pfh) = (intptr_t)osfh;
			}
		}

	exit:
		return retvalue;
	}

	//------------------------------------------------------------------------------
	CDeviceFile* CStream::CreateDeviceFile( const wchar_t* lpFileName, unsigned long& dwDesiredAccess, unsigned long dwShareMode, nsWin32::LPSECURITY_ATTRIBUTES lpSecurityAttributes, unsigned long dwCreationDisposition, unsigned long dwFlagsAndAttributes, void* hTemplateFile, int oflag )
	{
		CDeviceFile* pDeviceFile = 0;
		CErrorHelper ErrorHelper;

		CDeviceHandle Handle = CKernel32::CreateFileW( lpFileName, dwDesiredAccess, dwShareMode, reinterpret_cast< ::LPSECURITY_ATTRIBUTES >( lpSecurityAttributes ), dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile );

		if( Handle.IsInvalid() )
		{
			if( ( dwDesiredAccess & ( Generic_Read | Generic_Write ) ) == ( Generic_Read | Generic_Write ) && ( oflag & OWriteOnly ) )
			{
				//We just failed on CreateFile(), because we might be trying open something for read while it cannot be read (eg. pipes or devices).
				//So try again with GENERIC_WRITE and we will have to use the default encoding.  We won't be able to determine the encoding from reading the BOM.

				dwDesiredAccess &= ~Generic_Read;
				Handle = CKernel32::CreateFileW( lpFileName, dwDesiredAccess, dwShareMode, reinterpret_cast<::LPSECURITY_ATTRIBUTES>( lpSecurityAttributes ), dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile );
				if( Handle.IsInvalid() )
				{
					return pDeviceFile;
				}
			}
			else
			{
				return pDeviceFile;
			}
		}

		switch( CKernel32::GetFileType( Handle.Use() ) )
		{
		case File_Type_Unknown:
		{
			unsigned long dwLastError = ErrorHelper.GetLastError();
			if( dwLastError == Success )
			{
				pDeviceFile = new CDeviceFile( Handle );
			}
		}
			break;
		case File_Type_Char:
			pDeviceFile = new CDeviceFile( Handle );
			break;
		case File_Type_Pipe:
			pDeviceFile = new CPipe( Handle );
			break;
		case File_Type_Disk:
			pDeviceFile = new CFile( Handle );
			break;
		default:
			pDeviceFile = new CDeviceFile( Handle );
			break;
		}
		return pDeviceFile;
	}

	//------------------------------------------------------------------------------
	errno_t CStream::_chsize_s( int filedes, Cmp__int64 size )
	{
		int r = 0;                          // return value

											//_CHECK_FH_CLEAR_OSSERR_RETURN_ERRCODE( filedes, EBADF );
											//_VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((filedes >= 0 && (unsigned)filedes < (unsigned)_nhandle), EBADF);
											//_VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((_osfile(filedes) & FOPEN), EBADF);
											//_VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((size >= 0), EINVAL);

		flockfile();

		__try
		{
			if( CIOStream::IsOpen() )
			{
				r = _chsize_nolock( filedes, size );
			}
			else
			{
				//assert(("Invalid file descriptor. File possibly closed by a different thread",0));
				r = errno = EBADF;
			}
		}
		__finally
		{
			funlockfile();
		}

		return r;
	}

	//------------------------------------------------------------------------------
	errno_t CStream::_chsize_nolock( int filedes, Cmp__int64 size )
	{
		Cmp__int64 filend;
		Cmp__int64 extend;
		Cmp__int64 place;
		int cnt;
		int oldmode;
		Cmp__int64 retval = 0; // assume good return
		errno_t err = 0;

		// Get current file position and seek to end
		if( ( ( place = _lseeki64_nolock( filedes, 0i64, SEEK_CUR ) ) == -1i64 ) || ( ( filend = _lseeki64_nolock( filedes, 0i64, SEEK_END ) ) == -1i64 ) )
		{
			return errno;
		}

		extend = size - filend;

		// Grow or shrink the file as necessary

		if( extend > 0i64 )
		{
			// extending the file
			CHeap ProcessHeap;

			char *bl = reinterpret_cast< char* >( ProcessHeap.Alloc( CHeap::Zero_Memory, _INTERNAL_BUFSIZ ) );

			if( !bl )
			{
				err = errno = ENOMEM;
				retval = -1i64;
			}
			else
			{
				oldmode = _setmode_nolock( filedes, OBinary );

				// pad out with nulls
				do
				{
					cnt = ( extend >= (__int64)_INTERNAL_BUFSIZ ) ? _INTERNAL_BUFSIZ : (int)extend;

					if( ( cnt = _write_nolock( filedes, bl, ( extend >= (__int64)_INTERNAL_BUFSIZ ) ? _INTERNAL_BUFSIZ : (int)extend ) ) == -1 )
					{
						// Error on write
						err = 0;
						_get_doserrno( &err );
						if( err == ErrorAccessDenied )
						{
							err = errno = EACCES;
						}

						retval = cnt;
						break;  // leave write loop
					}
				} while( ( extend -= (__int64)cnt ) > 0i64 );

				_setmode_nolock( filedes, oldmode );

				ProcessHeap.Free( 0, bl );
			}

			// retval set correctly
		}
		else if( extend < 0i64 )
		{
			// shortening the file

			//Set file pointer to new eof...and truncate it there.

			retval = _lseeki64_nolock( filedes, size, SEEK_SET );

			if( retval != -1i64 )
			{
				if( ( retval = m_pStreamDevice->SetEOF() ? 0 : -1 ) == -1 )
				{
					err = errno = EACCES;
					_set_doserrno( m_ErrorHelper.GetLastError() );
				}
			}
		}

		// else
		// no file change needed
		// retval = 0;

		if( retval == -1 || ( _lseeki64_nolock( filedes, place, SEEK_SET ) == -1i64 ) )
		{
			return errno;
		}

		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::_chsize( int filedes, long size )
	{
		errno_t e;
		e = _chsize_s( filedes, (Cmp__int64)size );
		return e == 0 ? 0 : -1;
	}

	//------------------------------------------------------------------------------
	int CStream::_setmode( int fh, int mode )
	{
		int retval = 0;

		if( !( ( mode == OText ) || ( mode == OBinary ) || ( mode == OWText ) || ( mode == OU8Text ) || ( mode == OU16Text ) ) )
		{
			errno = EINVAL;
			return -1;
		}


		//_CHECK_FH_RETURN( fh, EBADF, -1 );
		//_VALIDATE_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
		//_VALIDATE_RETURN((_osfile(fh) & FOPEN), EBADF, -1);

		flockfile();

		__try
		{
			if( CIOStream::IsOpen() )
			{
				// set the text/binary mode
				retval = _setmode_nolock( fh, mode );
			}
			else
			{
				errno = EBADF;
				//_ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
				retval = -1;
			}
		}
		__finally
		{
			// unlock the file
			funlockfile();
		}

		// Return to user (_setmode_nolock sets errno, if needed)
		return retval;
	}

	//------------------------------------------------------------------------------
	int CStream::_setmode_nolock( int fh, int mode )
	{
		return CIOStream::SetMode( mode );
	}

	//------------------------------------------------------------------------------
	bool CStream::ParseMode( const char* szMode, int& iModeFlags, int& iStreamFlags )
	{
		bool bResult = false;

		bool bComModeSet = false;
		bool bScanSet = false;
		bool bEncodingFlag = false;

		char* pszMode = const_cast< char* >( szMode );

		if( pszMode )
		{
			while( *pszMode == ' ' )// Skip leading spaces
			{
				++pszMode;
			}

			switch( *pszMode )
			{
			case 'r':
				iModeFlags = OReadOnly;
				iStreamFlags |= _IOREAD;
				break;
			case 'w':
				iModeFlags = OWriteOnly | OCreate | OTruncate;
				iStreamFlags |= _IOWRT;
				break;
			case 'a':
				iModeFlags = OWriteOnly | OCreate | OAppend;
				iStreamFlags |= _IOWRT;
				break;
			default:
				return bResult;
			}

			bResult = true;
			bool bContinue = true;
			while( *pszMode && bContinue )
			{
				switch( *pszMode )
				{
				case ' ':
					break;

				case '+':
					if( iModeFlags & OReadWrite )
					{
						bContinue = false;
					}
					else
					{
						iModeFlags |= OReadWrite;
						iModeFlags &= ~( OReadOnly | OWriteOnly );
						iStreamFlags |= _IORW;
						iStreamFlags &= ~( _IOREAD | _IOWRT );
					}
					break;

				case 'b':

					if( iModeFlags & ( OText | OBinary ) )
					{
						bContinue = false;
					}
					else
					{
						iModeFlags |= OBinary;
					}
					break;

				case 't':

					if( iModeFlags & ( OText | OBinary ) )
					{
						bContinue = false;
					}
					else
					{
						iModeFlags |= OText;
					}
					break;

				case 'c':

					if( bComModeSet )
					{
						bContinue = false;
					}
					else
					{
						bComModeSet = true;
						iStreamFlags |= _IOCOMMIT;
					}
					break;

				case 'n':
					if( bComModeSet )
					{
						bContinue = false;
					}
					else
					{
						bComModeSet = true;
						iStreamFlags &= ~_IOCOMMIT;
					}
					break;

				case 'S':
					if( bScanSet )
					{
						bContinue = false;
					}
					else
					{
						bScanSet = true;
						iModeFlags |= OSequential;
					}
					break;

				case 'R':
					if( bScanSet )
					{
						bContinue = false;
					}
					else
					{
						bScanSet = true;
						iModeFlags |= ORandom;
					}
					break;

				case 'T':
					if( iModeFlags & OShortLived )
					{
						bContinue = false;
					}
					else
					{
						iModeFlags |= OShortLived;
					}
					break;

				case 'D':
					if( iModeFlags & OTemporary )
					{
						bContinue = false;
					}
					else
					{
						iModeFlags |= OTemporary;
					}
					break;

				case 'N':
					iModeFlags |= ONoInherit;
					break;

				case ',':
					bEncodingFlag = 1;
					bContinue = false;
					break;

				default:
					//_VALIDATE_RETURN(("Invalid file open mode",0), EINVAL, NULL);
					return bResult;
				}
			}
		}

		if( bEncodingFlag )
		{
			static const char ccsField[ ] = "ccs=";
			static const char utf8encoding[ ] = "UTF-8";
			static const char utf16encoding[ ] = "UTF-16LE";
			static const char unicodeencoding[ ] = "UNICODE";

			// Skip spaces
			while( *pszMode == ' ' )
			{
				++pszMode;
			}

			//The length that we want to compare is numbers of elements in csField -1 since this number also contains NULL terminator

			if( strncmp( ccsField, pszMode, ( _countof( ccsField ) ) - 1 ) != 0 )
			{
				//_VALIDATE_RETURN(("Invalid file open mode",0), EINVAL, NULL);
				bResult = false;
				return bResult;
			}

			pszMode += _countof( ccsField ) - 1;

			if( stricmp( pszMode, utf8encoding ) == 0 )
			{
				pszMode += _countof( utf8encoding ) - 1;
				iModeFlags |= OU8Text;
			}
			else if( stricmp( pszMode, utf16encoding ) == 0 )
			{
				pszMode += _countof( utf16encoding ) - 1;
				iModeFlags |= OU16Text;
			}
			else if( stricmp( szMode, unicodeencoding ) == 0 )
			{
				pszMode += _countof( unicodeencoding ) - 1;
				iModeFlags |= OWText;
			}
			else
			{
				//_VALIDATE_RETURN(("Invalid file open mode",0), EINVAL, NULL);
				bResult = false;
				return bResult;
			}
		}

		while( *pszMode == ' ' )// Skip trailing spaces
		{
			++pszMode;
		}

		return bResult;
	}

	//------------------------------------------------------------------------------
	int CStream::_stbuf()
	{
		int index;

		assert( this != NULL );

		// do nothing if not a tty device 
		if( !_isatty( _fileno() ) )
		{
			return 0;
		}

		// Make sure stream is stdout/stderr and init _stdbuf index
		if( this == stdout )
		{
			index = 0;
		}
		else if( this == stderr )
		{
			index = 1;
		}
		else
		{
			return 0;
		}

		// Make sure the stream is not already buffered.
		if( IsAnyBuffer() )
		{
			return 0;
		}

		// Allocate a buffer for this stream if we haven't done so yet.
		if( ( _stdbuf[ index ] == NULL ) && ( ( _stdbuf[ index ] = malloc( _INTERNAL_BUFSIZ ) ) == NULL ) )
		{
			SetNoBuffering();// Cannot allocate buffer. Use _charbuf this time
		}
		else
		{
			SetYourBuffering( reinterpret_cast<char*>( _stdbuf[ index ] ), m_scuiInternalBufferSize );
		}

		StartTempBuffering();

		return 1;
	}

	//------------------------------------------------------------------------------
	void CStream::_ftbuf( int flag )
	{
		assert( flag == 0 || flag == 1 );

		if( flag )
		{
			if( IsTempBuffering() )
			{
				// Flush the stream and tear down temp buffering.
				_flush();
				EndTempBuffering();
			}
		}
	}

	//------------------------------------------------------------------------------
	int CStream::fflush( void )
	{
		int rc = 0;

		if( this == NULL )//if stream is NULL, flush all streams
		{
			nsQOR::IRole::ref_type Role = CWin32Application::TheWin32Application()->GetRole();
			CStandardIO* pStandardIO = Role->GetSubSystem( CStandardIO::ClassID() ).As< CStandardIO >();

			if( pStandardIO )
			{
				pStandardIO->flsall( CStandardIO::FlushNULL );
			}
		}
		else
		{
			rc = fflushEx();
		}
		return( rc );
	}

	//------------------------------------------------------------------------------
	int CStream::fflushEx()
	{
		int rc = 0;
		flockfile();
		__try
		{
			rc = _fflush_nolock();
		}
		__finally
		{
			funlockfile();
		}
		return rc;
	}

	//------------------------------------------------------------------------------
	int CStream::_fflush_nolock()
	{
		if( this == NULL ) // if stream is NULL, flush all streams
		{
			nsQOR::IRole::ref_type Role = CWin32Application::TheWin32Application()->GetRole();
			CStandardIO* pStandardIO = Role->GetSubSystem( CStandardIO::ClassID() ).As< CStandardIO >();

			if( pStandardIO )
			{
				pStandardIO->flsall( CStandardIO::FlushNULL );
			}
		}
		else
		{
			if( _flush() != 0 )
			{				
				return( EOF );// _flush failed, don't attempt to commit
			}
			
			if( IsCommit() )
			{
				return( _commit( _fileno() ) ? EOF : 0 );// commit to ensure data is written to disk
			}
		}
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::_flush()
	{
		int rc = 0; // assume good return
		int nchar;

		if( BufferNeedsFlushing( nchar ) )		
		{
			if( _write( _fileno(), GetBufferBasePointer(), nchar ) == nchar )
			{
				// if this is a read/write file, clear _IOWRT so that next operation can be a read
				if( IsBufferReadWrite() )				
				{
					EndWrite();
				}
			}
			else
			{
				SetError();
				rc = EOF;
			}
		}

		BufferFlushed();
		return rc;
	}

	//------------------------------------------------------------------------------
	int CStream::_commit( int filedes )
	{
		int retval = 0;

		// if filedes out of range, complain
		//_CHECK_FH_RETURN( filedes, EBADF, -1 );
		//_VALIDATE_RETURN((filedes >= 0 && (unsigned)filedes < (unsigned)_nhandle), EBADF, -1);

		if( !IsOpen() )
		{
			errno = EBADF;
			return -1;
		}

		flockfile();

		__try
		{
			if( IsOpen() )
			{
				if( !m_pStreamDevice->FlushBuffers() )
				{
					retval = m_ErrorHelper.GetLastError();
				}
				else
				{
					retval = 0;     // return success
				}

				// map the OS return code to C errno value and return code
				if( retval == 0 )
				{
					goto good;
				}

				_set_doserrno( retval );
			}

			errno = EBADF;
			retval = -1;

			//assert(("Invalid file descriptor. File possibly closed by a different thread",0));
		good:
			;
		}
		__finally
		{
			funlockfile();
		}

		return retval;
	}

	//------------------------------------------------------------------------------
	void CStream::setbuf( char* buffer )
	{
		assert( this != NULL );

		if( buffer == NULL )
		{
			setvbuf( NULL, m_scusIONoBuffering, 0 );
		}
		else
		{
			setvbuf( buffer, m_scusIOFullBuffering, m_scuiBufferSize );
		}
	}

	//------------------------------------------------------------------------------
	int CStream::setvbuf( char* buffer, int type, size_t size )
	{
		int retval = 0;   // assume good return

		if( this == 0 )
		{
			errno = EINVAL;
			return -1;
		}

		//(1) Make sure type is one of the three legal values.
		//(2) If we are buffering, make sure size is between 2 and INT_MAX.

		if( !( ( type == m_scusIONoBuffering ) || ( type == m_scusIOFullBuffering ) || ( type == m_scusIOLineBuffering ) ) )
		{
			errno = EINVAL;
			return -1;
		}

		if( ( type == m_scusIOFullBuffering ) || ( type == m_scusIOLineBuffering ) )
		{
			if( !( ( 2 <= size ) && ( size <= INT_MAX ) ) )
			{
				errno = EINVAL;
				return -1;
			}
		}

		size &= (size_t)~1;//force size to be even by masking down to the nearest multiple of 2
		flockfile();//Lock the file

		__try
		{
			_flush();//Flush the current buffer and free it, if it is ours.
			_freebuf();
			retval = SetVBuffering( buffer, type, size );
		}
		__finally
		{
			funlockfile();
		}
		return retval;
	}

	//------------------------------------------------------------------------------
	void CStream::_getbuf()
	{
		GetBuffer();
	}


	//------------------------------------------------------------------------------
	void CStream::_freebuf()
	{
		FreeBuffer();
	}

	//------------------------------------------------------------------------------
	int CStream::fclose( void )
	{
		int result = EOF;

		if( this == 0 )
		{
			errno = EINVAL;
			return EOF;
		}
		
		if( IsBufferString() )// If stream is a string, simply clear flag and return EOF
		{
			SetBufferFlags( 0 );
		}
		else		// Stream is a real file.
		{
			flockfile();
			__try
			{
				result = _fclose_nolock();
			}
			__finally
			{
				funlockfile();
			}
		}

		return result;
	}

	//------------------------------------------------------------------------------
	int CStream::_fclose_nolock()
	{
		int result = EOF;

		if( this == 0 )
		{
			errno = EINVAL;
			return EOF;
		}

		if( IsInUse() )
		{
			// Stream is in use:
			//(1) flush stream
			//(2) free the buffer
			//(3) close the file
			//(4) delete the file if temporary

			result = _flush();
			_freebuf();

			if( _close( _fileno() ) < 0 )
			{
				result = EOF;
			}
			else if( IsTmpFileName() )
			{
				//temporary file (i.e., one created by tmpfile() call). 
				//delete, if necessary (don't have to on Windows NT because it was done by the system when the handle was closed). also, free up the heap block holding the pathname.
				free( GetTmpFileName() );
				SetTmpFileName( nullptr );
			}
		}

		SetBufferFlags( 0 );

		return result;
	}

	//------------------------------------------------------------------------------
	int CStream::_close( int fh )
	{
		int r = 0;

		//_CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
		//_VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
		//_VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);

		flockfile();

		__try
		{
			if( IsOpen() )
			{
				r = _close_nolock( fh );
			}
			else
			{
				errno = EBADF;
				r = -1;
				//assert(("Invalid file descriptor. File possibly closed by a different thread",0));
			}
		}
		__finally
		{
			funlockfile();
		}

		return r;
	}

	//------------------------------------------------------------------------------
	int CStream::_close_nolock( int fh )
	{
		//unsigned long dosretval;

		/* Close the underlying OS file handle. Special cases:
		*      1. If _get_osfhandle(fh) is INVALID_HANDLE_VALUE, don't try
		*         to actually close it. Just reset the lowio info so the
		*         handle can be reused. The standard handles are setup like
		*         this in Windows app, or a background app.
		*      2. If fh is STDOUT or STDERR, and if STDOUT and STDERR are
		*         mapped to the same OS file handle, skip the CloseHandle
		*         is skipped (without error). STDOUT and STDERR are the only
		*         handles for which this support is provided. Other handles
		*         are mapped to the same OS file handle only at the
		*         programmer's risk.
		*/

		if( _fileno() > 2 )
		{
			delete m_pStreamDevice;
			m_pStreamDevice = 0;
			CDOSError::MapError( m_ErrorHelper.GetLastError() );
		}

		nsQOR::IRole::ref_type Role = CWin32Application::TheWin32Application()->GetRole();
		CStandardIO* pStandardIO = Role->GetSubSystem( CStandardIO::ClassID() ).As< CStandardIO >();

		if( pStandardIO )
		{
			pStandardIO->FreeHandle( _fileno() );
		}

		SetFlags( 0 );		//clear file flags
		/*
		if( dosretval )
		{
			// OS error
			return -1;
		}
		*/
		return 0;
	}

	//------------------------------------------------------------------------------	
	void CStream::rewind( void )
	{
		int fd;

		if( this == NULL )
		{
			return;
		}

		fd = _fileno();

		// Lock the file
		flockfile();

		__try
		{
			// Flush the stream
			_flush();

			// Clear errors
			ClearBufferErrorFlags();
			ClearCtrlZ();

			// Set flags
			// [note: _flush set _cnt=0 and _ptr=_base]
			ClearBufferReadAndWrite();

			// Position to beginning of file
			if( _lseek( fd, 0L, 0 ) == -1 )
			{
				ClearBufferErrorFlags();
			}
		}
		__finally
		{
			// unlock stream
			funlockfile();
		}
	}

	//------------------------------------------------------------------------------
	int CStream::fgetpos( fpos_t* pos )
	{
		if( this == 0 || pos == 0 )
		{
			errno = EINVAL;
			return -1;
		}

		if( ( *pos = _ftelli64() ) != -1i64 )
		{
			return( 0 );
		}
		else
		{
			return( -1 );
		}
	}

	//------------------------------------------------------------------------------
	int CStream::fsetpos( const fpos_t* pos )
	{
		if( this == NULL || pos == NULL )
		{
			errno = EINVAL;
			return -1;
		}

		return( _fseeki64( *pos, SEEK_SET ) );
	}

	//------------------------------------------------------------------------------
	int CStream::fseek( long int offset, int whence )
	{
		return fseeko( static_cast< off_t >( offset ), whence );
	}

	//------------------------------------------------------------------------------
	int CStream::fseeko( off_t offset, int whence )
	{
		return _fseeki64( static_cast< Cmp__int64 >( offset ), whence );
	}

	//------------------------------------------------------------------------------
	int CStream::_fseeki64( Cmp__int64 offset, int whence )
	{
		int retval = 0;

		if( this == 0 )
		{
			errno = EINVAL;
			return -1;
		}

		if( !( ( whence == SEEK_SET ) || ( whence == SEEK_CUR ) || ( whence == SEEK_END ) ) )
		{
			errno = EINVAL;
			return -1;
		}

		flockfile();

		__try
		{
			retval = _fseeki64_nolock( offset, whence );
		}
		__finally
		{
			funlockfile();
		}

		return( retval );
	}

	//------------------------------------------------------------------------------
	int CStream::_fseeki64_nolock( Cmp__int64 offset, int whence )
	{
		assert( this != 0 );

		if( !IsInUse() || ( ( whence != SEEK_SET ) && ( whence != SEEK_CUR ) && ( whence != SEEK_END ) ) )
		{
			errno = EINVAL;
			return -1;
		}

		// Clear EOF flag
		ClearBufferEOF();

		// If seeking relative to current location, then convert to a seek relative to beginning of file.  This accounts for buffering, etc. by letting ftell() tell us where we are.

		if( whence == SEEK_CUR )
		{
			offset += _ftelli64_nolock();
			whence = SEEK_SET;
		}

		// Flush buffer as necessary

		_flush();

		BufferPrepare();		// If file opened for read/write, clear flags since we don't know what the user is going to do next. If the file was opened for read access only, decrease _bufsiz so that the next _filbuf won't cost quite so much

		// Seek to the desired locale and return.
		return( _lseeki64( _fileno(), offset, whence ) == -1i64 ? -1 : 0 );
	}

	//------------------------------------------------------------------------------
	long int CStream::ftell( void )
	{
		return static_cast< long >( ftello() );
	}

	//------------------------------------------------------------------------------
	off_t CStream::ftello()
	{
		off_t retval = 0;

		if( this == 0 )
		{
			errno = EINVAL;
			return -1;
		}

		flockfile();

		__try
		{
			retval = _ftell_nolock();
		}
		__finally
		{
			funlockfile();
		}

		return retval;
	}

	//------------------------------------------------------------------------------
	long CStream::_ftell_nolock()
	{
		unsigned int offset;
		long filepos;
		byte* p;
		byte* max;
		int fd;
		unsigned int rdcnt;
		char tmode;

		if( this == 0 )
		{
			errno = EINVAL;
			return -1;
		}

		fd = _fileno();

		NormalizeCount();

		if( ( filepos = _lseek( fd, 0L, SEEK_CUR ) ) < 0L )
		{
			return( -1L );
		}

		// _lseek validates fd, so it's now ok to retrieve the textmode
		tmode = GetTextMode();

		if( !IsBigBuffer() )            // _IONBF or no buffering designated
		{
			return( filepos - Count() );
		}

		offset = (unsigned)( BufferOffset() );

		if( IsBufferReadWrite() )
		{
			if( tmode == __IOINFO_TM_UTF8 && BufferContainsTranslations() )
			{
				size_t curpos = (size_t)( BufferOffset() ) / sizeof( wchar_t );

				if( Count() == 0 )
				{
					return filepos;
				}
				else
				{
					unsigned long bytes_read;
					byte buf[ m_scuiInternalBufferSize ];

					__int64 basepos = _lseeki64( fd, GetStartPos(), SEEK_SET );

					if( basepos != GetStartPos() )
					{
						return ( -1 );
					}

					if( !m_pStreamDevice->Read( buf, m_scuiInternalBufferSize, &bytes_read, 0 ) )
					{
						return ( -1 );
					}

					if( _lseek( fd, filepos, SEEK_SET ) < 0 )
					{
						return -1;
					}

					if( curpos > bytes_read )
					{
						return ( -1 );
					}

					p = buf;
					while( curpos-- && ( p < buf + bytes_read ) )
					{
						if( *p == CR )
						{
							// *p is CR, so must check next char for LF
							if( p < buf + bytes_read - 1 )
							{
								if( *( p + 1 ) == LF )
								{
									p++;
								}
							}
						}
						else
						{
							p += utf8_no_of_trailbytes( *p );
						}
						p++;
					}
					return (long)( basepos + (size_t)( p - buf ) );
				}
			}
			if( GetIsTextMode() )
			{
				for( p = GetBufferBasePointer(); p < (byte*)GetPointerIntoBuffer(); p++ )
				{
					if( *p == '\n' )  // adjust for '\r'
					{
						offset++;
					}
				}
			}
		}
		else
		{
			errno = EINVAL;
			return( -1L );
		}

		if( filepos == 0L )
		{
			return( (long)offset );
		}

		if( IsBufferRead() )
		{
			if( Count() == 0 )  // filepos holds correct location
			{
				offset = 0;
			}
			else
			{

				// Subtract out the number of unread bytes left in the buffer. 
				// [We can't simply use _iob[]._bufsiz because the last read may have hit EOF and, thus, the buffer was not completely filled.] 

				rdcnt = Count() + (unsigned)( BufferOffset() );

				// If text mode, adjust for the cr/lf substitution. If binary mode, we're outta here.
				if( GetIsTextMode() )
				{
					// (1) If we're not at eof, simply copy _bufsiz onto rdcnt to get the # of untranslated chars read. 
					// (2) If we're at eof, we must look through the buffer expanding the '\n' chars one at a time.

					// [NOTE: Performance issue -- it is faster to do the two _lseek() calls than to blindly go through and expand the '\n' chars regardless of whether we're at eof or not.]

					if( _lseek( fd, 0L, SEEK_END ) == filepos )
					{

						max = GetBufferBasePointer() + rdcnt;
						for( p = GetBufferBasePointer(); p < max; p++ )
						{
							if( *p == '\n' )
							{
								rdcnt++;// adjust for '\r'
							}
						}

						// If last byte was ^Z, the lowio read didn't tell us about it. Check flag and bump count, if necessary.

						if( IsCtrlZ() )
						{
							++rdcnt;
						}
					}
					else
					{
						if( _lseek( fd, filepos, SEEK_SET ) < 0 )
						{
							return ( -1 );
						}

						/* We want to set rdcnt to the number of bytes originally read into the stream buffer (before crlf->lf translation).
						In most cases, this will just be _bufsiz. However, the buffer size may have been changed, due to fseek optimization,
						at the END of the last _filbuf call. */

						if( ( rdcnt <= _SMALL_BUFSIZ ) && ( IsMyBuffer() ) && !( IsVBuffer() ) )
						{
							// The translated contents of the buffer is small and we are not at eof. The buffer size must have been set to _SMALL_BUFSIZ during the last _filbuf call.
							rdcnt = _SMALL_BUFSIZ;
						}
						else
						{
							rdcnt = GetBufferSize();
						}

						// If first byte in untranslated buffer was a '\n', assume it was preceeded by a '\r' which was discarded by the previous read operation and count the '\n'.
						if( IsCRLF() )
						{
							++rdcnt;
						}
					}

					if( tmode == __IOINFO_TM_UTF8 )
					{
						rdcnt /= sizeof( wchar_t );
					}
				}

				filepos -= (long)rdcnt;

			}
		}

		if( tmode == __IOINFO_TM_UTF8 )
		{
			offset /= sizeof( wchar_t );
		}

		return( filepos + (long)offset );
	}

	//------------------------------------------------------------------------------
	Cmp__int64 CStream::_ftelli64()
	{
		Cmp__int64 retval = 0;

		if( this == 0 )
		{
			errno = EINVAL;
			return -1;
		}

		flockfile();

		__try
		{
			retval = _ftelli64_nolock();
		}
		__finally
		{
			funlockfile();
		}

		return retval;
	}

	//------------------------------------------------------------------------------
	Cmp__int64 CStream::_ftelli64_nolock()
	{
		size_t offset;
		Cmp__int64 filepos;
		byte* p;
		byte* max;
		int fd;
		size_t rdcnt;
		char tmode;

		assert( this != 0 );

		fd = _fileno();

		NormalizeCount();

		if( ( filepos = _lseeki64( fd, 0i64, SEEK_CUR ) ) < 0L )
		{
			return( -1i64 );
		}

		// _lseek164 validates fd, so it's now ok to retrieve the textmode
		tmode = GetTextMode();

		if( !IsBigBuffer() )            // _IONBF or no buffering designated
		{
			return( filepos - Count() );
		}

		offset = (size_t)( BufferOffset() );

		if( IsBufferReadWrite() )
		{
			if( tmode == __IOINFO_TM_UTF8 && BufferContainsTranslations() )
			{
				size_t curpos = (size_t)( BufferOffset() ) / sizeof( wchar_t );

				if( Count() == 0 )
				{
					return filepos;
				}
				else
				{
					unsigned long bytes_read;
					byte buf[ m_scuiInternalBufferSize ];

					__int64 basepos = _lseeki64( fd, GetStartPos(), SEEK_SET );

					if( basepos != GetStartPos() )
					{
						return ( -1 );
					}

					if( !m_pStreamDevice->Read( buf, m_scuiInternalBufferSize, &bytes_read, 0 ) )
					{
						return ( -1 );
					}

					if( _lseeki64( fd, filepos, SEEK_SET ) < 0 )
					{
						return -1;
					}

					if( curpos > bytes_read )
					{
						return ( -1 );
					}

					p = buf;
					while( curpos-- && ( p < buf + bytes_read ) )
					{
						if( *p == CR )
						{
							// *p is CR, so must check next char for LF
							if( p < buf + bytes_read - 1 )
							{
								if( *( p + 1 ) == LF )
								{
									p++;
								}
							}
						}
						else
						{
							p += utf8_no_of_trailbytes( *p );
						}
						p++;
					}
					return basepos + (size_t)( p - buf );
				}
			}

			if( GetIsTextMode() )
			{
				for( p = GetBufferBasePointer() ; p < (byte*)GetPointerIntoBuffer(); p++ )
				{
					if( *p == '\n' )  // adjust for '\r'
					{
						offset++;
					}
				}
			}
		}
		else if( !( IsBufferReadWrite() ) )
		{
			errno = EINVAL;
			return ( -1i64 );
		}

		if( filepos == 0i64 )
		{
			return( (__int64)offset );
		}

		if( IsBufferRead() )
		{
			if( Count() == 0 )  // filepos holds correct location
			{
				offset = 0;
			}
			else
			{
				/* Subtract out the number of unread bytes left in the buffer. [We can't simply use _iob[]._bufsiz because
				the last read may have hit EOF and, thus, the buffer was not completely filled.] */

				rdcnt = Count() + (size_t)( BufferOffset() );

				// If text mode, adjust for the cr/lf substitution. If binary mode, we're outta here.
				if( GetIsTextMode() )
				{
					/* (1) If we're not at eof, simply copy _bufsiz onto rdcnt to get the # of untranslated
					chars read. (2) If we're at eof, we must look through the buffer expanding the '\n'
					chars one at a time. */

					/* [NOTE: Performance issue -- it is faster to do the two _lseek() calls than to blindly go
					through and expand the '\n' chars regardless of whether we're at eof or not.] */

					if( _lseeki64( fd, 0i64, SEEK_END ) == filepos )
					{
						max = GetBufferBasePointer() + rdcnt;
						for( p = GetBufferBasePointer(); p < max; p++ )
						{
							if( *p == '\n' )
							{	// adjust for '\r'
								rdcnt++;
							}
						}

						// If last byte was ^Z, the lowio read didn't tell us about it.  Check flag and bump count, if necessary.
						if( IsCtrlZ() )
						{
							++rdcnt;
						}
					}
					else
					{
						if( _lseeki64( fd, filepos, SEEK_SET ) < 0 )
						{
							return ( -1 );
						}

						/* We want to set rdcnt to the number of bytes originally read into the
						stream buffer (before crlf->lf translation). In most cases, this
						will just be _bufsiz. However, the buffer size may have been changed,
						due to fseek optimization, at the END of the last _filbuf call. */

						if( ( rdcnt <= _SMALL_BUFSIZ ) && ( IsMyBuffer() ) && !( IsVBuffer() ) )
						{
							// The translated contents of the buffer is small and we are not at eof. The buffer size must have been set to _SMALL_BUFSIZ during the last _filbuf call.
							rdcnt = _SMALL_BUFSIZ;
						}
						else
						{
							rdcnt = GetBufferSize();
						}

						// If first byte in untranslated buffer was a '\n', assume it was preceeded by a '\r' which was discarded by the previous read operation and count the '\n'.
						if( IsCRLF() )
						{
							++rdcnt;
						}
					}
				}

				if( tmode == __IOINFO_TM_UTF8 )
				{
					rdcnt /= sizeof( wchar_t );
				}

				filepos -= (__int64)rdcnt;

			}
		}

		if( tmode == __IOINFO_TM_UTF8 )
		{
			offset /= sizeof( wchar_t );
		}

		return( filepos + (__int64)offset );
	}

	//------------------------------------------------------------------------------
	Cmp__int64 CStream::_lseeki64( int fh, Cmp__int64 pos, int mthd )
	{
		__int64 r = -1i64;

		//_CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1i64 );
		//_VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1i64);

		if( !( IsOpen() ) )
		{
			errno = EBADF;
			return -1i64;
		}

		flockfile();
		__try
		{
			// make sure the file is open (after locking)
			if( IsOpen() )
			{
				r = _lseeki64_nolock( fh, pos, mthd );  /* seek */
			}
			else
			{
				errno = EBADF;
				_set_doserrno( 0 );  // not OS error
				r = -1i64;
				//assert(("Invalid file descriptor. File possibly closed by a different thread",0));
			}
		}
		__finally
		{
			funlockfile();
		}

		return r;
	}

	//------------------------------------------------------------------------------
	Cmp__int64 CStream::_lseeki64_nolock( int fh, Cmp__int64 pos, int mthd )
	{
		Cmp__int64 i64Result = m_pStreamDevice->Seek( pos, mthd );
		ClearCtrlZ();
		return i64Result;
	}

	//------------------------------------------------------------------------------
	long CStream::_lseek( int fh, long pos, int mthd )
	{
		int r = 0;

		//_CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
		//_VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);

		if( !( IsOpen() ) )
		{
			errno = EBADF;
			return -1;
		}

		flockfile();

		__try
		{
			if( IsOpen() )
			{
				r = _lseek_nolock( fh, pos, mthd );
			}
			else
			{
				errno = EBADF;
				_set_doserrno( 0 );
				r = -1;
				//assert(("Invalid file descriptor. File possibly closed by a different thread",0));
			}
		}
		__finally
		{
			funlockfile();
		}

		return r;
	}

	//------------------------------------------------------------------------------
	long CStream::_lseek_nolock( int fh, long pos, int mthd )
	{
		LARGE_INTEGER  large_pos;        // file position
		Cmp__int64  saved_pos;        // original file position
		Cmp__int64  new_pos;          // new file position

		// tell o.s. to seek

		large_pos.QuadPart = 0;

		// Save the current file pointer
		saved_pos = m_pStreamDevice->Tell();

		if( saved_pos == -1 )
		{
			return -1;
		}

		new_pos = m_pStreamDevice->Seek( pos, mthd );
		if( new_pos == -1 )
		{
			return -1;
		}

		large_pos.QuadPart = new_pos;
		// The call succeeded, but the new file pointer location is too large for the return type or a negative value.
		// So, restore file pointer to saved location and return error.
		if( large_pos.u.HighPart != 0 )
		{
			m_pStreamDevice->Seek( saved_pos, File_Begin );
			errno = EINVAL;
			return -1;
		}

		ClearCtrlZ();			// clear the ctrl-z flag on the file		
		return static_cast< long >( new_pos );		    // return
	}

	//------------------------------------------------------------------------------
	int __cdecl _winput_l( CStream* _File, const wchar_t*, _locale_t _Locale, va_list _ArgList )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int __cdecl _input_s_l( CStream* _File, const unsigned char*, _locale_t _Locale, va_list _ArgList )
	{
		return 0;
	}

	//--------------------------------------------------------------------------------
	int __cdecl _winput_s_l( CStream* _File, const wchar_t*, _locale_t _Locale, va_list _ArgList )
	{
		return 0;
	}

	//--------------------------------------------------------------------------------
	int __cdecl _woutput( const wchar_t* format, va_list argptr )
	{
		return 0;//OutputW( format, 0, false, false, argptr );
	}

	//--------------------------------------------------------------------------------
	int __cdecl _woutput_l( CStream* pStream, const wchar_t* format, localeinfo_struct* plocinfo, va_list argptr )
	{
		return 0;//OutputW( format, plocinfo, false, false, argptr );
	}

	//--------------------------------------------------------------------------------
	int __cdecl _woutput_p( CStream* pStream, const wchar_t* format, va_list argptr )
	{
		return 0;//OutputW( format, 0, false, true, argptr );
	}

	//--------------------------------------------------------------------------------
	int __cdecl _woutput_p_l( CStream* pStream, const wchar_t* format, localeinfo_struct* plocinfo, va_list argptr )
	{
		return 0;//OutputW( format, plocinfo, false, true, argptr );
	}

	//--------------------------------------------------------------------------------
	int __cdecl _woutput_s( CStream* pStream, const wchar_t* format, va_list argptr )
	{
		return 0;//OutputW( format, 0, true, false, argptr );
	}

	//--------------------------------------------------------------------------------
	int __cdecl _woutput_s_l( CStream* pStream, const wchar_t* format, localeinfo_struct* plocinfo, va_list argptr )
	{
		return 0;//OutputW( format, plocinfo, true, false, argptr );
	}

	//--------------------------------------------------------------------------------
	int __cdecl _output( CStream* pStream, const char* format, va_list argptr )
	{
		return 0;//OutputA( format, 0, false, false, argptr );
	}

	//--------------------------------------------------------------------------------
	int __cdecl _output_l( CStream* pStream, const char* format, localeinfo_struct* plocinfo, va_list argptr )
	{
		return 0;//OutputA( format, plocinfo, false, false, argptr );
	}

	//--------------------------------------------------------------------------------
	int __cdecl _output_p( CStream* pStream, const char* format, va_list argptr )
	{
		return 0;//OutputA( format, 0, false, true, argptr );
	}

	//--------------------------------------------------------------------------------
	int __cdecl _output_p_l( CStream* pStream, const char* format, localeinfo_struct* plocinfo, va_list argptr )
	{
		return 0;//OutputA( format, plocinfo, false, true, argptr );
	}

	//--------------------------------------------------------------------------------
	int __cdecl _output_s( CStream* pStream, const char* format, va_list argptr )
	{
		return 0;//OutputA( format, 0, true, false, argptr );
	}

	//--------------------------------------------------------------------------------
	int __cdecl _output_s_l( CStream* pStream, const char* format, localeinfo_struct* plocinfo, va_list argptr )
	{
		return 0;//OutputA( format, plocinfo, true, false, argptr );
	}

	//------------------------------------------------------------------------------
	int CStream::fprintf( const char* format, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::fprintf_s( const char* format, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::fscanf( const char* format, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::fscanf_s( const char* format, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::vfprintf( const char* format, va_list arg )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::vfprintf_s( const char* format, va_list arg )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::vfscanf( const char* format, va_list arg )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::_fwprintf_l( const wchar_t* format, ::locale_t locale, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::_fwprintf_p( const wchar_t* format, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::_fwprintf_p_l( const wchar_t* format, ::locale_t locale, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::_fwprintf_s_l( const wchar_t* format, ::locale_t locale, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::_fwscanf_l( const wchar_t* format, ::locale_t locale, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::_fwscanf_s_l( const wchar_t* format, ::locale_t locale, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::_fscanf_l( const char* format, ::locale_t locale, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::_fscanf_s_l( const char* format, ::locale_t locale, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::_fprintf_l( const char* format, ::locale_t locale, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::_fprintf_p( const char* format, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::_fprintf_p_l( const char* format, ::locale_t locale, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::_fprintf_s_l( const char* format, ::locale_t locale, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::fwprintf( const wchar_t* format, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::fwscanf( const wchar_t* format, va_list vargs )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::vfwprintf( const wchar_t* format, va_list arg )
	{
		return vfwprintf_helper( _woutput_l, format, 0, arg );
	}

	//------------------------------------------------------------------------------
	int CStream::vfwscanf( const wchar_t* format, va_list arg )
	{
		return vfwscanf_fn( _winput_l, format, 0, arg );
	}

	//------------------------------------------------------------------------------
	int CStream::fwprintf_s( const wchar_t* format, va_list vargs )
	{
		return _vfwprintf_s_l( format, 0, vargs );
	}

	//------------------------------------------------------------------------------
	int CStream::fwscanf_s( const wchar_t* format, va_list vargs )
	{
		return vfwscanf_fn( _winput_s_l, format, 0, vargs );
	}

	//------------------------------------------------------------------------------
	int CStream::vfwprintf_s( const wchar_t* format, va_list arg )
	{
		return vfwprintf_helper( _woutput_s_l, format, 0, arg );
	}

	//------------------------------------------------------------------------------
	int CStream::_vfprintf_l( const char* format, ::locale_t locale, va_list argptr )
	{
		return vfprintf_helper( _output_l, format, locale, argptr );
	}

	//------------------------------------------------------------------------------
	int CStream::_vfprintf_p( const char* format, va_list argptr )
	{
		return vfprintf_helper( _output_p_l, format, 0, argptr );
	}

	//------------------------------------------------------------------------------
	int CStream::_vfprintf_p_l( const char* format, ::locale_t locale, va_list argptr )
	{
		return vfprintf_helper( _output_p_l, format, locale, argptr );
	}

	//------------------------------------------------------------------------------
	int CStream::_vfprintf_s_l( const char* format, ::locale_t locale, va_list argptr )
	{
		return vfprintf_helper( _output_s_l, format, locale, argptr );
	}

	//------------------------------------------------------------------------------
	int CStream::_vfwprintf_l( const wchar_t* format, ::locale_t locale, va_list argptr )
	{
		return vfwprintf_helper( _woutput_l, format, locale, argptr );
	}

	//------------------------------------------------------------------------------
	int CStream::_vfwprintf_p( const wchar_t* format, va_list argptr )
	{
		return vfwprintf_helper( _woutput_p_l, format, 0, argptr );
	}

	//------------------------------------------------------------------------------
	int CStream::_vfwprintf_p_l( const wchar_t* format, ::locale_t locale, va_list argptr )
	{
		return vfwprintf_helper( _woutput_p_l, format, locale, argptr );
	}

	//------------------------------------------------------------------------------
	int CStream::_vfwprintf_s_l( const wchar_t* format, ::locale_t locale, va_list argptr )
	{
		return vfwprintf_helper( _woutput_s_l, format, locale, argptr );
	}

	//------------------------------------------------------------------------------
	int CStream::vfwprintf_helper( WOUTPUTFN woutfn, const wchar_t* format, _locale_t plocinfo, va_list ap )
	{
		int buffing;
		int retval = 0;

		if( this == NULL || format == NULL )
		{
			errno = EINVAL;
			return -1;
		}

		flockfile();
		__try
		{
			buffing = _stbuf();
			retval = woutfn( this, format, plocinfo, ap );
			_ftbuf( buffing );
		}
		__finally
		{
			funlockfile();
		}

		return( retval );
	}

	//------------------------------------------------------------------------------
	int CStream::vfprintf_helper( OUTPUTFN outfn, const char* format, _locale_t plocinfo, va_list ap )
	{
		int buffing;
		int retval = 0;

		if( this == NULL || format == NULL )
		{
			errno = EINVAL;
			return -1;
		}

		flockfile();

		__try
		{
			int fn;

			if( !( ( IsBufferString() ) || ( fn = _fileno(), ( ( GetTextMode() == __IOINFO_TM_ANSI ) && !IsUnicode() ) ) ) )
			{
				errno = EINVAL;
				retval = -1;
			}

			if( retval == 0 )
			{
				buffing = _stbuf();
				retval = outfn( this, format, plocinfo, ap );
				_ftbuf( buffing );
			}

		}
		__finally
		{
			funlockfile();
		}

		return retval;
	}

	//------------------------------------------------------------------------------
	int CStream::vfwscanf_fn( WINPUTFN winputfn, const wchar_t* format, _locale_t plocinfo, va_list arglist )
	{
		int retval = 0;

		if( this == NULL || format == NULL )
		{
			errno = EINVAL;
			return EOF;
		}

		flockfile();
		__try
		{
			retval = ( winputfn( this, format, plocinfo, arglist ) );
		}
		__finally
		{
			funlockfile();
		}

		return retval;
	}

	//------------------------------------------------------------------------------
	int CStream::_fgetc_nolock()
	{
		return ( DecrementBufferCount() >= 0 ? 0xff & GetNextChar() : _filbuf() );
	}

	//------------------------------------------------------------------------------
	int CStream::_fputc_nolock( int _c )
	{
		return ( DecrementBufferCount() >= 0 ? 0xff & ( PutNextChar((char)_c) ) : _flsbuf( _c ) );
	}

	//------------------------------------------------------------------------------
	int CStream::_getc_nolock()
	{
		return _fgetc_nolock();
	}

	//------------------------------------------------------------------------------
	int CStream::_putc_nolock( int _c )
	{
		return _fputc_nolock( _c );
	}

	//------------------------------------------------------------------------------

	//#define _getchar_nolock()           _getc_nolock(stdin)
	//#define _putchar_nolock(_c)         _putc_nolock((_c),stdout)
	//#define _getwchar_nolock()          _getwc_nolock(stdin)
	//#define _putwchar_nolock(_c)        _putwc_nolock((_c),stdout)

	//------------------------------------------------------------------------------
	int CStream::fgetc( void )
	{
		int retval = 0;

		if( this == NULL )
		{
			errno = EINVAL;
			return EOF;
		}

		flockfile();
		__try
		{
			int fn;

			if( !( ( IsBufferString()) || ( fn = _fileno(), ( ( GetTextMode() == __IOINFO_TM_ANSI ) && !IsUnicode() ) ) ) )
			{
				errno = EINVAL;
				retval = EOF;
			}

			if( retval == 0 )
			{
				retval = _getc_nolock();
			}
		}
		__finally
		{
			funlockfile();
		}

		return( retval );
	}

	//------------------------------------------------------------------------------
	char* CStream::fgets( char* string, int count )
	{
		char* pointer = string;
		char* retval = string;
		int ch;

		if( this == NULL || string == NULL || count <= 0 )
		{
			errno = EINVAL;
			return NULL;
		}

		// The C Standard states the input buffer should remain unchanged if EOF is encountered immediately. Hence we do not blank out the input buffer here

		flockfile();
		__try
		{
			int fn;

			if( !( ( IsBufferString() ) || ( fn = _fileno(), ( ( GetTextMode() == __IOINFO_TM_ANSI ) && !IsUnicode() ) ) ) )
			{
				errno = EINVAL;
				retval = NULL;
			}

			if( retval != NULL )
			{
				while( --count )
				{
					if( ( ch = _fgetc_nolock() ) == EOF )
					{
						if( pointer == string )
						{
							retval = NULL;
							goto done;
						}

						break;
					}

					if( ( *pointer++ = (char)ch ) == '\n' )
					{
						break;
					}
				}

				*pointer = '\0';
			}

		done:;
		}
		__finally
		{
			funlockfile();
		}

		return retval;
	}

	//------------------------------------------------------------------------------
	int CStream::fputc( int ch )
	{
		int retval = 0;

		if( this == NULL )
		{
			errno = EINVAL;
			return EOF;
		}

		flockfile();
		__try
		{

			int fn;

			if( !( ( IsBufferString() ) || ( fn = _fileno(), ( ( GetTextMode() == __IOINFO_TM_ANSI ) && !IsUnicode() ) ) ) )
			{
				errno = EINVAL;
				retval = EOF;
			}

			if( retval == 0 )
			{
				retval = _putc_nolock( ch );
			}
		}
		__finally
		{
			funlockfile();
		}

		return( retval );

	}

	//------------------------------------------------------------------------------
	int CStream::fputs( const char* string )
	{
		int buffing;
		size_t length;
		size_t ndone = 0;

		if( string == NULL || this == NULL )
		{
			errno = EINVAL;
			return EOF;
		}

		int fn;

		if( !( ( IsBufferString() ) || ( fn = _fileno(), ( ( GetTextMode() == __IOINFO_TM_ANSI ) && !IsUnicode() ) ) ) )
		{
			errno = EINVAL;
			return EOF;
		}

		length = strlen( string );

		flockfile();

		__try
		{
			buffing = _stbuf();
			ndone = _fwrite_nolock( string, 1, length );
			_ftbuf( buffing );
		}
		__finally
		{
			funlockfile();
		}

		return( ndone == length ? 0 : EOF );
	}

	//------------------------------------------------------------------------------
	int CStream::getc( void )
	{
		int retval = 0;

		if( this == NULL )
		{
			errno = EINVAL;
			return EOF;
		}

		flockfile();

		__try
		{
			int fn;

			if( !( ( IsBufferString()) || ( fn = _fileno(), ( ( GetTextMode() == __IOINFO_TM_ANSI ) && !IsUnicode() ) ) ) )
			{
				errno = EINVAL;
				retval = EOF;
			}

			if( retval == 0 )
			{
				retval = _getc_nolock();
			}
		}
		__finally
		{
			funlockfile();
		}

		return retval;
	}

	//------------------------------------------------------------------------------
	int CStream::getc_unlocked( void )
	{
		return _getc_nolock();
	}

	//------------------------------------------------------------------------------
	ssize_t CStream::getdelim( char**, size_t*, int )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	ssize_t CStream::getline( char**, size_t* )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::putc( int ch )
	{
		int retval = 0;

		if( this == NULL )
		{
			errno = EINVAL;
			return EOF;
		}

		flockfile();

		__try
		{
			int fn;

			if( !( ( IsBufferString() ) || ( fn = _fileno(), ( ( GetTextMode() == __IOINFO_TM_ANSI ) && !IsUnicode() ) ) ) )
			{
				errno = EINVAL;
				retval = EOF;
			}

			if( retval == 0 )
			{
				retval = _putc_nolock( ch );
			}
		}
		__finally
		{
			funlockfile();
		}

		return( retval );
	}

	//------------------------------------------------------------------------------
	int CStream::putc_unlocked( int c )
	{
		return _putc_nolock( c );
	}

	//------------------------------------------------------------------------------
	int CStream::ungetc( int ch )
	{
		int retval = 0;

		if( this == NULL )
		{
			errno = EINVAL;
			return EOF;
		}

		flockfile();

		__try
		{
			retval = _ungetc_nolock( ch );
		}
		__finally
		{
			funlockfile();
		}

		return retval;
	}

	//------------------------------------------------------------------------------
	int CStream::_ungetc_nolock( int ch )
	{
		int fn;

		if( !( ( IsBufferString() ) || ( fn = _fileno(), ( ( GetTextMode() == __IOINFO_TM_ANSI ) && ! IsUnicode() ) ) ) )
		{
			errno = EINVAL;
			return EOF;
		}

		// Stream must be open for read and can NOT be currently in write mode. Also, ungetc() character cannot be EOF.

		if( ( ch == EOF ) || !( ( IsBufferRead() ) || ( ( IsBufferReadWrite() ) && !( IsBufferWrite() ) ) ) )
		{
			return EOF;
		}

		return BufferUngetChar( ch );
	}

	//------------------------------------------------------------------------------
	int CStream::_putw( int binint )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::_getw( void )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	wint_t CStream::fgetwc()
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	wchar_t* CStream::fgetws( wchar_t* s, int n )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	wint_t CStream::fputwc( wchar_t c )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	int CStream::fputws( const wchar_t* s )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	wint_t CStream::getwc()
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	wint_t CStream::putwc( wchar_t c )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	wint_t CStream::ungetwc( wint_t c )
	{
		return 0;
	}

	//------------------------------------------------------------------------------
	wint_t CStream::_putwch_nolock( wchar_t ch )
	{
		unsigned long cchWritten = 0;

		// write character to console file handle
		CTerminal* pTerminal = CWin32Application::TheWin32Application()->GetRole()->GetSubSystem( CTerminal::ClassID() ).As< CTerminal >();

		if( !pTerminal->Console()->ScreenBuffer()->Write( &ch, 1, &cchWritten ) )
		{
			return WEOF;
		}

		return ch;
	}

	//------------------------------------------------------------------------------
	int CStream::_read_nolock( int fh, void* inputbuf, unsigned cnt )
	{
		int bytes_read = 0;				// number of bytes read
		char* buffer;					// buffer to read to
		int os_read;					// bytes read on OS call
		char *p, *q;					// pointers into buffer
		wchar_t *pu, *qu;				// wchar_t pointers into buffer for UTF16 
		char peekchr;					// peek-ahead character
		wchar_t wpeekchr;				// peek-ahead wchar_t
		Cmp__int64 filepos;				// file position after seek
		unsigned long dosretval;		// o.s. return value
		char tmode;						// textmode - ANSI/UTF-8/UTF-16
		bool fromConsole = 0;			// true when reading from console
		void* buf;						// buffer to read to
		int retval = -2;				// return value
		unsigned inputsize = cnt;

		//_CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
		//_VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);

		if( !( IsOpen() ) )
		{
			errno = EBADF;
			return -1;
		}

		if( cnt > IntMax )
		{
			errno = EINVAL;
			return -1;
		}

		if( cnt == 0 || ( IsFEOF() ) )
		{
			return 0;		// nothing to read or at EOF, so return 0 read
		}

		if( inputbuf == NULL )
		{
			errno = EINVAL;
			return -1;
		}

		tmode = GetTextMode();

		switch( tmode )
		{
		case __IOINFO_TM_UTF8:
			/* For a UTF-8 file, we need 2 buffers, because after reading we
			need to convert it into UNICODE - MultiByteToWideChar doesn't do
			in-place conversions. */

			/* MultiByte To WideChar conversion may double the size of the
			buffer required & hence we divide cnt by 2 */

			/*
			* Since we are reading UTF8 stream, cnt bytes read may vary
			* from cnt wchar_t characters to cnt/4 wchar_t characters. For
			* this reason if we need to read cnt characters, we will
			* allocate MBCS buffer of cnt. In case cnt is 0, we will
			* have 4 as minimum value. This will make sure we don't
			* overflow for reading from pipe case.
			*
			*
			* In this case the numbers of wchar_t characters that we can
			* read is cnt/2. This means that the buffer size that we will
			* require is cnt/2.
			*/

			// For UTF8 we want the count to be an even number
			if( !( ( cnt & 1 ) == 0 ) )
			{
				_set_doserrno( 0 );
				errno = EINVAL;
				return -1;
			}

			cnt = ( cnt / 2 ) < 4 ? 4 : ( cnt / 2 );

			buf = malloc( cnt );

			if( !buf )
			{
				errno = ENOMEM;
				_set_doserrno( CDOSError::E_nomem );
				return -1;
			}

			SetStartPos( _lseeki64_nolock( fh, 0, File_Current ) );
			break;

		case __IOINFO_TM_UTF16LE:
			// For UTF16 the count always needs to be an even number

			if( !( ( cnt & 1 ) == 0 ) )
			{
				_set_doserrno( 0 );
				errno = EINVAL;
				return -1;
			}

			cnt &= ( ~1 );

			// Fall Through to default

		default:
			// For non-UTF8 files, we need only 1 buffer - make buf point to the users input buffer
			buf = inputbuf;
		}


		buffer = reinterpret_cast< char* >( buf );

		char chPipe = 0;
		ReadPipeBuffer( chPipe );
		if( ( ( IsPipe() || IsDevice() ) ) && chPipe != LF && cnt != 0 )
		{
			// a pipe/device and pipe lookahead non-empty: read the lookahead char
			*buffer++ = chPipe;
			++bytes_read;
			--cnt;
			WritePipeBuffer( LF );

			unsigned short usPipeBufferDest;
			ReadPeakAheadPipeBuffer( usPipeBufferDest );
			// For UTF16, there maybe one more look ahead char. For UTF8, there maybe 2 more look ahead chars
			if( ( tmode != __IOINFO_TM_ANSI ) && ( LoByte( usPipeBufferDest) != LF ) && cnt != 0 )
			{
				*buffer++ = LoByte( usPipeBufferDest );
				++bytes_read;
				--cnt;

				usPipeBufferDest &= ( 0xFF00 );
				usPipeBufferDest |= ( LF );

				if( ( tmode == __IOINFO_TM_UTF8 ) && ( HiByte(usPipeBufferDest) != LF ) && cnt != 0 )
				{
					*buffer++ = HiByte( usPipeBufferDest );
					++bytes_read;
					--cnt;
					usPipeBufferDest &= ( 0x00FF );
					usPipeBufferDest |= ( ((unsigned short)(LF)) << 8  );
				}
			}
			WritePeakAheadPipeBuffer( usPipeBufferDest );
		}


#if !defined(_CRT_APP) || defined(_KERNELX)

		if( _isatty( fh ) && ( GetIsTextMode() ) )
		{
			unsigned long dwMode;
			CTerminal* pTerminal = CWin32Application::TheWin32Application()->GetRole()->GetSubSystem( CTerminal::ClassID() ).As< CTerminal >();
			fromConsole = pTerminal->Console()->ScreenBuffer()->GetInputMode( dwMode );
		}

		// read the data from Console
		if( fromConsole && ( tmode == __IOINFO_TM_UTF16LE ) )
		{
			CTerminal* pTerminal = CWin32Application::TheWin32Application()->GetRole()->GetSubSystem( CTerminal::ClassID() ).As< CTerminal >();
			if( !pTerminal->Console()->ScreenBuffer()->Read( buffer, cnt / 2, reinterpret_cast< unsigned long* >( &os_read ), 0 ) )
			{
				CDOSError::MapError( m_ErrorHelper.GetLastError() );
				retval = -1;
				goto error_return;
			}

			os_read *= 2; // In UTF16 mode, ReadConsoleW returns the actual number of wchar_t's read,
						  // so we make sure we update os_read accordingly
		}
		// read the data
		else
#endif  /* !defined(_CRT_APP) || defined(_KERNELX) */

			if( !m_pStreamDevice->Read( buffer, cnt, reinterpret_cast< unsigned long* >( &os_read ), 0 ) || os_read < 0 || (size_t)os_read > cnt )
			{
				/* ReadFile has reported an error. recognize two special cases.
				*
				*      1. map ERROR_ACCESS_DENIED to EBADF
				*
				*      2. just return 0 if ERROR_BROKEN_PIPE has occurred. it
				*         means the handle is a read-handle on a pipe for which
				*         all write-handles have been closed and all data has been
				*         read. */

				if( ( dosretval = m_ErrorHelper.GetLastError() ) == ErrorAccessDenied )
				{
					// wrong read/write mode should return EBADF, not EACCES
					errno = EBADF;
					_set_doserrno( dosretval );
					retval = -1;
					goto error_return;

				}
				else if( dosretval == ErrorBrokenPipe )
				{
					retval = 0;
					goto error_return;
				}
				else
				{
					CDOSError::MapError( m_ErrorHelper.GetLastError() );
					retval = -1;
					goto error_return;
				}
			}

		bytes_read += os_read;          // update bytes read

		if( GetIsTextMode() )
		{
			// now must translate CR-LFs to LFs in the buffer

			// For ANSI & UTF8, we read byte by byte. For UTF16, we need to read 2 bytes (wchar_t's) at a time
			if( tmode != __IOINFO_TM_UTF16LE )
			{
				// set CRLF flag to indicate LF at beginning of buffer
				if( ( os_read != 0 ) && ( *(char*)buf == LF ) )
				{
					SetCRLF();
				}
				else
				{
					ClearCRLF();
				}

				// convert chars in the buffer: p is src, q is dest
				p = q = reinterpret_cast< char* >( buf );

				while( p < (char *)buf + bytes_read )
				{
					if( *p == CTRLZ )
					{
						// if fh is not a device, set ctrl-z flag
						if( !( IsDevice() ) )
						{
							SetFEOF();
						}
						else
						{
							*q++ = *p++;
						}
						break;              // stop translating
					}
					else if( *p != CR )
					{
						*q++ = *p++;
					}
					else
					{
						// *p is CR, so must check next char for LF 
						if( p < (char *)buf + bytes_read - 1 )
						{
							if( *( p + 1 ) == LF )
							{
								p += 2;
								*q++ = LF;  // convert CR-LF to LF
							}
							else
							{
								*q++ = *p++;    // store char normally
							}
						}
						else
						{
							// This is the hard part.  We found a CR at end of buffer.  We must peek ahead to see if next char is an LF.
							++p;

							dosretval = 0;
							if( !m_pStreamDevice->Read( &peekchr, 1, reinterpret_cast< unsigned long* >( &os_read ), 0 ) )
							{
								dosretval = m_ErrorHelper.GetLastError();
							}

							if( dosretval != 0 || os_read == 0 )
							{
								// couldn't read ahead, store CR
								*q++ = CR;
							}
							else
							{
								/*
								* peekchr now has the extra character -- we now
								* have several possibilities:
								*
								* 1. disk file and char is not LF; just seek
								*    back and copy CR
								* 2. disk file and char is LF; seek back and
								*    discard CR
								* 3. disk file, char is LF but this is a
								*    one-byte read: store LF, don't seek back
								* 4. pipe/device and char is LF; store LF.
								* 5. pipe/device and char isn't LF, store CR
								*    and put char in pipe lookahead buffer.
								*/
								if( IsDevice() || IsPipe() )
								{
									// non-seekable device
									if( peekchr == LF )
									{
										*q++ = LF;
									}
									else
									{
										*q++ = CR;
										WritePipeBuffer( peekchr );
									}
								}
								else
								{
									// disk file
									if( q == buf && peekchr == LF )
									{
										// nothing read yet; must make some progress
										*q++ = LF;
									}
									else
									{
										// seek bac
										filepos = _lseeki64_nolock( fh, -1i64, File_Current );
										if( peekchr != LF )
										{
											*q++ = CR;
										}
									}
								}
							}
						}
					}
				}


				//we now change bytes_read to reflect the true number of chars in the buffer
				bytes_read = (int)( q - (char*)buf );

				if( ( tmode == __IOINFO_TM_UTF8 ) && ( bytes_read != 0 ) )
				{
					// UTF8 reads need to be converted into UTF16

					--q; // q has gone beyond the last char

						 /* If the last byte is a standalone UTF-8 char. We then take the whole buffer. Otherwise we skip back till we come to a lead byte.
						 If the leadbyte forms a complete UTF-8 character will the remaining part of the buffer, then again we take the whole buffer.
						 If not, we skip to one byte which should be the final trail byte of the previous UTF-8 char or a standalone UTF-8 character
						 */

					if( _utf8_is_independent( *q ) )
					{
						++q;
						// Final byte is standalone, we reset q, because we will now consider the full buffer which we have read
					}
					else
					{
						int ctr = 1;
						int cnt_trailbytes;

						while( !_utf8_is_leadbyte( *q ) && ctr <= 4 && q >= (char *)buf )
						{
							--q;
							++ctr;
						}

						cnt_trailbytes = utf8_no_of_trailbytes( *q );

						if( cnt_trailbytes == 0 )
						{
							// Should have exited the while by finding a lead byte else, the file has incorrect UTF-8 chars
							errno = EILSEQ;
							retval = -1;
							goto error_return;
						}

						if( cnt_trailbytes + 1 == ctr )
						{
							//The leadbyte + the remaining bytes form a full set
							q += ctr;
						}
						else
						{
							// Seek back

							if( IsDevice() || IsPipe() )
							{
								// non-seekable device. Put the extra chars in _pipech & _pipech2. We would have a maximum of 3 extra chars
								WritePipeBuffer( *q );
								++q;

								unsigned short usPipePeekBuffer = 0;
								if( ctr >= 2 )
								{
									usPipePeekBuffer = *q;
									++q;
								}

								if( ctr == 3 )
								{
									usPipePeekBuffer |= ( (unsigned short)( *q ) << 8 );
									++q;
								}

								WritePeakAheadPipeBuffer( usPipePeekBuffer );

								//We need to point q back to beyond whatever we actually took in.
								q -= ctr;

							}
							else
							{
								// We have read extra chars, so we seek back
								filepos = _lseeki64_nolock( fh, -ctr, FILE_CURRENT );
							}
						}
					}

					bytes_read = (int)( q - (char *)buf );
					bytes_read = m_StringHelper.MultiByteToWideChar( CCodePage::UTF8, 0, reinterpret_cast< char* >( buf ), bytes_read, reinterpret_cast< wchar_t* >( inputbuf ), inputsize / 2 );

					if( !bytes_read )
					{
						CDOSError::MapError( m_ErrorHelper.GetLastError() );
						retval = -1;
						goto error_return;
					}

					SetBufferContainsTranslations( bytes_read != (int)( q - (char *)buf ) );

					// MultiByteToWideChar returns no of wchar_t's. Double it
					bytes_read = bytes_read * 2;
				}
			}
#if !defined(_CRT_APP) || defined(_KERNELX)
			// reading from console && tmode == __IOINFO_TM_UTF16LE */
			else if( fromConsole )
			{
				pu = qu = (wchar_t *)buf;
				while( pu < ( (wchar_t*)buf ) + ( bytes_read / 2 ) )
				{
					if( *pu == CTRLZ )
					{
						SetFEOF();
						break;              // stop translating
					}
					else if( *pu != CR )
					{
						*qu++ = *pu++;
					}
					else
					{
						// *pu is CR, so must check next wchar_t for LF
						if( pu < ( (wchar_t*)buf ) + ( bytes_read / 2 ) - 1 )
						{
							if( *( pu + 1 ) == LF )
							{
								pu++;
								*qu++ = LF;  // convert CR-LF to LF
							}
							else
							{
								*qu++ = *pu++;    // store char normally
							}
						}
					}
				}

				// we now change bytes_read to reflect the true number of bytes in the buffer
				bytes_read = (int)( qu - (wchar_t*)buf ) * 2;
			}
#endif  /* _CRT_APP */
			// NOT reading from console and tmode == __IOINFO_TM_UTF16LE
			else
			{
				// set CRLF flag to indicate LF at beginning of buffer
				if( ( os_read != 0 ) && ( *(wchar_t *)buf == LF ) )
				{
					SetCRLF();
				}
				else
				{
					ClearCRLF();
				}

				// convert chars in the buffer: pu is src, qu is dest
				pu = qu = (wchar_t *)buf;

				while( (char *)pu < (char *)buf + bytes_read )
				{
					if( *pu == CTRLZ )
					{
						// if fh is not a device, set ctrl-z flag
						if( !( IsDevice() ) )
						{
							SetFEOF();
						}
						else
						{
							*qu++ = *pu++;
						}
						break;              // stop translating
					}
					else if( *pu != CR )
					{
						*qu++ = *pu++;
					}
					else
					{
						// *pu is CR, so must check next wchar_t for LF
						if( (char *)pu < (char *)buf + bytes_read - 2 )
						{
							if( *( pu + 1 ) == LF )
							{
								pu += 2;
								*qu++ = LF;  // convert CR-LF to LF
							}
							else
							{
								*qu++ = *pu++;    // store char normally
							}
						}
						else
						{
							// This is the hard part.  We found a CR at end of buffer.  We must peek ahead to see if next wchar_t is an LF
							++pu;

							dosretval = 0;
							if( !m_pStreamDevice->Read( &wpeekchr, 2, reinterpret_cast< unsigned long* >( &os_read ), 0 ) )
							{
								dosretval = m_ErrorHelper.GetLastError();
							}

							if( dosretval != 0 || os_read == 0 )
							{
								// couldn't read ahead, store CR
								*qu++ = CR;
							}
							else
							{
								/* peekchr now has the extra character -- we
								* now have several possibilities:
								* 1. wchar_t is not LF; just seek back and
								* copy CR
								* 2. wchar_t is LF; seek back and discard CR
								* 3. disk file, wchar_t is LF but this is a
								* one-byte read: store LF, don't seek back.
								*/

								if( IsDevice() || IsPipe() )
								{
									// non-seekable device
									if( wpeekchr == LF )
									{
										*qu++ = LF;
									}
									else
									{
										char * pwpeekchr = (char *)&wpeekchr;
										*qu++ = CR;
										WritePipeBuffer( *pwpeekchr );
										++pwpeekchr;
										unsigned short usPipeBuffer = *pwpeekchr;
										usPipeBuffer |= ( (unsigned short)( LF ) << 8 );
										WritePeakAheadPipeBuffer( usPipeBuffer );
									}
								}
								else
								{
									if( (char*)qu == buf && wpeekchr == LF )
									{
										// nothing read yet; must make some progress
										*qu++ = LF;
									}
									else
									{
										// seek back
										filepos = _lseeki64_nolock( fh, -2, FILE_CURRENT );
										if( wpeekchr != LF )
										{
											*qu++ = CR;
										}
									}
								}
							}
						}
					}
				}

				// we now change bytes_read to reflect the true number of chars in the buffer 
				bytes_read = (int)( (char*)qu - (char*)buf );

			}

		}

	error_return:

		if( buf != inputbuf )
		{
			free( buf );
		}

		return ( retval == -2 ) ? bytes_read : retval;
	}

	//------------------------------------------------------------------------------
	size_t CStream::fread( void* ptr, size_t size, size_t nmemb )
	{
		return fread_s( ptr, Size_Max, size, nmemb );
	}

	//------------------------------------------------------------------------------
	size_t CStream::_fread_nolock( void *buffer, size_t elementSize, size_t count )
	{
		// assumes there is enough space in the destination buffer
		return _fread_nolock_s( buffer, Size_Max, elementSize, count );
	}

	//------------------------------------------------------------------------------
	size_t CStream::fread_s( void* buffer, size_t bufferSize, size_t elementSize, size_t count )
	{
		size_t retval = 0;

		if( elementSize == 0 || count == 0 )
		{
			return 0;
		}

		// only checking for stream == NULL here for _lock_str()
		// the rest of the validation is in _fread_nolock_s()
		if( this == NULL )
		{
			if( bufferSize != Size_Max )
			{
				memset( buffer, 0, bufferSize );
			}

			errno = EINVAL;
			return 0;
		}

		flockfile();
		__try
		{
			// do the read; _fread_nolock_s will make sure we do not buffer overrun 
			retval = _fread_nolock_s( buffer, bufferSize, elementSize, count );
		}
		__finally
		{
			funlockfile();
		}

		return retval;
	}

	//------------------------------------------------------------------------------
	size_t CStream::_fread_nolock_s( void *buffer, size_t bufferSize, size_t elementSize, size_t num )
	{
		char* data;                     // point inside the destination buffer to where we need to copy the read chars
		size_t dataSize;                // space left in the destionation buffer (in bytes)
		size_t total;                   // total bytes to read
		size_t count;                   // num bytes left to read
		unsigned streambufsize;         // size of stream buffer
		unsigned nbytes;                // how much to read now
		unsigned nread;                 // how much we did read
		int c;                          // a temp char

										// initialize local vars
		if( elementSize == 0 || num == 0 )
		{
			return 0;
		}

		if( buffer == NULL )
		{
			errno = EINVAL;
			return 0;
		}

		data = reinterpret_cast< char* >( buffer );
		dataSize = bufferSize;

		if( this == NULL || num > ( Size_Max / elementSize ) )
		{
			if( bufferSize != Size_Max )
			{
				memset( buffer, 0, bufferSize );
			}

			if( this == NULL )
			{
				errno = EINVAL;
				return 0;
			}

			if( num > ( Size_Max / elementSize ) )
			{
				errno = EINVAL;
				return 0;
			}
		}


		count = total = elementSize * num;

		if( IsAnyBuffer() )
		{
			// already has buffer, use its size
			streambufsize = GetBufferSize();
		}
		else
		{
			// assume will get _INTERNAL_BUFSIZ buffer
			streambufsize = m_scuiInternalBufferSize;
		}

		// here is the main loop -- we go through here until we're done
		while( count != 0 )
		{
			// if the buffer exists and has characters, copy them to user buffer
			if( IsAnyBuffer() && GetCountOfBytesLeftInBuffer() != 0 )
			{
				if( GetCountOfBytesLeftInBuffer() < 0 )
				{
					//assert(("Inconsistent Stream Count. Flush between consecutive read and write", _cnt >= 0));
					SetError();
					return ( total - count ) / elementSize;
				}

				// how much do we want?
				nbytes = ( count < (size_t)GetCountOfBytesLeftInBuffer() ) ? (unsigned)count : GetCountOfBytesLeftInBuffer();
				if( nbytes > dataSize )
				{
					if( bufferSize != Size_Max )
					{
						memset( buffer, 0, bufferSize );
					}

					errno = ERANGE;
					return 0;
					//_VALIDATE_RETURN(("buffer too small", 0), ERANGE, 0)
				}

				ReadFromBuffer( data, dataSize, nbytes );

				// update amt of data read 
				count -= nbytes;
				data += nbytes;
				dataSize -= nbytes;
			}
			else if( count >= streambufsize )
			{
				// If we have more than streambufsize chars to read, get data by calling read with an integral number of bufsiz blocks.  Note that if the stream is text mode, read will return less chars than we ordered.

				if( streambufsize )
				{
					// In 64bit apps size_t is bigger than unsigned (which is 32bit even in 64 bit machines), so we need to split the read into INT_MAX chunks
					// since _read() only support up to _signed_ int (even though the in parameter is unsigned).

					if( count > INT_MAX )
					{
						// calc chars to read -- the largest multiple of streambufsize smaller then INT_MAX

						nbytes = (unsigned)( INT_MAX - INT_MAX % streambufsize );
					}
					else
					{
						// calc chars to read -- (count/streambufsize) * streambufsize
						nbytes = (unsigned)( count - count % streambufsize );
					}
				}
				else
				{
					nbytes = ( count > INT_MAX ) ? (unsigned)INT_MAX : (unsigned)count;
				}

				if( nbytes > dataSize )
				{
					if( bufferSize != Size_Max )
					{
						memset( buffer, 0, bufferSize );
					}

					errno = ERANGE;
					return 0;
					//_VALIDATE_RETURN(("buffer too small", 0), ERANGE, 0)
				}

				nread = _read_nolock( _fileno(), data, nbytes );
				if( nread == 0 )
				{
					// end of file -- out of here
					SetBufferEOF();
					return ( total - count ) / elementSize;
				}
				else if( nread == (unsigned)-1 )
				{
					SetError();
					return ( total - count ) / elementSize;
				}

				// update count and data to reflect read 
				count -= nread;
				data += nread;
				dataSize -= nread;
			}
			else
			{
				// less than streambufsize chars to read, so call _filbuf to fill buffer
				if( ( c = _filbuf() ) == EOF )
				{
					// error or eof, stream flags set by _filbuf
					return ( total - count ) / elementSize;
				}

				// _filbuf returned a char -- store it
				if( dataSize == 0 )
				{
					if( bufferSize != Size_Max )
					{
						memset( buffer, 0, bufferSize );
					}

					errno = ERANGE;
					return 0;
					//_VALIDATE_RETURN(("buffer too small", 0), ERANGE, 0)
				}

				*data++ = (char)c;
				--count;
				--dataSize;

				// update buffer size
				streambufsize = GetBufferSize();
			}
		}

		// we finished successfully, so just return num
		return num;
	}

	//------------------------------------------------------------------------------
	int CStream::_filbuf()
	{
		if( this == NULL )
		{
			errno = EINVAL;
			return EOF;
		}

		if( !IsInUse() || IsBufferString() )
		{
			return EOF;
		}

		if( IsBufferWrite() )
		{
			SetError();
			return EOF;
		}

		BeginRead();

		// Get a buffer, if necessary.

		if( !IsAnyBuffer() )
		{
			_getbuf();
		}
		else
		{
			SetPointerIntoBuffer( (char*)GetBufferBasePointer() );
		}

		SetCountOfBytesLeftInBuffer( _read( _fileno(), GetBufferBasePointer(), GetBufferSize() ) );
		
		if( GetCountOfBytesLeftInBuffer() == 0 )
		{
			SetBufferEOF();
			SetCountOfBytesLeftInBuffer( 0 );
			return EOF;
		}
		if( GetCountOfBytesLeftInBuffer() == -1 )
		{
			SetError();
			SetCountOfBytesLeftInBuffer( 0 );
			return EOF;
		}

		if( !( ( IsBufferWrite() | IsBufferReadWrite() ) ) && ( ( _fileno() & ( FTEXT | FEOFLAG ) ) == ( FTEXT | FEOFLAG ) ) )
		{
			SetCtrlZ();
		}

		// Check for small _bufsiz (_SMALL_BUFSIZ). If it is small and if it is our buffer, then this must be the first _filbuf after
		// an fseek on a read-access-only stream. Restore _bufsiz to its larger value (_INTERNAL_BUFSIZ) so that the next _filbuf call,
		//  if one is made, will fill the whole buffer.

		if( ( GetBufferSize() == _SMALL_BUFSIZ ) && ( IsMyBuffer() ) && !( IsVBuffer() ) )
		{
			SetBufferSize( m_scuiInternalBufferSize );
		}

		DecrementBufferCount();
		return( 0xff & GetNextChar() );
	}

	//------------------------------------------------------------------------------
	int CStream::_read( int fh, void* buf, unsigned cnt )
	{
		int r = 0;

		//_CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
		//_VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);

		if( !( IsOpen() ) )
		{
			errno = EBADF;
			return -1;
		}

		flockfile();

		__try
		{
			if( IsOpen() )
			{
				r = _read_nolock( fh, buf, cnt ); // read bytes
			}
			else
			{
				errno = EBADF;
				_set_doserrno( 0 );
				r = -1;
				//assert(("Invalid file descriptor. File possibly closed by a different thread",0));
			}
		}
		__finally
		{
			funlockfile();
		}

		return r;
	}

	//------------------------------------------------------------------------------
	size_t CStream::fwrite( const void* buffer, size_t size, size_t count )
	{
		size_t retval = 0;

		if( size == 0 || count == 0 )
		{
			return 0;
		}

		if( this == 0 )
		{
			errno = EINVAL;
			return 0;
		}

		flockfile();

		__try
		{
			retval = _fwrite_nolock( buffer, size, count );
		}
		__finally
		{
			funlockfile();
		}

		return retval;
	}

	//------------------------------------------------------------------------------
	size_t CStream::_fwrite_nolock( const void* buffer, size_t size, size_t num )
	{
		const char* data;               // point to where data comes from next
		size_t total;                   // total bytes to write
		size_t count;                   // num bytes left to write
		unsigned bufsize;               // size of stream buffer 
		unsigned nbytes;                // number of bytes to write now
		unsigned nactuallywritten;      // number of bytes actually written by write() call
		unsigned nwritten;              // number of bytes we consider written 
		int c;                          // a temp char 

		if( size == 0 || num == 0 )
		{
			return 0;
		}

		if( this == 0 )
		{
			errno = EINVAL;
			return 0;
		}

		if( buffer == 0 )
		{
			errno = EINVAL;
			return 0;
		}

		if( num > ( Size_Max / size ) )
		{
			errno = EINVAL;
			return 0;
		}

		data = reinterpret_cast< const char* >( buffer );
		count = total = size * num;

		if( IsAnyBuffer() )	// already has buffer, use its size
		{
			bufsize = GetBufferSize();
		}
		else
		{					// assume will get _INTERNAL_BUFSIZ buffer
			bufsize = _INTERNAL_BUFSIZ;
		}

		// here is the main loop -- we go through here until we're done
		while( count != 0 )
		{
			// if the buffer is big and has room, copy data to buffer
			if( IsBigBuffer() && GetCountOfBytesLeftInBuffer() != 0 )
			{
				if( GetCountOfBytesLeftInBuffer() < 0 )
				{
					assert( ( "Inconsistent Stream Count. Flush between consecutive read and write", GetCountOfBytesLeftInBuffer() >= 0 ) );
					SetError();
					return ( total - count ) / size;
				}

				// how much do we want?
				nbytes = ( count < (unsigned)GetCountOfBytesLeftInBuffer() ) ? (unsigned)count : GetCountOfBytesLeftInBuffer();
				WriteIntoBuffer( (const byte*)data, nbytes );

				// update stream and amount of data written
				count -= nbytes;
				data += nbytes;
			}
			else if( count >= bufsize )
			{
				/* If we have more than bufsize chars to write, write data by calling write with an integral number of
				bufsiz blocks.  If we reach here and we have a big buffer, it must be full so _flush it. */

				if( IsBigBuffer() )
				{
					if( _flush() )
					{
						// error, stream flags set -- we're outof here
						return ( total - count ) / size;
					}
				}

				// calc chars to read -- (count/bufsize) * bufsize
				nbytes = ( bufsize ? (unsigned)( count - count % bufsize ) : (unsigned)count );

				nactuallywritten = _write( _fileno(), data, nbytes );

				if( nactuallywritten == (unsigned)EOF )
				{
					// error -- out of here
					SetError();
					return ( total - count ) / size;
				}

				//VSWhidbey#326224 - _write can return more bytes than we requested due unicode involved conversions in text files.
				//But we do not care about how many bytes were written as long as the number is at least as big as we wanted.
				
				nwritten = ( nactuallywritten > nbytes ? nbytes : nactuallywritten );

				// update count and data to reflect write

				count -= nwritten;
				data += nwritten;

				if( nactuallywritten < nbytes )
				{
					// error -- out of here
					SetError();
					return ( total - count ) / size;
				}
			}
			else
			{
				// buffer full and not enough chars to do direct write, so do a _flsbuf. 
				c = *data;  // _flsbuf write one char, this is it
				if( _flsbuf( c ) == EOF )
				{
					// error or eof, stream flags set by _flsbuf
					return ( total - count ) / size;
				}

				// _flsbuf wrote a char -- update count
				++data;
				--count;

				// update buffer size */
				bufsize = GetBufferSize() > 0 ? GetBufferSize() : 1;
			}
		}

		// we finished successfully, so just return num
		return num;
	}

	//------------------------------------------------------------------------------
	int CStream::_flsbuf( int ch )
	{
		int charcount;
		int written;
		int fh;

		assert( this != NULL );

		fh = _fileno();

		if( !( IsBufferRead() || IsBufferWrite() ) )
		{
			errno = EBADF;
			SetError();
			return( EOF );
		}
		else if( ( IsBufferString() ) )
		{
			errno = ERANGE;
			SetError();
			return( EOF );
		}

		/* Check that _IOREAD is not set or, if it is, then so is _IOEOF. Note that _IOREAD and IOEOF both being set implies switching from read to
		write at end-of-file, which is allowed by ANSI. Note that resetting the _cnt and _ptr fields amounts to doing an fflush() on the stream
		in this case. Note also that the _cnt field has to be reset to 0 for the error path as well (i.e., _IOREAD set but _IOEOF not set) as
		well as the non-error path. */

		if( IsBufferRead() )
		{
			if( IsBufferEOF() )
			{
				BufferFlushed();
				EndRead();
			}
			else
			{
				SetCountOfBytesLeftInBuffer( 0 );
				SetError();
				return( EOF );
			}
		}

		SetCountOfBytesLeftInBuffer( 0 );
		BeginWrite();
		
		ClearBufferEOF();
		written = charcount = 0;

		// Get a buffer for this stream, if necessary.
		if( !IsAnyBuffer() )
		{
			/* Do NOT get a buffer if (1) stream is stdout/stderr, and
			(2) stream is NOT a tty. [If stdout/stderr is a tty, we do NOT set up single char buffering. This is so that later temporary buffering will not be thwarted by the _IONBF bit being set (see _stbuf/_ftbuf usage).]
			*/
			if( !( ( ( this == stdout ) || ( this == stderr ) ) && ( _isatty( fh ) ) ) )
			{
				_getbuf();
			}

		}

		// If big buffer is assigned to stream...
		if( IsBigBuffer() )
		{
			//assert( ("inconsistent IOB fields", _ptr - _base >= 0 ) );

			charcount = BufferOffset();

			SetPointerIntoBuffer( (char*)GetBufferBasePointer() + sizeof( char ) );
			SetCountOfBytesLeftInBuffer( GetBufferSize() - ( int )sizeof( char ) );
			

			if( charcount > 0 )
			{
				written = _write( fh, GetBufferBasePointer(), charcount );
			}
			else
			{
				if( IsAppendMode() )
				{
					if( _lseeki64( fh, 0L, SEEK_END ) == -1 )
					{
						SetError();
						return( EOF );
					}
				}
			}
			( *GetBufferBasePointer() ) = (byte)( ch );
		}
		else 		// Perform single character output (either _IONBF or no buffering)
		{
			charcount = sizeof( char );
			written = _write( fh, &ch, charcount );
		}

		// See if the _write() was successful.
		if( written != charcount )
		{
			SetError();
			return( EOF );
		}

		return( ch & 0xff );
	}

	//------------------------------------------------------------------------------
	int CStream::_write( int fh, const void* buf, unsigned cnt )
	{
		int r = 0;                      // return value

										// validate handle
		if( fh == _NO_CONSOLE_FILENO )
		{
			_set_doserrno( 0 );
			errno = EBADF;
			return -1;
		}

		int _Expr_val = !!( ( fh >= 0 ) );//&& (unsigned)fh < (unsigned)_nhandle));
		assert( ( _Expr_val ) );//, _WTXT("(fh >= 0 && (unsigned)fh < (unsigned)_nhandle)") );
		if( !( _Expr_val ) )
		{
			_set_doserrno( 0 );
			errno = EBADF;
			//TODO: Raise invalid parameter error
			return -1;
		}

		//_VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);

		flockfile();

		__try
		{
			if( IsOpen() )
			{
				r = _write_nolock( fh, buf, cnt );    // write bytes
			}
			else
			{
				errno = EBADF;
				_set_doserrno( 0 );  // not o.s. error
				r = -1;
				//_ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
			}
		}
		__finally
		{
			funlockfile();
		}

		return r;
	}

	//------------------------------------------------------------------------------
	int CStream::_write_nolock( int fh, const void* buf, unsigned cnt )
	{
		int lfcount = 0;								// count of line feeds
		int charcount = 0;								// count of chars written so far
		int written;									// count of chars written on this write
		unsigned long dosretval = 0;					// o.s. return value
		char tmode;										// textmode - ANSI or UTF-16
		bool toConsole = false;							// true when writing to console
		bool isCLocale = false;							// true when locale handle is C locale

		if( cnt == 0 )
		{
			return 0;							// nothing to do
		}

		assert( buf != NULL );
		if( buf == NULL )
		{
			_set_doserrno( 0 );
			errno = EINVAL;
			return -1;
		}

		tmode = GetTextMode();

		if( tmode == __IOINFO_TM_UTF16LE || tmode == __IOINFO_TM_UTF8 )
		{
			// For a UTF-16 file, the count must always be an even number
			assert( ( cnt & 1 ) == 0 );
			if( ( cnt & 1 ) != 0 )
			{
				_set_doserrno( 0 );
				errno = EINVAL;
				return -1;
			}
		}

		if( IsAppendMode() )
		{
			// appending - seek to end of file; ignore error, because maybe file doesn't allow seeking
			(void)_lseeki64_nolock( fh, 0, File_End );
		}

		// check for text mode with LF's in the buffer

		/* Note that in case the handle belongs to Console, write file will generate garbage output. For user to print these characters correctly, we will need to print ANSI.
		* Also note that in case of printing to Console, we still have to convert the characters to console codepage. */

		if( _isatty( fh ) && ( GetIsTextMode() ) )
		{
			unsigned long dwMode = 0;

			//isCLocale = (ptd->ptlocinfo->locale_name[LC_CTYPE] == NULL);

			isCLocale = ( GetCurrentWin32Thread()->LocaleInfoPtr()->Category( CLocale::LCCTYPE ).CatLocale() == NULL ) ? true : false;

			CTerminal* pTerminal = CWin32Application::TheWin32Application()->GetRole()->GetSubSystem( CTerminal::ClassID() ).As< CTerminal >();
			toConsole = pTerminal->Console()->ScreenBuffer()->GetInputMode( dwMode );
		}

		// don't need double conversion if it's ANSI mode C locale
		if( toConsole && !( isCLocale && ( tmode == __IOINFO_TM_ANSI ) ) )
		{
			CTerminal* pTerminal = CWin32Application::TheWin32Application()->GetRole()->GetSubSystem( CTerminal::ClassID() ).As< CTerminal >();
			unsigned int consoleCP = pTerminal->Console()->OutputCodePage().ID();
			char mboutbuf[ MBLenMax ];
			wchar_t tmpchar = 0;
			int size = 0;
			written = 0;
			char *pch;

			for( pch = (char *)buf; (unsigned)( pch - (char *)buf ) < cnt; )
			{
				int bCR = 0;

				if( tmode == __IOINFO_TM_ANSI )
				{
					bCR = *pch == LF;
					// Here we need to do double convert. i.e. convert from multibyte to unicode and then from unicode to multibyte in Console codepage.
					// Here, we have take into account that _write() might be called byte by byte, so when we see a lead byte without a trail byte, we have to store it and return no error.

					if( IsLeadByteBufferUsed() )
					{
						// we got something buffered, join it with the lead byte and convert
						assert( isleadbyte( ReadDBCSBuffer() ) );
						mboutbuf[ 0 ] = ReadDBCSBuffer();
						mboutbuf[ 1 ] = *pch;
						// reseting the flag
						SetIsLeadByteBufferUsed( false );

						if( mbtowc( &tmpchar, mboutbuf, 2 ) == -1 )
						{
							break;
						}
					}
					else
					{
						if( isleadbyte( *pch ) )
						{
							if( ( cnt - ( pch - (char*)buf ) ) > 1 )
							{
								// and we have more bytes to read, just convert
								if( mbtowc( &tmpchar, pch, 2 ) == -1 )
								{
									break;
								}
								// Increment pch to accomodate DBCS character.
								++pch;
							}
							else
							{
								// and we ran out of bytes to read, buffer the lead byte
								WriteDBCSBuffer( *pch );

								// lying that we actually wrote the last character, so it doesn't error
								charcount++;
								break;
							}
						}
						else
						{
							// single char conversion
							if( mbtowc( &tmpchar, pch, 1 ) == -1 )
							{
								break;
							}
						}
					}
					++pch;
				}
				else if( tmode == __IOINFO_TM_UTF8 || tmode == __IOINFO_TM_UTF16LE )
				{
					//Note that bCR set above is not valid in case of UNICODE stream. We need to set it using unicode character.
					tmpchar = *(wchar_t *)pch;
					bCR = tmpchar == LF;
					pch += 2;
				}

				if( tmode == __IOINFO_TM_ANSI )
				{
					if( ( size = m_StringHelper.WideCharToMultiByte( consoleCP, 0, &tmpchar, 1, mboutbuf, sizeof( mboutbuf ), NULL, NULL ) ) == 0 )
					{
						break;
					}
					else
					{
						if( m_pStreamDevice->Write( mboutbuf, size, reinterpret_cast< unsigned long* >( &written ), 0 ) )
						{
							/* When we are converting, some convertion can result in 2 mbcs char -> 1 wchar -> 1 mbcs
							* (ie. printing out Japanese characters in English ConsoleCP,
							* the Japanese char will be converted to a single question mark)
							* Therefore, we want to use how many bytes we converted + lfcount
							* instead of how many bytes we actually wrote
							*/
							charcount = lfcount + (int)( pch - (char*)buf );
							if( written < size )
							{
								break;
							}
						}
						else
						{
							dosretval = m_ErrorHelper.GetLastError();
							break;
						}
					}

					if( bCR )
					{
						size = 1;
						mboutbuf[ 0 ] = CR;
						if( m_pStreamDevice->Write( mboutbuf, size, reinterpret_cast< unsigned long* >( &written ), 0 ) )
						{
							if( written < size )
							{
								break;
							}
							lfcount++;
							charcount++;
						}
						else
						{
							dosretval = m_ErrorHelper.GetLastError();
							break;
						}
					}
				}
				else if( tmode == __IOINFO_TM_UTF8 || tmode == __IOINFO_TM_UTF16LE )
				{
					if( _putwch_nolock( tmpchar ) == tmpchar )
					{
						charcount += 2;
					}
					else
					{
						dosretval = m_ErrorHelper.GetLastError();
						break;
					}

					if( bCR ) // emit carriage return
					{
						size = 1;
						tmpchar = CR;
						if( _putwch_nolock( tmpchar ) == tmpchar )
						{
							charcount++;
							lfcount++;
						}
						else
						{
							dosretval = m_ErrorHelper.GetLastError();
							break;
						}
					}
				}
			}
		}
		else if( GetIsTextMode() )
		{
			// text mode, translate LF's to CR/LF's on output

			dosretval = 0;          // no OS error yet

			if( tmode == __IOINFO_TM_ANSI )
			{
				char ch;                    // current character
				char* p = NULL, *q = NULL;  // pointers into buf and lfbuf resp.
				char lfbuf[ BUF_SIZE ];
				p = (char *)buf;        // start at beginning of buffer
				while( (unsigned)( p - (char *)buf ) < cnt )
				{
					q = lfbuf;      // start at beginning of lfbuf 

									// fill the lf buf, except maybe last char
					while( q - lfbuf < sizeof( lfbuf ) - 1 && (unsigned)( p - (char *)buf ) < cnt )
					{
						ch = *p++;
						if( ch == LF )
						{
							++lfcount;
							*q++ = CR;
						}
						*q++ = ch;
					}

					// write the lf buf and update total
					if( m_pStreamDevice->Write( lfbuf, (int)( q - lfbuf ), reinterpret_cast< unsigned long* >( &written ), 0 ) )
					{
						charcount += written;
						if( written < q - lfbuf )
							break;
					}
					else
					{
						dosretval = m_ErrorHelper.GetLastError();
						break;
					}
				}
			}
			else if( tmode == __IOINFO_TM_UTF16LE )
			{
				char lfbuf[ BUF_SIZE ];
				wchar_t wch;            // current wide char
				wchar_t *pu = (wchar_t *)buf;
				wchar_t *qu = NULL;

				while( (unsigned)( (char *)pu - (char *)buf ) < cnt )
				{
					qu = (wchar_t *)lfbuf; // start at beginning of lfbuf

											// fill the lf buf, except maybe last wchar_t
					while( ( ( (char *)qu - lfbuf ) < ( sizeof( lfbuf ) - 2 ) ) && ( (unsigned)( (char *)pu - (char *)buf ) < cnt ) )
					{
						wch = *pu++;
						if( wch == LF )
						{
							lfcount += 2;
							*qu++ = CR;
						}
						*qu++ = wch;
					}

					// write the lf buf and update total
					if( m_pStreamDevice->Write( lfbuf, (int)( (char*)qu - lfbuf ), reinterpret_cast< unsigned long* >( &written ), 0 ) )
					{
						charcount += written;
						if( written < ( (char *)qu - lfbuf ) )
							break;
					}
					else
					{
						dosretval = m_ErrorHelper.GetLastError();
						break;
					}
				}
			}
			else
			{
				// Let's divide the lfbuf in 1:2 wher 1 is for storing widecharacters and 2 if for converting it to UTF8.  
				// This takes into account the worst case scenario where all the UTF8 characters are 4 byte long.
				char utf8_buf[ ( BUF_SIZE * 2 ) / 3 ];
				wchar_t utf16_buf[ BUF_SIZE / 6 ];

				wchar_t wch;            // current wide char
				wchar_t *pu = (wchar_t *)buf;
				wchar_t *qu = NULL;

				pu = (wchar_t *)buf;
				while( (unsigned)( (char *)pu - (char *)buf ) < cnt )
				{
					int bytes_converted = 0;
					qu = utf16_buf; // start at beginning of lfbuf

					while( ( ( (char *)qu - (char *)utf16_buf ) < ( sizeof( utf16_buf ) - 2 ) ) && ( (unsigned)( (char *)pu - (char *)buf ) < cnt ) )
					{
						wch = *pu++;
						if( wch == LF )
						{
							// no need to count the linefeeds here: we calculate the written chars in another way
							*qu++ = CR;
						}
						*qu++ = wch;
					}

					bytes_converted = m_StringHelper.WideCharToMultiByte( CCodePage::UTF8, 0, utf16_buf, ( (int)( (char *)qu - (char *)utf16_buf ) ) / 2, utf8_buf, sizeof( utf8_buf ), 0, 0 );

					if( bytes_converted == 0 )
					{
						dosretval = m_ErrorHelper.GetLastError();
						break;
					}
					else
					{
						// Here we need to make every attempt to write all the converted characters. 
						//The resaon behind this is incase half the bytes of a UTF8 character is written, it may currupt whole of the stream or file.
						// The loop below will make sure we exit only if all the bytes converted are written (which makes sure no partial MBCS is written) or there was some error in the stream.
						int bytes_written = 0;
						do
						{
							if( m_pStreamDevice->Write( utf8_buf + bytes_written, bytes_converted - bytes_written, reinterpret_cast< unsigned long* >( &written ), 0 ) )
							{
								bytes_written += written;
							}
							else
							{
								dosretval = m_ErrorHelper.GetLastError();
								break;
							}
						} while( bytes_converted > bytes_written );

						// Only way the condition below could be true is if there was en error. 
						//In case of error we need to break this loop as well.

						if( bytes_converted > bytes_written )
						{
							break;
						}
						// if this chunk has been committed successfully, update charcount
						charcount = (int)( (char *)pu - (char *)buf );
					}
				}
			}
		}
		else
		{
			// binary mode, no translation
			if( m_pStreamDevice->Write( (const byte*)buf, cnt, reinterpret_cast< unsigned long* >( &written ), 0 ) )
			{
				dosretval = 0;
				charcount = written;
			}
			else
			{
				dosretval = m_ErrorHelper.GetLastError();
			}
		}

		if( charcount == 0 )
		{
			// If nothing was written, first check if an o.s. error, otherwise we return -1 and set errno to ENOSPC, unless a device and first char was CTRL-Z
			if( dosretval != 0 )
			{
				// o.s. error happened, map error
				if( dosretval == ErrorAccessDenied )
				{
					// wrong read/write mode should return EBADF, not EACCES
					errno = EBADF;
					_set_doserrno( dosretval );
				}
				else
				{
					CDOSError::MapError( m_ErrorHelper.GetLastError() );
				}
				return -1;
			}
			else if( IsDevice() && *(char *)buf == CTRLZ )
			{
				return 0;
			}
			else
			{
				errno = ENOSPC;
				_set_doserrno( 0 );  // no o.s. error
				return -1;
			}
		}
		else
		{
			// return adjusted bytes written
			return charcount - lfcount;
		}
	}

	//------------------------------------------------------------------------------
	bool CStream::IsWrite( void )
	{
		return IsBufferWrite();
	}

	//------------------------------------------------------------------------------
	void CStream::SetLowLevelFlags( byte Flags )
	{
		SetFlags( Flags );
	}

	//------------------------------------------------------------------------------
	void CStream::SetLowLevelFile( CFile* pFile )
	{
		if( m_pStreamDevice == 0 )
		{
			m_pStreamDevice = pFile;
		}
	}
	
}//nsWin32

