//UTF16Char.cpp

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "CompilerQOR.h"
#include "CodeQOR/Text/UTF16Char.h"

//------------------------------------------------------------------------------
namespace nsCodeQOR
{
	//--------------------------------------------------------------------------------
	CUTF16Char::CUTF16Char() : m_pChar( 0 )
	{
	}

	//--------------------------------------------------------------------------------
	CUTF16Char::CUTF16Char( CChar16* pChar ) : m_pChar( pChar )
	{
	}

	//--------------------------------------------------------------------------------
	CUTF16Char::CUTF16Char( const CUTF16Char& Src )
	{
		if( &Src != this )
		{
			*this = Src;
		}
	}
		
	//--------------------------------------------------------------------------------
	CUTF16Char& CUTF16Char::operator = ( const CUTF16Char& Src )
	{
		m_pChar = Src.m_pChar;
		return *this;
	}

	//--------------------------------------------------------------------------------
	bool CUTF16Char::operator == ( const CUTF16Char& Cmp ) const
	{
		return ToCodePoint() == Cmp.ToCodePoint();
	}

	//--------------------------------------------------------------------------------
	CUTF16Char& CUTF16Char::operator++( void )
	{
		m_pChar = m_pChar + Len();
		return *this;
	}

	//--------------------------------------------------------------------------------
	CUTF16Char& CUTF16Char::operator--( void )
	{
		m_pChar = m_pChar - 2;
		if( ( m_pChar->m & 0xFC00 ) != 0xD800 )
		{
			m_pChar++;
		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	CUTF16Char& CUTF16Char::operator += ( unsigned short usOffset )
	{
		while( usOffset-- )
		{
			m_pChar = m_pChar + Len();
		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	CUTF16Char& CUTF16Char::operator -= ( unsigned short usOffset )
	{
		while( usOffset-- )
		{
			m_pChar = m_pChar - 2;
			if( ( m_pChar->m & 0xFC00 ) != 0xD800 )
			{
				m_pChar++;
			}
		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	CUTF16Char::operator CChar16*() const
	{
		return m_pChar;
	}

	//--------------------------------------------------------------------------------
	CChar16* CUTF16Char::operator -> () const
	{
		return m_pChar;
	}

	//--------------------------------------------------------------------------------
	CUTF16Char::~CUTF16Char()
    {
    }

	//--------------------------------------------------------------------------------
	void CUTF16Char::Dispose( void )
	{
		m_pChar = 0;
	}

	//--------------------------------------------------------------------------------
	void CUTF16Char::Attach( CChar16* p )
	{
		m_pChar = p;
	}

    //--------------------------------------------------------------------------------
    CChar16* CUTF16Char::Detach()
    {
		CChar16* pResult = m_pChar;
		m_pChar = 0;
		return pResult;
    }
	
	//--------------------------------------------------------------------------------
	bool CUTF16Char::IsNull() const
	{
		return m_pChar == 0 || m_pChar->m == 0;
	}

	//--------------------------------------------------------------------------------
	unsigned char CUTF16Char::Len() const
	{
		unsigned char ucResult = 0;
		if( !IsNull() )
		{			
			unsigned short W1 = m_pChar->m;

			if( ( W1 < 0xD800 ) || ( W1 > 0xDFFF ) )
			{
				ucResult = 2;
			}
			if( ( W1 & 0xFC00 ) == 0xD800 )
			{
				ucResult = 4;
			}
		}
		return ucResult;
	}

	//--------------------------------------------------------------------------------
	bool CUTF16Char::IsInvalid()
	{
		unsigned char ucLen = Len();
		switch (ucLen)
		{
		case 0:
			return true;
		case 2:
			return !( m_pChar->m < 0xD800 || m_pChar->m > 0xDFFF );
		case 4:
			if( ( m_pChar[ 1 ].m & 0xFC00 ) != 0xDC00 )
			{
				return true;
			}
			break;
		default:
			return true;
		}
		return false;
	}

	//------------------------------------------------------------------------------
	unsigned int CUTF16Char::ToCodePoint( void ) const
	{
		switch( Len() )
		{
		case 0:
			return 0;
		case 2:
			return static_cast< unsigned int >( m_pChar->m );
		case 4:
			return static_cast< unsigned int >( ( m_pChar[ 0 ].m << 10 ) + m_pChar[ 1 ].m - 0x35FDC00 );
		default:
			return 0;
		}
	}

	//------------------------------------------------------------------------------
	CChar16::eUnicodeVersion CUTF16Char::CurrentUnicodeVersion( void )
	{
		return CChar16::UNICODE_DATA_VERSION;
	}

	//--------------------------------------------------------------------------------
	CChar16::eCategory CUTF16Char::Category() const
	{
		return static_cast< CChar16::eCategory >( UnicodeGetProp( ToCodePoint() )->category );
	}

	//--------------------------------------------------------------------------------
	CChar16::eDirection CUTF16Char::Direction() const
	{
		return static_cast< CChar16::eDirection >( UnicodeGetProp( ToCodePoint() )->direction );
	}

	//--------------------------------------------------------------------------------
	CChar16::eJoining CUTF16Char::Joining() const
	{
		return static_cast< CChar16::eJoining >( UnicodeGetProp( ToCodePoint() )->joining );
	}

	//--------------------------------------------------------------------------------
	bool CUTF16Char::HasMirrored() const
	{
		return UnicodeGetProp( ToCodePoint() )->mirrorDiff != 0;
	}

	//--------------------------------------------------------------------------------
	unsigned char CUTF16Char::CombiningClass() const
	{
		return (unsigned char) UnicodeGetProp( ToCodePoint())->combiningClass;
	}

	//--------------------------------------------------------------------------------
	int CUTF16Char::DigitValue() const
	{
		return UnicodeGetProp( ToCodePoint() )->digitValue;
	}

	//--------------------------------------------------------------------------------
	CChar16::eUnicodeVersion CUTF16Char::UnicodeVersion() const
	{
		return static_cast< CChar16::eUnicodeVersion >( UnicodeGetProp( ToCodePoint() )->unicodeVersion );
	}

	//--------------------------------------------------------------------------------
	bool CUTF16Char::IsPrint() const
	{
		const int test = Flag( CChar16::Other_Control ) | Flag( CChar16::Other_NotAssigned );
		return !( Flag( UnicodeGetProp( ToCodePoint() )->category ) & test );
	}

	//--------------------------------------------------------------------------------
	bool CUTF16Char::IsPunct() const
	{
		const int test = Flag( CChar16::Punctuation_Connector ) | Flag( CChar16::Punctuation_Dash ) | Flag( CChar16::Punctuation_Open ) | Flag( CChar16::Punctuation_Close ) | Flag( CChar16::Punctuation_InitialQuote ) |
							Flag( CChar16::Punctuation_FinalQuote ) | Flag( CChar16::Punctuation_Other );
		return Flag( UnicodeGetProp( ToCodePoint() )->category) & test ? true : false;
	}

	//--------------------------------------------------------------------------------
	bool CUTF16Char::IsSpace() const
	{
		unsigned int ucs4 = ToCodePoint();
		if( ucs4 >= 9 && ucs4 <= 13 )
		{
			return true;
		}
		const int test = Flag( CChar16::Separator_Space ) | Flag( CChar16::Separator_Line ) | Flag( CChar16::Separator_Paragraph );
		return Flag( UnicodeGetProp( ucs4 )->category ) & test ? true : false;
	}

	//--------------------------------------------------------------------------------
	bool CUTF16Char::IsMark() const
	{
		const int test = Flag( CChar16::Mark_NonSpacing ) | Flag( CChar16::Mark_SpacingCombining ) | Flag( CChar16::Mark_Enclosing );
		return Flag( UnicodeGetProp( ToCodePoint() )->category ) & test ? true : false;
	}

	//--------------------------------------------------------------------------------
	bool CUTF16Char::IsLetter() const
	{
		const int test = Flag( CChar16::Letter_Uppercase ) | Flag( CChar16::Letter_Lowercase ) | Flag( CChar16::Letter_Titlecase ) | Flag( CChar16::Letter_Modifier ) | Flag( CChar16::Letter_Other );
		return Flag( UnicodeGetProp( ToCodePoint() )->category ) & test ? true : false;
	}

	//--------------------------------------------------------------------------------
	bool CUTF16Char::IsNumber() const
	{
		const int test = Flag( CChar16::Number_DecimalDigit ) | Flag( CChar16::Number_Letter ) | Flag( CChar16::Number_Other );
		return Flag( UnicodeGetProp( ToCodePoint() )->category ) & test ? true : false;
	}

	//--------------------------------------------------------------------------------
	bool CUTF16Char::IsLetterOrNumber() const
	{
		const int test = Flag( CChar16::Letter_Uppercase) | Flag( CChar16::Letter_Lowercase) | Flag( CChar16::Letter_Titlecase) | Flag( CChar16::Letter_Modifier) | Flag(CChar16::Letter_Other) | Flag(CChar16::Number_DecimalDigit) |
							Flag(CChar16::Number_Letter) | Flag(CChar16::Number_Other);
		return Flag( UnicodeGetProp( ToCodePoint() )->category ) & test ? true : false;
	}

	//--------------------------------------------------------------------------------
	bool CUTF16Char::IsDigit() const
	{
		return ( UnicodeGetProp( ToCodePoint() )->category == CChar16::Number_DecimalDigit );
	}

	//--------------------------------------------------------------------------------
	bool CUTF16Char::IsSymbol() const
	{
		const int test = Flag(CChar16::Symbol_Math) | Flag(CChar16::Symbol_Currency) | Flag(CChar16::Symbol_Modifier) | Flag(CChar16::Symbol_Other); 
		return Flag( UnicodeGetProp( ToCodePoint() )->category ) & test ? true : false;
	}

	//--------------------------------------------------------------------------------
	inline bool CUTF16Char::IsLower() const
	{
		return Category() == CChar16::Letter_Lowercase;
	}

	//--------------------------------------------------------------------------------
	inline bool CUTF16Char::IsUpper() const
	{
		return Category() == CChar16::Letter_Uppercase;
	}

	//--------------------------------------------------------------------------------
	inline bool CUTF16Char::IsTitleCase() const
	{
		return Category() == CChar16::Letter_Titlecase;
	}

	//--------------------------------------------------------------------------------
	CChar16::eDecomposition CUTF16Char::DecompositionTag() const
	{
		unsigned int ucs4 = ToCodePoint();
		const unsigned short index = GET_DECOMPOSITION_INDEX( ucs4 );
		if( index == 0xffff )
		{
			return CChar16::NoDecomposition;
		}
		return static_cast< CChar16::eDecomposition >( uc_decomposition_map[ index ] & 0xff );
	}

}//nsCodeQOR
