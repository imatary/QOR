//ErrorDomain.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQAPI/WinQAPI.h"
#include "SystemQOR.h"
#include "CodeQOR/Modules/ProcessBase.h"
#include "CodeQOR/ErrorSystem/What.h"
#include "CodeQOR/ErrorSystem/Where.h"
#include "CodeQOR/ErrorSystem/When.h"
#include "../Source/SystemQOR/MSWindows/WinQAPI/include/ErrorDomain.h"
#include "../Source/SystemQOR/MSWindows/WinQAPI/include/Error.h"
#include "WinQAPI/Kernel32.h"
#include "WinQAPI/AdvAPI32.h"

//--------------------------------------------------------------------------------
namespace nsWinQAPI
{
	CErrorDomain _ErrorDomain;

    //--------------------------------------------------------------------------------
    CErrorDomain::CErrorDomain() : nsCodeQOR::CBaseErrorDomain( _TXT("WinQAPI") )
    {
    }

    //--------------------------------------------------------------------------------
    CErrorDomain::~CErrorDomain()
    {
    }

	//--------------------------------------------------------------------------------
	CErrorDomain* ErrorDomainPtr( void )
	{
		return &_ErrorDomain;
	}

	//--------------------------------------------------------------------------------
	const CErrorDomain::s_WinQAPIError CErrorDomain::m_Notes[ MAX_NOTES ] =
	{
		{ _T( "%1" ), { &CErrorDomain::GetParam< 0 >, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
	};

	//--------------------------------------------------------------------------------
	const CErrorDomain::s_WinQAPIError CErrorDomain::m_Warnings[ MAX_WARNINGS ] =
	{
		{ _T( "%1 %2" ), { _ERR_SEVERITY_, _ERR_PARAM0_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 The buffer supplied to the Win32 API function %2 was too small at %3. The API did not complete its function, please retry the call with a larger buffer." ),//BUFFER_INADEQUATE
			{ _ERR_SEVERITY_, _ERR_PARAM0_, _ERR_PARAM1_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 The Win32 API function %2 returned no data." ), { _ERR_SEVERITY_, _ERR_PARAM0_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//API_RETURNED_NO_DATA
		{ _T( "%1 The value returned from Win32 API function %2 indicates the required feature is unsupported." ), { _ERR_SEVERITY_, _ERR_PARAM0_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//RESULT_INDICATES_UNSUPPORTED_FEATURE
		{ _T( "%1 The Win32 API function %2 is unreliable and should not be used." ), { _ERR_SEVERITY_, _ERR_PARAM0_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//UNRELIABLE_API
		{ _T( "%1 The value returned from Win32 API function %2 may indicate a security issue." ), { _ERR_SEVERITY_, _ERR_PARAM0_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//RETURN_MAY_INDICATE_SECURITY_ISSUE
		{ _T( "%1 The value returned from Win32 API function %2 indicates the requested information is not available." ), { _ERR_SEVERITY_, _ERR_PARAM0_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },//RESULT_INDICATES_INFO_UNAVAILABLE
	};

	//--------------------------------------------------------------------------------
	const CErrorDomain::s_WinQAPIError CErrorDomain::m_Errors[ MAX_ERROR ] =
	{
		{ _T( "%1 A call to Win32 API function %2 failed %3. Windows reports %4." ), //GENERAL_API_ERROR
		{ _ERR_SEVERITY_, _ERR_PARAM0_, _ERR_SOURCE_, &CErrorDomain::GetOSError, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 The Win32 API function %2 is unavailable. Target %3 to use this function.\n%4" ), //API_REQUIRES_VERSION
		{ _ERR_SEVERITY_, _ERR_PARAM0_, _ERR_PARAM1_, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 No Standard handle of the type requested is available. Is this process a Service or lacking a Console?" ), //NO_STANDARD_HANDLE
		{ _ERR_SEVERITY_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 The Win32 Tape API function %2 failed. %3 %4" ), //TAPE_API_ERROR
		{ _ERR_SEVERITY_, _ERR_PARAM0_, _ERR_PARAM1_, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 The Win32 API function %2 failed. %3 %4" ), //API_FAILED
		{ _ERR_SEVERITY_, _ERR_PARAM0_, &CErrorDomain::GetWinError< 1 >, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 The Win32 Application Recovery API function %2 failed. %3 %4" ), //APP_RECOVERY_API_ERROR
		{ _ERR_SEVERITY_, _ERR_PARAM0_, _ERR_PARAM1_, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 The Win32 Snapshot API function %2 failed. %3 %4" ), //SNAPSHOT_API_ERROR
		{ _ERR_SEVERITY_, _ERR_PARAM0_, _ERR_PARAM1_, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 The Win32 LZ File API function %2 failed. %3 %4" ),//LZ_API_ERROR
		{ _ERR_SEVERITY_, _ERR_PARAM0_, _ERR_PARAM1_, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 The Win32 WinExec API function %2 failed. %3 %4" ),//WINEXEC_API_ERROR
		{ _ERR_SEVERITY_, _ERR_PARAM0_, _ERR_PARAM1_, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 The Win32 DDE API function %2 failed. %3 %4" ), //DDE_API_ERROR
		{ _ERR_SEVERITY_, _ERR_PARAM0_, &CErrorDomain::GetDDEError< 2 >, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 The Win32 DDEML API function %2 failed. %3 %4" ), //DDEML_API_ERROR
		{ _ERR_SEVERITY_, _ERR_PARAM0_, _ERR_PARAM1_, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 A Win32 Wait API function %2 failed. %3" ),//API_WAIT_FAILED
		{ _ERR_SEVERITY_, _ERR_PARAM0_, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 A Win32 Display Settings API function %2 failed. %3 %4" ), //DISP_CHANGE_API_ERROR
		{ _ERR_SEVERITY_, _ERR_PARAM0_, &CErrorDomain::GetDispChangeError< 2 >, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 The Win32 Spooler API function %2 failed. %3 %4" ), //SPOOLER_API_ERROR
		{ _ERR_SEVERITY_, _ERR_PARAM0_, _ERR_PARAM1_, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 The Win32 Directory API function %2 failed. %3 %4" ), //DIRECTORY_API_ERROR
		{ _ERR_SEVERITY_, _ERR_PARAM0_, _ERR_PARAM1_, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 The named Kernel object %4 was not found. %2 failed. %3" ),//NAMED_KERNELOBJ_NOT_FOUND,
		{ _ERR_SEVERITY_, _ERR_PARAM0_, _ERR_PARAM1_, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 A Win32 API call %2 failed due to an invalid parameter. %3" ),//API_INVALID_PARAMETER,
		{ _ERR_SEVERITY_, _ERR_PARAM0_, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 The Win32 API function %2 failed with status %3 %4" ), //API_RETURNED_NTSTATUS
		{ _ERR_SEVERITY_, _ERR_PARAM0_, &CErrorDomain::GetNTStatus< 1 >, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 A Windows specifc Structured Exception occured" ), //SEH_ERROR
		{ _ERR_SEVERITY_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 An invalid security identifier object was found" ), //INVALID_SID
		{ _ERR_SEVERITY_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
		{ _T( "%1 An error occured which compromises security %2 %3" ),//SECURITY_ERROR
		{ _ERR_SEVERITY_, _ERR_PARAM0_, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },

		{ _T( "%1 An uninitialized parameter was passed %2" ), //UNINITIALIZED_PARAMETER
		{ _ERR_SEVERITY_, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },

		{ _T( "%1 This Win32 API is not available because the application was built with MinGW32: %2" ), //API_NOT_IN_MINGW32
		{ _ERR_SEVERITY_, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },

		{ _T( "%1 Dynamic Library function is missing and was not called: %2" ), //MISSING_LIBRARY_FUNCTION
		{ _ERR_SEVERITY_, _ERR_SOURCE_, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
	};

	//--------------------------------------------------------------------------------
	const nsCodeQOR::CBaseErrorDomain::s_BaseError* CErrorDomain::NoteTemplate( unsigned int uiCode )
	{
		if( uiCode < MAX_NOTES )
		{
			return (CBaseErrorDomain::s_BaseError*)&m_Notes[ uiCode - CBaseErrorDomain::MAX_NOTES ];
		}
		else
		{
			return 0;
		}
	}

	//--------------------------------------------------------------------------------
	const nsCodeQOR::CBaseErrorDomain::s_BaseError* CErrorDomain::WarningTemplate( unsigned int uiCode )
	{
		if( uiCode < MAX_WARNINGS )
		{
			return (CBaseErrorDomain::s_BaseError*)&m_Warnings[ uiCode - CBaseErrorDomain::MAX_WARNS ];
		}
		else
		{
			return 0;
		}
	}

	//--------------------------------------------------------------------------------
	const nsCodeQOR::CBaseErrorDomain::s_BaseError* CErrorDomain::ErrorTemplate( unsigned int uiCode )
	{
		if( uiCode < MAX_ERROR )
		{
			return (CBaseErrorDomain::s_BaseError*)&m_Errors[ uiCode - CBaseErrorDomain::MAX_ERRORS ];
		}
		else
		{
			return 0;
		}
	}

	//--------------------------------------------------------------------------------
	bool CErrorDomain::GetDescription( mxTCHAR** ppDescription, nsCodeQOR::CError* pError )
	{
		bool bResult = false;
		*ppDescription = new mxTCHAR[ MAX_ERRTEXT ];

		unsigned int uiCustomLevel = 0;
		nsCodeQOR::CError::E_LEVEL Severity = pError->What().GetLevel( &uiCustomLevel );

		unsigned int uiCode = pError->What().Code();

		const s_WinQAPIError* pTemplate = 0;
		mxTCHAR* ppszParts[ MAX_ERRPARTS ];
		int i = 0;
		while( i < MAX_ERRPARTS )
		{
			ppszParts[ i++ ] = 0;
		}

		switch ( Severity )
		{
		case nsCodeQOR::CError::ERR_LVL_NOTE:
			if( uiCode < MAX_NOTES )
			{
				pTemplate = (const s_WinQAPIError*)NoteTemplate( uiCode );
			}
			break;
		case nsCodeQOR::CError::ERR_LVL_WARNING:
			if( uiCode < MAX_WARNINGS )
			{
				pTemplate = (const s_WinQAPIError*)WarningTemplate( uiCode );
			}
			break;
		case nsCodeQOR::CError::ERR_LVL_CONTINUE:
		case nsCodeQOR::CError::ERR_LVL_SERIOUS:
		case nsCodeQOR::CError::ERR_LVL_FATAL:
		default:
			{
				pTemplate = (const s_WinQAPIError*)ErrorTemplate( uiCode );
			}
			break;
		};

		if( pTemplate != 0 )
		{
			GetErrorParts( pError, *((const nsCodeQOR::CBaseErrorDomain::s_BaseError*)pTemplate), ppszParts );
			CKernel32::FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, pTemplate->pText, 0, 0, *ppDescription, MAX_ERRTEXT, (va_list*)ppszParts );
			bResult = true;
		}

		return bResult;
	}

	//--------------------------------------------------------------------------------
	//Get the Windows Error message corresponding to the value of parameter ui
	void* CErrorDomain::GetWinError( nsCodeQOR::CError* pError, unsigned int ui )
	{
		mxTCHAR* pBuffer = new mxTCHAR[ Max_OS_Message_Size ];
		CKernel32::FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, 0, ui, MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), pBuffer, Max_OS_Message_Size, 0 );
		return pBuffer;
	}

	//--------------------------------------------------------------------------------
	void* CErrorDomain::GetNTStatusMsg( nsCodeQOR::CError* pError, unsigned int ui )
	{
		mxTCHAR* pBuffer = new mxTCHAR[ Max_OS_Message_Size ];
		//nsWinQAPI::CAdvAPI32 AdvAPI;
		//CKernel32::FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, 0, AdvAPI.LsaNtStatusToWinError( ui ), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), pBuffer, Max_OS_Message_Size,  0 );
		return pBuffer;
	}

	//--------------------------------------------------------------------------------
	unsigned int CErrorDomain::GetErrorParts( nsCodeQOR::CError* pError, const nsCodeQOR::CBaseErrorDomain::s_BaseError& ErrorTemplate, mxTCHAR** ppszParts )
	{
		unsigned int uiCount = 0;
		while( ErrorTemplate.pDescriptorFuncs[ uiCount ] != 0 )
		{
			fpErrorDescriptor pFunc = reinterpret_cast< fpErrorDescriptor >( ErrorTemplate.pDescriptorFuncs[ uiCount ] );
			if( pFunc != 0 )
			{
				ppszParts[uiCount] = ( this->*pFunc )( pError );
			}
			uiCount++;
		}
		return uiCount;
	}

	//--------------------------------------------------------------------------------
    void* CErrorDomain::GetSeverity( nsCodeQOR::CError* pError )
	{
		mxTCHAR* szSeverity = _T( "Unknown Error:" );
		nsCodeQOR::CError::Level Severity = nsCodeQOR::CError::ERR_LVL_FATAL;
		unsigned int uiCustomLevel = 0;
		if( pError != 0 )
		{
			Severity = pError->What().GetLevel( &uiCustomLevel );
		}

		switch ( Severity )
		{
        case nsCodeQOR::CError::ERR_LVL_NOTE:
			szSeverity = _T( "Note:" );
			break;
		case nsCodeQOR::CError::ERR_LVL_WARNING:
			szSeverity = _T( "Warning:" );
			break;
		case nsCodeQOR::CError::ERR_LVL_CONTINUE:
			szSeverity = _T( "Error:" );
			break;
		case nsCodeQOR::CError::ERR_LVL_SERIOUS:
			szSeverity = _T( "Serious Error:" );
			break;
		case nsCodeQOR::CError::ERR_LVL_FATAL:
			szSeverity = _T( "Fatal Error:" );
			break;
		}

		return szSeverity;
	}

	//--------------------------------------------------------------------------------
	void* CErrorDomain::GetSource( nsCodeQOR::CError* pError )
	{
		unsigned long dwResult = 0;

		void* ppszParts[ MAX_ERRPARTS ] = {0};
		mxTCHAR* pBuffer = new mxTCHAR[ 2048 ];

		if( pError != 0 )
		{
			unsigned long ulLine = pError->Where().GetLine();

			nsCodeQOR::CProcessBase* pProcess = nsCodeQOR::CProcessBase::ThisProcess();
			ppszParts[ 0 ] = const_cast< char* >( pError->Where().GetFile() );
			ppszParts[ 1 ] = reinterpret_cast< mxTCHAR* >( ulLine );
			ppszParts[ 2 ] = pError->Where().GetDescription().GetBuffer();
			ppszParts[ 3 ] = _T( "Unnamed Thread" );
			ppszParts[ 4 ] = pError->Where().GetThreadContext();
			if( pProcess )
			{
				ppszParts[ 5 ] = const_cast< char* >( pProcess->LibraryName() );
				ppszParts[ 6 ] = reinterpret_cast< void* >( pProcess->Identifier() );
			}
			ppszParts[ 7 ] = _T( "< Localized time stamp >" );
			ppszParts[ 8 ] = 0;
			ppszParts[ 9 ] = 0;

			dwResult = CKernel32::FormatMessage(
				FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
				_T( "%1(%2!u!):    %3 - Thread '%4' (id = %5!u!), Process '%6' (id = %7!u!) at %8.\n" ) , 0, 0, pBuffer, 2048, (va_list*)ppszParts );

		}
		return pBuffer;
	}

	//--------------------------------------------------------------------------------
	void* CErrorDomain::GetOSError( nsCodeQOR::CError* pError )
	{
		mxTCHAR* pszMsg = new mxTCHAR[ Max_OS_Message_Size ];
		unsigned int uiError = pError->What().Code();
		CKernel32::FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, 0, uiError, 0, pszMsg, Max_OS_Message_Size, 0 );
		return pszMsg;
	}

}//nsWinQAPI
