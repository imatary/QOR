//WinQLMemory.h

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Win32 Code Services Memory class

#ifndef WINQL_APP_MEM_H_3
#define WINQL_APP_MEM_H_3

#include "CompilerQOR.h"

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "WinQL/WinQL.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	class __QOR_INTERFACE( __WINQL ) CVirtualHelper;
	class __QOR_INTERFACE( __WINQL ) CLocalHelper;
	class __QOR_INTERFACE( __WINQL ) CGlobalHelper;
	class __QOR_INTERFACE( __WINQL ) CExePageAllocator;
	class __QOR_INTERFACE( __WINQL ) CHeap;

	//--------------------------------------------------------------------------------
	typedef struct _MEMORYSTATUSEX
	{
		unsigned long dwLength;
		unsigned long dwMemoryLoad;
		Cmp_unsigned_long_long ullTotalPhys;
		Cmp_unsigned_long_long ullAvailPhys;
		Cmp_unsigned_long_long ullTotalPageFile;
		Cmp_unsigned_long_long ullAvailPageFile;
		Cmp_unsigned_long_long ullTotalVirtual;
		Cmp_unsigned_long_long ullAvailVirtual;
		Cmp_unsigned_long_long ullAvailExtendedVirtual;
	} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;

	//--------------------------------------------------------------------------------
	typedef enum _MEMORY_RESOURCE_NOTIFICATION_TYPE
	{
		LowMemoryResourceNotification,
		HighMemoryResourceNotification
	} MEMORY_RESOURCE_NOTIFICATION_TYPE;

	//--------------------------------------------------------------------------------
	typedef unsigned char (__QCMP_STDCALLCONVENTION *fpSecureMemoryCacheCallback) (void* Addr, Cmp_ulong_ptr Range);

	class __QOR_INTERFACE(__WINQL) CUserPhysicalPages;

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE(__WINQL) CMemoryManager
	{
	public:

		__QOR_DECLARE_OCLASS_ID(CMemoryManager);

		//--------------------------------------------------------------------------------
		enum eSpecialHeap
		{
			eErrorHeap,
			eReserveHeap,
		};

		CMemoryManager();
		~CMemoryManager();
		void Copy(void* pDest, const void* pSource, Cmp_ulong_ptr Length);
		void Fill(void* pDest, Cmp_ulong_ptr Length, unsigned char Fill);
		void Move(void* pDest, const void* pSource, Cmp_ulong_ptr Length);
		void* SecureZero(void* pDest, Cmp_ulong_ptr Length);
		void Zero(void* pDest, Cmp_ulong_ptr Length);
		Cmp_ulong_ptr Compare(const void* pSource1, const void* pSource2, Cmp_ulong_ptr Length);
		Cmp_ulong_ptr GetLargePageMinimum(void);
		bool GetPhysicallyInstalledSystemMemory(Cmp_unsigned_long_long* pTotalMemoryInKilobytes);
		unsigned int GetWriteWatch(unsigned long dwFlags, void* pBaseAddress, Cmp_ulong_ptr RegionSize, void** pAddresses, Cmp_ulong_ptr* pdwCount, unsigned long* pdwGranularity);
		unsigned int ResetWriteWatch(void* pBaseAddress, Cmp_ulong_ptr RegionSize);
		bool GetGlobalMemoryStatus(nsWin32::LPMEMORYSTATUSEX lpBuffer);
		bool GetSystemFileCacheSize(Cmp_ulong_ptr* pMinimumFileCacheSize, Cmp_ulong_ptr* pMaximumFileCacheSize, unsigned long* pFlags);
		bool SetSystemFileCacheSize(Cmp_ulong_ptr MinimumFileCacheSize, Cmp_ulong_ptr MaximumFileCacheSize, unsigned long dwFlags);

		//TODO:
		/*
		Keep a vector of all the Heaps created in the process
		Keep stats on total allocation size and count
		Keep a vector of all the stacks created in the process


		Default heap allocator
		Special heap allocator by enum
		Custom heap allocator by index

		*/
		CHeap& DefaultHeap( void );
		CHeap& SpecialHeap( eSpecialHeap heap );
		CHeap& PrivateHeap( unsigned int uiIndex );
		CUserPhysicalPages& Physical( void );
		CExePageAllocator& Executable( void );
		CVirtualHelper& Virtual( void );
		CLocalHelper& Local( void );
		CGlobalHelper& Global( void );
		//Default Allocator

	};

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE(__WINQL) CSecureMemoryCacheCallback
	{
	public:

		__QOR_DECLARE_OCLASS_ID(CSecureMemoryCacheCallback);

		CSecureMemoryCacheCallback(nsWin32::fpSecureMemoryCacheCallback pfnCallBack);
		virtual ~CSecureMemoryCacheCallback();

	protected:

		nsWin32::fpSecureMemoryCacheCallback m_pCallBack;
		bool m_bConstructed;
	};

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE(__WINQL) CMemoryResourceNotification
	{
	public:

		__QOR_DECLARE_OCLASS_ID(CMemoryResourceNotification);

		CMemoryResourceNotification(nsWin32::MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType);
		virtual ~CMemoryResourceNotification();
		bool Query(int* ResourceState);

	protected:

		void* m_h;
	};

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE(__WINQL) CUserPhysicalPages
	{
	public:

		__QOR_DECLARE_OCLASS_ID(CUserPhysicalPages);

		CUserPhysicalPages();
		~CUserPhysicalPages();
		bool Allocate(void* hProcess, Cmp_ulong_ptr* NumberOfPages, Cmp_ulong_ptr* UserPfnArray);
		bool Free(void* hProcess, Cmp_ulong_ptr* NumberOfPages, Cmp_ulong_ptr* UserPfnArray);
		bool Map(void* lpAddress, Cmp_ulong_ptr NumberOfPages, Cmp_ulong_ptr* UserPfnArray);
		bool MapScatter(void** VirtualAddresses, Cmp_ulong_ptr NumberOfPages, Cmp_ulong_ptr* PageArray);
	};

}//nsWin32

#endif//WINQL_APP_MEM_H_3
