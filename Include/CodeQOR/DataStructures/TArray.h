//TArray.h

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Array class template

#ifndef CODEQOR_DATASTRUCTS_TARRAY_H_1
#define CODEQOR_DATASTRUCTS_TARRAY_H_1

#include "CompilerQOR.h"

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "CodeQOR/MemoryManagement/DefaultAllocator.h"
#include "CodeQOR/Traits/MemoryTraits.h"
#include "CodeQOR/Traits/Policy.h"

//------------------------------------------------------------------------------
//A templated array class that grows to the size required
//Uses a trait determined allocator
//Memory is a single contiguous block

//NOTE: Contained items must have valid default construction
//NOTE: Can be made thread safe by Policy

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
	//------------------------------------------------------------------------------
	template < class Type, class TPolicy = CPolicy, class TAllocator = __QCMP_FEATURE_TONDTIDTP( typename ) mem_traits< Type >::CTAllocator >
	class CTArray
	{

	public:

		__QCMP_STATIC_CONSTANT( unsigned long, INVALID = (unsigned long)(-1) );

		//------------------------------------------------------------------------------
		//Construct a CTArray with a default allocation count
		CTArray() : m_ulCurrentSize( 0 )
		, m_ulMaxSize( TPolicy::DEFAULT_INITIAL_ARRAY_SIZE )
		{
			m_ArrayData = TAllocator::Allocate( m_ulMaxSize );
		}

		//------------------------------------------------------------------------------
		//Construct a CTArray with an initial empty allocation
		CTArray( unsigned long size ) : m_ulCurrentSize( 0 )
		, m_ulMaxSize( size )
		{
			m_ArrayData = TAllocator::Allocate( m_ulMaxSize );
		}

		//------------------------------------------------------------------------------
		//Copy construct
		CTArray( CTArray< Type, TPolicy, TAllocator > const & srcArray ) : m_ulCurrentSize( srcArray.m_ulCurrentSize )
		, m_ulMaxSize( srcArray.m_ulMaxSize )
		{
			srcArray.AcquireAccess();
			m_ArrayData = TAllocator::Allocate( m_ulMaxSize );
			unsigned long k = 0;
			while ( k < m_ulCurrentSize )
			{
				m_ArrayData[ k ] = srcArray.m_ArrayData[ k ];
				k++;
			}
			srcArray.ReleaseAccess();
		}

		//------------------------------------------------------------------------------
		//Two CTArray< T > are equivalent if all their sizes and all their members are equivalent
		template< class APolicy, class AAllocator >
		bool operator == ( CTArray< Type, APolicy, AAllocator >& Comperand )
		{
			Comperand.AcquireAccess();
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			bool bResult = true;
			if( Comperand.m_ulCurrentSize != m_ulCurrentSize )
			{
				bResult = false;
			}
			else
			{
				unsigned int k = 0;
				while ( k < m_ulCurrentSize )
				{
					if( Comperand.m_ArrayData[ k ] != m_ArrayData[ k ] )
					{
						bResult = false;
						break;
					}
					k++;
				}
			}
			Comperand.ReleaseAccess();
			return bResult;
		}

		//------------------------------------------------------------------------------
		//Assignment from any array holding the same type of elements
		template< class APolicy, class AAllocator >
		CTArray& operator = ( const CTArray< Type, APolicy, AAllocator >& srcArray )
		{
			srcArray.AcquireAccess();
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			m_ulCurrentSize = srcArray.m_ulCurrentSize;
			if ( m_ArrayData != 0 )
			{
				TAllocator::Free( m_ArrayData, m_ulMaxSize );
			}
			m_ulMaxSize = srcArray.m_ulMaxSize;

			m_ArrayData = TAllocator::Allocate( m_ulMaxSize );

			unsigned long k;
			for ( k = 0; k < srcArray.m_ulCurrentSize; k++ )
			{
				m_ArrayData[ k ] = srcArray.m_ArrayData[ k ];
			}
			srcArray.ReleaseAccess();
			return *this;
		}

		//------------------------------------------------------------------------------
		//Default Assignment operator
		CTArray& operator = ( const CTArray& srcArray )
		{
			srcArray.AcquireAccess();
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			m_ulCurrentSize = srcArray.m_ulCurrentSize;
			if ( m_ArrayData != 0 )
			{
				TAllocator::Free( m_ArrayData, m_ulMaxSize );
			}
			m_ulMaxSize = srcArray.m_ulMaxSize;

			m_ArrayData = TAllocator::Allocate( m_ulMaxSize );

			unsigned long k;
			for ( k = 0; k < srcArray.m_ulCurrentSize; k++ )
			{
				m_ArrayData[ k ] = srcArray.m_ArrayData[ k ];
			}
			srcArray.ReleaseAccess();
			return *this;
		}

		//------------------------------------------------------------------------------
		//Default virtual destructor frees array data
		virtual ~CTArray()
		{
			Free();		// if m_ArrayData hasn't been freed we must free it
		}

		//------------------------------------------------------------------------------
		//Free the array data and reset the allocation and usage sizes to 0
		virtual void Free()
		{
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			if( m_ArrayData != 0 )
			{
				TAllocator::Free( m_ArrayData, m_ulMaxSize );
			}
			m_ArrayData = 0;
			m_ulCurrentSize = 0;
			m_ulMaxSize = 0;
		}

		//------------------------------------------------------------------------------
		//Return a reference to an array element
		//The caller should acquire access to this array before calling the [] operator
		Type& operator[]( unsigned long k ) const
		{
			//TODO: This should throw if k is out of range
			return m_ArrayData[ k ];
		}

		//------------------------------------------------------------------------------
		//Append a single array element
		unsigned long Append( Type& newInfo )
		{
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			if ( m_ulCurrentSize == m_ulMaxSize )
			{
				unsigned long ulOldCount = m_ulMaxSize;
				m_ulMaxSize *= 2;
				m_ArrayData = TAllocator::Reallocate( m_ArrayData, ulOldCount, m_ulMaxSize, true );
			}

			m_ArrayData[ m_ulCurrentSize ] = newInfo;
			return m_ulCurrentSize++;
		}

		//------------------------------------------------------------------------------
		//Appends copies of each of the items from a source array holding the same type of elements
		template< class APolicy, class AAllocator >
		void Append( const CTArray< Type, APolicy, AAllocator > & ArrayToAdd )
		{
			ArrayToAdd.AcquireAccess();
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			if ( m_ulCurrentSize + ArrayToAdd.Size() > m_ulMaxSize )
			{
				unsigned long ulOldCount = m_ulMaxSize;
				m_ulMaxSize += ArrayToAdd.Size();
				m_ArrayData = TAllocator::Reallocate( m_ArrayData, ulOldCount, m_ulMaxSize, true );
			}

			for ( unsigned long i = 0, k = ArrayToAdd.Size(); i < k; i++ )
			{
				m_ArrayData[ m_ulCurrentSize ] = ArrayToAdd[ i ];
				++m_ulCurrentSize;
			}
			ArrayToAdd.ReleaseAccess();
		}

		//------------------------------------------------------------------------------
		//Appends copies of each of the items from a source array (by pointer) holding the same type of elements
		template< class APolicy, class AAllocator >
		void Append( const CTArray< Type, APolicy, AAllocator >* const pArrayToAdd )
		{
			if( pArrayToAdd )
			{
				pArrayToAdd->AcquireAccess();
				CLockPrimitive Lock( m_ThreadSyncPrimitive );
				if ( m_ulCurrentSize + pArrayToAdd->Size() > m_ulMaxSize )
				{
					unsigned long ulOldCount = m_ulMaxSize;
					m_ulMaxSize += pArrayToAdd->Size();
					m_ArrayData = TAllocator::Reallocate( m_ArrayData, ulOldCount, m_ulMaxSize, true );
				}

				Type * dataToAdd = pArrayToAdd->GetAddressOfData();
				for ( unsigned long i = 0, k = pArrayToAdd->Size(); i < k; i++ )
				{
					m_ArrayData[ m_ulCurrentSize ] = dataToAdd[ i ];
					++m_ulCurrentSize;
				}
				pArrayToAdd->ReleaseAccess();
			}
		}

		//------------------------------------------------------------------------------
		//Is the array empty?
		bool Empty() const
		{
			return( m_ulCurrentSize == 0 );
		}

		//------------------------------------------------------------------------------
		//Is the array not empty?
		bool NotEmpty() const
		{
			return( m_ulCurrentSize > 0 );
		}

		//------------------------------------------------------------------------------
		//return the in use size
		unsigned long Size() const
		{
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			unsigned long ulResult = m_ulCurrentSize;
			return ulResult;
		}

		//------------------------------------------------------------------------------
		//return the allocation count
		unsigned long Capacity() const
		{
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			unsigned long ulResult = m_ulMaxSize;
			return ulResult;
		}

		//------------------------------------------------------------------------------
		//swap two elements within the array
		void SwapTwoElements( unsigned long first , unsigned long second )
		{
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			Type temp = m_ArrayData[ first ];
			m_ArrayData[ first ] = m_ArrayData[ second ];
			m_ArrayData[ second ] = temp;
		}

		//------------------------------------------------------------------------------
		//swap an element within the array with an external item of the same type
		void Swap( unsigned long ulIndex, Type& _t )
		{
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			Type temp = m_ArrayData[ ulIndex ];
			m_ArrayData[ ulIndex ] = _t;
			_t = temp;
		}

		//------------------------------------------------------------------------------
		//Return the address of the actual array data
		//The caller should acquire access to the array before calling GetAddressOfData
		Type* GetAddressOfData() const
		{
			return m_ArrayData;
		}
		//------------------------------------------------------------------------------
		//The caller is responsible for the detached data
		Type* DetachData()
		{
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			Type* pResult = m_ArrayData;
			m_ulCurrentSize = 0;
			m_ulMaxSize = 0;
			m_ArrayData = 0;
			ReleaseAccess();
			return pResult;
		}

		//------------------------------------------------------------------------------
		bool Validate( unsigned long ulNewSize )
		{
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			bool bResult = false;
			if( ulNewSize <= m_ulMaxSize )
			{
				m_ulCurrentSize = ulNewSize;
				bResult = true;
			}
			else
			{
				m_ulCurrentSize = 0;
			}
			ReleaseAccess();
			return bResult;
		}

		//------------------------------------------------------------------------------
		//Set the in use size to 0 without affecting the allocation
		virtual void Clear()
		{
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			m_ulCurrentSize = 0;
		}

		//------------------------------------------------------------------------------
		//Insert array element from a source array shuffling all subsequent elements down and growing the array if necessary
		virtual void InsertAt( const unsigned long position, const unsigned long size, const Type* arrayToInsert )
		{
			if( arrayToInsert != 0 )
			{
				CLockPrimitive Lock( m_ThreadSyncPrimitive );
				unsigned long k, j, stoppingPoint;

				if ( ( size + m_ulCurrentSize ) >= m_ulMaxSize )
				{
					unsigned long ulOldSize = m_ulMaxSize;
					m_ulMaxSize += size;
					m_ArrayData = TAllocator::Reallocate( m_ArrayData, ulOldSize, m_ulMaxSize, true );
				}

				for ( k = m_ulCurrentSize + size - 1, stoppingPoint = position + size - 1; k > stoppingPoint; k-- )
				{
					m_ArrayData[ k ] = m_ArrayData[( k - size ) ];
				}

				k = position;
				for ( j = 0; j < size; )
				{
					m_ArrayData[ k++ ] = arrayToInsert[ j++ ];
				}
				m_ulCurrentSize += size;
			}
		}

		//------------------------------------------------------------------------------
		//Insert an array element shuffling all subsequent elements down and growing the array if necessary
		virtual void InsertAt( const unsigned long position, const Type& itemToInsert )
		{
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			if ( ( 1 + m_ulCurrentSize ) >= m_ulMaxSize )
			{
				unsigned long ulOldSize = m_ulMaxSize;
				m_ulMaxSize *= 2;
				m_ArrayData = TAllocator::Reallocate( m_ArrayData, ulOldSize, m_ulMaxSize, true );
			}

			for ( unsigned long k = m_ulCurrentSize; k > position; )
			{
				m_ArrayData[ k ] = m_ArrayData[ k - 1 ];
				--k;
			}

			m_ArrayData[ position ] = itemToInsert;
			m_ulCurrentSize++;
		}

		//------------------------------------------------------------------------------
		//Set an element growing the array to contain that element if necessary
		virtual void SetAt( const unsigned long ulPosition, const Type& itemToSet )
		{
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			if( ulPosition < m_ulCurrentSize )
			{
				m_ArrayData[ ulPosition ] = itemToSet;
			}
			else if( ulPosition < ( m_ulMaxSize - 1 ) )
			{
				m_ulCurrentSize = ulPosition + 1;
				m_ArrayData[ ulPosition ] = itemToSet;
			}
			else
			{
				m_ulCurrentSize = ( m_ulMaxSize - 1 );
				InsertAt( ulPosition, itemToSet );
			}
		}

		//------------------------------------------------------------------------------
		//Remove an array element shuffling all subsequent elements up and reducing
		// the in use count by 1
		virtual void RemoveAt( unsigned long ulPosition )
		{
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			for ( unsigned long k = ulPosition; k < ( m_ulCurrentSize - 1 ); k++ )
			{
				m_ArrayData[ k ] = m_ArrayData[ k + 1 ];
			}
			m_ulCurrentSize--;
		}

		//------------------------------------------------------------------------------
		//Remove ulSize array elements shuffling all subsequent elements up and
		// reducing the in use count by ulSize
		virtual void RemoveAt( const unsigned long ulPosition, const unsigned long ulSize )
		{
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			for ( unsigned long k = ulPosition; k < m_ulCurrentSize - ( ulSize + 1 ); k++ )
			{
				m_ArrayData[ k ] = m_ArrayData[ k + ulSize ];
			}
			m_ulCurrentSize -= ulSize;
		}

		//------------------------------------------------------------------------------
		//Set the allocated size of the array without affecting the in use size unless
		// you reduce it below the current in use size
		virtual void SetCapacity( const unsigned long ulNewSize )
		{
			CLockPrimitive Lock( m_ThreadSyncPrimitive );
			if ( ulNewSize != m_ulMaxSize )
			{
				m_ArrayData = TAllocator::Reallocate( m_ArrayData, m_ulMaxSize, ulNewSize, true );
				m_ulMaxSize = ulNewSize;
			}

			if( m_ulMaxSize <= m_ulCurrentSize )
			{
				//maximum allowed m_ulCurrentSize before growing again is m_ulMaxSize - 1
				m_ulCurrentSize = m_ulMaxSize - 1;
			}
		}

		//------------------------------------------------------------------------------
		void AcquireAccess( void ) const
		{
			m_ThreadSyncPrimitive.Acquire();
		}

		//------------------------------------------------------------------------------
		void ReleaseAccess( void ) const
		{
			m_ThreadSyncPrimitive.Release();
		}

	protected:

		unsigned long m_ulCurrentSize;		//number of array items in use
		unsigned long m_ulMaxSize;			//allocated size of the array
		Type* m_ArrayData;					//pointer to the actual array data

		typedef typename TPolicy::TThreadSyncSinglePrimitive CSyncPrimitive;
		typedef typename TPolicy::TThreadSyncSingleLock CLockPrimitive;

		mutable CSyncPrimitive m_ThreadSyncPrimitive;
	};

}//nsCodeQOR

#endif//CODEQOR_DATASTRUCTS_TARRAY_H_1
