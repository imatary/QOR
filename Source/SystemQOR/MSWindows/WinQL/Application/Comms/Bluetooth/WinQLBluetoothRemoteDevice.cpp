//WinQLBluetoothRemoteDevice.cpp

// Copyright Querysoft Limited 2013, 2016
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "WinQL/Application/Comms/Bluetooth/WinQLBluetoothClient.h"
#include "WinQL/Application/Comms/Bluetooth/WinQLBluetoothRemoteDevice.h"
#include "WinQL/Application/Comms/Bluetooth/WinQLBluetoothAuthenticationSession.h"
#include "WinQL/System/Devices/BluetoothRadio/WinQLBluetoothRadio.h"
#include "WinQAPI/Kernel32.h"
#include "WinQAPI/BthProps.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	using namespace nsWinQAPI;

	__QOR_IMPLEMENT_OCLASS_LUID( CBluetoothRemoteDevice );

	//--------------------------------------------------------------------------------
	CBluetoothRemoteDevice::CBluetoothRemoteDevice() : m_Library( CBthProps::Instance() ), m_pGuidServices( 0 ), m_ulCountServices( 0 ), m_pServiceClients( 0 )
	{
		_WINQ_FCONTEXT( "CBluetoothRemoteDevice::CBluetoothRemoteDevice" );
		Reset();		
	}

	//--------------------------------------------------------------------------------
	CBluetoothRemoteDevice::~CBluetoothRemoteDevice()
	{
		_WINQ_FCONTEXT( "CBluetoothRemoteDevice::~CBluetoothRemoteDevice" );
	}

	//--------------------------------------------------------------------------------
	//NOTE: Not ideal at all. Only for the use of closely related classes, should be private and use friends
	CBluetoothRemoteDevice::Info* CBluetoothRemoteDevice::GetInfo( void )
	{
		return &m_Info;
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::Reset( void )
	{
		m_Info.dwSize = sizeof( Info );
		m_Info.Address.ullLong = 0;						//  Bluetooth address
		m_Info.ulClassofDevice.Reset();                    //  Bluetooth "Class of Device"
		m_Info.fConnected = 0;                         //  Device connected/in use
		m_Info.fRemembered = 0;                        //  Device remembered
		m_Info.fAuthenticated = 0;                     //  Device authenticated/paired/bonded
		memset( &m_Info.stLastSeen, 0, sizeof( SystemTime ) );                     //  Last time the device was seen
		memset( &m_Info.stLastUsed, 0, sizeof( SystemTime ) );                     //  Last time the device was used for other than RNR, inquiry, or SDP
		memset( m_Info.szName, 0, BluetoothMaxNameSize * sizeof( wchar_t ) );		//  Name of the device
		delete [] m_pGuidServices;
		delete [] m_pServiceClients;
		m_ulCountServices = 0;
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::Authenticate( COSWindow::refType ParentWindow, CWString strPassKey )
	{
		_WINQ_FCONTEXT( "CBluetoothRemoteDevice::Authenticate" );

		unsigned long ulErrorCode = m_Library.BluetoothAuthenticateDevice( 
			ParentWindow.IsNull() ? 0 : reinterpret_cast< ::HWND >( ParentWindow->Handle()->Use() ),
			0,
			reinterpret_cast< ::BLUETOOTH_DEVICE_INFO* >( &m_Info ),
			strPassKey.IsEmpty() ? 0 : strPassKey.GetBuffer(),
			min( strPassKey.Len(), BLUETOOTH_MAX_PASSKEY_SIZE ) );
		strPassKey.ReleaseBuffer();
	}

	//--------------------------------------------------------------------------------
	unsigned long CBluetoothRemoteDevice::AuthenticateEx( COSWindow::refType ParentWindow, BluetoothOutOfBandData* pbtOobData, CBluetoothRemoteDevice::Authentication_Requirements AuthentRequirements )
	{
		_WINQ_FCONTEXT( "CBluetoothRemoteDevice::AuthenticateEx" );

		unsigned long ulErrCode = m_Library.BluetoothAuthenticateDeviceEx(
			ParentWindow.IsNull() ? 0 : reinterpret_cast< ::HWND >( ParentWindow->Handle()->Use() ),
			0,
			reinterpret_cast< ::BLUETOOTH_DEVICE_INFO* >( &m_Info ),
			reinterpret_cast< PBLUETOOTH_OOB_DATA_INFO >( pbtOobData ),
			static_cast< ::AUTHENTICATION_REQUIREMENTS >( AuthentRequirements ) );
		return ulErrCode;
	}

	//--------------------------------------------------------------------------------
	bool CBluetoothRemoteDevice::DisplayProperties( COSWindow::refType ParentWindow )
	{
		_WINQ_FCONTEXT( "CBluetoothRemoteDevice::DisplayProperties" );

		bool bResult = m_Library.BluetoothDisplayDeviceProperties( 
			ParentWindow.IsNull() ? 0 : reinterpret_cast< ::HWND >( ParentWindow->Handle()->Use() ),
			reinterpret_cast< ::BLUETOOTH_DEVICE_INFO* >( &m_Info ) ) ? true : false;

		return bResult;
	}


	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::EnumerateInstalledServices()
	{
		_WINQ_FCONTEXT( "CBluetoothRemoteDevice::EnumerateInstalledServices" );

		m_ulCountServices = 0;
		delete [] m_pGuidServices;
		delete [] m_pServiceClients;

		m_Library.BluetoothEnumerateInstalledServices( 0, 
			reinterpret_cast< ::BLUETOOTH_DEVICE_INFO* >( &m_Info ), &m_ulCountServices, 0 );

		if( m_ulCountServices > 0 )
		{
			m_pGuidServices = new nsCodeQOR::mxGUID[ m_ulCountServices ];
			m_pServiceClients = new CBluetoothClient*[ m_ulCountServices ];
			for( unsigned int uiService = 0; uiService < m_ulCountServices; uiService++ )
			{
				m_pServiceClients[ uiService ] = 0;
			}
			m_Library.BluetoothEnumerateInstalledServices( 0, reinterpret_cast< ::BLUETOOTH_DEVICE_INFO* >( &m_Info ), &m_ulCountServices, 
				reinterpret_cast< ::GUID* >( const_cast< nsCodeQOR::__mxGUID* >( m_pGuidServices ) ) );
		}
	}

	//--------------------------------------------------------------------------------
	nsCodeQOR::mxGUID* CBluetoothRemoteDevice::GetServices( unsigned long& ulCountServices )
	{
		_WINQ_FCONTEXT( "CBluetoothRemoteDevice::GetServices" );
		ulCountServices = m_ulCountServices;
		return m_pGuidServices;
	}

	//--------------------------------------------------------------------------------
	CBluetoothClient** CBluetoothRemoteDevice::GetServiceClients()
	{
		_WINQ_FCONTEXT( "CBluetoothRemoteDevice::GetServices" );
		return m_pServiceClients;
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::Remove( void )
	{
		_WINQ_FCONTEXT( "CBluetoothRemoteDevice::Remove" );

		m_Library.BluetoothRemoveDevice( reinterpret_cast< ::BLUETOOTH_ADDRESS_STRUCT* >( &m_Info.Address ) );
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::Update( void )
	{
		_WINQ_FCONTEXT( "CBluetoothRemoteDevice::Update" );

		m_Library.BluetoothUpdateDeviceRecord( reinterpret_cast< ::BLUETOOTH_DEVICE_INFO* >( &m_Info ) );
	}

	//--------------------------------------------------------------------------------
	CBluetoothRemoteDevice::refType CBluetoothRemoteDevice::Prototype( void )
	{
		return refType( new CBluetoothRemoteDevice, true );
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnConnect( eConnectionType ConnectionType )
	{
		//Low level ACL/SCO connection
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnDisconnect( void )
	{
		//Low level ACL/SCO disconnection
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnL2CAPEvent( BluetoothL2CAPEventInfo* pEventInfo, CBluetoothRadio* pRadio )
	{
		if( pEventInfo->connected == 0 )
		{
			OnL2CAPDisconnect( static_cast< ePSM >( pEventInfo->psm ), pEventInfo->initiated == 1 ? true : false );
		}
		else
		{
			OnL2CAPConnect( static_cast< ePSM >( pEventInfo->psm ), pEventInfo->initiated == 1 ? true : false  );
		}
		
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnL2CAPDisconnect( ePSM PSM, bool bInitiated )
	{
		switch( PSM )
		{
		case PSM_SDP:
		{
			bool bEndServiceDiscovery = true;
		}
		break;
		case PSM_RFCOMM:
			break;
		case PSM_TCS_BIN:
			break;
		case PSM_TCS_BIN_CORDLESS:
			break;
		case PSM_BNEP:
			break;
		case PSM_HID_CONTROL:
			break;
		case PSM_AVCTP:
			break;
		case PSM_AVDTP:
			break;
		case PSM_UDI_C_PLANE:
			break;
		}
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnL2CAPConnect( ePSM PSM, bool bInitiated )
	{		
		switch( PSM )
		{
		case PSM_SDP:
		{
			bool bBeginServiceDiscovery = true;
		}
		break;
		case PSM_RFCOMM:
			break;
		case PSM_TCS_BIN:
			break;
		case PSM_TCS_BIN_CORDLESS:
			break;
		case PSM_BNEP:
			break;
		case PSM_HID_CONTROL:
			break;
		case PSM_AVCTP:
			break;
		case PSM_AVDTP:
			break;
		case PSM_UDI_C_PLANE:
			break;
		}
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnEstablishCODMiscellaneous()
	{
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnEstablishCODComputer()
	{
		switch( m_Info.ulClassofDevice.GetMinor() )
		{
		case ClassOfDevice::Computer_Unclassified:
			break;
		case ClassOfDevice::Computer_Desktop:
			break;
		case ClassOfDevice::Computer_Server:
			break;
		case ClassOfDevice::Computer_Laptop:
			break;
		case ClassOfDevice::Computer_Handheld:
			break;
		case ClassOfDevice::Computer_Palm:
			break;
		case ClassOfDevice::Computer_Wearable:
			break;
		}
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnEstablishCODPhone()
	{
		switch( m_Info.ulClassofDevice.GetMinor() )
		{
		case ClassOfDevice::Phone_Unclassified:
			break;
		case ClassOfDevice::Phone_Cellular:
			break;
		case ClassOfDevice::Phone_Cordless:
			break;
		case ClassOfDevice::Phone_Smart:
			break;
		case ClassOfDevice::Phone_WiredModem:
			break;
		}
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnEstablishCODLANAccess()
	{
		//TODO:
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnEstablishCODAudio()
	{
		switch( m_Info.ulClassofDevice.GetMinor() )
		{
		case ClassOfDevice::Audio_Unclassified:
			break;
		case ClassOfDevice::Audio_Headset:
			break;
		case ClassOfDevice::Audio_HandsFree:
			break;
		case ClassOfDevice::Audio_HeadsetHandsFree:
			break;
		case ClassOfDevice::Audio_Microphone:
			break;
		case ClassOfDevice::Audio_Loudspeaker:
			break;
		case ClassOfDevice::Audio_Headphones:
			break;
		case ClassOfDevice::Audio_PortableAudio:
			break;
		case ClassOfDevice::Audio_CasrAudio:
			break;
		case ClassOfDevice::Audio_SetTopBox:
			break;
		case ClassOfDevice::Audio_HiFiAudio:
			break;
		case ClassOfDevice::Audio_VCR:
			break;
		case ClassOfDevice::Audio_VideoCamera:
			break;
		case ClassOfDevice::Audio_Camcorder:
			break;
		case ClassOfDevice::Audio_VideoMonitor:
			break;
		case ClassOfDevice::Audio_VideoDisplayLoudspeaker:
			break;
		case ClassOfDevice::Audio_VideoDisplayConferencing:
			break;
		case ClassOfDevice::Audio_GamingToy:
			break;
		}
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnEstablishCODPeripheral()
	{
		//TODO:
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnEstablishCODImaging()
	{
		//TODO:
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnEstablishCODWearable()
	{
		//TODO:
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnEstablishCODToy()
	{
		//TODO:
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnEstablishCODHealth()
	{
		//TODO:
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnEstablishCODUnclassified()
	{
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnEstablishCOD( void )
	{
		switch( m_Info.ulClassofDevice.GetMajor() )
		{
		case ClassOfDevice::Miscellaneous:
			OnEstablishCODMiscellaneous();
			break;
		case ClassOfDevice::Computer:
			OnEstablishCODComputer();
			break;
		case ClassOfDevice::Phone:
			OnEstablishCODPhone();
			break;
		case ClassOfDevice::LANAccess:
			OnEstablishCODLANAccess();
			break;
		case ClassOfDevice::Audio:
			OnEstablishCODAudio();
			break;
		case ClassOfDevice::Peripheral:
			OnEstablishCODPeripheral();
			break;
		case ClassOfDevice::Imaging:
			OnEstablishCODImaging();
			break;
		case ClassOfDevice::Wearable:
			OnEstablishCODWearable();
			break;
		case ClassOfDevice::Toy:
			OnEstablishCODToy();
			break;
		case ClassOfDevice::Health:
			OnEstablishCODHealth();
			break;
		case ClassOfDevice::Unclassified:
			OnEstablishCODUnclassified();
			break;
		}

		switch( m_Info.ulClassofDevice.GetService() )
		{
		case ClassOfDevice::Service_Limited:
			break;
		case ClassOfDevice::Service_Positioning:
			break;
		case ClassOfDevice::Service_Networking:
			break;
		case ClassOfDevice::Service_Rendering:
			break;
		case ClassOfDevice::Service_Capturing:
			break;
		case ClassOfDevice::Service_ObjectXfer:
			break;
		case ClassOfDevice::Service_Audio:
			break;
		case ClassOfDevice::Service_Telephony:
			break;
		case ClassOfDevice::Service_Information:
			break;
		}
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnInRange( ShortInfo& sInfo, unsigned long ulPreviousFlags, CBluetoothRadio* pRadio )
	{
		unsigned long ulChangedFlags = sInfo.flags ^ ulPreviousFlags;

		if( sInfo.flags & BDIF_Address )
		{
			if( ( sInfo.flags & BDIF_COD ) )
			{
				if( m_Info.ulClassofDevice.ulClassofDevice != sInfo.classOfDevice.ulClassofDevice )
				{
					m_Info.ulClassofDevice = sInfo.classOfDevice;
					OnEstablishCOD();
				}
			}
			
			if( ( sInfo.flags & BDIF_Name )/* && ( ulChangedFlags & BDIF_Name )*/ )
			{
				CAString strName( sInfo.name );
				//TODO: We need to convert to UTF16 here
			}

			if( sInfo.flags & BDIF_EIR )
			{
				bool bEIR = true;
				//TODO: Do we get this? Were would the extra 240 bytes be?
			}

			if( sInfo.flags & BDIF_CONNECTED )
			{
				
			}
		}
		else
		{
			//we got here by mistaken chance because the address was not valid
		}
	}

	//--------------------------------------------------------------------------------
	void CBluetoothRemoteDevice::OnOutOfRange( void )
	{
	}

	//--------------------------------------------------------------------------------
	bool CBluetoothRemoteDevice::OnAuthenticationRequest( CBluetoothRemoteDevice::Authentication_CallbackParams* pAuthCallbackParams, CAuthenticateBluetoothSession& AuthenticationSession )
	{
		bool bResult = false;
		if( pAuthCallbackParams )
		{
			switch( pAuthCallbackParams->authenticationMethod )
			{
			case BLUETOOTH_AUTHENTICATION_METHOD_LEGACY://     = 0x1,
				return OnLegacyAuthenticationRequest( pAuthCallbackParams, AuthenticationSession );
				break;
			case BLUETOOTH_AUTHENTICATION_METHOD_OOB:
				return OnOutOfBandAuthenticationRequest( pAuthCallbackParams, AuthenticationSession );
				break;
			case BLUETOOTH_AUTHENTICATION_METHOD_NUMERIC_COMPARISON:
				return OnNumericComparisonAuthenticationRequest( pAuthCallbackParams, AuthenticationSession );
				break;
			case BLUETOOTH_AUTHENTICATION_METHOD_PASSKEY_NOTIFICATION:
				return OnPasskeyNotificationAuthenticationRequest( pAuthCallbackParams, AuthenticationSession );
				break;
			case BLUETOOTH_AUTHENTICATION_METHOD_PASSKEY:
				return OnPassKeyAuthenticationRequest( pAuthCallbackParams, AuthenticationSession );
				break;
			}
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CBluetoothRemoteDevice::OnLegacyAuthenticationRequest( CBluetoothRemoteDevice::Authentication_CallbackParams* pAuthCallbackParams, CAuthenticateBluetoothSession& AuthenticationSession )
	{
		//Acquire PIN
		//Send Response
		return true;
	}

	//--------------------------------------------------------------------------------
	bool CBluetoothRemoteDevice::OnOutOfBandAuthenticationRequest( CBluetoothRemoteDevice::Authentication_CallbackParams* pAuthCallbackParams, CAuthenticateBluetoothSession& AuthenticationSession )
	{
		return true;
	}

	//--------------------------------------------------------------------------------
	bool CBluetoothRemoteDevice::OnNumericComparisonAuthenticationRequest( CBluetoothRemoteDevice::Authentication_CallbackParams* pAuthCallbackParams, CAuthenticateBluetoothSession& AuthenticationSession )
	{
		if( pAuthCallbackParams->authenticationRequirements == MITMProtectionNotRequired || 
			pAuthCallbackParams->authenticationRequirements == MITMProtectionNotRequiredBonding || 
			pAuthCallbackParams->authenticationRequirements == MITMProtectionNotRequiredGeneralBonding || 
			pAuthCallbackParams->authenticationRequirements == MITMProtectionNotDefined )
		{
			CAuthenticateBluetoothSession::Authentication_Response Response;

		    Response.bthAddressRemote = m_Info.Address;
			Response.authMethod = BLUETOOTH_AUTHENTICATION_METHOD_NUMERIC_COMPARISON;
			Response.numericCompInfo.NumericValue = pAuthCallbackParams->Numeric_Value;
			Response.negativeResponse = 0;

			AuthenticationSession.SendResponseEx( CBluetoothRadio::refType( 0 ), &Response );
		}
		else 
		{
			switch( pAuthCallbackParams->ioCapability )
			{
			case BLUETOOTH_IO_CAPABILITY_DISPLAYONLY:
				//Numeric comparison with confirmation on initiator side only - Unauthenticated
				break;
			case BLUETOOTH_IO_CAPABILITY_DISPLAYYESNO:
			//Numeric comparison, both display, both confirm - Authenticated
			{
				//TODO: - Test only
				CAuthenticateBluetoothSession::Authentication_Response Response;

				Response.bthAddressRemote = m_Info.Address;
				Response.authMethod = BLUETOOTH_AUTHENTICATION_METHOD_NUMERIC_COMPARISON;
				Response.numericCompInfo.NumericValue = pAuthCallbackParams->Numeric_Value;
				Response.negativeResponse = 0;

				AuthenticationSession.SendResponseEx( CBluetoothRadio::refType( 0 ), &Response );
			}
			break;
			case BLUETOOTH_IO_CAPABILITY_KEYBOARDONLY:
				//Passkey entry: responder display, Initiator input - Authenticated
				break;
			case BLUETOOTH_IO_CAPABILITY_NOINPUTNOOUTPUT:
				//Numeric comparison with automatic confirmation on Initiator only - Unauthenticated
				break;
			case BLUETOOTH_IO_CAPABILITY_UNDEFINED:
				break;
			}
		}

		return true;
	}

	//--------------------------------------------------------------------------------
	bool CBluetoothRemoteDevice::OnPasskeyNotificationAuthenticationRequest( CBluetoothRemoteDevice::Authentication_CallbackParams* pAuthCallbackParams, CAuthenticateBluetoothSession& AuthenticationSession )
	{
		return true;
	}

	//--------------------------------------------------------------------------------
	bool CBluetoothRemoteDevice::OnPassKeyAuthenticationRequest( CBluetoothRemoteDevice::Authentication_CallbackParams* pAuthCallbackParams, CAuthenticateBluetoothSession& AuthenticationSession )
	{
		return true;
	}

}//nsWin32
