//FunctionContextBase.h

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Stack following context for functions

#ifndef CODEQOR_FUNCTIONCONTEXTBASE_H_1
#define CODEQOR_FUNCTIONCONTEXTBASE_H_1

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "CodeQOR/DataStructures/TLinkedList.h"
#include "CodeQOR/Instancing/sTOB.h"
#include "CallContextBase.h"
#include "CodeQOR/Instancing/STMember.h"
#include "CodeQOR.h"
#include "CodeQOR/Tracing/ObjectContextBase.h"
#include "CodeQOR/Tracing/ObjectContext.h"
#include "AppocritaQOR/SubSystems/IThread.h"

//Declare a __QCS_FCONTEXT macro which will only take effect if context tracking is switched on
//It will make use of any compiler function naming support
#if		( __QOR_FUNCTION_CONTEXT_TRACKING == __QCS_YES_ )
#	if		( __QCMP_SUPPORTS__FUNCSIG__ == 1 )
#		if		( __QOR_CODE_COVERAGE == __QCS_YES_ )
#			define __QCS_FCONTEXT( NameString ) \
	__QCMP_MESSAGE( "QOR_CC:" __QCMP_FUNCSIG__( __FUNCTION__ ) ) \
	nsCodeQOR::CFunctionContextBase _FContext_( __QCMP_FUNCSIG__( __FUNCTION__ ), __FILE__, __LINE__ )
#			define __QCS_MEMBER_FCONTEXT( NameString ) \
	__QCMP_MESSAGE( "QOR_CC:" __QCMP_FUNCSIG__( __FUNCTION__ ) ) \
	nsCodeQOR::CFunctionContextBase _FContext_( nsCodeQOR::CObjectContextBase( this ), __QCMP_FUNCSIG__( __FUNCTION__ ), __FILE__, __LINE__ )
#		else
#			define __QCS_FCONTEXT( NameString ) nsCodeQOR::CFunctionContextBase _FContext_( __QCMP_FUNCSIG__( __FUNCTION__ ), __FILE__, __LINE__ )
#			define __QCS_MEMBER_FCONTEXT( NameString ) nsCodeQOR::CFunctionContextBase _FContext_( nsCodeQOR::CObjectContextBase( this ), __QCMP_FUNCSIG__( __FUNCTION__ ), __FILE__, __LINE__ )
#		endif
#	else//!	( __QCMP_SUPPORTS__FUNCSIG__ == 1 )
#		define __QCS_FCONTEXT( NameString ) nsCodeQOR::CFunctionContextBase _FContext_( NameString, __FILE__, __LINE__ )
#		define __QCS_MEMBER_FCONTEXT( NameString ) nsCodeQOR::CFunctionContextBase _FContext_( nsCodeQOR::CObjectContextBase( this ), NameString, __FILE__, __LINE__ )
#	endif//	( __QCMP_SUPPORTS__FUNCSIG__ == 1 )
#else//!( __QOR_FUNCTION_CONTEXT_TRACKING == __QCS_YES_ )
#	define __QCS_FCONTEXT( NameString )
#	define __QCS_MEMBER_FCONTEXT( NameString )
#endif//( __QOR_FUNCTION_CONTEXT_TRACKING == __QCS_YES_ )

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
	//--------------------------------------------------------------------------------
	//A base only class to allow all CCleanup types to be stored in a homogeneous container
	class __QOR_INTERFACE( __CODEQOR ) CCleanupBase
	{
	public:
		
		virtual ~CCleanupBase();
		virtual void Cleanup(void);

	protected:

		CCleanupBase();				
	};

#ifdef _USRDLL																			//if we're building a complete module not a static lib
	template class __QOR_INTERFACE( __CODEQOR ) CTLinkedList< CCleanupBase >;			//persuade the compiler to instantiate the linked list template 
#endif
	typedef __QOR_INTERFACE( __CODEQOR ) CTLinkedList< CCleanupBase > CCleanupList;		//give it a simple name to be exported/imported by

	//--------------------------------------------------------------------------------
	//A minimal Base class for tracking function context 
	//Usage: Only ever create these on the stack at the beginning of a function
	class __QOR_INTERFACE( __CODEQOR ) CFunctionContextBase
	{

	protected:

		//--------------------------------------------------------------------------------
		template <class T>
		class CCleanup : public CCleanupBase
		{
		private:

			T m_t;

		public:

			//--------------------------------------------------------------------------------
			CCleanup(T _t)
			{
				m_t = _t;
			}

			//--------------------------------------------------------------------------------
			~CCleanup()
			{					
			}

			//--------------------------------------------------------------------------------
			void Cleanup(void)
			{
				delete m_t;
			}
		};

	public:

		//--------------------------------------------------------------------------------
		CFunctionContextBase();
		CFunctionContextBase( const char* szFuncName, const char* szFile, unsigned int uiLine );
		CFunctionContextBase( CObjectContextBase ObjContext, const char* szFuncName, const char* szFile, unsigned int uiLine );
		virtual ~CFunctionContextBase();
		bool Locked();
		unsigned int Lock();
		unsigned int Unlock();
		static bool Trace( bool bNewTrace );
		static bool Booted( bool bBooted );
		virtual CCallContextBase* CallContext( void );
		void Name( const char** ppName );
		void Name( const wchar_t** ppName );

		const char* File();
		const char* Name( void );

		unsigned int Line( void );
		CFunctionContextBase* GetParent();
		void SetParent( CFunctionContextBase* pParent );
		static CFunctionContextBase* GetCurrent( void );

		//--------------------------------------------------------------------------------
		template< typename T > void __QCMP_ALWAYSINLINE Register( T _t )
		{
			m_Cleanups.Append( new CCleanup< T >( _t ) );
		}

		void Cleanup();
		int& TraceDepth();

		CObjectContextBase ObjectContext( void );
		CObjectContextBase* ObjectContextPointer( void );

	protected:
		
		static bool s_bTraceCalls;

		unsigned int m_uiLocked;
		int m_iTraceDepth;
		const char* m_szFuncName;
		const char* m_szFile;
		CFunctionContextBase* m_pParent;
		CCleanupList m_Cleanups;
		CObjectContextBase m_ObjContext;
		unsigned int m_uiLine;		
		nsQOR::IThread::ref_type m_pThread;
		CCallContextBase m_CallContext;

		virtual void Init();

	};

}//nsCodeQOR

#endif//CODEQOR_FUNCTIONCONTEXTBASE_H_1
