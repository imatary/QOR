//Error.cpp: implementation of the CError class.

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "CompilerQOR.h"
#include "CodeQOR/Tracing/FunctionContextBase.h"
#include "CodeQOR/ErrorSystem/Error.h"
#include "CodeQOR/ErrorSystem/What.h"
#include "CodeQOR/ErrorSystem/Where.h"
#include "CodeQOR/ErrorSystem/When.h"
#include "CodeQOR/Modules/ProcessBase.h"
#include "CodeQOR/Instancing/TInstancePtr.h"
#include "CodeQOR/ErrorSystem/DefaultHandler.h"
#include "CodeQOR/Text/Char.h"
#include "CodeQOR/ErrorSystem/BaseErrorDomain.h"
#include <string.h>
#include <stdarg.h>

#pragma TODO("All allocation and deallocation must deal with the Error heap, if there is one, through an allocator" )

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
	//------------------------------------------------------------------------------
	CError::CBaseErrorParams::CBaseErrorParams( CError::CBaseErrorParams const& cSrc ) : m_uiCode( cSrc.m_uiCode )
	{
		CError::CBaseErrorParams& Src = const_cast< CError::CBaseErrorParams& >( cSrc );

		if( &Src != this )
		{
			unsigned int uiParam = 0;
			for( ;uiParam < sMaxParams; uiParam++ )
			{
				m_pParams[ uiParam ] = Src.m_pParams[ uiParam ];
				Src.m_pParams[ uiParam ] = 0;
			}
		}
	}

	//------------------------------------------------------------------------------
	CError::CBaseErrorParams::CBaseErrorParams() : m_uiCode( 0 )
	{
		for( unsigned char ucCount = 0; ucCount < sMaxParams; ucCount++ )
		{
			m_pParams[ ucCount ] = 0;
		}
	}

	//------------------------------------------------------------------------------
	CError::CBaseErrorParams::CBaseErrorParams( unsigned int uiCode, ... ) : m_uiCode( uiCode )
	{
		va_list args;
		va_start(args, uiCode);

		m_uiCode = uiCode;
		unsigned int iParam = 0;
		void* pParam = 0;
		do
		{
			pParam = va_arg( args, void* );

			if( pParam )
			{
				m_pParams[ iParam++ ] = pParam;
			}

		}while( pParam != 0 && iParam < sMaxParams );

		while( iParam < sMaxParams )
		{
			m_pParams[ iParam++ ] = 0;
		}

		va_end(args);
	}

	//------------------------------------------------------------------------------
	CError::CBaseErrorParams::~CBaseErrorParams()
	{
	}

	//--------------------------------------------------------------------------------
	void* CError::CBaseErrorParams::operator[]( unsigned int uiIndex )
	{
		void* pParam = 0;
		if( uiIndex < sMaxParams )
		{
			pParam = m_pParams[ uiIndex ];
		}
		return pParam;
	}

	//--------------------------------------------------------------------------------
	unsigned int CError::CBaseErrorParams::Code()
	{
		return m_uiCode;
	}

	//------------------------------------------------------------------------------
	CString CError::ErrorLevel[] =
	{
		_TXT("Note").str(),
		_TXT("Warning").str(),
		_TXT("Continuable Error").str(),
		_TXT("Serious Error").str(),
		_TXT("Fatal Error").str()
	};

	//--------------------------------------------------------------------------------
	void CError::Resolved( bool bResolved )
	{
		if( bResolved )
		{
			delete this;
		}
		else
		{
#if __QOR_CPP_EXCEPTIONS
			throw( this );
#else
            abort();
#endif
		}
	}

	//------------------------------------------------------------------------------
	CError::CError()
	{
	}

	//------------------------------------------------------------------------------
	CError::CError( const CError& src )
	{
		if( &src != this )
		{
			*this = src;
		}
	}

	//------------------------------------------------------------------------------
	CError& CError::operator = ( const CError& csrc )
	{
		CError& src = const_cast< CError& >( csrc );
		m_What.Configure( src.What().Clone() );
		m_Where.Configure( src.Where().Clone() );
		m_When.Configure( src.When().Clone() );
		return *this;
	}

	//------------------------------------------------------------------------------
	CError::~CError()
	{
	}

	//------------------------------------------------------------------------------
	void CError::Raise( const char* szFile, int iLine, const char* szFunc, CObjectContextBase& ObjContext, CBaseErrorParams Params, CBaseErrorDomain* pDomain, Level eLevel )
	{
		CError* pError = new CError;

		//Construct the parts of the error

		//When
		pError->m_When.Configure( new CWhen() );

		//What
		pError->m_What.Configure( new CWhat() );
		pError->What().SetParams( Params );
		pError->What().SetLevel( eLevel );
		pError->What().SetCode( Params.Code() );

		//Where
		pError->m_Where.Configure( new CWhere() );
		pError->Where().SetLine( static_cast< unsigned int >( iLine ) );
		pError->Where().SetFunction( szFunc );
		pError->Where().SetFile( szFile );
		pError->Where().SetDomain( pDomain );
		pError->Where().SetObjectContext( ObjContext );

		//Attempt to resolve the error
		pError->Resolved( pError->Handle() );
	}

	//------------------------------------------------------------------------------
	void CError::Raise( unsigned int uiErrCode, CBaseErrorDomain* pDomain, CError::Level eLevel )
	{
		if( !nsCodeQOR::CFunctionContextBase::Booted( false ) )
		{
			return;//Don't allow errors to be raised before static initialization completes
		}

		CFunctionContextBase* pFunctionContext = CFunctionContextBase::GetCurrent();

		if( pFunctionContext )
		{
			CObjectContextBase& ObjRef( pFunctionContext->ObjectContextPointer() ? *(pFunctionContext->ObjectContextPointer()) : CObjectContextBase::NullContext() );
			Raise( pFunctionContext->File(), (int)pFunctionContext->Line(), pFunctionContext->Name(), ObjRef, 
				uiErrCode, pDomain, eLevel );
		}
		else
		{
			Raise( "Unknown file", 0, "Unknown function", CObjectContextBase::NullContext(), uiErrCode, pDomain, eLevel );
		}
	}

	//------------------------------------------------------------------------------
	void CError::Raise( const char* szFile, int iLine, const char* strFunc, CObjectContextBase& ObjContext, unsigned int uiCode, CBaseErrorDomain* pDomain, CError::Level eLevel )
	{
		CError* pError = new CError;

		//Construct the parts of the error

		//When
		pError->m_When.Configure( new CWhen() );

		//Where
		pError->m_Where.Configure( new CWhere() );
		pError->Where().SetLine( static_cast< unsigned int >( iLine ) );
		pError->Where().SetFunction( strFunc );
		pError->Where().SetFile( szFile );
		pError->Where().SetDomain( pDomain );
		pError->Where().SetObjectContext( ObjContext );

		//What
		pError->m_What.Configure( new CWhat() );
		pError->What().SetCode( uiCode );
		pError->What().SetLevel( eLevel );
		*( pError->What().Params() ) = new CBaseErrorParams();

		//Attempt to resolve the error
		pError->Resolved( pError->Handle() );
	}

	//------------------------------------------------------------------------------
	void CError::Catch()
	{
#if		( __QCMP_SUPPORTS( __QCMP_FEATURE_TEMPLATE_PARTIAL_SPECIALIZATION ) )
		m_Where.operator()< CWhere >().SetInException( true );
#else
		dynamic_cast< CWhere* >( m_Where.Base() )->SetInException( true );
#endif
		Resolved( Handle() );
	}

	//------------------------------------------------------------------------------
	//Handle Errors by invoking the appropriate Error handler
	bool CError::Handle()
	{
		bool bHandled = false;

#if		( __QCMP_SUPPORTS( __QCMP_FEATURE_TEMPLATE_PARTIAL_SPECIALIZATION ) )
		switch ( m_What.operator()< CWhat >().GetLevel() )
#else
		switch ( dynamic_cast< CWhat* >( m_What.Base() )->GetLevel() )
#endif
		{
		case ERR_LVL_NOTE:
			{
				CTInstancePtr< CDefaultNoteHandler > pHandler;
				if( pHandler.operator->() )
				{
					pHandler->Handle( *this );
				}
				bHandled = true;//Notes are not allowed to escalate
			}
			break;
		case ERR_LVL_WARNING:
			{
				CTInstancePtr< CDefaultWarningHandler > pHandler;
				bHandled = pHandler.operator->() && pHandler->Handle( *this );
			}
			break;
		case ERR_LVL_CONTINUE:
			{
				CTInstancePtr< CDefaultContinuableHandler > pHandler;
				bHandled = pHandler.operator->() && pHandler->Handle( *this );
			}
			break;
		case ERR_LVL_SERIOUS:
			{
				CTInstancePtr< CDefaultSeriousHandler > pHandler;
				bHandled = pHandler.operator->() && pHandler->Handle( *this );
			}
			break;
		case ERR_LVL_FATAL:
			{
				CTInstancePtr< CDefaultFatalHandler > pHandler;
				if( pHandler.operator->() )
				{
					pHandler->Handle( *this );
				}
				bHandled = false;//Fatal errors cannot be resolved
			}
			break;
		}

		return bHandled;
	}

	//------------------------------------------------------------------------------
	CWhere& CError::Where()
	{
#if		( __QCMP_SUPPORTS( __QCMP_FEATURE_TEMPLATE_PARTIAL_SPECIALIZATION ) )
		return m_Where.operator()< CWhere >();
#else
		return *( dynamic_cast< CWhere* >( m_Where.Base() ) );
#endif
	}

	//------------------------------------------------------------------------------
	CWhat& CError::What()
	{
#if		( __QCMP_SUPPORTS( __QCMP_FEATURE_TEMPLATE_PARTIAL_SPECIALIZATION ) )
		return m_What.operator()< CWhat >();
#else
		return *( dynamic_cast< CWhat* >( m_What.Base() ) );
#endif
	}

	//------------------------------------------------------------------------------
	CWhen& CError::When()
	{
#if		( __QCMP_SUPPORTS( __QCMP_FEATURE_TEMPLATE_PARTIAL_SPECIALIZATION ) )
		return m_When.operator()< CWhen >();
#else
		return *( dynamic_cast< CWhen* >( m_When.Base() ) );
#endif
	}

	//------------------------------------------------------------------------------
	CString CError::Description()
	{
		CString strDescription = _TXT("Failed to get error description").str();
		Where().GetDomain()->GetDescription( strDescription, this );

		return strDescription;
	}

}//nsCodeQOR
