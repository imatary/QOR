//WinQLIOStream.h

// Copyright Querysoft Limited 2016
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef WINQL_FILESYSTEM_IOSTREAM_H_3
#define WINQL_FILESYSTEM_IOSTREAM_H_3

#include <stdio.h>
#include <errno.h>
#include "WinQL/WinQL.h"
#include "WinQL/Application/Threading/WinQLCriticalSection.h"
#include "WinQL/Application/Threading/WinQLSynchronization.h"
#include "WinQL/System/FileSystem/WinQLFile.h"
#include "WinQL/Application/ErrorSystem/WinQLErrorHandling.h"
#include "WinQL/System/FileSystem/WinQLFileManagement.h"
#include "WinQL/System/FileSystem/WinQLIOBuffer.h"
#include "WinQL/Application/ErrorSystem/WinQLDOSError.h"

//------------------------------------------------------------------------------
namespace nsWin32
{
	//Consider CTextStream and CByteStream

	//------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CIOStream : public CIOBuffer
	{
	public:

		//------------------------------------------------------------------------------
		enum ETextMode
		{
			ANSI = 0,
			UTF8,
			UTF16LE,
			UTF16BE,
			UTF32,
		};

		__QCMP_STATIC_CONSTANT( int, __IOINFO_TM_ANSI = 0 );// Regular Text
		__QCMP_STATIC_CONSTANT( int, __IOINFO_TM_UTF8 = 1 );// UTF8 Encoded
		__QCMP_STATIC_CONSTANT( int, __IOINFO_TM_UTF16LE = 2 );// UTF16 Little Endian Encoded

		__QCMP_STATIC_CONSTANT( unsigned char, FOPEN = 0x01 );				// file open
		__QCMP_STATIC_CONSTANT( unsigned char, FEOFLAG = 0x02 );			// end of file has been encountered
		__QCMP_STATIC_CONSTANT( unsigned char, FCRLF = 0x04 );				// CR-LF across read buffer (in text mode)
		__QCMP_STATIC_CONSTANT( unsigned char, FPIPE = 0x08 );				// file refers to a pipe
		__QCMP_STATIC_CONSTANT( unsigned char, FNOINHERIT = 0x10 );			// file opened _O_NOINHERIT
		__QCMP_STATIC_CONSTANT( unsigned char, FAPPEND = 0x20 );			// file opened O_APPEND
		__QCMP_STATIC_CONSTANT( unsigned char, FDEV = 0x40 );				// file refers to device
		__QCMP_STATIC_CONSTANT( unsigned char, FTEXT = 0x80 );				// file is in text mode

		CIOStream();
		virtual ~CIOStream();
		CIOStream( const CIOStream& );
		CIOStream& operator = ( const CIOStream& );

		virtual void Reset( void );

		void ClearErrorFlags( void );

		bool IsOpen( void );
		void SetIsOpen( bool bOpen );

		bool GetIsTextMode( void );
		void SetIsTextMode( bool bTextMode );

		bool IsLeadByteBufferUsed( void );
		void SetIsLeadByteBufferUsed( bool bUsed );

		char ReadDBCSBuffer( void );
		void WriteDBCSBuffer( char leadByte );

		bool BufferContainsTranslations( void );
		void SetBufferContainsTranslations( bool bUTF8 );

		Cmp__int64 GetStartPos( void );
		void SetStartPos( const Cmp__int64& newPos );

		void ReadPeakAheadPipeBuffer( unsigned short& usPipeBufferDest );
		void WritePeakAheadPipeBuffer( unsigned short usPipeBufferSource );

		bool IsUnicode( void );
		void SetIsUnicode( bool bUnicode );

		bool IsAppend( void );
		void SetIsAppend( bool bAppend );

		char GetTextMode( void );
		void SetTextMode( char chMode );

		void ReadPipeBuffer( char& cPipeBufferDest );
		void WritePipeBuffer( char cPipeBufferSource );
		
		void SetFlags( unsigned char ucFlags );
		unsigned char GetFlags( void );

		void Lock( void );
		int TryLock( void );
		void Unlock( void );
		bool IsLocked( void );

		int SetMode( int mode );

		bool IsCtrlZ( void );
		void SetCtrlZ( void );
		void ClearCtrlZ( void );

		bool IsCRLF( void );
		void SetCRLF( void );
		void ClearCRLF( void );

		bool IsDevice( void );
		bool IsPipe( void );

		bool IsAppendMode( void );
		void SetAppendMode( void );
		void ClearAppendMode();

		bool IsFEOF( void );
		void SetFEOF( void );
		void ClearFEOF( void );

	private:

		CCriticalSection m_Lock;
		bool m_bLocked;

		unsigned char m_chFlags;	// attributes of file (e.g., open in text mode?)

		//Read buffer for UTF-16 input from non seekable devices e.g. Pipe
		char m_chPipe;				// one char buffer for Handles opened on pipes
		char m_chTextMode : 7;		// __IOINFO_TM_ANSI or __IOINFO_TM_UTF8 or __IOINFO_TM_UTF16LE

		char m_bchUnicode : 1;      // Was the file opened as unicode?

		//Read buffer for UTF-8 and UTF-16 input from non seekable devices e.g. Pipe
		char m_achPipeBuffer[ 2 ];	// 2 more peak ahead chars for UNICODE mode

		Cmp__int64 m_i64StartPos;	// File position that matches buffer start

		//Set only in UTF-8 Text Mode to indicate we have translated the buffer, doesn't seem to be read anywhere
		bool m_bUTF8Translations;	// Buffer contains translations other than CRLF

		//These are used only for writing Multibyte characters with translation byte by byte
		char m_dbcsBuffer;			// Buffer for the lead byte of dbcs when converting from dbcs to unicode
		bool m_dbcsBufferUsed;		// Bool for the lead byte buffer is used or not
	};

}//nsWin32

#endif//WINQL_FILESYSTEM_IOSTREAM_H_3
