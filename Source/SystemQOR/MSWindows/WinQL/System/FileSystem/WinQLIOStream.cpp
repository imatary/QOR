//WinQLIOStream.cpp

// Copyright Querysoft Limited 2016
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "WinQL/Application/ErrorSystem/WinQLErrDomain.h"
#include "WinQL/System/FileSystem/WinQLIOStream.h"
#include "WinQAPI/Kernel32.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	using namespace nsWinQAPI;

	//--------------------------------------------------------------------------------
	CIOStream::CIOStream()
	{
		Reset();
	}
	//--------------------------------------------------------------------------------
	CIOStream::~CIOStream()
	{
	}

	//--------------------------------------------------------------------------------
	CIOStream::CIOStream( const CIOStream& src )
	{
		*this = src;
	}

	//--------------------------------------------------------------------------------
	CIOStream& CIOStream::operator = ( const CIOStream& src )
	{
		if( &src != this )
		{
			CIOBuffer::operator=( src );
			m_chFlags = src.m_chFlags;							// attributes of file (e.g., open in text mode?)
			m_chPipe = src.m_chPipe;							// one char buffer for Handles opened on pipes
			m_chTextMode = src.m_chTextMode;					// __IOINFO_TM_ANSI or __IOINFO_TM_UTF8 or __IOINFO_TM_UTF16LE
			m_bchUnicode = src.m_bchUnicode;					// Was the file opened as unicode?
			m_achPipeBuffer[ 0 ] = src.m_achPipeBuffer[ 0 ];	// 2 more peak ahead chars for UNICODE mode
			m_achPipeBuffer[ 1 ] = src.m_achPipeBuffer[ 1 ];	// 2 more peak ahead chars for UNICODE mode
			m_i64StartPos = src.m_i64StartPos;					// File position that matches buffer start
			m_bUTF8Translations = src.m_bUTF8Translations;		// Buffer contains translations other than CRLF
			m_dbcsBuffer = src.m_dbcsBuffer;					// Buffer for the lead byte of dbcs when converting from dbcs to unicode
			m_dbcsBufferUsed = src.m_dbcsBufferUsed;			// Bool for the lead byte buffer is used or not
		}
		return *this;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::Reset( void )
	{
		ResetBuffer();
		m_chFlags = 0;
		m_chPipe = 0;
		m_chTextMode = __IOINFO_TM_ANSI;
		m_bchUnicode = 0;
		m_achPipeBuffer[ 0 ] = 0;
		m_achPipeBuffer[ 1 ] = 0;
		m_i64StartPos = 0;
		m_bUTF8Translations = false;
		m_dbcsBuffer = 0;
		m_dbcsBufferUsed = false;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::ClearErrorFlags( void )
	{
		m_chFlags &= ~( FEOFLAG );
		ClearBufferErrorFlags();
	}

	//--------------------------------------------------------------------------------
	bool CIOStream::IsOpen( void )
	{
		return m_chFlags & FOPEN ? true : false;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::SetIsOpen( bool bOpen )
	{
		bOpen ? m_chFlags |= FOPEN : m_chFlags &= ~FOPEN;
	}

	//--------------------------------------------------------------------------------
	bool CIOStream::GetIsTextMode( void )
	{
		return ( m_chFlags & FTEXT ) ? true : false;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::SetIsTextMode( bool bTextMode )
	{
		bTextMode ? m_chFlags |= FTEXT : m_chFlags &= ~FTEXT;
	}

	//--------------------------------------------------------------------------------
	bool CIOStream::IsLeadByteBufferUsed( void )
	{
		return m_dbcsBufferUsed;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::SetIsLeadByteBufferUsed( bool bUsed )
	{
		m_dbcsBufferUsed = bUsed;
	}

	//--------------------------------------------------------------------------------
	char CIOStream::ReadDBCSBuffer( void )
	{
		return m_dbcsBuffer;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::WriteDBCSBuffer( char leadByte )
	{
		m_dbcsBuffer = leadByte;
		SetIsLeadByteBufferUsed( true );
	}

	//--------------------------------------------------------------------------------
	bool CIOStream::BufferContainsTranslations( void )
	{
		return m_bUTF8Translations;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::SetBufferContainsTranslations( bool bUTF8 )
	{
		m_bUTF8Translations = bUTF8;
	}

	//--------------------------------------------------------------------------------
	Cmp__int64 CIOStream::GetStartPos( void )
	{
		return m_i64StartPos;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::SetStartPos( const Cmp__int64& newPos )
	{
		m_i64StartPos = newPos;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::ReadPeakAheadPipeBuffer( unsigned short& usPipeBufferDest )
	{
		usPipeBufferDest = ( ( static_cast<unsigned short>( m_achPipeBuffer[ 1 ] ) ) << 8 ) | static_cast<unsigned short>( m_achPipeBuffer[ 0 ] );
	}

	//--------------------------------------------------------------------------------
	void CIOStream::WritePeakAheadPipeBuffer( unsigned short usPipeBufferSource )
	{
		m_achPipeBuffer[ 0 ] = LoByte( usPipeBufferSource );
		m_achPipeBuffer[ 1 ] = HiByte( usPipeBufferSource );
	}

	//--------------------------------------------------------------------------------
	bool CIOStream::IsUnicode( void )
	{
		return m_bchUnicode ? true : false;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::SetIsUnicode( bool bUnicode )
	{
		m_bchUnicode = bUnicode;
	}

	//--------------------------------------------------------------------------------
	bool CIOStream::IsAppend( void )
	{
		return m_chFlags & FAPPEND ? true : false;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::SetIsAppend( bool bAppend )
	{
		bAppend ? m_chFlags |= FAPPEND : m_chFlags &= ~FAPPEND;
	}

	//--------------------------------------------------------------------------------
	bool CIOStream::IsCtrlZ( void )
	{
		return m_chFlags & FEOFLAG ? true : false;
	}
	
	//--------------------------------------------------------------------------------
	void CIOStream::SetCtrlZ( void )
	{
		m_chFlags |= FEOFLAG;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::ClearCtrlZ()
	{
		m_chFlags &= ~FEOFLAG;
	}

	//--------------------------------------------------------------------------------
	bool CIOStream::IsCRLF( void )
	{
		return m_chFlags & FCRLF ? true : false;
	}
	//--------------------------------------------------------------------------------
	void CIOStream::SetCRLF( void )
	{
		m_chFlags |= FCRLF;
	}
	//--------------------------------------------------------------------------------
	void CIOStream::ClearCRLF( void )
	{
		m_chFlags &= ~FCRLF;
	}

	//--------------------------------------------------------------------------------
	char CIOStream::GetTextMode( void )
	{
		return m_chTextMode;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::SetTextMode( char chMode )
	{
		m_chTextMode = chMode;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::ReadPipeBuffer( char& cPipeBufferDest )
	{
		cPipeBufferDest = m_chPipe;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::WritePipeBuffer( char cPipeBufferSource )
	{
		m_chPipe = cPipeBufferSource;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::SetFlags( unsigned char ucFlags )
	{
		m_chFlags = ucFlags;
	}

	//--------------------------------------------------------------------------------
	unsigned char CIOStream::GetFlags()
	{
		return m_chFlags;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::Lock()
	{
		m_Lock.Acquire();
		m_bLocked = true;
		CIOBuffer::LockBuffer();
	}

	//--------------------------------------------------------------------------------
	int CIOStream::TryLock()
	{
		int iResult = !m_Lock.TryEnter();

		if( iResult == 0 )
		{
			m_bLocked = true;
			CIOBuffer::LockBuffer();
		}

		return iResult;
	}

	//--------------------------------------------------------------------------------
	void CIOStream::Unlock()
	{
		CIOBuffer::UnlockBuffer();
		m_bLocked = false;
		m_Lock.Release();
	}

	//--------------------------------------------------------------------------------
	bool CIOStream::IsLocked()
	{
		return m_bLocked;
	}

	//------------------------------------------------------------------------------
	int CIOStream::SetMode( int mode )
	{
		int oldmode = m_chFlags & FTEXT;
		int oldtextmode = m_chTextMode;

		switch( mode )
		{
		case OBinary:
			m_chFlags &= ~FTEXT;
			break;

		case OText:
			m_chFlags |= FTEXT;
			m_chTextMode = __IOINFO_TM_ANSI;
			break;

		case OU8Text:
			m_chFlags |= FTEXT;
			m_chTextMode = __IOINFO_TM_UTF8;
			break;

		case OU16Text:
		case OWText:
			m_chFlags |= FTEXT;
			m_chTextMode = __IOINFO_TM_UTF16LE;
			break;
		}

		if( oldmode == 0 )
		{
			return OBinary;
		}

		if( oldtextmode == __IOINFO_TM_ANSI )
		{
			return OText;
		}
		else
		{
			return OWText;
		}
	}

	//------------------------------------------------------------------------------
	bool CIOStream::IsDevice()
	{
		return m_chFlags & FDEV ? true : false;
	}

	//------------------------------------------------------------------------------
	bool CIOStream::IsPipe( void )
	{
		return m_chFlags & FPIPE ? true : false;
	}

	//------------------------------------------------------------------------------
	bool CIOStream::IsAppendMode( void )
	{
		return m_chFlags & FAPPEND ? true : false;
	}

	//------------------------------------------------------------------------------
	void CIOStream::SetAppendMode( void )
	{
		m_chFlags |= FAPPEND;
	}

	//------------------------------------------------------------------------------
	void CIOStream::ClearAppendMode()
	{
		m_chFlags &= ~FAPPEND;
	}

	//------------------------------------------------------------------------------
	bool CIOStream::IsFEOF( void )
	{
		return m_chFlags & FEOFLAG ? true : false;
	}

	//------------------------------------------------------------------------------
	void CIOStream::SetFEOF( void )
	{
		m_chFlags |= FEOFLAG;
	}

	//------------------------------------------------------------------------------
	void CIOStream::ClearFEOF( void )
	{
		m_chFlags &= ~FEOFLAG;
	}

}//nsWin32

