//CallContextBase.h

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Track calls between contexted functions to facilitate AOP interception
//Currently fixed at 10 parameters to avoid allocation/deallocation in the middle of interception
//TODO: A custom pool based allocator for CParameterBase would be better.

#ifndef CODEQOR_STCALLCONTEXT_H_1
#define CODEQOR_STCALLCONTEXT_H_1

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "CodeQOR/DataStructures/TArray.h"
#include "CodeQOR/DataStructures/TLinkedList.h"
#include "CodeQOR/Instancing/STMember.h"
#include "CodeQOR.h"
#include "AppocritaQOR/SubSystems/IThread.h"

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
	class __QOR_INTERFACE( __CODEQOR ) CFunctionContextBase;

	//--------------------------------------------------------------------------------
	//A base class to allow all CParameterPass types to be stored in a homogeneous container
	class __QOR_INTERFACE( __CODEQOR ) CParameterBase
	{
	public:

		inline CParameterBase();
		inline CParameterBase( const CParameterBase& src );
		inline CParameterBase& operator = ( const CParameterBase& src );
		virtual ~CParameterBase();

		inline void Clear( void );

	protected:

		void* m_p;
	};

	//--------------------------------------------------------------------------------
	//A class for tracking the parameters of a call between two functions with context
	class __QOR_INTERFACE( __CODEQOR ) CCallContextBase
	{
	public:

		//--------------------------------------------------------------------------------
		template< class T >
		class CParameterPass : public CParameterBase
		{
		public:

			//--------------------------------------------------------------------------------
			CParameterPass( T& _t ) : CParameterBase()
			{
				m_p = &_t;//Capture the parameter reference on construction
			}

			//--------------------------------------------------------------------------------
			CParameterPass( const CParameterBase& src ) : CParameterBase( src )
			{
			}

			//--------------------------------------------------------------------------------
			CParameterPass( const CParameterPass& src ) : CParameterBase( src )
			{
			}

			//--------------------------------------------------------------------------------
			CParameterPass& operator = ( const CParameterPass& src )
			{
				CParameterBase::operator=( src );
				return *this;
			}

			//--------------------------------------------------------------------------------
			virtual ~CParameterPass()
			{
			}

			//--------------------------------------------------------------------------------
			//Access to the parameter reference
			T& ParamterRef()
			{
				return *( reinterpret_cast< T* >(m_p) );
			}

		private:

			//prevent these from being autogenerated by the compiler
			CParameterPass();
		};

	public:

		//--------------------------------------------------------------------------------
		//Enable clients to register parameters by inlining this code at the point of registration
		template< typename T > void __QCMP_ALWAYSINLINE Register( T& _t )
		{
			CParameterPass< T > paramt( _t );
			OutOfLineRegistration( paramt );
		}

		//--------------------------------------------------------------------------------
		//Enable clients to register return values of practically any type by inlining
		//this code at the point of registration
		template< typename T > void __QCMP_ALWAYSINLINE RegisterReturn( T& _t )
		{
			CParameterPass< T > ReturnValue( _t );
			m_ReturnValue = ReturnValue;
		}

		CCallContextBase( nsQOR::IThread::ref_type ThreadContext );
		virtual ~CCallContextBase();

		virtual void CallMade( CFunctionContextBase* );			//Called when the child function contect is constructed, the call has reached the child function
		virtual void CallCompleted();							//Called when the child function context is winding up, the call has completed
		virtual void OnReturnAssignment();
		CParameterBase* Parameters( void );						//Access to the array of registered parameters
		CParameterBase* ReturnValue( void );					//Access to the return value

		void Cleanup();											//Utility function to clean up the linked list

	protected:

		void __QCMP_NOINLINE OutOfLineRegistration( CParameterBase& Param );
		void __QCMP_NOINLINE OutOfLineReturnRegistration( CParameterBase* pParam );
		CParameterBase m_aParameters[ 10 ];
		CParameterBase m_ReturnValue;							//Return value
		unsigned char m_ucParamCount;
		nsQOR::IThread::ref_type m_ThreadContext;
	};

}//nsCodeQOR

#endif//CODEQOR_STCALLCONTEXT_H_1
