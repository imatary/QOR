//i086CPU.cpp

// Copyright (c) 2008-2010, Petr Kobalicek <kobalicek.petr@gmail.com>
// Copyright (c) Querysoft Limited 2013, 2016
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Implement i086 Assmebler intrinsics for x86PC platform

#include "ArchQOR.h"

#if		( QOR_ARCH == QOR_ARCH_X86_32 || QOR_ARCH == QOR_ARCH_X86_64 )

#include "ArchQOR/x86/Assembler/BatchCPU/i086CPU.h"

//------------------------------------------------------------------------------
namespace nsArch
{
	namespace nsx86
	{
		//------------------------------------------------------------------------------
		Ci086CPU::Ci086CPU( CCodeGeneratorBase* codeGenerator ) __QCMP_THROW : Cx86CPUCore( codeGenerator )
		{
		}

		//------------------------------------------------------------------------------
		Ci086CPU::~Ci086CPU() __QCMP_THROW
		{
		}

		//ADC

		//------------------------------------------------------------------------------
		//Add with Carry.
		void Ci086CPU::adc( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_ADC, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Add with Carry.
		void Ci086CPU::adc( const CGPReg& dst, const CMem& src )
		{
			_emitInstruction( INST_ADC, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Add with Carry.
		void Ci086CPU::adc( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_ADC, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Add with Carry.
		void Ci086CPU::adc( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_ADC, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Add with Carry.
		void Ci086CPU::adc( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_ADC, &dst, &src );
		}

		//ADD

		//------------------------------------------------------------------------------
		//Add.
		void Ci086CPU::add( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_ADD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Add.
		void Ci086CPU::add( const CGPReg& dst, const CMem& src )
		{
			_emitInstruction( INST_ADD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Add.
		void Ci086CPU::add( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_ADD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Add.
		void Ci086CPU::add( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_ADD, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Add.
		void Ci086CPU::add( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_ADD, &dst, &src );
		}

		//AND

		//------------------------------------------------------------------------------
		//Logical And.
		void Ci086CPU::and_( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_AND, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Logical And.
		void Ci086CPU::and_( const CGPReg& dst, const CMem& src )
		{
			_emitInstruction( INST_AND, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Logical And.
		void Ci086CPU::and_( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_AND, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Logical And.
		void Ci086CPU::and_( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_AND, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Logical And.
		void Ci086CPU::and_( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_AND, &dst, &src );
		}

		//CALL

		//------------------------------------------------------------------------------
		//Call Procedure.
		void Ci086CPU::call( const CGPReg& dst )
		{
			//assert(dst.isRegType(REG_TYPE_GPN));
			_emitInstruction( INST_CALL, &dst );
		}

		//------------------------------------------------------------------------------
		//Call Procedure.
		void Ci086CPU::call( const CMem& dst )
		{
			_emitInstruction( INST_CALL, &dst );
		}

		//------------------------------------------------------------------------------
		//Call Procedure.
		void Ci086CPU::call( const CImm& dst )
		{
			_emitInstruction( INST_CALL, &dst );
		}

		//------------------------------------------------------------------------------
		//Call Procedure.
		void Ci086CPU::call( void* dst )
		{
			CImm imm( (Cmp_int_ptr)dst );
			_emitInstruction( INST_CALL, &imm );
		}

		//------------------------------------------------------------------------------
		//Call Procedure.
		void Ci086CPU::call( const CLabel& label )
		{
			_emitInstruction( INST_CALL, &label );
		}

		//CBW

		//------------------------------------------------------------------------------
		//Convert Byte to Word (Sign Extend).
		// AX <- Sign Extend AL
		void Ci086CPU::cbw()
		{
			_emitInstruction( INST_CBW );
		}

		//CLC

		//------------------------------------------------------------------------------
		//Clear Carry flag
		// This instruction clears the CF flag in the EFLAGS register.
		void Ci086CPU::clc()
		{
			_emitInstruction( INST_CLC );
		}

		//CLD

		//------------------------------------------------------------------------------
		//Clear Direction flag
		// This instruction clears the DF flag in the EFLAGS register.
		void Ci086CPU::cld()
		{
			_emitInstruction( INST_CLD );
		}

		//CMC

		//------------------------------------------------------------------------------
		//Complement Carry Flag.
		// This instruction complements the CF flag in the EFLAGS register.
		// (CF = NOT CF)
		void Ci086CPU::cmc()
		{
			_emitInstruction( INST_CMC );
		}

		//CMP

		//------------------------------------------------------------------------------
		//Compare Two Operands.
		void Ci086CPU::cmp( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_CMP, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Compare Two Operands.
		void Ci086CPU::cmp( const CGPReg& dst, const CMem& src )
		{
			_emitInstruction( INST_CMP, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Compare Two Operands.
		void Ci086CPU::cmp( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_CMP, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Compare Two Operands.
		void Ci086CPU::cmp( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_CMP, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Compare Two Operands.
		void Ci086CPU::cmp( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_CMP, &dst, &src );
		}

		//DAA

#if	( QOR_ARCH_WORDSIZE == 32 )
		//------------------------------------------------------------------------------
		//Decimal adjust AL after addition
		//
		// This instruction adjusts the sum of two packed BCD values to create
		// a packed BCD result.
		//
		// Note This instruction is only available in 32-bit mode.
		void Ci086CPU::daa()
		{
			_emitInstruction( INST_DAA );
		}
#endif

		//DAS

#if	( QOR_ARCH_WORDSIZE == 32 )
		//------------------------------------------------------------------------------
		//Decimal adjust AL after subtraction
		//
		// This instruction adjusts the result of the subtraction of two packed
		// BCD values to create a packed BCD result.
		//
		// Note This instruction is only available in 32-bit mode.
		void Ci086CPU::das()
		{
			_emitInstruction( INST_DAS );
		}
#endif // ( QOR_ARCH_WORDSIZE == 32 )

		//DEC

		//------------------------------------------------------------------------------
		//Decrement by 1.
		// Note This instruction can be slower than sub( dst, 1 )
		void Ci086CPU::dec( const CGPReg& dst )
		{
			_emitInstruction( INST_DEC, &dst );
		}

		//------------------------------------------------------------------------------
		//Decrement by 1.
		// Note This instruction can be slower than sub(dst, 1)
		void Ci086CPU::dec( const CMem& dst )
		{
			_emitInstruction( INST_DEC, &dst );
		}

		//DIV

		//------------------------------------------------------------------------------
		//Unsigned divide.
		// This instruction divides (unsigned) the value in the AL, AX, or EAX
		// register by the source operand and stores the result in the AX,
		// DX:AX, or EDX:EAX registers.
		void Ci086CPU::div( const CGPReg& src )
		{
			_emitInstruction( INST_DIV, &src );
		}

		//------------------------------------------------------------------------------
		//Unsigned divide.
		void Ci086CPU::div( const CMem& src )
		{
			_emitInstruction( INST_DIV, &src );
		}

		//IDIV

		//------------------------------------------------------------------------------
		//Signed divide.
		// This instruction divides (signed) the value in the AL, AX, or EAX
		// register by the source operand and stores the result in the AX,
		// DX:AX, or EDX:EAX registers.
		void Ci086CPU::idiv( const CGPReg& src )
		{
			_emitInstruction( INST_IDIV, &src );
		}

		//------------------------------------------------------------------------------
		//Signed divide.
		void Ci086CPU::idiv( const CMem& src )
		{
			_emitInstruction( INST_IDIV, &src );
		}

		//IMUL


		//------------------------------------------------------------------------------
		//Signed multiply.
		// Source operand (in a general-purpose register or memory location)
		// is multiplied by the value in the AL, AX, or EAX register (depending
		// on the operand size) and the product is stored in the AX, DX:AX, or
		// EDX:EAX registers, respectively.
		void Ci086CPU::imul( const CGPReg& src )
		{
			_emitInstruction( INST_IMUL, &src );
		}

		//------------------------------------------------------------------------------
		void Ci086CPU::imul( const CMem& src )
		{
			_emitInstruction( INST_IMUL, &src );
		}

		//------------------------------------------------------------------------------
		//Signed multiply.
		// Destination operand (the first operand) is multiplied by the source
		// operand (second operand). The destination operand is a general-purpose
		// register and the source operand is an immediate value, a general-purpose
		// register, or a memory location. The product is then stored in the
		// destination operand location.
		void Ci086CPU::imul( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_IMUL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Signed multiply.
		void Ci086CPU::imul( const CGPReg& dst, const CMem& src )
		{
			_emitInstruction( INST_IMUL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Signed multiply.
		void Ci086CPU::imul( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_IMUL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Signed multiply.
		// source operand ( which can be a general-purpose register or a memory
		// location ) is multiplied by the second source operand (an immediate
		// value). The product is then stored in the destination operand
		// (a general-purpose register).
		void Ci086CPU::imul( const CGPReg& dst, const CGPReg& src, const CImm& imm )
		{
			_emitInstruction( INST_IMUL, &dst, &src, &imm );
		}

		//------------------------------------------------------------------------------
		void Ci086CPU::imul( const CGPReg& dst, const CMem& src, const CImm& imm )
		{
			_emitInstruction( INST_IMUL, &dst, &src, &imm );
		}

		//INC

		//------------------------------------------------------------------------------
		//Increment by 1.
		// Note This instruction can be slower than add( dst, 1 )
		void Ci086CPU::inc( const CGPReg& dst )
		{
			_emitInstruction( INST_INC, &dst );
		}

		//------------------------------------------------------------------------------
		//Increment by 1.
		// Note This instruction can be slower than add( dst, 1 )
		void Ci086CPU::inc( const CMem& dst )
		{
			_emitInstruction( INST_INC, &dst );
		}

		//INT

		//------------------------------------------------------------------------------
		//Interrupt 3 - trap to debugger.
		void Ci086CPU::int3()
		{
			_emitInstruction( INST_INT3 );
		}

		//Jcc

		//------------------------------------------------------------------------------
		//Jump to label label if condition cc is met.
		//
		// This instruction checks the state of one or more of the status flags in
		// the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the
		// specified state (condition), performs a jump to the target instruction
		// specified by the destination operand. A condition code (cc) is associated
		// with each instruction to indicate the condition being tested for. If the
		// condition is not satisfied, the jump is not performed and execution
		// continues with the instruction following the Jcc instruction.
		void Ci086CPU::j( CONDITION cc, const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE */)
		{
			_emitJcc( ConditionToInstruction::toJCC( cc ), &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label if condition is met.
		void Ci086CPU::ja( const CLabel& label, Cmp_unsigned__int32 hint/* = HINT_NONE*/ )
		{
			_emitJcc( INST_JA, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jae( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JAE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jb( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JB, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jbe( const CLabel& label, Cmp_unsigned__int32 hint/* = HINT_NONE*/ )
		{
			_emitJcc( INST_JBE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jc( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JC, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::je( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jg( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JG, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jge( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JGE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jl( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JL, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jle( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JLE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jna( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JNA, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jnae( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JNAE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jnb( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JNB, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jnbe( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JNBE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jnc( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JNC, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jne( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JNE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jng( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JNG, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jnge( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JNGE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jnl( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JNL, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jnle( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JNLE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jno( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JNO, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jnp( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JNP, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jns( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JNS, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jnz( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JNZ, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jo( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JO, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jp( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JP, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jpe( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JPE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jpo( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JPO, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::js( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JS, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Jump to label label if condition is met.
		void Ci086CPU::jz( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitJcc( INST_JZ, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label label if condition cc is met.
		void Ci086CPU::short_j( CONDITION cc, const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			m_uiEmitOptions |= EMIT_OPTION_SHORT_JUMP;
			j( cc, label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label label if condition is met.
		void Ci086CPU::short_ja( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JA, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jae( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JAE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label label if condition is met.
		void Ci086CPU::short_jb( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JB, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jbe( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JBE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jc( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JC, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_je( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jg( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JG, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jge( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JGE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jl( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JL, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jle( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JLE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jna( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JNA, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jnae( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JNAE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jnb( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JNB, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jnbe( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JNBE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jnc( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JNC, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jne( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JNE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jng( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JNG, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jnge( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JNGE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jnl( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JNL, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jnle( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JNLE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jno( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JNO, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jnp( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JNP, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jns( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JNS, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jnz( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JNZ, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jo( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JO, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jp( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JP, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jpe( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JPE, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jpo( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JPO, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_js( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JS, &label, hint );
		}

		//------------------------------------------------------------------------------
		//Short jump to label if condition is met.
		void Ci086CPU::short_jz( const CLabel& label, Cmp_unsigned__int32 hint /*= HINT_NONE*/ )
		{
			_emitShortJcc( INST_JZ, &label, hint );
		}

		//JMP

		//------------------------------------------------------------------------------
		//Jump.
		void Ci086CPU::jmp( const CGPReg& dst )
		{
			_emitInstruction( INST_JMP, &dst );
		}

		//------------------------------------------------------------------------------
		//Jump.
		void Ci086CPU::jmp( const CMem& dst )
		{
			_emitInstruction( INST_JMP, &dst );
		}

		//------------------------------------------------------------------------------
		//Jump.
		void Ci086CPU::jmp( const CImm& dst )
		{
			_emitInstruction( INST_JMP, &dst );
		}

		//------------------------------------------------------------------------------
		//Jump.
		void Ci086CPU::jmp( void* dst )
		{
			CImm imm( (Cmp_int_ptr)dst );
			_emitInstruction( INST_JMP, &imm );
		}

		//------------------------------------------------------------------------------
		//Jump.
		// This instruction transfers program control to a different point
		// in the instruction stream without recording return information.
		// The destination (target) operand specifies the label of the
		// instruction being jumped to.
		void Ci086CPU::jmp( const CLabel& label )
		{
			_emitInstruction( INST_JMP, &label );
		}

		//------------------------------------------------------------------------------
		//Short jump.
		void Ci086CPU::short_jmp( const CLabel& label )
		{
			m_uiEmitOptions |= EMIT_OPTION_SHORT_JUMP;
			_emitInstruction( INST_JMP, &label );
		}

		//LEA

		//------------------------------------------------------------------------------
		//Load Effective Address
		//
		// This instruction computes the effective address of the second
		// operand (the source operand) and stores it in the first operand
		// (destination operand). The source operand is a memory address
		// (offset part) specified with one of the processors addressing modes.
		// The destination operand is a general-purpose register.
		void Ci086CPU::lea( const CGPReg& dst, const CMem& src )
		{
			_emitInstruction( INST_LEA, &dst, &src );
		}

		//MOV

		//------------------------------------------------------------------------------
		//Move.
		// This instruction copies the second operand (source operand) to the first
		// operand (destination operand). The source operand can be an immediate
		// value, general-purpose register, segment register, or memory location.
		// The destination register can be a general-purpose register, segment
		// register, or memory location. Both operands must be the same size, which
		// can be a byte, a word, or a DWORD.
		//
		// Note To move MMX or SSE registers to/from GP registers or memory, use
		// corresponding functions: movd(), movq(), etc. Passing MMX or SSE
		// registers to mov() is illegal.
		void Ci086CPU::mov( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Move.
		void Ci086CPU::mov( const CGPReg& dst, const CMem& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Move.
		void Ci086CPU::mov( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Move.
		void Ci086CPU::mov( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Move.
		void Ci086CPU::mov( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Move from segment register.
		void Ci086CPU::mov( const CGPReg& dst, const CSegmentReg& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Move from segment register.
		void Ci086CPU::mov( const CMem& dst, const CSegmentReg& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Move to segment register.
		void Ci086CPU::mov( const CSegmentReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Move to segment register.
		void Ci086CPU::mov( const CSegmentReg& dst, const CMem& src )
		{
			_emitInstruction( INST_MOV, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Move byte, word, dword or qword from absolute address src to AL, AX, EAX or RAX register.
		void Ci086CPU::mov_ptr( const CGPReg& dst, void* src )
		{
			//assert(dst.getRegIndex() == 0);
			CImm imm( (Cmp_int_ptr)src );
			_emitInstruction( INST_MOV_PTR, &dst, &imm );
		}

		//------------------------------------------------------------------------------
		//Move byte, word, dword or qword from AL, AX, EAX or RAX register to absolute address dst.
		void Ci086CPU::mov_ptr( void* dst, const CGPReg& src )
		{
			//assert(src.getRegIndex() == 0);
			CImm imm( (Cmp_int_ptr)dst );
			_emitInstruction( INST_MOV_PTR, &imm, &src );
		}

		//------------------------------------------------------------------------------
		//Move with Sign-Extension.
		// This instruction copies the contents of the source operand (register
		// or memory location) to the destination operand (register) and sign
		// extends the value to 16, 32 or 64-bits.
		void Ci086CPU::movsx( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_MOVSX, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Move with Sign-Extension.
		void Ci086CPU::movsx( const CGPReg& dst, const CMem& src )
		{
			_emitInstruction( INST_MOVSX, &dst, &src );
		}

		//MUL

		//------------------------------------------------------------------------------
		//Unsigned multiply.
		// Source operand (in a general-purpose register or memory location)
		// is multiplied by the value in the AL, AX, or EAX register (depending
		// on the operand size) and the product is stored in the AX, DX:AX, or
		// EDX:EAX registers, respectively.
		void Ci086CPU::mul( const CGPReg& src )
		{
			_emitInstruction( INST_MUL, &src );
		}

		//------------------------------------------------------------------------------
		//Unsigned multiply.
		void Ci086CPU::mul( const CMem& src )
		{
			_emitInstruction( INST_MUL, &src );
		}

		//NEG

		//------------------------------------------------------------------------------
		//Two's Complement Negation.
		void Ci086CPU::neg( const CGPReg& dst )
		{
			_emitInstruction( INST_NEG, &dst );
		}

		//------------------------------------------------------------------------------
		//Two's Complement Negation.
		void Ci086CPU::neg( const CMem& dst )
		{
			_emitInstruction( INST_NEG, &dst );
		}

		//NOP

		//------------------------------------------------------------------------------
		//No Operation.
		// This instruction performs no operation. This instruction is a one-byte
		// instruction that takes up space in the instruction stream but does not
		// affect the machine context, except the EIP register. The NOP instruction
		// is an alias mnemonic for the XCHG (E)AX, (E)AX instruction.
		void Ci086CPU::nop()
		{
			_emitInstruction( INST_NOP );
		}

		//NOT

		//------------------------------------------------------------------------------
		//One's Complement Negation.
		void Ci086CPU::not_( const CGPReg& dst )
		{
			_emitInstruction( INST_NOT, &dst );
		}

		//------------------------------------------------------------------------------
		//One's Complement Negation.
		void Ci086CPU::not_( const CMem& dst )
		{
			_emitInstruction( INST_NOT, &dst );
		}

		//OR

		//------------------------------------------------------------------------------
		//Logical Inclusive OR.
		void Ci086CPU::or_( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_OR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Logical Inclusive OR.
		void Ci086CPU::or_( const CGPReg& dst, const CMem& src )
		{
			_emitInstruction( INST_OR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Logical Inclusive OR.
		void Ci086CPU::or_( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_OR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Logical Inclusive OR.
		void Ci086CPU::or_( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_OR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Logical Inclusive OR.
		void Ci086CPU::or_( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_OR, &dst, &src );
		}

		//POP

		//------------------------------------------------------------------------------
		//Pop a Value from the Stack.
		//
		// This instruction loads the value from the top of the stack to the location
		// specified with the destination operand and then increments the stack pointer.
		// The destination operand can be a general purpose register, memory location,
		// or segment register.
		void Ci086CPU::pop( const CGPReg& dst )
		{
			//assert(dst.isRegType(REG_TYPE_GPW) || dst.isRegType(REG_TYPE_GPN));
			_emitInstruction( INST_POP, &dst );
		}

		//------------------------------------------------------------------------------
		void Ci086CPU::pop( const CMem& dst )
		{
			//assert(dst.getSize() == 2 || dst.getSize() == sizeof(Cmp_int_ptr));
			_emitInstruction( INST_POP, &dst );
		}

		//PUSH

		//------------------------------------------------------------------------------
		//Push WORD/DWORD/QWORD Onto the Stack.
		//
		// Note 32-bit architecture pushed DWORD while 64-bit
		// pushes QWORD. 64-bit mode not provides instruction to
		// push 32-bit register/memory.
		void Ci086CPU::push( const CGPReg& src )
		{
			//assert(src.isRegType(REG_TYPE_GPW) || src.isRegType(REG_TYPE_GPN));
			_emitInstruction( INST_PUSH, &src );
		}

		//------------------------------------------------------------------------------
		//Push WORD/DWORD/QWORD Onto the Stack.
		void Ci086CPU::push( const CMem& src )
		{
			//assert(src.getSize() == 2 || src.getSize() == sizeof(Cmp_int_ptr));
			_emitInstruction( INST_PUSH, &src );
		}

		//------------------------------------------------------------------------------
		//Push WORD/DWORD/QWORD Onto the Stack.
		void Ci086CPU::push( const CImm& src )
		{
			_emitInstruction( INST_PUSH, &src );
		}

		//RCL

		//------------------------------------------------------------------------------
		//Rotate Bits Left.
		// Note src register can be only cl.
		void Ci086CPU::rcl( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_RCL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Rotate Bits Left.
		void Ci086CPU::rcl( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_RCL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Rotate Bits Left.
		// Note src register can be only cl.
		void Ci086CPU::rcl( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_RCL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Rotate Bits Left.
		void Ci086CPU::rcl( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_RCL, &dst, &src );
		}

		//RCR

		//------------------------------------------------------------------------------
		//Rotate Bits Right.
		// Note src register can be only cl.
		void Ci086CPU::rcr( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_RCR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Rotate Bits Right.
		void Ci086CPU::rcr( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_RCR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Rotate Bits Right.
		// Note src register can be only cl.
		void Ci086CPU::rcr( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_RCR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Rotate Bits Right.
		void Ci086CPU::rcr( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_RCR, &dst, &src );
		}

		//REPxx

		//------------------------------------------------------------------------------
		//Load ECX/RCX BYTEs from DS:[ESI/RSI] to AL.
		void Ci086CPU::rep_lodsb()
		{
			_emitInstruction( INST_REP_LODSB );
		}

		//------------------------------------------------------------------------------
		//Load ECX/RCX DWORDs from DS:[ESI/RSI] to EAX.
		void Ci086CPU::rep_lodsd()
		{
			_emitInstruction( INST_REP_LODSD );
		}

		//------------------------------------------------------------------------------
		//Move ECX/RCX BYTEs from DS:[ESI/RSI] to ES:[EDI/RDI].
		void Ci086CPU::rep_movsb()
		{
			_emitInstruction( INST_REP_MOVSB );
		}

		//------------------------------------------------------------------------------
		//Move ECX/RCX DWORDs from DS:[ESI/RSI] to ES:[EDI/RDI].
		void Ci086CPU::rep_movsd()
		{
			_emitInstruction( INST_REP_MOVSD );
		}

		//------------------------------------------------------------------------------
		//Fill ECX/RCX BYTEs at ES:[EDI/RDI] with AL.
		void Ci086CPU::rep_stosb()
		{
			_emitInstruction( INST_REP_STOSB );
		}

		//------------------------------------------------------------------------------
		//Fill ECX/RCX DWORDs at ES:[EDI/RDI] with EAX.
		void Ci086CPU::rep_stosd()
		{
			_emitInstruction( INST_REP_STOSD );
		}

		//------------------------------------------------------------------------------
		//Repeated find nonmatching BYTEs in ES:[EDI/RDI] and DS:[ESI/RDI].
		void Ci086CPU::repe_cmpsb()
		{
			_emitInstruction( INST_REPE_CMPSB );
		}

		//------------------------------------------------------------------------------
		//Repeated find nonmatching DWORDs in ES:[EDI/RDI] and DS:[ESI/RDI].
		void Ci086CPU::repe_cmpsd()
		{
			_emitInstruction( INST_REPE_CMPSD );
		}

		//------------------------------------------------------------------------------
		//Find non-AL BYTE starting at ES:[EDI/RDI].
		void Ci086CPU::repe_scasb()
		{
			_emitInstruction( INST_REPE_SCASB );
		}

		//------------------------------------------------------------------------------
		//Find non-EAX DWORD starting at ES:[EDI/RDI].
		void Ci086CPU::repe_scasd()
		{
			_emitInstruction( INST_REPE_SCASD );
		}

		//------------------------------------------------------------------------------
		//Repeated find nonmatching BYTEs in ES:[EDI/RDI] and DS:[ESI/RDI].
		void Ci086CPU::repne_cmpsb()
		{
			_emitInstruction( INST_REPNE_CMPSB );
		}

		//------------------------------------------------------------------------------
		//Repeated find nonmatching DWORDs in ES:[EDI/RDI] and DS:[ESI/RDI].
		void Ci086CPU::repne_cmpsd()
		{
			_emitInstruction( INST_REPNE_CMPSD );
		}

		//------------------------------------------------------------------------------
		//Find AL, starting at ES:[EDI/RDI].
		void Ci086CPU::repne_scasb()
		{
			_emitInstruction( INST_REPNE_SCASB );
		}

		//------------------------------------------------------------------------------
		//Find EAX, starting at ES:[EDI/RDI].
		void Ci086CPU::repne_scasd()
		{
			_emitInstruction( INST_REPNE_SCASD );
		}

		//RET

		//------------------------------------------------------------------------------
		//Return from Procedure.
		void Ci086CPU::ret()
		{
			_emitInstruction( INST_RET );
		}

		//------------------------------------------------------------------------------
		//Return from Procedure.
		void Ci086CPU::ret( const CImm& imm16 )
		{
			_emitInstruction( INST_RET, &imm16 );
		}

		//ROL


		//------------------------------------------------------------------------------
		//Rotate Bits Left.
		// Note src register can be only cl.
		void Ci086CPU::rol( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_ROL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Rotate Bits Left.
		void Ci086CPU::rol( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_ROL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Rotate Bits Left.
		// Note src register can be only cl.
		void Ci086CPU::rol( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_ROL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Rotate Bits Left.
		void Ci086CPU::rol( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_ROL, &dst, &src );
		}

		//ROR

		//------------------------------------------------------------------------------
		//Rotate Bits Right.
		// Note src register can be only cl.
		void Ci086CPU::ror( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_ROR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Rotate Bits Right.
		void Ci086CPU::ror( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_ROR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Rotate Bits Right.
		// Note src register can be only cl.
		void Ci086CPU::ror( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_ROR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Rotate Bits Right.
		void Ci086CPU::ror( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_ROR, &dst, &src );
		}

		//SAHF

#if	( QOR_ARCH_WORDSIZE == 32 )
		//------------------------------------------------------------------------------
		//Store AH into Flags.
		void Ci086CPU::sahf()
		{
			_emitInstruction( INST_SAHF );
		}
#endif // ( QOR_ARCH_WORDSIZE == 32 )

		//SBB

		//------------------------------------------------------------------------------
		//Integer subtraction with borrow.
		void Ci086CPU::sbb( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_SBB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Integer subtraction with borrow.
		void Ci086CPU::sbb( const CGPReg& dst, const CMem& src )
		{
			_emitInstruction( INST_SBB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Integer subtraction with borrow.
		void Ci086CPU::sbb( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_SBB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Integer subtraction with borrow.
		void Ci086CPU::sbb( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_SBB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Integer subtraction with borrow.
		void Ci086CPU::sbb( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_SBB, &dst, &src );
		}

		//SAL

		//------------------------------------------------------------------------------
		//Shift Bits Left.
		// Note src register can be only cl.
		void Ci086CPU::sal( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_SAL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Shift Bits Left.
		void Ci086CPU::sal( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_SAL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Shift Bits Left.
		// Note src register can be only cl.
		void Ci086CPU::sal( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_SAL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Shift Bits Left.
		void Ci086CPU::sal( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_SAL, &dst, &src );
		}

		//SAR

		//------------------------------------------------------------------------------
		//Shift Bits Right.
		// Note src register can be only cl.
		void Ci086CPU::sar( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_SAR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Shift Bits Right.
		void Ci086CPU::sar( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_SAR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Shift Bits Right.
		// Note src register can be only cl.
		void Ci086CPU::sar( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_SAR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Shift Bits Right.
		void Ci086CPU::sar( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_SAR, &dst, &src );
		}

		//SHL

		//------------------------------------------------------------------------------
		//Shift Bits Left.
		// Note src register can be only cl.
		void Ci086CPU::shl( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_SHL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Shift Bits Left.
		void Ci086CPU::shl( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_SHL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Shift Bits Left.
		// Note src register can be only cl.
		void Ci086CPU::shl( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_SHL, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Shift Bits Left.
		void Ci086CPU::shl( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_SHL, &dst, &src );
		}

		//SHR

		//------------------------------------------------------------------------------
		//Shift Bits Right.
		// Note src register can be only cl.
		void Ci086CPU::shr( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_SHR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Shift Bits Right.
		void Ci086CPU::shr( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_SHR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Shift Bits Right.
		// Note src register can be only cl.
		void Ci086CPU::shr( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_SHR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Shift Bits Right.
		void Ci086CPU::shr( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_SHR, &dst, &src );
		}

		//STC

		//------------------------------------------------------------------------------
		//Set Carry Flag to 1.
		void Ci086CPU::stc()
		{
			_emitInstruction( INST_STC );
		}

		//STD

		//------------------------------------------------------------------------------
		//Set Direction Flag to 1.
		void Ci086CPU::std()
		{
			_emitInstruction( INST_STD );
		}

		//SUB

		//------------------------------------------------------------------------------
		//Subtract.
		void Ci086CPU::sub( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_SUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Subtract.
		void Ci086CPU::sub( const CGPReg& dst, const CMem& src )
		{
			_emitInstruction( INST_SUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Subtract.
		void Ci086CPU::sub( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_SUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Subtract.
		void Ci086CPU::sub( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_SUB, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Subtract.
		void Ci086CPU::sub( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_SUB, &dst, &src );
		}

		//TEST

		//------------------------------------------------------------------------------
		//Logical Compare.
		void Ci086CPU::test( const CGPReg& op1, const CGPReg& op2 )
		{
			_emitInstruction( INST_TEST, &op1, &op2 );
		}

		//------------------------------------------------------------------------------
		//Logical Compare.
		void Ci086CPU::test( const CGPReg& op1, const CImm& op2 )
		{
			_emitInstruction( INST_TEST, &op1, &op2 );
		}

		//------------------------------------------------------------------------------
		//Logical Compare.
		void Ci086CPU::test( const CMem& op1, const CGPReg& op2 )
		{
			_emitInstruction( INST_TEST, &op1, &op2 );
		}

		//------------------------------------------------------------------------------
		//Logical Compare.
		void Ci086CPU::test( const CMem& op1, const CImm& op2 )
		{
			_emitInstruction( INST_TEST, &op1, &op2 );
		}

		//XCHG

		//------------------------------------------------------------------------------
		//Exchange Register/Memory with Register.
		void Ci086CPU::xchg( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_XCHG, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Exchange Register/Memory with Register.
		void Ci086CPU::xchg( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_XCHG, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Exchange Register/Memory with Register.
		void Ci086CPU::xchg( const CGPReg& dst, const CMem& src )
		{
			_emitInstruction( INST_XCHG, &src, &dst );
		}

		//XOR

		//------------------------------------------------------------------------------
		//Exchange Register/Memory with Register.
		void Ci086CPU::xor_( const CGPReg& dst, const CGPReg& src )
		{
			_emitInstruction( INST_XOR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Exchange Register/Memory with Register.
		void Ci086CPU::xor_( const CGPReg& dst, const CMem& src )
		{
			_emitInstruction( INST_XOR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Exchange Register/Memory with Register.
		void Ci086CPU::xor_( const CGPReg& dst, const CImm& src )
		{
			_emitInstruction( INST_XOR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Exchange Register/Memory with Register.
		void Ci086CPU::xor_( const CMem& dst, const CGPReg& src )
		{
			_emitInstruction( INST_XOR, &dst, &src );
		}

		//------------------------------------------------------------------------------
		//Exchange Register/Memory with Register.
		void Ci086CPU::xor_( const CMem& dst, const CImm& src )
		{
			_emitInstruction( INST_XOR, &dst, &src );
		}
	}//nsx86
}//nsArch

#endif//( QOR_ARCH == QOR_ARCH_X86_32 || QOR_ARCH == QOR_ARCH_X86_64 )
