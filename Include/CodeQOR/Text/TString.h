//TString.h

// Copyright Querysoft Limited 2013, 2016
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//String class
//A very basic string template with header and footer data

#ifndef CODEQOR_DATASTRUCTS_TSTRING_H_1
#define CODEQOR_DATASTRUCTS_TSTRING_H_1

#include "CompilerQOR.h"

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "SystemQOR.h"
#include "CodeQOR/DataStructures/TCRef.h"
#include "CodeQOR/Text/CodeString.h"
#include "CodeQOR/MemoryManagement/DefaultSource.h"
#include "CodeQOR/DataStructures/TArray.h"
#include <stddef.h>
#include <string.h>
#include <limits.h>
#include <ctype.h>

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{
	template< typename _tChar > unsigned short ExtSysLen( const _tChar* cpString );
    template< typename _tChar, class _tRawAllocator = CDefaultSource  > class CTString;
	template< typename _tChar, class _tRawAllocator > void ExtWriteBuffer( CTString< _tChar, _tRawAllocator >& String, const _tChar* cpString, unsigned short usSrcLen, _tChar* pInternalBuffer );
	template< typename _tChar, class _tRawAllocator > void ExtSetSize( CTString< _tChar, _tRawAllocator >& String, unsigned short usCharCount );
	template< typename _tChar, class _tRawAllocator > void ExtAssignFromAString( CTString< _tChar, _tRawAllocator >& String, const CACodeString& aSrc );	
	template< typename _tChar, class _tRawAllocator > bool ExtIsStringEqual( const CTString< _tChar, _tRawAllocator >& Cmp1, const CTString< _tChar, _tRawAllocator >& Cmp2 );


	class __QOR_INTERFACE( __CODEQOR ) CChar8;
	class __QOR_INTERFACE( __CODEQOR ) CChar16;
	class __QOR_INTERFACE( __CODEQOR ) CChar32;

    typedef __QOR_INTERFACE( __CODEQOR ) CTString< CChar8 > CLocal8BitString;
    typedef __QOR_INTERFACE( __CODEQOR ) CTString< CChar16 > CUCS2String;
    typedef __QOR_INTERFACE( __CODEQOR ) CTString< CChar32 > CUCS4String;
	typedef __QOR_INTERFACE( __CODEQOR ) CTString< char > CASCIIString;
	typedef __QOR_INTERFACE( __CODEQOR ) CTString< wchar_t > CWideString;

	void __QOR_INTERFACE( __CODEQOR ) ExtAssignFromAString( CLocal8BitString& String, const nsCodeQOR::CACodeString& aSrc );
	void __QOR_INTERFACE( __CODEQOR ) ExtAssignFromAString( CUCS2String& String, const nsCodeQOR::CACodeString& aSrc );
	void __QOR_INTERFACE( __CODEQOR ) ExtAssignFromAString( CUCS4String& String, const nsCodeQOR::CACodeString& aSrc );
	void __QOR_INTERFACE( __CODEQOR ) ExtAssignFromAString( CASCIIString& String, const nsCodeQOR::CACodeString& aSrc );
	void __QOR_INTERFACE( __CODEQOR ) ExtAssignFromAString( CWideString& String, const nsCodeQOR::CACodeString& aSrc );

	void __QOR_INTERFACE( __CODEQOR ) ExtAssignFromWString( CLocal8BitString& String, const nsCodeQOR::CWCodeString& aSrc );
	void __QOR_INTERFACE( __CODEQOR ) ExtAssignFromWString( CUCS2String& String, const nsCodeQOR::CWCodeString& aSrc );
	void __QOR_INTERFACE( __CODEQOR ) ExtAssignFromWString( CUCS4String& String, const nsCodeQOR::CWCodeString& aSrc );
	void __QOR_INTERFACE( __CODEQOR ) ExtAssignFromWString( CASCIIString& String, const nsCodeQOR::CWCodeString& aSrc );
	void __QOR_INTERFACE( __CODEQOR ) ExtAssignFromWString( CWideString& String, const nsCodeQOR::CWCodeString& aSrc );

	CLocal8BitString __QOR_INTERFACE( __CODEQOR ) ExtToLocal8Bit( const CLocal8BitString& String );
	CLocal8BitString __QOR_INTERFACE( __CODEQOR ) ExtToLocal8Bit( const CUCS2String& String );
	CLocal8BitString __QOR_INTERFACE( __CODEQOR ) ExtToLocal8Bit( const CUCS4String& String );
	CLocal8BitString __QOR_INTERFACE( __CODEQOR ) ExtToLocal8Bit( const CASCIIString& String );
	CLocal8BitString __QOR_INTERFACE( __CODEQOR ) ExtToLocal8Bit( const CWideString& String );

	Cmp_long_long __QOR_INTERFACE( __CODEQOR ) ExtByteArrayToLongLong( const char* num, int base );
	Cmp_unsigned_long_long __QOR_INTERFACE( __CODEQOR ) ExtByteArrayToUnsignedLongLong( const char* num, int base );

    __QOR_INTERFACE( __CODEQOR ) int CharInt( CChar8 c );
    __QOR_INTERFACE( __CODEQOR ) int CharInt( CChar16 c );
    __QOR_INTERFACE( __CODEQOR ) int CharInt( CChar32 c );
	__QOR_INTERFACE( __CODEQOR ) int CharInt( char c );
	__QOR_INTERFACE( __CODEQOR ) int CharInt( wchar_t c );
	__QOR_INTERFACE( __CODEQOR ) int CharInt( byte c );
	//TODO:
	/*
		formatting, arguments, placement
		sprintf variants
		sscanf variants

		SubString class as reference, position, extent on an existing string, leading to cttl port
	*/

#if __QOR_UNICODE
	typedef CUCS2String CString;
#else
	typedef CLocal8BitString CString;
#endif

    //--------------------------------------------------------------------------------
    struct __QOR_INTERFACE( __CODEQOR ) sHeader
    {
        unsigned short usAlloc;					//Byte length of allocation for string, header, footer and all
        unsigned short usLen;					//Character count in use
		unsigned short usCodePage;				//Assigned code page of contained characters
		unsigned short usHeaderLen;				//Byte length of header
		static unsigned short Size( void );
    };

    //--------------------------------------------------------------------------------
    struct __QOR_INTERFACE( __CODEQOR ) sFooter
    {
        unsigned short usRefCount;
		unsigned short usFooterLen;				//Byte length of footer
		static unsigned short Size( void );
    };

	//--------------------------------------------------------------------------------
	enum eProcessResult
	{
		eProcessResultEnd,
		eProcessResultMore,
		eProcessResultBegin,
	};


	//--------------------------------------------------------------------------------
	template< typename _tChar, class _tRawAllocator >
	class __QOR_INTERFACE( __CODEQOR ) CConstCharProcessorFunctor
	{
	public:

		//--------------------------------------------------------------------------------
		CConstCharProcessorFunctor()
		{
		}

		//--------------------------------------------------------------------------------
		virtual ~CConstCharProcessorFunctor()
		{
		}

		//--------------------------------------------------------------------------------
		eProcessResult operator()( CTString< _tChar, _tRawAllocator >& strResult,  _tChar Char ) const
		{
			return eProcessResultEnd;
		}
	};

	//--------------------------------------------------------------------------------
	template< typename _tChar, class _tRawAllocator >
	class __QOR_INTERFACE( __CODEQOR ) CCharProcessorFunctor
	{
	public:

		//--------------------------------------------------------------------------------
		CCharProcessorFunctor()
		{
		}

		//--------------------------------------------------------------------------------
		virtual ~CCharProcessorFunctor()
		{
		}

		//--------------------------------------------------------------------------------
		eProcessResult operator()( CTString< _tChar, _tRawAllocator >& strResult,  _tChar Char )
		{
			return eProcessResultEnd;
		}
	};

	//--------------------------------------------------------------------------------
	template< typename _tChar, class _tRawAllocator >
	class __QOR_INTERFACE( __CODEQOR ) CStringProcessorFunctor
	{
	public:
		//--------------------------------------------------------------------------------
		CStringProcessorFunctor()
		{
		}

		//--------------------------------------------------------------------------------
		virtual ~CStringProcessorFunctor()
		{
		}

		eProcessResult operator()( CTString< _tChar, _tRawAllocator >& str )
		{
			return eProcessResultEnd;
		}
	};

	//--------------------------------------------------------------------------------
    //A string class with header and footer data structures, reference counted 
    template< typename _tChar, class _tRawAllocator >
    class CTString
    {
        friend class CTCRef< CTString< _tChar, _tRawAllocator > >;

		friend void ExtWriteBuffer< _tChar, _tRawAllocator >( CTString< _tChar, _tRawAllocator >& String, const _tChar* cpString, unsigned short usSrcLen, _tChar* pInternalBuffer );
		friend void ExtSetSize< _tChar, _tRawAllocator > ( CTString< _tChar, _tRawAllocator >& String, unsigned short usCharCount );
		friend void ExtAssignFromAString( CLocal8BitString& String, const nsCodeQOR::CACodeString& aSrc );
		friend void ExtAssignFromAString( CUCS2String& String, const nsCodeQOR::CACodeString& aSrc );
		friend void ExtAssignFromAString( CUCS4String& String, const nsCodeQOR::CACodeString& aSrc );
		friend void ExtAssignFromAString( CASCIIString& String, const nsCodeQOR::CACodeString& aSrc );
		friend void ExtAssignFromAString( CWideString& String, const nsCodeQOR::CACodeString& aSrc );
		friend void ExtAssignFromWString( CUCS2String& String, const nsCodeQOR::CWCodeString& aSrc );
		friend void ExtAssignFromWString( CLocal8BitString& String, const nsCodeQOR::CWCodeString& aSrc );
		friend void ExtAssignFromWString( CUCS4String& String, const nsCodeQOR::CWCodeString& aSrc );
		friend void ExtAssignFromWString( CASCIIString& String, const nsCodeQOR::CWCodeString& aSrc );
		friend void ExtAssignFromWString( CWideString& String, const nsCodeQOR::CWCodeString& aSrc );
		friend bool ExtIsStringEqual< _tChar, _tRawAllocator >( const CTString< _tChar, _tRawAllocator >& Cmp1, const CTString< _tChar, _tRawAllocator >& Cmp2 );

    public:

        typedef _tChar char_type;
		typedef _tRawAllocator allocator_type;
        typedef CTCRef< CTString< _tChar, _tRawAllocator > > ref_type;

        //--------------------------------------------------------------------------------
        CTString()
        {
            m_p = 0;
        }

		//--------------------------------------------------------------------------------
        CTString( const _tChar* cpString, unsigned short usSrcLen = 0 )
        {
			m_p = 0;
            if( usSrcLen == 0 )
            {
                usSrcLen = SysLen( cpString );
            }
            Init( cpString, usSrcLen, usSrcLen | 128 );
        }

        //--------------------------------------------------------------------------------
        CTString( const _tChar* cpString, unsigned short usSrcLen, unsigned short usInitialBufferSize )
        {
			m_p = 0;
            Init( cpString, usSrcLen, usInitialBufferSize );
        }

        //--------------------------------------------------------------------------------
        CTString( nsCodeQOR::CTLRef< _tChar > Src )
        {
            unsigned short usSrcLen = SysLen( Src );
            Init( Src, usSrcLen, usSrcLen | 128 );
        }

		//--------------------------------------------------------------------------------
		CTString( const nsCodeQOR::CACodeString& aSrc )
		{
			ExtAssignFromAString( *this, aSrc );
		}

		//--------------------------------------------------------------------------------
		CTString( const nsCodeQOR::CWCodeString& aSrc )
		{
			ExtAssignFromWString( *this, aSrc );
		}

		//--------------------------------------------------------------------------------
		CTString( _tChar c )
		{
			Init( &c, 1, 16 );
		}

		//--------------------------------------------------------------------------------
		CTString( ref_type Src )
		{
			m_p = 0;
			*this = Src;
		}

        //--------------------------------------------------------------------------------
        CTString( const CTString< _tChar, _tRawAllocator  >& Src )
        {
			m_p = 0;
            *this = Src;
        }

        //--------------------------------------------------------------------------------
        CTString& operator = ( const CTString< _tChar, _tRawAllocator >& Src )
        {
            if( &Src != this )
            {
				Src.AddRef();
                Release();
                m_p = Src.m_p;
            }
            return *this;
        }

		//--------------------------------------------------------------------------------
		CTString& operator = ( ref_type Src )
		{
			if( Src != this )
			{
				Src->AddRef();
				Release();
				m_p = Src->m_p;
			}
			return *this;
		}

		//--------------------------------------------------------------------------------
		CTString& operator = ( _tChar c )
		{
			return operator = ( CTString( c ) );
		}

		//--------------------------------------------------------------------------------
		unsigned short GetCodePage() const
		{
			return ( ( m_p != 0 ) ? ( reinterpret_cast< sHeader* >( m_p ) -1 )->usCodePage : 0 );
		}

		//--------------------------------------------------------------------------------
		bool SetCodePage( unsigned short usCodePage )
		{
			bool bResult = false;
			if( m_p != 0 )
			{
				( reinterpret_cast< sHeader* >( m_p ) -1 )->usCodePage = usCodePage;
				bResult = true;
			}
			return bResult;
		}

        //--------------------------------------------------------------------------------
		//Returns Character count.
        unsigned short Len() const
        {
            unsigned short uiValid = 0;
            if( m_p != 0 )
            {
                uiValid = (( reinterpret_cast< sHeader* >( m_p ) ) - 1 )->usLen;
				while( uiValid > 0 && CharInt( m_p[ uiValid - 1 ] ) == 0 )
				{
					uiValid--;
				}
            }
            return uiValid;
        }

        //--------------------------------------------------------------------------------
		//Get byte size of whole string, header, footer and all from the header
        unsigned short Allocation() const
        {
            unsigned short uiAlloc = 0;
            if( m_p != 0 )
            {
                uiAlloc = (( reinterpret_cast< sHeader* >( m_p ) ) - 1 )->usAlloc;
            }
            return uiAlloc;
        }

		//--------------------------------------------------------------------------------
		//Returns Character capacity
		unsigned short Capacity() const
		{
			unsigned short usCapacity = 0;
			if( m_p != 0 )
			{
				usCapacity = Allocation() - ( ActualHeaderByteSize()  + ActualFooterByteSize() );
			}
			return usCapacity / sizeof( _tChar );
		}

		//--------------------------------------------------------------------------------
		bool IsEmpty( void ) const
		{
			return Len() == 0;
		}

        //--------------------------------------------------------------------------------
        bool operator == ( const CTString< _tChar, _tRawAllocator >& Src ) const
        {
			return ExtIsStringEqual( *this, Src );
        }

		//--------------------------------------------------------------------------------
        bool operator != ( const CTString< _tChar, _tRawAllocator >& Src ) const
        {
			return !ExtIsStringEqual( *this, Src );
        }

        //--------------------------------------------------------------------------------
        bool operator < ( const CTString< _tChar, _tRawAllocator >& Cmp ) const
        {
            bool bResult = false;
            unsigned int uiCounter = 0;
            unsigned int uiValid = Len();
            if( Cmp.Len() < Len() )
            {
                uiValid = Cmp.Len();
            }
            while( bResult == false && uiCounter < uiValid && m_p[ uiCounter ] <= Cmp.m_p[ uiCounter ] )
            {
                if( m_p[ uiCounter ] < Cmp.m_p[ uiCounter ] )
                {
					bResult = true;
                }
                uiCounter++;
            }

            if( bResult == false && uiCounter >= uiValid && Len() < Cmp.Len() )
            {
				bResult = true;
            }
            return bResult;
        }

        //--------------------------------------------------------------------------------
        virtual ~CTString()
        {
            Release();
        }

        //--------------------------------------------------------------------------------
        ref_type operator()( void )
        {
            return ref_type( this );
        }

        //--------------------------------------------------------------------------------
        operator const _tChar* ( void ) const
        {
            return m_p;
        }

		//--------------------------------------------------------------------------------
		_tChar At( unsigned short nPos ) const
		{
			_tChar Result( (byte)(0) );
			if( nPos < Len() )
			{
				Result = m_p[ nPos ];
			}
			return Result;
		}

		//--------------------------------------------------------------------------------
		bool Set( unsigned short nPos, _tChar ch )
		{
			bool bResult = false;
			if( nPos < Len() )
			{
				if( InternalRefCount() > 1 )
				{	//Copy On Write
					SetSize( InternalLen() | 0x10 );
				}
				m_p[ nPos ] = ch;
				bResult = true;
			}
			return bResult;
		}

		//--------------------------------------------------------------------------------
		CTString& Insert(  unsigned short usPos, CTString< _tChar, _tRawAllocator >& Src )
		{
			if( !m_p )
			{
				return operator = ( Src );
			}

			if( usPos < Len() )
			{
				Src.AddRef();
				unsigned short usSrcLen = Src.Len();
				unsigned short usOldSize = InternalLen();
				unsigned short usNewSize = usOldSize + usSrcLen;		//New characters required after insertion
				
				if( InternalRefCount() > 1 || ( usNewSize > Capacity() ) )	//COW 
				{
					SetSize( usNewSize | 16 );
				}

				unsigned short usCounter = usOldSize;
				while( usCounter >= usPos )
				{
					m_p[ usCounter + usSrcLen ] = m_p[ usCounter ];		//Move the tail out to its new position
					usCounter--;
				}

				usCounter = 0;
				while( usCounter < usSrcLen )
				{
					m_p[ usPos + usCounter ] = Src.m_p[ usCounter ];		//Insert chars from the source string
					usCounter++;
				}
				InternalLen() += usSrcLen;
				
				Src.Release();
			}
			else
			{
				return Append( Src );
			}
			return *this;
		}

		//--------------------------------------------------------------------------------
		CTString& Remove( unsigned short usPos, unsigned short usCount )
		{
			if( m_p && ( usPos < Len() ) )
			{
				if( InternalRefCount() > 1 )
				{	//Copy On Write
					SetSize( InternalLen() | 0x10 );
				}

				if( ( usPos + usCount ) < Len() )
				{
					for( unsigned short usChar = usPos; usChar < usPos + usCount; usChar++ )
					{
						m_p[ usChar ] = m_p[ usChar + usCount ];
					}
					SetSize( Len() - usCount );
				}
				else
				{
					SetSize( usPos );
				}
			}
			return *this;
		}

		//--------------------------------------------------------------------------------
		CTString& Clear( void )
		{
			if( m_p )
			{
				if( InternalRefCount() > 1 )
				{
					SetSize( 16 );
					InternalLen() = 0;
				}
				else
				{
					InternalLen() = 0;
				}
			}
			return *this;
		}

        //--------------------------------------------------------------------------------
		CTString& Append( _tChar AChar )
		{
			return Append( const_cast< const _tChar* >( &AChar ), 1 );
		}

		//--------------------------------------------------------------------------------
        CTString& Append( const _tChar* cpString, unsigned short usSrcLen )
        {
            _tChar* pString = const_cast< _tChar* >( cpString );                    

			if( !m_p )
			{
				SetSize( usSrcLen | 0x0010 );//Round the allocation size up to the nearest 16 characters
			}
			else 
			{
				unsigned short usOldSize = Capacity();					//Available characters without reallocation
				unsigned short usNewSize = InternalLen()  + usSrcLen;		//New characters required after append
				
				if( InternalRefCount() > 1 || ( usNewSize > usOldSize ) )	//COW 
				{
					SetSize( ( usNewSize > usOldSize ) ? usNewSize : usOldSize );
				}
			}
            unsigned short usCounter = 0;
            while( usCounter < usSrcLen && Len() < Capacity() )
            {
                m_p[ InternalLen()++ ] = pString[ usCounter++ ];
            }
            return *this;
        }

		//--------------------------------------------------------------------------------
		CTString& Append( const CTString& Str )
		{
			return Append( Str, Str.Len() );
		}

		//--------------------------------------------------------------------------------
		CTString Left( unsigned short usLen ) const
		{
			if( usLen >= InternalLen() )
			{
				return *this;
			}
			else
			{
				return CTString( m_p, usLen );
			}
		}

		//--------------------------------------------------------------------------------
		CTString Right( unsigned short usLen ) const
		{
			if( usLen >= InternalLen() )
			{
				return *this;
			}
			else
			{
				return CTString( m_p + ( InternalLen() - usLen ), usLen );
			}
		}

		//--------------------------------------------------------------------------------
		CTString Mid( unsigned short usPos, short usLen = -1 ) const
		{
			if( usPos > InternalLen() )
			{
				return CTString();
			}

			if( usLen < 0 )
			{
				usLen = InternalLen() - usPos;
			}

			if( usLen + usPos >  InternalLen() )
			{
				usLen = InternalLen() - usPos;
			}

			if( usPos == 0 && usLen == InternalLen() )
			{
				return *this;
			}

			return CTString( m_p + usPos, usLen );
		}

		//--------------------------------------------------------------------------------
		CTString TrimLeft() const
		{
			unsigned short usPos = 0;
			if( IsEmpty() )
			{
				return *this;
			}

			while( isblank( CharInt( m_p[ usPos ] ) ) )
			{
				usPos++;
			}

			return CTString( m_p + usPos, Len() - usPos );
		}

		//--------------------------------------------------------------------------------
		CTString TrimRight() const
		{			
			if( IsEmpty() )
			{
				return *this;
			}
			unsigned short usLen = Len();

			while( isblank( CharInt( m_p[ usLen ] ) ) )
			{
				usLen--;
			}

			return CTString( m_p, usLen );
		}

		//--------------------------------------------------------------------------------
		//Process the string through a functor one character at a time
		CTString ProcessByChar( CConstCharProcessorFunctor< _tChar, _tRawAllocator >& ProcessFunctor, unsigned short usPos = 0 ) const
		{
			CTString strResult;
			while( usPos < InternalLen() && ProcessFunctor( strResult, m_p[ usPos++ ] ) == eProcessResultMore )
			{
			}
			return strResult;
		}

		//--------------------------------------------------------------------------------
		//Process the string through a functor one character at a time
		CTString ProcessByChar( CCharProcessorFunctor< _tChar, _tRawAllocator >& ProcessFunctor, unsigned short usPos = 0 )
		{
			CTString strResult;
			while( usPos < InternalLen() && ProcessFunctor( strResult, m_p[ usPos++ ] ) == eProcessResultMore )
			{
			}
			return strResult;
		}

		//--------------------------------------------------------------------------------
		//Process the string through a functor one character at a time in reverse
		CTString ReverseProcessByChar( CCharProcessorFunctor< _tChar, _tRawAllocator >& ProcessFunctor, unsigned short usPos = 0 )
		{
			CTString strResult;
			if( usPos == 0 )
			{
				usPos = InternalLen();
			}
			while( usPos >= 0 && ProcessFunctor( strResult, m_p[ usPos-- ] ) == eProcessResultMore )
			{
			}
			return strResult;
		}

		//--------------------------------------------------------------------------------
		//Process the string through a functor to find the beginning and end of substrings and then process each substring through a second functor
		//This can be used as the basis for tokenizing a string, the beginning of language parsing.
		void ProcessForSubString( CCharProcessorFunctor< _tChar, _tRawAllocator >& CharFunctor, CStringProcessorFunctor< _tChar, _tRawAllocator >& StringFunctor, unsigned short usPos = 0 )
		{
			CTString strResult;
			do
			{				
				strResult.Clear();
				while( usPos < InternalLen() && CharFunctor( strResult, m_p[ usPos++ ] ) != eProcessResultBegin )
				{
				}
				while( usPos < InternalLen() && CharFunctor( strResult, m_p[ usPos++ ] ) == eProcessResultMore )
				{
				}
			}while( StringFunctor( strResult ) != eProcessResultEnd );
		}

        //--------------------------------------------------------------------------------
		//If you use the string memory as a raw buffer the in use length will not be tracked.
		//Call ValidateBuffer( usCharCount ) to set the in use length. 
		//Use ValidateBuffer() to set the in use length up to a NULL terminator. Make sure that there is one!
        bool ValidateBuffer( unsigned short usSize = -1 )
        {
            bool bResult = false;

			if( usSize == (unsigned short)(-1) )
			{
				usSize = SysLen( (const _tChar*)m_p );
			}

            if( usSize <= Capacity() )
            {				
                InternalLen() = usSize;
                bResult = true;
            }
			ReleaseBuffer();
            return bResult;
        }

		//--------------------------------------------------------------------------------
		//Reserve memory for the string in advance if you plan to make many small appends
		void Reserve( unsigned short usSize )
		{
			SetSize( usSize );
		}

        //--------------------------------------------------------------------------------
		//Returns a raw pointer to space for usSize characters. Existing contents up to that count are preserved.
		//Caller must call ReleaseBuffer or ValidateBuffer!
        _tChar* GetBufferSetLength( unsigned short usSize )
        {            
            SetSize( usSize );
            return GetBuffer();
        }

        //--------------------------------------------------------------------------------
		//Returns a raw pointer to the string data. Caller must call ReleaseBuffer or ValidateBuffer! 
        _tChar* GetBuffer()
        {
            AddRef();
            return m_p;
        }

		//--------------------------------------------------------------------------------
		//Returns a raw pointer to the string data or NULL if the string is empty. Caller must call ReleaseBuffer or ValidateBuffer!
		_tChar* GetNullableBuffer()
		{
			AddRef();
			if( IsEmpty() )
			{				
				return 0;
			}
			else
			{
				return m_p;
			}
		}

		//--------------------------------------------------------------------------------
		//Returns a copy of the string as a reference to a _tChar array.
		CTLRef< _tChar > DetachBuffer( void )
		{
			_tRawAllocator allocator;
			AddRef();
			_tChar* pDetachedBuffer = reinterpret_cast< _tChar* >( allocator.Source( InternalLen() ) );
			memcpy( pDetachedBuffer, m_p, InternalLen() );
			Release();
			CTLRef< _tChar > Result( pDetachedBuffer, true );
			return Result;
		}

        //--------------------------------------------------------------------------------
		//Decrement the internal reference count.
		//If is reaches 0 deallocate the string data
        void ReleaseBuffer( void ) 
        {
            Release();
        }

		CTString& Replace( _tChar Target, const CTString& Replacement, unsigned short usPos = 0 );
		CTString& Replace( unsigned short usOffset, unsigned short usLen, const CTString< _tChar, _tRawAllocator >& Replacement );
		int Find( _tChar Find, unsigned short usPos = 0 ) const;
		int Find( CTString& strFind, unsigned short usPos = 0 ) const;

		//--------------------------------------------------------------------------------
		CLocal8BitString ToLocal8Bit( void ) const
		{
			return ExtToLocal8Bit( *this );
		}

		//--------------------------------------------------------------------------------
		unsigned int ToUInt( int iBase ) const
		{
			return ToUIntegralHelper< unsigned int >( ToLocal8Bit(), iBase );
		}

    protected:

        _tChar* m_p;
        
		//--------------------------------------------------------------------------------
		//Return the size of header to use if this base class is used directly
		//Override this to use a larger custom header
		virtual unsigned short ClassHeaderByteSize( void ) const
		{
			return sHeader::Size();
		}

		//--------------------------------------------------------------------------------
		//Return the size of footer to use if this base class is used directly
		//Override this to use a larger custom footer
		virtual unsigned short ClassFooterByteSize( void ) const
		{
			return sFooter::Size();
		}

        //--------------------------------------------------------------------------------
		//Return the Byte size of header in use by this actual instance which may be of a derived class with a cutom header
        virtual unsigned short ActualHeaderByteSize( void ) const
        {
			return (( reinterpret_cast< sHeader* >( m_p ) ) - 1 )->usHeaderLen;
        }

        //--------------------------------------------------------------------------------
		//Return the Byte size of footer in use by this actual instance which may be of a derived class with a cutom footer
        virtual unsigned short ActualFooterByteSize( void ) const
        {
			unsigned short usSize = 0;
			sFooter* pFooter = GetFooter();
			if( pFooter )
			{
				usSize = pFooter->usFooterLen;
			}
			
			return usSize;
        }

		//--------------------------------------------------------------------------------
		//Get a pointer to the base Footer
		sFooter* GetFooter( void ) const
		{
			sFooter* pFooter = 0;
			if( m_p )
			{
				unsigned short usSize = Allocation();
				byte* pData = reinterpret_cast< byte* >( m_p );
				pFooter = ( reinterpret_cast< sFooter* >( pData - ActualHeaderByteSize() + usSize ) ) - 1;
			}
			return pFooter;
		}

		//--------------------------------------------------------------------------------
		//Get the length of NULL terminated constant strings only to enable assignment
		unsigned short SysLen( const _tChar* cpString )
		{
			return ExtSysLen( cpString );
		}

        //--------------------------------------------------------------------------------
        void Init( const _tChar* cpString, unsigned short usSrcLen, unsigned short usInitialBufferSize )
        {
            m_p = 0;//Don't copy old data if there is any on a re-init
            SetSize( ( usSrcLen >= usInitialBufferSize ) ? usSrcLen + 1 : usInitialBufferSize );
            WriteBuffer( cpString, usSrcLen );
        }

        //--------------------------------------------------------------------------------
		//Get the Character Count in use from the header
        unsigned short& InternalLen() const
        {
			return ( ( reinterpret_cast< sHeader* >( m_p ) ) - 1 )->usLen;
        }

        //--------------------------------------------------------------------------------
		//Get the reference count from the footer
        unsigned short InternalRefCount() const
        {
			sFooter* pFooter = GetFooter();
			if( pFooter )
			{
				return pFooter->usRefCount;
			}
			else
			{
				return 0;
			}
        }

		//--------------------------------------------------------------------------------
		//Write the string with COW semantics as a resizable buffer. Source is not required to be NULL terminated
        void WriteBuffer( const _tChar* cpString, unsigned short usSrcLen )
        {
			unsigned short usRefCount = InternalRefCount();
            if( usSrcLen >= Capacity() || usRefCount > 1 )
            {
				SetSize( usSrcLen );
            }
			ExtWriteBuffer( *this, cpString, usSrcLen, m_p );
        }

        //--------------------------------------------------------------------------------
		//Increment the reference count to lock or share string data
        unsigned short AddRef( void ) const
        {
            if( m_p == 0 )
            {
				return 0;
            }

			return GetFooter()->usRefCount++;
        }

        //--------------------------------------------------------------------------------
		//Decrement the reference count and carry out any consequences
        unsigned short Release( void )
        {
            if( m_p == 0 )
            {
				return 0;
            }

            unsigned short usRefCount = --( GetFooter()->usRefCount );
            if( usRefCount == 0 )
            {
				Free();
            }
            return usRefCount;
        }

        //--------------------------------------------------------------------------------
		//Free the entire string memory, header, text and footer
        void Free()
        {
            if( m_p != 0 )
            {
				_tRawAllocator allocator;
				byte* pData = reinterpret_cast< byte* >( m_p );
				pData -= ActualHeaderByteSize();
				m_p = 0;
				allocator.Free( pData, 0 );                
            }
        }

        //--------------------------------------------------------------------------------
		//Overrride this to write additional Header data 
        virtual void HeaderOnResize( byte* /*pOld*/, byte* /*pNew*/ )
        {
        }

        //--------------------------------------------------------------------------------
		//Overrride this to write additional Footer data
        virtual void FooterOnResize( byte* /*pOld*/, byte* /*pNew*/ )
        {
        }

        //--------------------------------------------------------------------------------
		//Sets or resets the allocation based on the required character count. Also used to perform Copy On Write
		void SetSize( unsigned short usCharCount )
		{                               
			ExtSetSize( *this, usCharCount );
		}

		//--------------------------------------------------------------------------------
		template< typename T > T ToUIntegralHelper( const CLocal8BitString& strData, int base ) const
		{
			Cmp_unsigned__int64 val = ExtByteArrayToUnsignedLongLong( reinterpret_cast< const char* >( ( const_cast< CLocal8BitString& >( strData ) ).GetBuffer() ), base );
			const_cast< CLocal8BitString& >( strData ).ReleaseBuffer();
			if( T( val ) != val ) 
			{
				val = 0;
			}
			return T(val);
		}

		//--------------------------------------------------------------------------------
		template< typename T > T ToSIntegralHelper( const CLocal8BitString& strData, int base ) const
		{
			Cmp_unsigned__int64 val = ExtByteArrayToLongLong( reinterpret_cast< const char* >( ( const_cast< CLocal8BitString& >( strData ) ).GetBuffer() ), base );
			const_cast< CLocal8BitString& >( strData ).ReleaseBuffer();
			if( T( val ) != val ) 
			{
				val = 0;
			}
			return T(val);
		}


    };

	//--------------------------------------------------------------------------------
	template< typename _tChar, class _tRawAllocator >
	class __QOR_INTERFACE( __CODEQOR ) CCharFind : public CConstCharProcessorFunctor< _tChar, _tRawAllocator >
	{
	public:

		typedef CTString< _tChar, _tRawAllocator > StringType;

		//--------------------------------------------------------------------------------
		CCharFind( _tChar Find ) : CConstCharProcessorFunctor< _tChar, _tRawAllocator >()
		,	m_Find( Find )
		,	m_Result( -1 )
		{
		}

		//--------------------------------------------------------------------------------
		eProcessResult operator()( StringType& strResult, _tChar Char ) const
		{
			m_Result++;
			if( Char == m_Find )
			{
				eProcessResultEnd;
			}
			return eProcessResultMore;
		}

		//--------------------------------------------------------------------------------
		int Pos( void )
		{
			return m_Result;
		}

	protected:

		//--------------------------------------------------------------------------------
		CCharFind()
		{
		}

		_tChar m_Find;
		mutable int m_Result;
	};

	//--------------------------------------------------------------------------------
	template< typename _tChar, class _tRawAllocator >
	class __QOR_INTERFACE( __CODEQOR ) CStringFind : public CConstCharProcessorFunctor< _tChar, _tRawAllocator >
	{
	public:

		typedef CTString< _tChar, _tRawAllocator > StringType;

		//--------------------------------------------------------------------------------
		CStringFind( StringType& strFind ) : CConstCharProcessorFunctor< _tChar, _tRawAllocator >()
		{
		}

		//--------------------------------------------------------------------------------
		eProcessResult operator()( StringType& strResult, _tChar Char ) const
		{
			m_Result++;
			if( strResult == m_strFind )
			{
				eProcessResultEnd;
			}
			return eProcessResultMore;
		}

		//--------------------------------------------------------------------------------
		int Pos( void ) const
		{
			return m_Result;
		}

	protected:

		//--------------------------------------------------------------------------------
		CStringFind()
		{
		}

		StringType m_strFind;
		mutable int m_Result;
	};

	//--------------------------------------------------------------------------------
	template< typename _tChar, class _tRawAllocator >
	class __QOR_INTERFACE( __CODEQOR ) CCharReplaceProcessorFunctor : public CCharProcessorFunctor< _tChar, _tRawAllocator >
	{
	public:

		typedef CTString< _tChar, _tRawAllocator > StringType;

		//--------------------------------------------------------------------------------
		CCharReplaceProcessorFunctor( _tChar Target, const StringType& Replacement, unsigned short usOffset = 0 ) : CCharProcessorFunctor< _tChar, _tRawAllocator >()
		,	m_Target( Target )
		,	m_usPos( usOffset )
		,	m_Replacement( Replacement )
		{
		}

		//--------------------------------------------------------------------------------
		eProcessResult operator()( StringType& strResult,  _tChar Char )
		{
			if( Char == m_Target )
			{
				StringType strLeft = strResult.Left( m_usPos );
				strLeft.Append( m_Replacement );
				strLeft.Append( strResult.Mid( m_usPos + 1 ) );
				strResult = strLeft;
			}
			m_usPos++;
			return eProcessResultMore;
		}

	protected:

		//--------------------------------------------------------------------------------
		CCharReplaceProcessorFunctor() : CCharProcessorFunctor()
		{
		}

		_tChar m_Target;
		unsigned short m_usPos;
		StringType m_Replacement;
	};

	//--------------------------------------------------------------------------------
	template< typename _tChar, class _tRawAllocator >
    CTString< _tChar, _tRawAllocator >& CTString< _tChar, _tRawAllocator >::Replace( _tChar Target, const CTString< _tChar, _tRawAllocator >& Replacement, unsigned short usPos )
	{
		CCharReplaceProcessorFunctor< _tChar, _tRawAllocator > CharReplacer( Target, Replacement );
		ProcessByChar( CharReplacer, usPos );
		return *this;
	}

	//--------------------------------------------------------------------------------
	template< typename _tChar, class _tRawAllocator >
	CTString< _tChar, _tRawAllocator >& CTString< _tChar, _tRawAllocator >::Replace( unsigned short usOffset, unsigned short usLen, const CTString< _tChar, _tRawAllocator >& Replacement )
	{
		CTString< _tChar, _tRawAllocator > strLeft = Left( usOffset );
		strLeft.Append( Replacement );
		CTString< _tChar, _tRawAllocator > strRight = Mid( usOffset + usLen );
		strLeft.Append( strRight );
		*this = strLeft;
		return *this;
	}

	//--------------------------------------------------------------------------------
	template< typename _tChar, class _tRawAllocator >
	int CTString< _tChar, _tRawAllocator >::Find( _tChar Find, unsigned short usPos ) const
	{
		CCharFind< _tChar, _tRawAllocator > CharFinder( Find );
		ProcessByChar( CharFinder, usPos );
		return CharFinder.Pos();
	}

	//--------------------------------------------------------------------------------
	template< typename _tChar, class _tRawAllocator >
	int CTString< _tChar, _tRawAllocator >::Find( CTString< _tChar, _tRawAllocator >& strFind, unsigned short usPos ) const
	{
		CStringFind< _tChar, _tRawAllocator > StringFinder( strFind );
		ProcessByChar( StringFinder, usPos );
		return StringFinder.Pos();
	}

}//nsCodeQOR

#endif//CODEQOR_DATASTRUCTS_TSTRING_H_1
