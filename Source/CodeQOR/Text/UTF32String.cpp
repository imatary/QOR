//UTF32String.cpp

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "CompilerQOR.h"
#include "CodeQOR/Text/UTF8String.h"
#include "CodeQOR/Text/UTF16String.h"
#include "CodeQOR/Text/UTF32String.h"

//------------------------------------------------------------------------------
namespace nsCodeQOR
{
	//--------------------------------------------------------------------------------
	CChar32* CUTF32String::begin( void )
	{
		CChar32* it( m_String.GetBuffer() );
		m_String.ReleaseBuffer();
		return it;
	}

	//--------------------------------------------------------------------------------
	CChar32* CUTF32String::end( void )
	{
		CChar32* it( m_String.GetBuffer() + m_String.Len() );
		m_String.ReleaseBuffer();
		return it;
	}

	//--------------------------------------------------------------------------------
	CChar32* CUTF32String::CharAt( unsigned short usPos )
	{
		CChar32* it( m_String.GetBuffer() + usPos );
		m_String.ReleaseBuffer();
		return it;
	}

    //--------------------------------------------------------------------------------
    CUTF32String::CUTF32String() : m_String()
    {
		m_String.SetCodePage( CCodePage::eUTF32 );
    }

	//--------------------------------------------------------------------------------
    CUTF32String::CUTF32String( const CChar32* cpString, unsigned short usSrcLen ) : m_String( cpString, usSrcLen )
    {
		m_String.SetCodePage( CCodePage::eUTF32 );
    }

    //--------------------------------------------------------------------------------
    CUTF32String::CUTF32String( const CChar32* cpString, unsigned short usSrcLen, unsigned short usInitialBufferSize ) : m_String( cpString, usSrcLen, usInitialBufferSize )
    {
		m_String.SetCodePage( CCodePage::eUTF32 );
    }

	//--------------------------------------------------------------------------------
	CUTF32String::CUTF32String( const CUTF32String& Src ) : m_String( Src.m_String )
	{
	}

	//--------------------------------------------------------------------------------
	CUTF32String::CUTF32String( const CUTF16String& Src )
	{

	}

	//--------------------------------------------------------------------------------
	CUTF32String::CUTF32String( const CUTF8String& Src )
	{
	}

    //--------------------------------------------------------------------------------
    CUTF32String::CUTF32String( nsCodeQOR::CTLRef< CChar32 > Src ) : m_String( Src )
    {
		m_String.SetCodePage( CCodePage::eUTF32 );
    }

	//--------------------------------------------------------------------------------
	CUTF32String::CUTF32String( CChar32 c ) : m_String( c )
	{
		m_String.SetCodePage( CCodePage::eUTF32 );
	}

	//--------------------------------------------------------------------------------
	CUTF32String::CUTF32String( CTString< CChar32, CDefaultSource >::ref_type Src ) : m_String( Src )
	{
	}

    //--------------------------------------------------------------------------------
    CUTF32String::CUTF32String( const CTString< CChar32, CDefaultSource >& Src ) : m_String( Src )
    {
    }

	//--------------------------------------------------------------------------------
	CUTF32String& CUTF32String::operator = ( const CUTF32String& Src )
	{
		if( &Src != this )
		{
			m_String = Src.m_String;
		}
		return *this;
	}

    //--------------------------------------------------------------------------------
    CUTF32String& CUTF32String::operator = ( const CTString< CChar32, CDefaultSource >& Src )
    {
		m_String = Src;
        return *this;
    }

	//--------------------------------------------------------------------------------
	CUTF32String& CUTF32String::operator = ( CTString< CChar32, CDefaultSource >::ref_type Src )
	{
		m_String = Src;
		return *this;
	}

	//--------------------------------------------------------------------------------
	CUTF32String& CUTF32String::operator = ( CChar32 c )
	{
		operator = ( CTString< CChar32, CDefaultSource >( c ) );
		return *this;
	}
		
	//--------------------------------------------------------------------------------
	unsigned short CUTF32String::GetCodePage() const
	{
		return m_String.GetCodePage();
	}

    //--------------------------------------------------------------------------------
	//Returns UTF-32 character count
    unsigned short CUTF32String::Length() const
    {
		return m_String.Len();
    }

	//--------------------------------------------------------------------------------
	bool CUTF32String::IsEmpty( void ) const
	{
		return m_String.IsEmpty();
	}

    //--------------------------------------------------------------------------------
    bool CUTF32String::operator == ( const CTString< CChar32, CDefaultSource >& Src ) const
    {
		return m_String == Src;
    }

    //--------------------------------------------------------------------------------
    bool CUTF32String::operator < ( const CTString< CChar32, CDefaultSource >& Cmp ) const
    {
		return m_String < Cmp;
    }

    //--------------------------------------------------------------------------------
    CUTF32String::~CUTF32String()
    {
    }

	//--------------------------------------------------------------------------------
	CChar32* CUTF32String::At( unsigned short usPos )
	{
		CChar32* it = begin() + usPos;
		return it;
	}

	//--------------------------------------------------------------------------------
	bool CUTF32String::Set( unsigned short usPos, CChar32 ch )
	{
		return m_String.Set( usPos, ch );
	}

	//--------------------------------------------------------------------------------
	CUTF32String& CUTF32String::Insert(  unsigned short usPos, CUTF32String& Src )
	{
		m_String.Insert( usPos, Src.m_String );
		return *this;
	}

	//--------------------------------------------------------------------------------
	CUTF32String& CUTF32String::Remove( unsigned short usPos, unsigned short usCount )
	{
		m_String.Remove( usPos, usCount );
		return *this;
	}

	//--------------------------------------------------------------------------------
	CUTF32String& CUTF32String::Clear( void )
	{
		m_String.Clear();
		return *this;
	}

    //--------------------------------------------------------------------------------
	CUTF32String& CUTF32String::Append( CChar32 ch )
	{
		return Append( const_cast< const CChar32* >( &ch ), 1 );
	}

	//--------------------------------------------------------------------------------
    CUTF32String& CUTF32String::Append( const CChar32* cpString, unsigned short usSrcLen )
    {
		m_String.Append( cpString, usSrcLen );
        return *this;
    }

	//--------------------------------------------------------------------------------
	CUTF32String& CUTF32String::Append( const CUTF32String& Str )
	{
		return Append( Str.m_String, Str.m_String.Len() );
	}

	//--------------------------------------------------------------------------------
	CUTF32String CUTF32String::Left( unsigned short usLen )
	{
		return CUTF32String( m_String.Left( usLen ) );
	}

	//--------------------------------------------------------------------------------
	CUTF32String CUTF32String::Right( unsigned short usLen )
	{
		return CUTF32String( m_String.Right( usLen ) );
	}

	//--------------------------------------------------------------------------------
	CUTF32String CUTF32String::Mid( unsigned short usPos, short usLen )
	{
		return CUTF32String( m_String.Mid( usPos, usLen ) );
	}

	//--------------------------------------------------------------------------------
	CUTF32String CUTF32String::TrimLeft()
	{
		return CUTF32String( m_String.TrimLeft() );
	}

	//--------------------------------------------------------------------------------
	CUTF32String CUTF32String::TrimRight()
	{		
		return CUTF32String( m_String.TrimRight() );
	}


	//--------------------------------------------------------------------------------
	//Process the string through a functor one character at a time
	CUTF32String CUTF32String::ProcessByChar( CCharProcessorFunctor& ProcessFunctor, unsigned short usPos )
	{
		CUTF32String strResult;
		CChar32* Pos = CharAt( usPos );
		while( Pos != end() && ProcessFunctor( strResult, *Pos ) == eProcessResultMore )
		{
			++Pos;
		}
		return strResult;
	}

	//--------------------------------------------------------------------------------
	//Process the string through a functor one character at a time in reverse
	CUTF32String CUTF32String::ReverseProcessByChar( CCharProcessorFunctor& ProcessFunctor, unsigned short usPos )
	{
		CUTF32String strResult;
		CChar32* Pos = CharAt( usPos );
		while( Pos >= begin() && ProcessFunctor( strResult, *Pos ) == eProcessResultMore )
		{
			--Pos;
		}
		return strResult;
	}

	//--------------------------------------------------------------------------------
	//Process the string through a functor to find the beginning and end of substrings and then process each substring through a second functor
	//This can be used as the basis for tokenizing a string, the beginning of language parsing.
	void CUTF32String::ProcessForSubString( CCharProcessorFunctor& CharFunctor, CStringProcessorFunctor& StringFunctor, unsigned short usPos )
	{
		CUTF32String strResult;
		CChar32* Pos = CharAt( usPos );
		do
		{				
			strResult.Clear();
			while( Pos != end() && CharFunctor( strResult, *Pos ) != eProcessResultBegin )
			{
				++Pos;
			}
			
			while( Pos != end() && CharFunctor( strResult, *Pos ) == eProcessResultMore )
			{
			}
		}while( StringFunctor( strResult ) != eProcessResultEnd );
	}

	//--------------------------------------------------------------------------------
	//Reserve memory for the string in advance if you plan to make many small appends
	void CUTF32String::Reserve( unsigned short usCharCount )
	{
		m_String.Reserve( usCharCount );
	}

	//--------------------------------------------------------------------------------
	unsigned short CUTF32String::BufferByteCount( void )
	{
		return m_String.Len();
	}

	//--------------------------------------------------------------------------------
	CUTF16String CUTF32String::ToUTF16String( void )
	{
		return CUTF16String( *this );
	}

	//--------------------------------------------------------------------------------
	CUTF8String CUTF32String::ToUTF8String( void )
	{
		return CUTF8String( *this );
	}

}//nsCodeQOR

