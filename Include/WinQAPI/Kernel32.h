//Kernel32.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef WINQAPI_MODULES_KERNEL_H_2
#define WINQAPI_MODULES_KERNEL_H_2

#include "WinQAPI/WinQAPI.h"
#include "SystemQOR.h"
#include <string.h>

#ifdef	__GNUC__
#ifndef	__MINGW32__
#define	__MINGW32__
#endif//__MINGW32__
#endif//__GNUC__

#ifdef 	__MINGW32__
typedef void* PVOID;
typedef unsigned int size_t;
typedef unsigned int new_size_t;
#	if( __QOR_UNICODE )
#		define UNICODE
#		define _UNICODE
#	endif
#endif//__MINGW32__


#define WIN32_NO_STATUS 1
//#undef _ADDRESSOF
#undef _APALIGN
#include <windows.h>
#undef WIN32_NO_STATUS

#ifndef __MINGW32__
__QCMP_WARNING_PUSH
__QCMP_WARNING_DISABLE( __QCMP_WARN_MACRO_REDEFINITION, "NTSTATUS macros defined awkwardly in Windows headers" )
#include <ntstatus.h>
__QCMP_WARNING_POP
#include <tlhelp32.h>

#include <Winternl.h>

typedef NTSTATUS *PNTSTATUS;

#include <winbase.inl>
#else
#include "../SystemQOR/MSWindows/WinQAPI/include/MinGWin32Ext.h"
#endif//__MINGW32__

#if( _MSC_VER >= 1700 )
//#include <fibersapi.h>
#endif

#include "../Source/SystemQOR/MSWindows/WinQAPI/include/ErrorDomain.h"
#include "CodeQOR/Parameters/ParamChecking.h"
#include "CodeQOR/Parameters/PChecks/IntRangeChecks.h"
#include "CodeQOR/Parameters/PChecks/TRangeChecks.h"
#include "CodeQOR/Parameters/PChecks/StringChecks.h"
#include "CodeQOR/Parameters/PChecks/FlagChecks.h"
#include "CodeQOR/Parameters/PChecks/PointerChecks.h"
#include "CodeQOR/Parameters/PChecks/StringChecks.h"
#include "CodeQOR/Parameters/PChecks/FlagChecks.h"
#include "CodeQOR/Parameters/InterParamChecks.h"
#include "../Source/SystemQOR/MSWindows/WinQAPI/include/HandleCheck.h"
#include "../Source/SystemQOR/MSWindows/WinQAPI/include/StringChecks.h"
#include "../Source/SystemQOR/MSWindows/WinQAPI/include/FlagChecks.h"
#include "../Source/SystemQOR/MSWindows/WinQAPI/include/PointerChecks.h"
#include "../Source/SystemQOR/MSWindows/WinQAPI/include/Library.h"

#include "WinQAPI/WinQAPI.h"

#ifndef __MINGW32__
#if( _WIN32_WINNT >= 0x0600 )
#include <WerAPI.h>
#endif
#endif//__MINGW32__

#if( _WIN32_WINNT < 0x0600 )
#	define CREATE_EVENT_MANUAL_RESET 0x00000001
#	define CREATE_EVENT_INITIAL_SET 0x00000002
#	define CREATE_MUTEX_INITIAL_OWNER 0x00000001
#	define RTL_RUN_ONCE_CHECK_ONLY     0x00000001UL
#	define RTL_RUN_ONCE_ASYNC          0x00000002UL
#	define RTL_RUN_ONCE_INIT_FAILED    0x00000004UL
#	define RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO         0x01000000
#	define RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN          0x02000000
#	define RTL_CRITICAL_SECTION_FLAG_STATIC_INIT           0x04000000
#	define RTL_CRITICAL_SECTION_ALL_FLAG_BITS              0xFF000000
#	define RTL_CRITICAL_SECTION_FLAG_RESERVED              (RTL_CRITICAL_SECTION_ALL_FLAG_BITS & (~(RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO | RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN | RTL_CRITICAL_SECTION_FLAG_STATIC_INIT)))
#	define CRITICAL_SECTION_NO_DEBUG_INFO  RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO
#endif

#if( _WIN32_WINNT < 0x0600 && NTDDI_VERSION < NTDDI_VISTASP1 && !defined( __MINGW32__) )
#	ifndef PSECURE_MEMORY_CACHE_CALLBACK
	typedef unsigned char ( __QCMP_STDCALLCONVENTION *PSECURE_MEMORY_CACHE_CALLBACK ) ( void* Addr, Cmp_ulong_ptr Range );
#	endif
#endif

#if( _WIN32_WINNT < 0x0600 )
#	ifndef _RTL_RUN_ONCE_DEF
#		define _RTL_RUN_ONCE_DEF
		typedef union _RTL_RUN_ONCE
		{
			PVOID Ptr;
		} RTL_RUN_ONCE, *PRTL_RUN_ONCE;
#	endif
	typedef RTL_RUN_ONCE INIT_ONCE;
#endif

#ifndef LPCALDATETIME
#	define LPCALDATETIME void*
#endif

#ifndef _WIN64

typedef struct _RUNTIME_FUNCTION
{
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD UnwindData;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;

#define UNWIND_HISTORY_TABLE_SIZE 12

typedef struct _UNWIND_HISTORY_TABLE_ENTRY
{
    DWORD64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
} UNWIND_HISTORY_TABLE_ENTRY, *PUNWIND_HISTORY_TABLE_ENTRY;

typedef struct _UNWIND_HISTORY_TABLE
{
    DWORD Count;
    BYTE  LocalHint;
    BYTE  GlobalHint;
    BYTE  Search;
    BYTE  Once;
    DWORD64 LowAddress;
    DWORD64 HighAddress;
    UNWIND_HISTORY_TABLE_ENTRY Entry[UNWIND_HISTORY_TABLE_SIZE];
} UNWIND_HISTORY_TABLE, *PUNWIND_HISTORY_TABLE;

#endif // _WIN64

#ifndef PGET_RUNTIME_FUNCTION_CALLBACK
#	define PGET_RUNTIME_FUNCTION_CALLBACK void*
#endif

#ifndef FRAME_POINTERS
typedef struct _FRAME_POINTERS
{
    ULONGLONG MemoryStackFp;
    ULONGLONG BackingStoreFp;
} FRAME_POINTERS, *PFRAME_POINTERS;
#endif

#ifndef PKNONVOLATILE_CONTEXT_POINTERS
#	define PKNONVOLATILE_CONTEXT_POINTERS void*
#endif

#if( _WIN32_WINNT < 0x0600 )
typedef enum _WER_REGISTER_FILE_TYPE
{
	WerRegFileTypeUserDocument = 1,
	WerRegFileTypeOther = 2,
	WerRegFileTypeMax
} WER_REGISTER_FILE_TYPE;
#endif

#if( _WIN32_WINNT < 0x0600 )
typedef int CALDATETIME_DATEUNIT;
#endif

#if( _WIN32_WINNT < 0x0600 )
#	define CALINFO_ENUMPROCEXEX void*
#endif

#if( _WIN32_WINNT < 0x0600 )
#	define DATEFMT_ENUMPROCEXEX void*
#endif

#if( _WIN32_WINNT < 0x0600 )
#	define LOCALE_ENUMPROCEX void*
#endif

#if( _WIN32_WINNT < 0x0600 )
#	define TIMEFMT_ENUMPROCEX void*
#endif

#if( _WIN32_WINNT < 0x0600 )
typedef enum _NORM_FORM
{
  NormalizationOther  = 0,
  NormalizationC  = 0x1,
  NormalizationD  = 0x2,
  NormalizationKC  = 0x5,
  NormalizationKD  = 0x6
}NORM_FORM;
#endif

#if( _WIN32_WINNT < 0x0600 )
	typedef DWORD TP_WAIT_RESULT;
	typedef struct _TP_WAIT TP_WAIT, *PTP_WAIT;
	typedef struct _TP_WORK TP_WORK, *PTP_WORK;
	typedef struct _TP_TIMER TP_TIMER, *PTP_TIMER;
	typedef struct _TP_CLEANUP_GROUP TP_CLEANUP_GROUP, *PTP_CLEANUP_GROUP;
	typedef struct _TP_POOL TP_POOL, *PTP_POOL;
	typedef struct _TP_IO TP_IO, *PTP_IO;
	typedef struct _TP_CALLBACK_INSTANCE TP_CALLBACK_INSTANCE, *PTP_CALLBACK_INSTANCE;
	typedef VOID (WINAPI *PTP_WIN32_IO_CALLBACK)( PTP_CALLBACK_INSTANCE Instance, PVOID Context, PVOID Overlapped, ULONG IoResult, ULONG_PTR NumberOfBytesTransferred, PTP_IO Io );
	typedef VOID (NTAPI *PTP_TIMER_CALLBACK)( PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_TIMER Timer );
	typedef VOID (NTAPI *PTP_WORK_CALLBACK)( PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WORK Work );
	typedef VOID (NTAPI *PTP_WAIT_CALLBACK)( PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WAIT Wait, TP_WAIT_RESULT WaitResult );

#endif

#if( _WIN32_WINNT < 0x0400 )
typedef enum _FINDEX_INFO_LEVELS
{
	FindExInfoStandard
} FINDEX_INFO_LEVELS;
#endif

#if( _WIN32_WINNT < 0x0501 )
typedef enum _STREAM_INFO_LEVELS
{
	FindStreamInfoStandard
} STREAM_INFO_LEVELS;
#endif

#if( _WIN32_WINNT < 0x0500 )
	typedef DWORD (WINAPI *LPPROGRESS_ROUTINE)( LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, void* lpData );
#endif

#if( _WIN32_WINNT < 0x0600 )
	typedef enum _FILE_ID_TYPE
	{
		  FileIdType,
		  ObjectIdType,
		  MaximumFileIdType
	} FILE_ID_TYPE, *PFILE_ID_TYPE;

	typedef struct FILE_ID_DESCRIPTOR
	{
		DWORD dwSize;  // Size of the struct
		FILE_ID_TYPE Type; // Describes the type of identifier passed in.
		union {
			LARGE_INTEGER FileId;
			GUID ObjectId;
		} DUMMYUNIONNAME;
	} FILE_ID_DESCRIPTOR, *LPFILE_ID_DESCRIPTOR;
#endif

#if		( _WIN32_WINNT < 0x0501 )

	typedef struct tagACTCTXA
	{
		ULONG       cbSize;
		DWORD       dwFlags;
		LPCSTR      lpSource;
		USHORT      wProcessorArchitecture;
		LANGID      wLangId;
		LPCSTR      lpAssemblyDirectory;
		LPCSTR      lpResourceName;
		LPCSTR      lpApplicationName;
		HMODULE     hModule;
	} ACTCTXA, *PACTCTXA;

	typedef struct tagACTCTXW
	{
		ULONG       cbSize;
		DWORD       dwFlags;
		LPCWSTR     lpSource;
		USHORT      wProcessorArchitecture;
		LANGID      wLangId;
		LPCWSTR     lpAssemblyDirectory;
		LPCWSTR     lpResourceName;
		LPCWSTR     lpApplicationName;
		HMODULE     hModule;
	} ACTCTXW, *PACTCTXW;

#	ifdef UNICODE
		typedef ACTCTXW ACTCTX;
		typedef PACTCTXW PACTCTX;
#	else
		typedef ACTCTXA ACTCTX;
		typedef PACTCTXA PACTCTX;
#	endif // UNICODE

#endif//( _WIN32_WINNT < 0x0501 )

#if( _WIN32_WINNT < 0x0400 )
typedef VOID (WINAPI *PFIBER_START_ROUTINE)( void* lpFiberParameter );
typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;
#endif

#if( _WIN32_WINNT < 0x0501 )
typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
    PVOID lpInformation;
    PVOID lpSectionBase;
    ULONG ulSectionLength;
    PVOID lpSectionGlobalDataBase;
    ULONG ulSectionGlobalDataLength;
} ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA, *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA *PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;

typedef struct tagACTCTX_SECTION_KEYED_DATA
{
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;
// 2600 stops here
    ULONG ulFlags;
    ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
} ACTCTX_SECTION_KEYED_DATA, *PACTCTX_SECTION_KEYED_DATA;
typedef const ACTCTX_SECTION_KEYED_DATA * PCACTCTX_SECTION_KEYED_DATA;

#endif

#if( _WIN32_WINNT < 0x0501 )
typedef struct _CONSOLE_SELECTION_INFO
{
    DWORD dwFlags;
    COORD dwSelectionAnchor;
    SMALL_RECT srSelection;
} CONSOLE_SELECTION_INFO, *PCONSOLE_SELECTION_INFO;
#endif

#if( _WIN32_WINNT < 0x0400 )
typedef enum _FINDEX_SEARCH_OPS
{
  FindExSearchNameMatch,
  FindExSearchLimitToDirectories,
  FindExSearchLimitToDevices
} FINDEX_SEARCH_OPS;
#endif

#if( _WIN32_WINNT < 0x0600 )

typedef struct _CONSOLE_READCONSOLE_CONTROL {
    ULONG nLength;
    ULONG nInitialChars;
    ULONG dwCtrlWakeupMask;
    ULONG dwControlKeyState;
} CONSOLE_READCONSOLE_CONTROL, *PCONSOLE_READCONSOLE_CONTROL;

typedef struct _CONSOLE_HISTORY_INFO
{
    UINT cbSize;
    UINT HistoryBufferSize;
    UINT NumberOfHistoryBuffers;
    DWORD dwFlags;
} CONSOLE_HISTORY_INFO, *PCONSOLE_HISTORY_INFO;

typedef struct _CONSOLE_SCREEN_BUFFER_INFOEX
{
    ULONG cbSize;
    COORD dwSize;
    COORD dwCursorPosition;
    WORD wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
    WORD wPopupAttributes;
    BOOL bFullscreenSupported;
    COLORREF ColorTable[16];
} CONSOLE_SCREEN_BUFFER_INFOEX, *PCONSOLE_SCREEN_BUFFER_INFOEX;

#	ifndef NOGDI
typedef struct _CONSOLE_FONT_INFOEX
{
    ULONG cbSize;
    DWORD nFont;
    COORD dwFontSize;
    UINT FontFamily;
    UINT FontWeight;
    WCHAR FaceName[LF_FACESIZE];
} CONSOLE_FONT_INFOEX, *PCONSOLE_FONT_INFOEX;
#	endif

typedef struct _TIME_DYNAMIC_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
    WCHAR TimeZoneKeyName[ 128 ];
    BOOLEAN DynamicDaylightTimeDisabled;
} DYNAMIC_TIME_ZONE_INFORMATION, *PDYNAMIC_TIME_ZONE_INFORMATION;

typedef enum _FILE_INFO_BY_HANDLE_CLASS
{
  FileBasicInfo,
  FileStandardInfo,
  FileNameInfo,
  FileRenameInfo,
  FileDispositionInfo,
  FileAllocationInfo,
  FileEndOfFileInfo,
  FileStreamInfo,
  FileCompressionInfo,
  FileAttributeTagInfo,
  FileIdBothDirectoryInfo,
  FileIdBothDirectoryRestartInfo,
  FileIoPriorityHintInfo,
  MaximumFileInfoByHandlesClass
} FILE_INFO_BY_HANDLE_CLASS,  *PFILE_INFO_BY_HANDLE_CLASS;
#endif

#if( _WIN32_WINNT < 0x0501 )
typedef int MEMORY_RESOURCE_NOTIFICATION_TYPE;
#endif

#if( _WIN32_WINNT < 0x0500 )
typedef enum _COMPUTER_NAME_FORMAT
{
  ComputerNameNetBIOS,
  ComputerNameDnsHostname,
  ComputerNameDnsDomain,
  ComputerNameDnsFullyQualified,
  ComputerNamePhysicalNetBIOS,
  ComputerNamePhysicalDnsHostname,
  ComputerNamePhysicalDnsDomain,
  ComputerNamePhysicalDnsFullyQualified,
  ComputerNameMax
} COMPUTER_NAME_FORMAT;
#endif

#if( _WIN32_WINNT < 0x0400 )
typedef void ( __QCMP_STDCALLCONVENTION * PAPCFUNC )( ULONG_PTR dwParam );
#endif

#if( _WIN32_WINNT < 0x0500 )
typedef VOID ( NTAPI * WAITORTIMERCALLBACK ) ( PVOID, BOOLEAN );
#endif

#if( _WIN32_WINNT < 0x0500 )
	typedef VOID ( APIENTRY *PTIMERAPCROUTINE)( void* lpArgToCompletionRoutine, DWORD dwTimerLowValue, DWORD dwTimerHighValue );
#endif

#ifndef PCONSOLE_FONT
#	define PCONSOLE_FONT void*
#endif

#if		( _WIN32_WINNT < 0x0600 )

typedef enum _DEP_SYSTEM_POLICY_TYPE
{
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn,
    DEPPolicyOptIn,
    DEPPolicyOptOut,
    DEPTotalPolicyCount
} DEP_SYSTEM_POLICY_TYPE;


typedef struct _PROC_THREAD_ATTRIBUTE_LIST *PPROC_THREAD_ATTRIBUTE_LIST, *LPPROC_THREAD_ATTRIBUTE_LIST;

typedef struct _OVERLAPPED_ENTRY
{
    ULONG_PTR lpCompletionKey;
    LPOVERLAPPED lpOverlapped;
    ULONG_PTR Internal;
    DWORD dwNumberOfBytesTransferred;
} OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;

typedef DWORD TP_VERSION, *PTP_VERSION;

typedef VOID (NTAPI *PTP_SIMPLE_CALLBACK)( PTP_CALLBACK_INSTANCE Instance, PVOID Context );

typedef VOID (NTAPI *PTP_CLEANUP_GROUP_CANCEL_CALLBACK)( PVOID ObjectContext, PVOID CleanupContext);

typedef struct _TP_CALLBACK_ENVIRON_V1 {
    TP_VERSION                         Version;
    PTP_POOL                           Pool;
    PTP_CLEANUP_GROUP                  CleanupGroup;
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK  CleanupGroupCancelCallback;
    PVOID                              RaceDll;
    struct _ACTIVATION_CONTEXT        *ActivationContext;
    PTP_SIMPLE_CALLBACK                FinalizationCallback;
    union {
        DWORD                          Flags;
        struct {
            DWORD                      LongFunction :  1;
            DWORD                      Persistent   :  1;
            DWORD                      Private      : 30;
        } s;
    } u;
} TP_CALLBACK_ENVIRON_V1;

typedef TP_CALLBACK_ENVIRON_V1 TP_CALLBACK_ENVIRON, *PTP_CALLBACK_ENVIRON;


typedef struct _FILEMUIINFO
{
    DWORD       dwSize;
    DWORD       dwVersion;
    DWORD       dwFileType;
    BYTE        pChecksum[16];
    BYTE        pServiceChecksum[16];
    DWORD       dwLanguageNameOffset;
    DWORD       dwTypeIDMainSize;
    DWORD       dwTypeIDMainOffset;
    DWORD       dwTypeNameMainOffset;
    DWORD       dwTypeIDMUISize;
    DWORD       dwTypeIDMUIOffset;
    DWORD       dwTypeNameMUIOffset;
    BYTE        abBuffer[8];
} FILEMUIINFO, *PFILEMUIINFO;

#define WOW64_SIZE_OF_80387_REGISTERS      80

#define WOW64_MAXIMUM_SUPPORTED_EXTENSION     512

typedef struct _WOW64_FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[WOW64_SIZE_OF_80387_REGISTERS];
    DWORD   Cr0NpxState;
} WOW64_FLOATING_SAVE_AREA;

typedef WOW64_FLOATING_SAVE_AREA *PWOW64_FLOATING_SAVE_AREA;

typedef struct _WOW64_CONTEXT
{

    DWORD ContextFlags;

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    WOW64_FLOATING_SAVE_AREA FloatSave;

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;
    DWORD   EFlags;
    DWORD   Esp;
    DWORD   SegSs;

    BYTE    ExtendedRegisters[WOW64_MAXIMUM_SUPPORTED_EXTENSION];

} WOW64_CONTEXT;

typedef WOW64_CONTEXT *PWOW64_CONTEXT;

typedef struct _nlsversioninfoex
{
	DWORD dwNLSVersionInfoSize;
	DWORD dwNLSVersion;
	DWORD dwDefinedVersion;
	DWORD dwEffectiveId;
	GUID guidCustomVersion;
} NLSVERSIONINFOEX, *LPNLSVERSIONINFOEX;

typedef struct _RTL_CONDITION_VARIABLE
{
	PVOID Ptr;
} RTL_CONDITION_VARIABLE, *PRTL_CONDITION_VARIABLE;

typedef RTL_CONDITION_VARIABLE CONDITION_VARIABLE, *PCONDITION_VARIABLE;

typedef struct _RTL_SRWLOCK
{
	PVOID Ptr;
} RTL_SRWLOCK, *PRTL_SRWLOCK;

typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;
//
//typedef union _RTL_RUN_ONCE
//{
//	PVOID Ptr;
//} RTL_RUN_ONCE, *PRTL_RUN_ONCE;

//Define one-time initialization primitive
//typedef RTL_RUN_ONCE INIT_ONCE;
typedef PRTL_RUN_ONCE PINIT_ONCE;
typedef PRTL_RUN_ONCE LPINIT_ONCE;
#	define INIT_ONCE_STATIC_INIT   RTL_RUN_ONCE_INIT
//Run once flags
#	define INIT_ONCE_CHECK_ONLY        RTL_RUN_ONCE_CHECK_ONLY
#	define INIT_ONCE_ASYNC             RTL_RUN_ONCE_ASYNC
#	define INIT_ONCE_INIT_FAILED       RTL_RUN_ONCE_INIT_FAILED
// The context stored in the run once structure must leave the following number of low order bits unused.
#	define INIT_ONCE_CTX_RESERVED_BITS RTL_RUN_ONCE_CTX_RESERVED_BITS
typedef BOOL( WINAPI *PINIT_ONCE_FN ) ( PINIT_ONCE InitOnce, PVOID Parameter, PVOID* Context );

#	define CREATE_WAITABLE_TIMER_MANUAL_RESET  0x00000001

typedef DWORD (WINAPI * APPLICATION_RECOVERY_CALLBACK)(PVOID pvParameter);

#	if( _WIN32_MAXVER > 0x0601 )
HRESULT WINAPI RegisterApplicationRecoveryCallback( APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags );
HRESULT WINAPI UnregisterApplicationRecoveryCallback(void);
HRESULT WINAPI RegisterApplicationRestart( PCWSTR pwzCommandline, DWORD dwFlags );
HRESULT WINAPI UnregisterApplicationRestart(void);
HRESULT WINAPI GetApplicationRecoveryCallback( HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK* pRecoveryCallback, PVOID* ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags );
HRESULT WINAPI GetApplicationRestartSettings( HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags );
HRESULT WINAPI ApplicationRecoveryInProgress( PBOOL pbCancelled );
VOID WINAPI ApplicationRecoveryFinished( BOOL bSuccess );
DWORD WINAPI FlsAlloc( PFLS_CALLBACK_FUNCTION lpCallback );
PVOID WINAPI FlsGetValue( DWORD dwFlsIndex );
BOOL WINAPI FlsSetValue( DWORD dwFlsIndex, PVOID lpFlsData );
BOOL WINAPI FlsFree( DWORD dwFlsIndex );
BOOL WINAPI GetNamedPipeClientComputerNameA( HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength );

#ifndef UNICODE
#define GetNamedPipeClientComputerName  GetNamedPipeClientComputerNameA
#endif

BOOL WINAPI GetNamedPipeClientProcessId( HANDLE Pipe, PULONG ClientProcessId );
BOOL WINAPI GetNamedPipeClientSessionId( HANDLE Pipe, PULONG ClientSessionId );
BOOL WINAPI GetNamedPipeServerProcessId( HANDLE Pipe, PULONG ServerProcessId );
BOOL WINAPI GetNamedPipeServerSessionId( HANDLE Pipe, PULONG ServerSessionId );
UINT WINAPI GetErrorMode( VOID );
BOOL WINAPI GetFileBandwidthReservation( HANDLE  hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL  pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests );
BOOL WINAPI GetNamedPipeClientComputerNameW( HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength );

BOOL WINAPI CancelSynchronousIo( HANDLE hThread );
BOOL WINAPI CancelIoEx( HANDLE hFile, LPOVERLAPPED lpOverlapped );
#	endif
#endif//( _WIN32_WINNT < 0x0600 )

//neeeded in order to step back to SDK 6.0A or MinGW32
/*
#ifdef __MINGW32__
typedef BOOLEAN ( NTAPI * PSECURE_MEMORY_CACHE_CALLBACK ) ( PVOID Addr, SIZE_T Range );
*/
/*
#ifdef __MINGW32__
typedef enum _DEP_SYSTEM_POLICY_TYPE
{
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn,
    DEPPolicyOptIn,
    DEPPolicyOptOut,
    DEPTotalPolicyCount
} DEP_SYSTEM_POLICY_TYPE;
#endif//__MINGW32__
*/
//Win32 API Macro for turning apiname into "apinameW" or "apinameA"
#define _WINQ_LNAME( _NAME ) #_NAME
//Set up a function static pointer to a Dll export, W or A variant
#define _WINQ_USESAPI( _NAME ) static const DefProc pFunc = reinterpret_cast< DefProc>( CKernel32::GetProcAddress( reinterpret_cast< ::HMODULE >( m_hModule ), _WINQ_LNAME( _NAME ) ) )
//If the function is from a later version of Windows than we targetted in the build then the Windows headers
//won't define the function name as either its A or W variant so the above won't work
//The _WINQ_USESAPIAW macro will if the function follows the standard naming convention.
#ifdef UNICODE
#	define _WINQ_USESAPIAW( _NAME ) static const DefProc pFunc = reinterpret_cast< DefProc>( CKernel32::GetProcAddress( reinterpret_cast< ::HMODULE >( m_hModule ), _WINQ_LNAME( _NAME##W ) ) )
#else
#	define _WINQ_USESAPIAW( _NAME ) static const DefProc pFunc = reinterpret_cast< DefProc>( CKernel32::GetProcAddress( reinterpret_cast< ::HMODULE >( m_hModule ), _WINQ_LNAME( _NAME##A ) ) )
#endif

namespace
{
	const char* _QOR_FileName()
	{
		return __FILE__;
	}
};

//--------------------------------------------------------------------------------
namespace nsWinQAPI
{
	//Updated to match Windows Server 2008 Build 6001 System32\Kernel32.dll

	using namespace nsParamChecking;

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQAPI ) CKernel32 : public CLibrary
	{

    private:

        HMODULE m_hModule;

	public:

		__QOR_DECLARE_OCLASS_ID( CKernel32 );

        CKernel32();
        ~CKernel32();
        static CKernel32& Instance( void );

		//--------------------------------------------------------------------------------
		//Slim Reader/Writer (SRW) Locks
		//--------------------------------------------------------------------------------
		static VOID AcquireSRWLockExclusive( CCheckParam< ::PSRWLOCK, CTRWPointerCheck< sizeof( ::SRWLOCK ) > >::TType pSRWLock );
		static VOID AcquireSRWLockShared( CCheckParam< ::PSRWLOCK, CTRWPointerCheck< sizeof( ::SRWLOCK ) > >::TType pSRWLock );
		static VOID InitializeSRWLock( CCheckParam< ::PSRWLOCK, CTRWPointerCheck< sizeof( ::SRWLOCK ) > >::TType pSRWLock );
		static VOID ReleaseSRWLockExclusive( CCheckParam< ::PSRWLOCK, CTRWPointerCheck< sizeof( ::SRWLOCK ) > >::TType pSRWLock );
		static VOID ReleaseSRWLockShared( CCheckParam< ::PSRWLOCK, CTRWPointerCheck< sizeof( ::SRWLOCK ) > >::TType pSRWLock );
		static BOOL SleepConditionVariableSRW(
			CCheckParam< ::PCONDITION_VARIABLE, CTRWPointerCheck< sizeof( ::CONDITION_VARIABLE ) > >::TType pConditionVariable,
			CCheckParam< ::PSRWLOCK, CTRWPointerCheck< sizeof( ::SRWLOCK ) > >::TType pSRWLock,
			CCheckParam< DWORD, CNoCheck >::TType dwMilliseconds,
			CCheckParam< ULONG, CNoCheck >::TType Flags );

		//--------------------------------------------------------------------------------
		//Object Namespaces

		//--------------------------------------------------------------------------------
		static HANDLE CreatePrivateNamespace(
			CCheckParam< ::SECURITY_ATTRIBUTES*, CTReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpPrivateNamespaceAttributes,
			CCheckParam< LPVOID, CNullPointerCheck >::TType lpBoundaryDescriptor,
			CCheckParam< LPCTSTR, CTStringKernelObjestNamespacePrefixCheck< LPCTSTR > >::TType lpAliasPrefix );

		static HANDLE OpenPrivateNamespace(
			CCheckParam< LPVOID, CNullPointerCheck >::TType lpBoundaryDescriptor,
			CCheckParam< LPCTSTR, CTStringKernelObjestNamespacePrefixCheck< LPCTSTR > >::TType lpAliasPrefix );

		static BOOLEAN ClosePrivateNamespace( HANDLE Handle, CCheckParam< ULONG, CNoCheck >::TType Flags );

		//--------------------------------------------------------------------------------
		//Boundary Descriptor
		//--------------------------------------------------------------------------------
		static HANDLE CreateBoundaryDescriptor( CCheckParam< LPCTSTR, CNullPointerCheck >::TType Name, CCheckParam< ULONG, CNoCheck >::TType Flags );
		static BOOL AddSIDToBoundaryDescriptor( PHANDLE BoundaryDescriptor, CCheckParam< PSID, CNullPointerCheck >::TType RequiredSid );
		static void DeleteBoundaryDescriptor( CCheckParam< HANDLE, CHandleParamCheck >::TType BoundaryDescriptor );

		//--------------------------------------------------------------------------------
		//Event
		//--------------------------------------------------------------------------------
		static HANDLE CreateEvent(
			CCheckParam< ::SECURITY_ATTRIBUTES*, CTNullOrReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpEventAttributes,
			CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bManualReset,
			CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bInitialState,
			CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpName,
			bool& bAlreadyExists );

		static HANDLE CreateEventEx(
			CCheckParam< ::SECURITY_ATTRIBUTES*, CTNullOrReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpEventAttributes,
			CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpName,
			CCheckParam< DWORD, CEventFlagsCheck >::TType dwFlags,
			CCheckParam< DWORD, CEventSyncAccessFlagsCheck >::TType dwDesiredAccess,
			bool& bAlreadyExists );

		static HANDLE OpenEvent(
			CCheckParam< DWORD, CEventFlagsCheck >::TType dwDesiredAccess,
			CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bInheritHandle,
			CCheckParam< LPCTSTR, CTStringKernelObjNameCheck< LPCTSTR > >::TType lpName );

		static BOOL PulseEvent( HANDLE hEvent );
		static BOOL ResetEvent( HANDLE hEvent );
		static BOOL SetEvent( HANDLE hEvent );

		//--------------------------------------------------------------------------------
		//Mutex
		//--------------------------------------------------------------------------------
		static HANDLE CreateMutex(
			CCheckParam< ::SECURITY_ATTRIBUTES*, CTNullOrReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpMutexAttributes,
			CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bInitialOwner,
			CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpName,
			bool& bAlreadyExists );

		HANDLE CreateMutexEx(
			CCheckParam< ::SECURITY_ATTRIBUTES*, CTNullOrReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpMutexAttributes,
			CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpName,
			CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType dwFlags,
			CCheckParam< DWORD, CMutexAccessFlagsCheck >::TType dwDesiredAccess,
			bool& bAlreadyExists );

		static HANDLE OpenMutex( CCheckParam< DWORD, CMutexAccessFlagsCheck > dwDesiredAccess,
			CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bInheritHandle,
			CCheckParam< LPCTSTR, CTStringKernelObjNameCheck< LPCTSTR > >::TType lpName );

		static BOOL ReleaseMutex( HANDLE hMutex );

		//--------------------------------------------------------------------------------
		//Semaphore
		//--------------------------------------------------------------------------------
		static HANDLE CreateSemaphore(
			CCheckParam< ::SECURITY_ATTRIBUTES*, CTNullOrReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpSemaphoreAttributes,
			CCheckParam<
				LONG,
				nsCodeQOR::CTInterLargerEqualCheck< LONG, 2 > //CCheckParam< LONG, nsParamChecking::CTLargerCheck< LONG, 0 > >::TType
			>::TType lInitialCount,
			CCheckParam< LONG, nsParamChecking::CTLargerCheck< LONG, 0 > >::TType lMaximumCount,
			CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpName,
			bool& bAlreadyExists );

		static HANDLE CreateSemaphoreEx(
			CCheckParam< ::SECURITY_ATTRIBUTES*, CTNullOrReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpSemaphoreAttributes,
			CCheckParam<
				LONG,
				nsCodeQOR::CTInterSmallerEqualCheck< LONG, 4 >	//ensure less than or equal to lMaximumCount
			>::TType lInitialCount,
			CCheckParam< LONG, nsParamChecking::CTLargerCheck< LONG, 0 > >::TType lMaximumCount,
			CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpName,
			CCheckParam< DWORD, nsParamChecking::CTEqualCheck< DWORD, 0 > >::TType dwFlags,
			CCheckParam< DWORD, CSemaphoreAccessFlagsCheck >::TType dwDesiredAccess,
			bool& bAlreadyExists );

		static HANDLE OpenSemaphore(
			CCheckParam< DWORD, CSemaphoreAccessFlagsCheck >::TType dwDesiredAccess,
			CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bInheritHandle,
			CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpName );

		static BOOL ReleaseSemaphore(
			HANDLE hSemaphore,
			CCheckParam< LONG, nsParamChecking::CTLargerCheck< LONG, 0 > >::TType lReleaseCount,
			CCheckParam< LONG*, CTNullOrWriteablePointerCheck< sizeof( LONG ) > >::TType lpPreviousCount );

		//------------------------------------------------------------------------------
		//Timer Queue
		//Timer-queue timers are lightweight objects that enable you to specify a
		//callback function to be called at a specified time.
		//------------------------------------------------------------------------------
		static HANDLE CreateTimerQueue(void);
		static BOOL DeleteTimerQueue( HANDLE TimerQueue );
		static BOOL DeleteTimerQueueEx( HANDLE TimerQueue, HANDLE CompletionEvent );
		static BOOL ChangeTimerQueueTimer( HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period );

		//------------------------------------------------------------------------------
		//TimerQueueTimer
		//------------------------------------------------------------------------------
		static BOOL CreateTimerQueueTimer(
			CCheckParam< HANDLE*, CTWritablePointerCheck< sizeof( HANDLE ) > >::TType phNewTimer,
			CCheckParam< HANDLE, CNoCheck >::TType TimerQueue,
			CCheckParam< WAITORTIMERCALLBACK, CTCodePointerCheck< WAITORTIMERCALLBACK > >::TType Callback,
			CCheckParam< PVOID, CNoCheck >::TType Parameter,
			CCheckParam< DWORD, CNoCheck >::TType DueTime,
			CCheckParam< DWORD, CNoCheck >::TType Period,
			CCheckParam< ULONG, CTQTCreateFlagsCheck >::TType Flags );

		//NOTE:This function cannot be called while the thread is using impersonation. The resulting behavior is undefined.
		static BOOL DeleteTimerQueueTimer( HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent, bool& bRetry );

		//------------------------------------------------------------------------------
		//Waitable Timer
		//------------------------------------------------------------------------------
		static HANDLE CreateWaitableTimer(
			CCheckParam< ::SECURITY_ATTRIBUTES*, CTNullOrReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpTimerAttributes,
			CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bManualReset,
			CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpTimerName,
			bool& bAlreadyExists );

		static HANDLE CreateWaitableTimerEx(
			CCheckParam< ::SECURITY_ATTRIBUTES*, CTNullOrReadablePointerCheck< sizeof( ::SECURITY_ATTRIBUTES ) > >::TType lpTimerAttributes,
			CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpTimerName,
			CCheckParam< DWORD, CWaitTmrCreateFlagsCheck >::TType dwFlags,
			CCheckParam< DWORD, CSybcObjAccessFlagsCheck >::TType dwDesiredAccess,
			bool& bAlreadyExists );

		static HANDLE OpenWaitableTimer(
			CCheckParam< DWORD, CSybcObjAccessFlagsCheck >::TType dwDesiredAccess,
			CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bInheritHandle,
			CCheckParam< LPCTSTR, CTStringKernelObjNameOrNullCheck< LPCTSTR > >::TType lpTimerName );

		static BOOL SetWaitableTimer(
			HANDLE hTimer,
			CConstCheckParam< ::LARGE_INTEGER*, CTReadablePointerCheck< sizeof( ::LARGE_INTEGER ) > >::TType pDueTime,
			CCheckParam< LONG, CNoCheck >::TType lPeriod,
			CCheckParam< PTIMERAPCROUTINE, CTNullOrCodePointer< PTIMERAPCROUTINE > >::TType pfnCompletionRoutine,
			CCheckParam< PVOID, CNoCheck >::TType lpArgToCompletionRoutine,
			CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType fResume );

		static BOOL CancelWaitableTimer( HANDLE hTimer );

		//--------------------------------------------------------------------------------
		//CriticalSection
		//--------------------------------------------------------------------------------
		static void InitializeCriticalSection( CCheckParam< ::LPCRITICAL_SECTION, CTRWPointerCheck< sizeof( ::CRITICAL_SECTION ) > >::TType pCriticalSection );
		static BOOL InitializeCriticalSectionAndSpinCount( CCheckParam< ::LPCRITICAL_SECTION, CNullPointerCheck >::TType lpCriticalSection, CCheckParam< DWORD, CNoCheck >::TType dwSpinCount );
		BOOL InitializeCriticalSectionEx(
			CCheckParam< ::LPCRITICAL_SECTION, CNullPointerCheck >::TType lpCriticalSection,
			CCheckParam< DWORD, CNoCheck >::TType dwSpinCount,
			CCheckParam< DWORD, CCritSecCreateFlagsCheck >::TType Flags );
		static void DeleteCriticalSection( CCheckParam< ::LPCRITICAL_SECTION, CNullPointerCheck >::TType lpCriticalSection );
		static void EnterCriticalSection( CCheckParam< ::LPCRITICAL_SECTION, CNullPointerCheck >::TType lpCriticalSection );
		static void LeaveCriticalSection( CCheckParam< ::LPCRITICAL_SECTION, CNullPointerCheck >::TType lpCriticalSection );
		static DWORD SetCriticalSectionSpinCount( CCheckParam< ::LPCRITICAL_SECTION, CNullPointerCheck >::TType lpCriticalSection, CCheckParam< DWORD, CNoCheck >::TType dwSpinCount );
		static BOOL TryEnterCriticalSection( CCheckParam< ::LPCRITICAL_SECTION, CNullPointerCheck >::TType lpCriticalSection );

		//--------------------------------------------------------------------------------
		//Overlapped
		//--------------------------------------------------------------------------------
		static BOOL GetOverlappedResult(
			HANDLE hFile,
			CCheckParam< ::OVERLAPPED*, CTWritablePointerCheck< sizeof( ::OVERLAPPED ) > >::TType lpOverlapped,
			CCheckParam< DWORD*, CTWritablePointerCheck< sizeof( DWORD ) > >::TType lpNumberOfBytesTransferred,
			CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bWait );

		//--------------------------------------------------------------------------------
		//ConditionVariable
		//--------------------------------------------------------------------------------
		static void InitializeConditionVariable( CCheckParam< ::CONDITION_VARIABLE*, CTWritablePointerCheck< sizeof( ::CONDITION_VARIABLE ) > >::TType ConditionVariable );

		static BOOL SleepConditionVariableCS(
			CCheckParam< ::CONDITION_VARIABLE*, CTWritablePointerCheck< sizeof( ::CONDITION_VARIABLE ) > >::TType ConditionVariable,
			CCheckParam< ::CRITICAL_SECTION*, CTWritablePointerCheck< sizeof( ::CRITICAL_SECTION ) > >::TType pCriticalSection,
			CCheckParam< DWORD, CNoCheck >::TType dwMilliseconds );

		static VOID WakeAllConditionVariable(
			CCheckParam< ::CONDITION_VARIABLE*, CTWritablePointerCheck< sizeof( ::CONDITION_VARIABLE ) > >::TType pConditionVariable );

		static VOID WakeConditionVariable(
			CCheckParam< ::CONDITION_VARIABLE*, CTWritablePointerCheck< sizeof( ::CONDITION_VARIABLE ) > >::TType pConditionVariable );

		//--------------------------------------------------------------------------------
		//SList
		//--------------------------------------------------------------------------------
		static void InitializeSListHead(
			CCheckParam< ::SLIST_HEADER*, CTWritablePointerCheck< sizeof( ::SLIST_HEADER ) > >::TType pListHead );

		static ::PSINGLE_LIST_ENTRY InterlockedFlushSList( CCheckParam< ::SLIST_HEADER*, CTWritablePointerCheck< sizeof( ::SLIST_HEADER ) > >::TType pListHead );

		static ::PSINGLE_LIST_ENTRY InterlockedPopEntrySList( CCheckParam< ::SLIST_HEADER*, CTWritablePointerCheck< sizeof( ::SLIST_HEADER ) > >::TType pListHead );

		static ::PSLIST_ENTRY InterlockedPushEntrySList( CCheckParam< ::SLIST_HEADER*, CTWritablePointerCheck< sizeof( ::SLIST_HEADER ) > >::TType pListHead,
			CCheckParam< ::SLIST_ENTRY*, CTWritablePointerCheck< sizeof( ::SLIST_ENTRY ) > >::TType pListEntry );

		static USHORT QueryDepthSList( CCheckParam< ::SLIST_HEADER*, CTWritablePointerCheck< sizeof( ::SLIST_HEADER ) > >::TType pListHead );

		//--------------------------------------------------------------------------------
		//InitOnce
		//--------------------------------------------------------------------------------
		static BOOL InitOnceBeginInitialize(
			CCheckParam< ::INIT_ONCE*, CTWritablePointerCheck< sizeof( ::INIT_ONCE ) > >::TType lpInitOnce,
			CCheckParam< DWORD, CInitOnceBeginFlagsCheck >::TType dwFlags,
			CCheckParam< BOOL*, CTWritablePointerCheck< sizeof( BOOL ) > >::TType fPending,
			CCheckParam< PVOID*, CNoCheck >::TType lpContext );

		static BOOL InitOnceComplete(
			CCheckParam< ::INIT_ONCE*, CTWritablePointerCheck< sizeof( ::INIT_ONCE ) > >::TType lpInitOnce,
			CCheckParam< DWORD, CInitOnceCompleteFlagsCheck >::TType dwFlags,
			CCheckParam< PVOID, CNoCheck >::TType lpContext );

		static BOOL InitOnceExecuteOnce(
			CCheckParam< ::INIT_ONCE*, CTWritablePointerCheck< sizeof( ::INIT_ONCE ) > >::TType InitOnce,
			CCheckParam< PINIT_ONCE_FN, CTCodePointerCheck< ::PINIT_ONCE_FN > >::TType pInitFn,
			CCheckParam< PVOID, CNoCheck >::TType Parameter,
			CCheckParam< PVOID*, CNoCheck >::TType Context );

		static VOID InitOnceInitialize( CCheckParam< ::INIT_ONCE*, CTWritablePointerCheck< sizeof( ::INIT_ONCE ) > >::TType pInitOnce );

		//--------------------------------------------------------------------------------
		//Interlocked primitives
		//--------------------------------------------------------------------------------
		static long InterlockedIncrement( long volatile* Addend );
		static LONGLONG InterlockedCompareExchange64( LONGLONG volatile* Destination, LONGLONG Exchange, LONGLONG Comperand );
		static long mxInterlockedCompareExchangeAcquire( long volatile* Destination, long Exchange, long Comperand );
		static LONGLONG mxInterlockedCompareExchangeAcquire64( LONGLONG volatile* Destination, LONGLONG Exchange, LONGLONG Comperand );
		static long mxInterlockedCompareExchangeRelease( long volatile* Destination, long Exchange, long Comperand );
		static LONGLONG mxInterlockedCompareExchangeRelease64( LONGLONG volatile* Destination, LONGLONG Exchange, LONGLONG Comperand );
		static LONGLONG InterlockedDecrement64( LONGLONG volatile* Addend );
		static long mxInterlockedDecrementAcquire( long volatile* Addend );
		static long mxInterlockedDecrementRelease( long volatile* Addend );
		static LONGLONG InterlockedExchange64( LONGLONG volatile* Target, LONGLONG Value );
		static LONGLONG InterlockedExchangeAcquire64( LONGLONG volatile Target, LONGLONG Value );
		static LONGLONG InterlockedExchangeAdd64( LONGLONG volatile* Addend, LONGLONG Value );
		static LONGLONG InterlockedIncrement64( LONGLONG volatile* Addend );
		static long mxInterlockedIncrementAcquire( long volatile* Addend );
		static long mxInterlockedIncrementRelease( long volatile* Addend );
		static long InterlockedCompareExchange( long volatile* Destination, long Exchange, long Comperand );
		static void* mxInterlockedCompareExchangePointer( void* volatile* Destination, void* Exchange, void* Comperand );
		static long InterlockedExchangeAdd( long volatile* Addend, long Value );
		static long InterlockedDecrement( long volatile* Addend );
		static long InterlockedExchange( long volatile* Target, long Value );

		//--------------------------------------------------------------------------------
		//APC
		//--------------------------------------------------------------------------------
		static DWORD QueueUserAPC(
			CCheckParam< ::PAPCFUNC, CTCodePointerCheck< ::PAPCFUNC > >::TType pfnAPC,
			CCheckParam< HANDLE, CNoCheck >::TType hThread,
			CCheckParam< ULONG_PTR, CNoCheck >::TType dwData );

		//------------------------------------------------------------------------------
		//Wait
		//------------------------------------------------------------------------------
		static BOOL RegisterWaitForSingleObject(
			CCheckParam< HANDLE*, CTWritablePointerCheck< sizeof( HANDLE ) > >::TType phNewWaitObject,
			CCheckParam< HANDLE, CNoCheck >::TType hObject,
			CCheckParam< ::WAITORTIMERCALLBACK, CTCodePointerCheck< ::WAITORTIMERCALLBACK > >::TType pCallback,
			CCheckParam< PVOID, CNoCheck >::TType pContext,
			CCheckParam< ULONG, CNoCheck >::TType dwMilliseconds,
			CCheckParam< ULONG, CRgstrWaitFlagsCheck >::TType dwFlags );

		static DWORD SignalObjectAndWait(
			CCheckParam< HANDLE, CNoCheck >::TType hObjectToSignal,
			CCheckParam< HANDLE, CNoCheck >::TType hObjectToWaitOn,
			CCheckParam< DWORD, CNoCheck >::TType dwMilliseconds,
			CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bAlertable );

		static BOOL UnregisterWait( CCheckParam< HANDLE, CNoCheck >::TType WaitHandle );
		static BOOL UnregisterWaitEx( CCheckParam< HANDLE, CNoCheck >::TType WaitHandle, CCheckParam< HANDLE, CNoCheck >::TType CompletionEvent );

		static DWORD WaitForMultipleObjects(
			CCheckParam< DWORD, nsParamChecking::CTIntegerRangeCheck< DWORD, 1, MAXIMUM_WAIT_OBJECTS > >::TType nCount,
			HANDLE* lpHandles /*CConstCheckParam< PHANDLE, CTArrayNCheck< PHANDLE, 0 > >::TType lpHandles*/,
			CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bWaitAll,
			CCheckParam< DWORD, CNoCheck >::TType dwMilliseconds );

		static DWORD WaitForMultipleObjectsEx(
			CCheckParam< DWORD, nsParamChecking::CTIntegerRangeCheck< DWORD, 1, MAXIMUM_WAIT_OBJECTS > >::TType nCount,
			CConstCheckParam< PHANDLE, nsCodeQOR::CTArrayNCheck< PHANDLE, 0 > >::TType lpHandles,
			CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bWaitAll,
			CCheckParam< DWORD, CNoCheck >::TType dwMilliseconds,
			CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bAlertable );

		static DWORD WaitForSingleObject(
			CCheckParam< HANDLE, CNoCheck >::TType hHandle,
			CCheckParam< DWORD, CNoCheck >::TType dwMilliseconds );

		static DWORD WaitForSingleObjectEx(
			CCheckParam< HANDLE, CNoCheck >::TType hHandle,
			CCheckParam< DWORD, CNoCheck >::TType dwMilliseconds,
			CCheckParam< int, nsParamChecking::CTIntRangeCheck< 0, 1 > >::TType bAlertable );


		//Memory Management functions

		static BOOL AddSecureMemoryCacheCallback( PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack );
		static BOOL AllocateUserPhysicalPages( HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray );
		static BOOL AllocateUserPhysicalPagesNuma( HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred );
		static VOID mxRtlCopyMemory( VOID /*UNALIGNED*/* Destination, CONST VOID /*UNALIGNED*/* Source, SIZE_T Length );
		static HANDLE CreateFileMapping( HANDLE hFile, ::LPSECURITY_ATTRIBUTES lpAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpName );
		static HANDLE CreateFileMappingNuma( HANDLE hFile, ::LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpName, DWORD nndPreferred );
		static HANDLE CreateMemoryResourceNotification( ::MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType );
		static void mxFillMemory( void* Destination, SIZE_T Length, BYTE Fill );
		static BOOL FlushViewOfFile( LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush );
		static BOOL FreeUserPhysicalPages( HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray );
		static SIZE_T GetLargePageMinimum(void);
		static BOOL GetPhysicallyInstalledSystemMemory( PULONGLONG TotalMemoryInKilobytes );
		static BOOL GetProcessDEPPolicy( HANDLE hProcess, LPDWORD lpFlags, PBOOL lpPermanent );
		static HANDLE GetProcessHeap(void);
		static DWORD GetProcessHeaps( DWORD NumberOfHeaps, PHANDLE ProcessHeaps );
		static DEP_SYSTEM_POLICY_TYPE GetSystemDEPPolicy(void);
		static BOOL GetSystemFileCacheSize( PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags );
		static UINT GetWriteWatch( DWORD dwFlags, void* lpBaseAddress, SIZE_T dwRegionSize, void** lpAddresses, PULONG_PTR lpdwCount, PULONG lpdwGranularity );
		static HGLOBAL GlobalAlloc( UINT uFlags, SIZE_T dwBytes );
		static UINT GlobalFlags( HGLOBAL hMem );
		static HGLOBAL GlobalFree( HGLOBAL hMem );
		static HGLOBAL GlobalHandle( LPCVOID pMem );
		static void* GlobalLock( HGLOBAL hMem );
		//[GlobalMemoryStatus can return incorrect information. Use the GlobalMemoryStatusEx function instead. ];
		static void GlobalMemoryStatus( LPMEMORYSTATUS lpBuffer );
		static BOOL GlobalMemoryStatusEx( ::LPMEMORYSTATUSEX lpBuffer );
		static HGLOBAL GlobalReAlloc( HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags );
		static SIZE_T GlobalSize( HGLOBAL hMem );
		static BOOL GlobalUnlock( HGLOBAL hMem );
		static void* HeapAlloc( HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes );
		static SIZE_T HeapCompact( HANDLE hHeap, DWORD dwFlags );
		static HANDLE HeapCreate( DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize );
		static BOOL HeapDestroy( HANDLE hHeap );
		static BOOL HeapFree( HANDLE hHeap, DWORD dwFlags, void* lpMem );
		static BOOL HeapLock( HANDLE hHeap );
		static BOOL HeapQueryInformation ( void* HeapHandle, ::HEAP_INFORMATION_CLASS HeapInformationClass, void* HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength );
		static LPVOID HeapReAlloc( HANDLE hHeap, DWORD dwFlags, void* lpMem, SIZE_T dwBytes );
		static BOOL HeapSetInformation( void* HeapHandle, ::HEAP_INFORMATION_CLASS HeapInformationClass, void* HeapInformation, SIZE_T HeapInformationLength );
		static SIZE_T HeapSize( HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem );
		static BOOL HeapUnlock( HANDLE hHeap );
		static BOOL HeapValidate( HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem );
		static BOOL HeapWalk( HANDLE hHeap, ::LPPROCESS_HEAP_ENTRY lpEntry );
		static BOOL IsBadCodePtr( FARPROC lpfn );
		static BOOL IsBadReadPtr( const VOID* lp, UINT_PTR ucb );
		static BOOL IsBadStringPtr( LPCTSTR lpsz, UINT_PTR ucchMax );
		static BOOL IsBadWritePtr( void* lp, UINT_PTR ucb );
		static HLOCAL LocalAlloc( UINT uFlags, SIZE_T uBytes );
		static UINT LocalFlags( HLOCAL hMem );
		static HLOCAL LocalFree( HLOCAL hMem );
		static HLOCAL LocalHandle( LPCVOID pMem );
		static void* LocalLock( HLOCAL hMem );
		static HLOCAL LocalReAlloc( HLOCAL hMem, SIZE_T uBytes, UINT uFlags);
		static SIZE_T LocalSize( HLOCAL hMem );
		static BOOL LocalUnlock( HLOCAL hMem );
		static void* MapViewOfFile( HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap );
		static void* MapViewOfFileEx( HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, void* lpBaseAddress );
		static LPVOID MapViewOfFileExNuma( HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred );
		static BOOL MapUserPhysicalPages( void* lpAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray );
		static BOOL MapUserPhysicalPagesScatter( void** VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray );
		static void mxMoveMemory( void* Destination, const VOID* Source, SIZE_T Length );
		static HANDLE OpenFileMapping( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName );
		static BOOL QueryMemoryResourceNotification( HANDLE ResourceNotificationHandle, PBOOL ResourceState );
		static BOOL RemoveSecureMemoryCacheCallback( PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack );
		static UINT ResetWriteWatch( void* lpBaseAddress, SIZE_T dwRegionSize );
		static void* mxSecureZeroMemory( void* ptr, SIZE_T cnt );
		static BOOL SetProcessDEPPolicy( DWORD dwFlags );
		static BOOL SetSystemFileCacheSize( SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags );
		static BOOL UnmapViewOfFile( LPCVOID lpBaseAddress );
		static void* VirtualAlloc( void* lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect );
		static void* VirtualAllocEx( HANDLE hProcess, void* lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect );
		static LPVOID VirtualAllocExNuma( HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred );
		static BOOL VirtualFree( void* lpAddress, SIZE_T dwSize, DWORD dwFreeType );
		static BOOL VirtualFreeEx( HANDLE hProcess, void* lpAddress, SIZE_T dwSize, DWORD dwFreeType );
		static BOOL VirtualLock( void* lpAddress, SIZE_T dwSize );
		static BOOL VirtualProtect( void* lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect );
		static BOOL VirtualProtectEx( HANDLE hProcess, void* lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect );
		static SIZE_T VirtualQuery( LPCVOID lpAddress, ::PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength );
		static SIZE_T VirtualQueryEx( HANDLE hProcess, LPCVOID lpAddress, ::PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength );
		static BOOL VirtualUnlock( void* lpAddress, SIZE_T dwSize );
		static void mxZeroMemory( void* Destination, SIZE_T Length );

		//This essentially cannot fail because it has no effect in 32 bit Windows;
		static SIZE_T LocalCompact( UINT uMinFree );
		//This essentially cannot fail because it has no effect in 32 bit Windows;
		static SIZE_T LocalShrink( HLOCAL hMem, UINT cbNewSize );

		static SIZE_T RtlCompareMemory( CONST VOID* Source1, CONST VOID* Source2, SIZE_T Length );

#		ifdef	__GNUC__
#			if _WIN32_WINNT >= 0x0600
				typedef BOOL (__QCMP_STDCALLCONVENTION* TIMEFMT_ENUMPROCEX)(LPWSTR, LPARAM);
#			endif
#		endif//__GNUC__

		static BOOL AdjustCalendarDate( LPCALDATETIME lpCalDateTime, /*CALDATETIME_DATEUNIT*/int calUnit, INT amount );
		static int CompareStringOrdinal ( LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2, BOOL bIgnoreCase );
		static LCID ConvertDefaultLocale( LCID Locale );// default locale
		static BOOL ConvertCalDateTimeToSystemTime( const LPCALDATETIME lpCalDateTime, ::SYSTEMTIME* lpSysTime );
		static BOOL ConvertSystemTimeToCalDateTime( const ::SYSTEMTIME* lpSysTime, ::CALID calId, LPCALDATETIME lpCalDateTime );
		static BOOL EnumCalendarInfo( ::CALINFO_ENUMPROC pCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType );
		static BOOL EnumCalendarInfoEx( ::CALINFO_ENUMPROCEX pCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType );
		static BOOL EnumCalendarInfoExEx( CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam );
		static BOOL EnumDateFormats( ::DATEFMT_ENUMPROC lpDateFmtEnumProc, LCID Locale, DWORD dwFlags );
		static BOOL EnumDateFormatsEx ( ::DATEFMT_ENUMPROCEX lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags );
		static BOOL EnumDateFormatsExEx ( DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam );
		static BOOL EnumLanguageGroupLocales ( ::LANGGROUPLOCALE_ENUMPROC pLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam );
		static BOOL EnumSystemCodePages( ::CODEPAGE_ENUMPROC lpCodePageEnumProc, DWORD dwFlags );
		static BOOL EnumSystemGeoID( GEOCLASS GeoClass, GEOID ParentGeoId, ::GEO_ENUMPROC lpGeoEnumProc );
		static BOOL EnumSystemLanguageGroups( ::LANGUAGEGROUP_ENUMPROC pLangGroupEnumProc, DWORD dwFlags, LONG_PTR lParam );
		static BOOL EnumSystemLocalesA( ::LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags );
		static BOOL EnumSystemLocalesW( ::LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags );
		static BOOL EnumSystemLocalesEx( LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved );
		static BOOL EnumTimeFormats( ::TIMEFMT_ENUMPROC lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags );
		static BOOL EnumTimeFormatsEx( TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam );
		static int FindNLSString ( LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound );
		static int FindNLSStringEx ( LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, ::LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam );
		static UINT GetACP(VOID);
		static BOOL GetCalendarDateFormatEx( LPCWSTR lpszLocale, DWORD dwFlags, const LPCALDATETIME lpCalDateTime, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate );
		static int GetCalendarInfo( LCID Locale, CALID Calendar, CALTYPE CalType, LPTSTR lpCalData, int cchData, LPDWORD lpValue );
		static int GetCalendarInfoEx( LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue );
		static BOOL GetCalendarSupportedDateRange( CALID Calendar, LPCALDATETIME lpCalMinDateTime, LPCALDATETIME lpCalMaxDateTime );
		static BOOL GetCPInfo( UINT CodePage, ::LPCPINFO lpCPInfo );
		static BOOL GetCPInfoEx ( UINT CodePage, DWORD dwFlags, ::LPCPINFOEX lpCPInfoEx );
		static int GetCurrencyFormat( LCID Locale, DWORD dwFlags, LPCTSTR lpValue, CONST ::CURRENCYFMT* lpFormat, LPTSTR lpCurrencyStr, int cchCurrency );
		//Docs say Win95 supports this but headers say no
		static int GetCurrencyFormatEx ( LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, CONST ::CURRENCYFMTW* lpFormat, LPWSTR lpCurrencyStr, int cchCurrency );
		static int GetDateFormat( LCID Locale, DWORD dwFlags, CONST ::SYSTEMTIME* lpDate, LPCTSTR lpFormat, LPTSTR lpDateStr, int cchDate );
		static int GetDateFormatEx( LPCWSTR lpLocaleName, DWORD dwFlags, CONST ::SYSTEMTIME* lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate, LPCWSTR lpCalendar );
		static int GetDurationFormat( LCID Locale, DWORD dwFlags, CONST ::SYSTEMTIME* lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration );
		static int GetDurationFormatEx( LPCWSTR lpLocaleName, DWORD dwFlags, CONST ::SYSTEMTIME* lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration );
		static int GetGeoInfo( GEOID GeoId, GEOTYPE GeoType, LPTSTR lpGeoData, int cchData, LANGID language );
		static int GetLocaleInfoA( LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData );
		static int GetLocaleInfoW( LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData );
		static int GetLocaleInfoEx ( LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData );
		static BOOL GetNLSVersion( NLS_FUNCTION Function, LCID Locale, ::LPNLSVERSIONINFO lpVersionInformation );
		static BOOL GetNLSVersionEx( NLS_FUNCTION function, LPCWSTR lpLocaleName, ::LPNLSVERSIONINFOEX lpVersionInformation );
		static int GetNumberFormat( LCID Locale, DWORD dwFlags, LPCTSTR lpValue, CONST ::NUMBERFMT* lpFormat, LPTSTR lpNumberStr, int cchNumber );
		static int GetNumberFormatEx( LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const ::NUMBERFMTW* lpFormat, LPWSTR lpNumberStr, int cchNumber );
		static UINT GetOEMCP(void);
		static int GetStringScripts( DWORD dwFlags, LPCWSTR lpString, int cchString, LPWSTR lpScripts, int cchScripts );
		static LANGID GetSystemDefaultLangID(void);
		static LCID GetSystemDefaultLCID(void);
		static int GetSystemDefaultLocaleName( LPWSTR lpLocaleName, int cchLocaleName );
		static LCID GetThreadLocale(void);
		static int GetTimeFormat( LCID Locale, DWORD dwFlags, CONST ::SYSTEMTIME* lpTime, LPCTSTR lpFormat, LPTSTR lpTimeStr, int cchTime );
		static int GetTimeFormatEx( LPCWSTR lpLocaleName, DWORD dwFlags, CONST ::SYSTEMTIME* lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime );
		static LANGID GetUserDefaultLangID(void);
		static LCID GetUserDefaultLCID(void);
		static int GetUserDefaultLocaleName( LPWSTR lpLocaleName, int cchLocaleName );
		static GEOID GetUserGeoID( GEOCLASS GeoClass );
		static int IdnToAscii( DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpASCIICharStr, int cchASCIIChar );
		static int IdnToNameprepUnicode( DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpNameprepCharStr, int cchNameprepChar );
		static int IdnToUnicode( DWORD dwFlags, LPCWSTR lpASCIICharStr, int cchASCIIChar, LPWSTR lpUnicodeCharStr, int cchUnicodeChar );
		static BOOL IsCalendarLeapYear( CALID calId, UINT year, UINT era );
		static BOOL IsNLSDefinedString( NLS_FUNCTION Function, DWORD dwFlags, ::LPNLSVERSIONINFO lpVersionInfo, LPCWSTR lpString, int cchStr );
		static BOOL IsNormalizedString( ::NORM_FORM NormForm, LPCWSTR lpString, int cwLength );
		static BOOL IsValidCodePage( UINT CodePage );
		static BOOL IsValidLanguageGroup( LGRPID LanguageGroup, DWORD dwFlags );
		static BOOL IsValidLocale( LCID Locale, DWORD dwFlags );
		static BOOL IsValidLocaleName( LPCWSTR lpLocaleName );
		static int LCIDToLocaleName( LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags );
		static int LCMapStringA( LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest );
		static int LCMapStringW( LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest );
		static int LCMapStringEx( LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, ::LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam );
		static LCID LocaleNameToLCID( LPWSTR lpName, DWORD dwFlags );
		static int NormalizeString( ::NORM_FORM NormForm, LPCWSTR lpSrcString, int cwSrcLength, LPWSTR lpDstString, int cwDstLength );
		static int SetCalendarInfo( LCID Locale, CALID Calendar, CALTYPE CalType, LPCTSTR lpCalData );
		static BOOL SetLocaleInfo( LCID Locale, LCTYPE LCType, LPCTSTR lpLCData );
		static BOOL SetThreadLocale ( LCID Locale );
		static BOOL SetUserGeoID( GEOID GeoID );
		static BOOL UpdateCalendarDayOfWeek( LPCALDATETIME lpCalDateTime );
		static BOOL VerifyScripts( DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts );

		//Structured Exception Handling functions

		static void* AddVectoredContinueHandler( ULONG FirstHandler, ::PVECTORED_EXCEPTION_HANDLER VectoredHandler );
		static void* AddVectoredExceptionHandler( ULONG FirstHandler, ::PVECTORED_EXCEPTION_HANDLER VectoredHandler );
		static __QCMP_NORETURN __QCMP_ALWAYSINLINE void RaiseException( DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR* lpArguments )
		{
			//NOTE: No protection or tracing here due to the part this plays in the exception mechanism
			::RaiseException( dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments );
		}
		//Client Requires Windows Vista or Windows XP Professional x64 Edition.
		//Server Requires Windows Server 2008 or Windows Server 2003 SP1.
		static ULONG RemoveVectoredContinueHandler( void* Handler );
		static ULONG RemoveVectoredExceptionHandler( void* VectoredHandlerHandle );
		//Client Requires Windows XP 64-Bit Edition Version 2003.
		//Server Requires 64-bit edition of Windows Server 2003.
		static BOOLEAN RtlAddFunctionTable( PRUNTIME_FUNCTION FunctionTable, DWORD EntryCount, DWORD64 BaseAddress, ULONGLONG TargetGp );
		//Client Requires Windows XP 64-Bit Edition Version 2003.
		//Server Requires 64-bit edition of Windows Server 2003.
		static VOID RtlCaptureContext( ::PCONTEXT ContextRecord );
		//Client Requires Windows XP 64-Bit Edition Version 2003.
		//Server Requires 64-bit edition of Windows Server 2003.
		static BOOLEAN RtlDeleteFunctionTable( PRUNTIME_FUNCTION FunctionTable );
		//Client Requires Windows XP 64-Bit Edition Version 2003.
		//Server Requires 64-bit edition of Windows Server 2003.
		static BOOLEAN RtlInstallFunctionTableCallback( DWORD64 TableIdentifier, DWORD64 BaseAddress, DWORD Length, PGET_RUNTIME_FUNCTION_CALLBACK Callback, void* Context, PCWSTR OutOfProcessCallbackDll );
		static VOID RtlRestoreContext( PCONTEXT ContextRecord, PEXCEPTION_RECORD ExceptionRecord );
		static ::LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter( ::LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter );

		//Application Recovery and Restart

		static VOID ApplicationRecoveryFinished( BOOL bSuccess );
		static HRESULT ApplicationRecoveryInProgress( PBOOL pbCanceled );
		static HRESULT GetApplicationRecoveryCallback( HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK* pRecoveryCallback, void** ppvParameter, PDWORD dwPingInterval, PDWORD dwFlags );
		static HRESULT GetApplicationRestartSettings( HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags );
		static HRESULT RegisterApplicationRecoveryCallback( APPLICATION_RECOVERY_CALLBACK pRecoveryCallback, void* pvParameter, DWORD dwPingInterval, DWORD dwFlags );
		static HRESULT RegisterApplicationRestart( PCWSTR pwzCommandline, DWORD dwFlags );
		static HRESULT UnregisterApplicationRecoveryCallback(void);
		static HRESULT UnregisterApplicationRestart(void);

		#ifdef	__MINGW32__
			typedef struct _TP_CLEANUP_GROUP TP_CLEANUP_GROUP, *PTP_CLEANUP_GROUP;
		#endif//__MINGW32__

		static BOOL AssignProcessToJobObject( HANDLE hJob, HANDLE hProcess );
		static BOOL BindIoCompletionCallback( HANDLE FileHandle, ::LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags );
		static BOOL CallbackMayRunLong( ::PTP_CALLBACK_INSTANCE pci );
		static VOID CancelThreadpoolIo( ::PTP_IO pio );
		static VOID CloseThreadpool( ::PTP_POOL ptpp );
		static VOID CloseThreadpoolCleanupGroup( ::PTP_CLEANUP_GROUP ptpcg );
		static VOID CloseThreadpoolCleanupGroupMembers( ::PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, void* pvCleanupContext );
		static VOID CloseThreadpoolIo( ::PTP_IO pio );
		static VOID CloseThreadpoolTimer( ::PTP_TIMER pti );
		static VOID CloseThreadpoolWait( ::PTP_WAIT pwa );
		static VOID CloseThreadpoolWork( ::PTP_WORK pwk );
		static BOOL ConvertFiberToThread(void);
		static void* ConvertThreadToFiber( void* lpParameter );
		static LPVOID ConvertThreadToFiberEx( void* lpParameter, DWORD dwFlags );
		static void* CreateFiber( SIZE_T dwStackSize, ::LPFIBER_START_ROUTINE lpStartAddress, void* lpParameter );
		static void* CreateFiberEx( SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, ::LPFIBER_START_ROUTINE lpStartAddress, void* lpParameter );
		static HANDLE CreateJobObject( ::LPSECURITY_ATTRIBUTES lpJobAttributes, LPCTSTR lpName );
		static BOOL CreateProcess( LPCTSTR lpApplicationName, LPTSTR lpCommandLine, ::LPSECURITY_ATTRIBUTES lpProcessAttributes, ::LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, void* lpEnvironment, LPCTSTR lpCurrentDirectory, ::LPSTARTUPINFO lpStartupInfo, ::LPPROCESS_INFORMATION lpProcessInformation );
		static HANDLE CreateRemoteThread( HANDLE hProcess, ::LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, void* lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId );
		static HANDLE CreateThread( ::LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, ::LPTHREAD_START_ROUTINE lpStartAddress, void* lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId );
		static ::PTP_POOL CreateThreadpool( void* reserved );
		static ::PTP_CLEANUP_GROUP CreateThreadpoolCleanupGroup(void);
		static ::PTP_IO CreateThreadpoolIo( HANDLE fl, ::PTP_WIN32_IO_CALLBACK pfnio, void* pv, ::PTP_CALLBACK_ENVIRON pcbe );
		static ::PTP_TIMER CreateThreadpoolTimer( ::PTP_TIMER_CALLBACK pfnti, void* pv, ::PTP_CALLBACK_ENVIRON pcbe );
		static ::PTP_WAIT CreateThreadpoolWait( ::PTP_WAIT_CALLBACK pfnwa, void* pv, ::PTP_CALLBACK_ENVIRON pcbe );
		static ::PTP_WORK CreateThreadpoolWork( ::PTP_WORK_CALLBACK pfnwk, void* pv, ::PTP_CALLBACK_ENVIRON pcbe );
		static VOID DeleteFiber( void* lpFiber );
		static VOID DeleteProcThreadAttributeList( ::LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList );
		static VOID DisassociateCurrentThreadFromCallback( ::PTP_CALLBACK_INSTANCE pci );
		static VOID ExitProcess( UINT uExitCode );
		static VOID ExitThread( DWORD dwExitCode );
		static DWORD FlsAlloc( ::PFLS_CALLBACK_FUNCTION lpCallback );
		static BOOL FlsFree( DWORD dwFlsIndex );
		static void* FlsGetValue( DWORD dwFlsIndex );
		static BOOL FlsSetValue( DWORD dwFlsIndex, void* lpFlsData );
		static VOID FlushProcessWriteBuffers(void);
		static BOOL FreeEnvironmentStringsA( LPSTR lpszEnvironmentBlock );
		static BOOL FreeEnvironmentStringsW( LPWSTR lpszEnvironmentBlock );
		static VOID FreeLibraryWhenCallbackReturns( ::PTP_CALLBACK_INSTANCE pci, HMODULE mod );
		static LPTSTR GetCommandLine(void);
		static HANDLE GetCurrentProcess(void);
		static DWORD GetCurrentProcessId(void);
		static DWORD GetCurrentProcessorNumber(void);
		static HANDLE GetCurrentThread(void);
		static DWORD GetCurrentThreadId(void);
		static LPVOID GetEnvironmentStringsA(void);
		static LPVOID GetEnvironmentStringsW(void);
		static DWORD GetEnvironmentVariable (LPCTSTR lpName, LPTSTR lpBuffer, DWORD nSize );
		static BOOL GetExitCodeProcess( HANDLE hProcess, LPDWORD lpExitCode );
		static BOOL GetExitCodeThread( HANDLE hThread, LPDWORD lpExitCode );
		static BOOL GetLogicalProcessorInformation( ::PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnLength );
		static BOOL GetNumaAvailableMemoryNode( UCHAR Node, PULONGLONG AvailableBytes );
		static BOOL GetNumaHighestNodeNumber( PULONG HighestNodeNumber );
		static BOOL GetNumaNodeProcessorMask( UCHAR Node, PULONGLONG ProcessorMask );
		static BOOL GetNumaProcessorNode( UCHAR Processor, PUCHAR NodeNumber );
		static BOOL GetNumaProximityNode( ULONG ProximityId, PUCHAR NodeNumber );
		static DWORD GetPriorityClass( HANDLE hProcess );
		static BOOL GetProcessAffinityMask( HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask );
		static BOOL GetProcessHandleCount( HANDLE hProcess, PDWORD pdwHandleCount );
		static DWORD GetProcessId( HANDLE Process );
		static DWORD GetProcessIdOfThread( HANDLE Thread );
		static BOOL GetProcessIoCounters( HANDLE hProcess, ::PIO_COUNTERS lpIoCounters );
		static BOOL GetProcessPriorityBoost( HANDLE hProcess, PBOOL pDisablePriorityBoost );
		static BOOL GetProcessShutdownParameters( LPDWORD lpdwLevel, LPDWORD lpdwFlags );
		static BOOL GetProcessTimes( HANDLE hProcess, ::LPFILETIME lpCreationTime, ::LPFILETIME lpExitTime, ::LPFILETIME lpKernelTime, ::LPFILETIME lpUserTime );
		static DWORD GetProcessVersion( DWORD ProcessId );
		static BOOL GetProcessWorkingSetSize( HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize );
		static BOOL GetProcessWorkingSetSizeEx( HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags );
		static VOID GetStartupInfo( CCheckParam< ::LPSTARTUPINFO, CTRWPointerCheck< sizeof( ::STARTUPINFO ) > >::TType pStartupInfo );
		static DWORD GetThreadId( HANDLE Thread );
		static BOOL GetThreadIOPendingFlag( HANDLE hThread, PBOOL lpIOIsPending );
		static int GetThreadPriority( HANDLE hThread );
		static BOOL GetThreadPriorityBoost( HANDLE hThread, PBOOL pDisablePriorityBoost );
		static BOOL GetThreadTimes( HANDLE hThread, ::LPFILETIME lpCreationTime, ::LPFILETIME lpExitTime, ::LPFILETIME lpKernelTime, ::LPFILETIME lpUserTime );
		static BOOL InitializeProcThreadAttributeList( ::LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize );
		static VOID InitializeThreadpoolEnvironment( ::PTP_CALLBACK_ENVIRON pcbe );
		static VOID DestroyThreadpoolEnvironment( ::PTP_CALLBACK_ENVIRON pcbe );
		static BOOL IsProcessInJob( HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result );
		static BOOL IsThreadAFiber(void);
		static BOOL IsThreadpoolTimerSet( ::PTP_TIMER pti );
		static BOOL IsWow64Process( HANDLE hProcess, PBOOL Wow64Process );
		static VOID LeaveCriticalSectionWhenCallbackReturns( ::PTP_CALLBACK_INSTANCE pci, ::PCRITICAL_SECTION pcs );
		static BOOL NeedCurrentDirectoryForExePath( LPCTSTR ExeName );
		static HANDLE OpenJobObject( DWORD dwDesiredAccess, BOOL bInheritHandles, LPCTSTR lpName );
		static HANDLE OpenProcess( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId );
		static HANDLE OpenThread( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId );
		static BOOL QueryFullProcessImageName( HANDLE hProcess, DWORD dwFlags, LPTSTR lpExeName, PDWORD lpdwSize );
		static BOOL QueryIdleProcessorCycleTime( PULONG BufferLength, PULONG64 ProcessorIdleCycleTime );
		static BOOL QueryInformationJobObject( HANDLE hJob, ::JOBOBJECTINFOCLASS JobObjectInfoClass, void* lpJobObjectInfo, DWORD cbJobObjectInfoLength, LPDWORD lpReturnLength );
		//Requires Windows Vista SP1. Server Requires Windows Server 2008.
		static BOOL QueryProcessAffinityUpdateMode( HANDLE ProcessHandle, LPDWORD lpdwFlags );
		static BOOL QueryProcessCycleTime( HANDLE ProcessHandle, PULONG64 CycleTime );
		static BOOL QueryThreadCycleTime( HANDLE ThreadHandle, PULONG64 CycleTime );
		static BOOL QueueUserWorkItem( LPTHREAD_START_ROUTINE Function, void* Context, ULONG Flags );
		static VOID ReleaseMutexWhenCallbackReturns( ::PTP_CALLBACK_INSTANCE pci, HANDLE mut );
		static VOID WINAPI ReleaseSemaphoreWhenCallbackReturns( ::PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel );
		static DWORD ResumeThread( HANDLE hThread );
		static BOOL SetEnvironmentVariable( LPCTSTR lpName, LPCTSTR lpValue );
		static VOID SetEventWhenCallbackReturns( ::PTP_CALLBACK_INSTANCE pci, HANDLE evt );
		static BOOL SetInformationJobObject( HANDLE hJob, ::JOBOBJECTINFOCLASS JobObjectInfoClass, void* lpJobObjectInfo, DWORD cbJobObjectInfoLength );
		static BOOL SetPriorityClass( HANDLE hProcess, DWORD dwPriorityClass );
		static BOOL SetProcessAffinityMask( HANDLE hProcess, DWORD_PTR dwProcessAffinityMask );
		static BOOL SetProcessAffinityUpdateMode( HANDLE ProcessHandle, DWORD dwFlags );
		static BOOL SetProcessPriorityBoost( HANDLE hProcess, BOOL DisablePriorityBoost );
		static BOOL SetProcessShutdownParameters( DWORD dwLevel, DWORD dwFlags );
		static BOOL SetProcessWorkingSetSize( HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize );
		static BOOL SetProcessWorkingSetSizeEx( HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags );
		static DWORD_PTR SetThreadAffinityMask( HANDLE hThread, DWORD_PTR dwThreadAffinityMask );
		static DWORD SetThreadIdealProcessor( HANDLE hThread, DWORD dwIdealProcessor );
		static VOID SetThreadpoolCallbackCleanupGroup( ::PTP_CALLBACK_ENVIRON pcbe, ::PTP_CLEANUP_GROUP ptpcg, ::PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng );
		static VOID SetThreadpoolCallbackLibrary( ::PTP_CALLBACK_ENVIRON pcbe, void* mod );
		static VOID SetThreadpoolCallbackPool( ::PTP_CALLBACK_ENVIRON pcbe, ::PTP_POOL ptpp );
		static VOID SetThreadpoolCallbackRunsLong( ::PTP_CALLBACK_ENVIRON pcbe );
		static VOID SetThreadpoolThreadMaximum( ::PTP_POOL ptpp, DWORD cthrdMost );
		static BOOL SetThreadpoolThreadMinimum( ::PTP_POOL ptpp, DWORD cthrdMic );
		static VOID SetThreadpoolTimer( ::PTP_TIMER pti, ::PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength );
		static VOID SetThreadpoolWait( ::PTP_WAIT pwa, HANDLE h, ::PFILETIME pftTimeout );
		static BOOL SetThreadPriority( HANDLE hThread, int nPriority );
		static BOOL SetThreadPriorityBoost( HANDLE hThread, BOOL bDisablePriorityBoost );
		//Client Requires Windows XP Professional x64 Edition.
		//Server Requires Windows Server 2003 SP1.
		static BOOL SetThreadStackGuarantee( PULONG StackSizeInBytes );
		static VOID Sleep( DWORD dwMilliseconds );
		static DWORD SleepEx( DWORD dwMilliseconds, BOOL bAlertable );
		static VOID StartThreadpoolIo( ::PTP_IO pio );
		static VOID SubmitThreadpoolWork( ::PTP_WORK pwk );
		static DWORD SuspendThread( HANDLE hThread );
		static VOID SwitchToFiber( void* lpFiber );
		static BOOL SwitchToThread(void);
		static BOOL TerminateJobObject( HANDLE hJob, UINT uExitCode );
		static BOOL TerminateProcess( HANDLE hProcess, UINT uExitCode );
		static BOOL TerminateThread( HANDLE hThread,  DWORD dwExitCode );
		static DWORD TlsAlloc(void);
		static BOOL TlsFree( DWORD dwTlsIndex );
		static void* TlsGetValue( DWORD dwTlsIndex );
		static BOOL TlsSetValue( DWORD dwTlsIndex, void* lpTlsValue );
		static BOOL TrySubmitThreadpoolCallback( ::PTP_SIMPLE_CALLBACK pfns, void* pv, ::PTP_CALLBACK_ENVIRON pcbe );
		static BOOL UpdateProcThreadAttribute( ::LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, void* lpValue, SIZE_T cbSize, void* lpPreviousValue, PSIZE_T lpReturnSize );
		static VOID WaitForThreadpoolIoCallbacks( ::PTP_IO pio, BOOL fCancelPendingCallbacks );
		static VOID WaitForThreadpoolTimerCallbacks( ::PTP_TIMER pti, BOOL fCancelPendingCallbacks );
		static VOID WaitForThreadpoolWaitCallbacks( ::PTP_WAIT pwa, BOOL fCancelPendingCallbacks );
		static VOID WaitForThreadpoolWorkCallbacks( ::PTP_WORK pwk, BOOL fCancelPendingCallbacks );
		static UINT WinExec( LPCSTR lpCmdLine, UINT uCmdShow );
		static DWORD Wow64SuspendThread( HANDLE hThread );
		static DWORD LoadModule( LPCSTR lpModuleName, void* lpParameterBlock );

		/*
		typedef enum _STREAM_INFO_LEVELS
		{

			FindStreamInfoStandard,
			FindStreamInfoMaxInfoLevel

		} STREAM_INFO_LEVELS;
		*/
		static BOOL AreFileApisANSI(void);
		static BOOL CancelIo( HANDLE hFile );
		BOOL CancelIoEx( HANDLE hFile, ::LPOVERLAPPED lpOverlapped );
		BOOL CancelSynchronousIo( HANDLE hThread );
		static BOOL CheckNameLegalDOS8Dot3( LPCTSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal );
		static BOOL CopyFile( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, BOOL bFailIfExists );
		static BOOL CopyFileEx( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, ::LPPROGRESS_ROUTINE lpProgressRoutine, void* lpData, LPBOOL pbCancel, DWORD dwCopyFlags );
		BOOL CopyFileTransacted( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, ::LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction );
		static HANDLE CreateFileA( LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile );
		static HANDLE CreateFileW( LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile );
		HANDLE CreateFileTransacted( LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, void* pExtendedParameter );
		static BOOL CreateHardLink( LPCTSTR lpFileName, LPCTSTR lpExistingFileName, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes );
		BOOL CreateHardLinkTransacted( LPCTSTR lpFileName, LPCTSTR lpExistingFileName, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction );
		static HANDLE CreateIoCompletionPort( HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads );
		static BOOL CreateSymbolicLink( LPCTSTR lpSymlinkFileName, LPCTSTR lpTargetFileName, DWORD dwFlags );
		BOOL CreateSymbolicLinkTransacted( LPCTSTR lpSymlinkFileName, LPCTSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction );
		static BOOL DeleteFile( LPCTSTR lpFileName );
		BOOL DeleteFileTransacted( LPCTSTR lpFileName, HANDLE hTransaction );
		static BOOL FindClose( HANDLE hFindFile );
		static HANDLE FindFirstFile( LPCTSTR lpFileName, ::LPWIN32_FIND_DATA lpFindFileData );
		static HANDLE FindFirstFileEx( LPCTSTR lpFileName, ::FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, ::FINDEX_SEARCH_OPS fSearchOp, void* lpSearchFilter, DWORD dwAdditionalFlags );
		HANDLE FindFirstFileNameTransactedW( LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWCHAR LinkName, HANDLE hTransaction );
		HANDLE FindFirstFileNameW( LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWCHAR LinkName );
		HANDLE FindFirstFileTransacted( LPCTSTR lpFileName, ::FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, ::FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction );
		HANDLE FindFirstStreamTransactedW( LPCWSTR lpFileName, ::STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction );
		HANDLE FindFirstStreamW( LPCWSTR lpFileName, ::STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags );
		static BOOL FindNextFile( HANDLE hFindFile, ::LPWIN32_FIND_DATA lpFindFileData );
		BOOL FindNextFileNameW( HANDLE hFindStream, LPDWORD StringLength, PWCHAR LinkName );
		BOOL FindNextStreamW( HANDLE hFindStream, void* lpFindStreamData );
		static BOOL FlushFileBuffers( HANDLE hFile );
		static BOOL GetBinaryType( LPCTSTR lpApplicationName, LPDWORD lpBinaryType );
		static DWORD GetCompressedFileSize( LPCTSTR lpFileName, LPDWORD lpFileSizeHigh );
		DWORD GetCompressedFileSizeTransacted( LPCTSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction );
		static DWORD GetFileAttributes( LPCTSTR lpFileName );
		static BOOL GetFileAttributesEx( LPCTSTR lpFileName, ::GET_FILEEX_INFO_LEVELS fInfoLevelId, void* lpFileInformation );
		BOOL GetFileAttributesTransacted( LPCTSTR lpFileName, ::GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction );
		BOOL GetFileBandwidthReservation( HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests );
		static BOOL GetFileInformationByHandle( HANDLE hFile, ::LPBY_HANDLE_FILE_INFORMATION lpFileInformation );
		static BOOL GetFileInformationByHandleEx( HANDLE hFile, ::FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize );
		static DWORD GetFileSize( HANDLE hFile, LPDWORD lpFileSizeHigh );
		static BOOL GetFileSizeEx( HANDLE hFile, PLARGE_INTEGER lpFileSize );
		static DWORD GetFileType( HANDLE hFile );
		static DWORD GetFinalPathNameByHandle( HANDLE hFile, LPTSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags );
		static DWORD GetFullPathName( LPCTSTR lpFileName, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR* lpFilePart );
		DWORD GetFullPathNameTransacted( LPCTSTR lpFileName, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR *lpFilePart, HANDLE hTransaction );
		static DWORD GetLongPathName( LPCTSTR lpszShortPath, LPTSTR lpszLongPath, DWORD cchBuffer );
		DWORD GetLongPathNameTransacted( LPCTSTR lpszShortPath, LPTSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction );
		static BOOL GetQueuedCompletionStatus( HANDLE CompletionPort, LPDWORD lpNumberOfBytes, PULONG_PTR lpCompletionKey, ::LPOVERLAPPED* lpOverlapped, DWORD dwMilliseconds );
		BOOL GetQueuedCompletionStatusEx( HANDLE CompletionPort, ::LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable );
		static DWORD GetShortPathName( LPCTSTR lpszLongPath, LPTSTR lpszShortPath, DWORD cchBuffer );
		static UINT GetTempFileName( LPCTSTR lpPathName, LPCTSTR lpPrefixString, UINT uUnique, LPTSTR lpTempFileName );
		static DWORD GetTempPath( DWORD nBufferLength, LPTSTR lpBuffer );
		static BOOL LockFile( HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh );
		static BOOL LockFileEx( HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, ::LPOVERLAPPED lpOverlapped );
		static BOOL MoveFile( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName );
		static BOOL MoveFileEx( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, DWORD dwFlags );
		BOOL MoveFileTransacted( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, ::LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction );
		static BOOL MoveFileWithProgress( LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, ::LPPROGRESS_ROUTINE lpProgressRoutine, void* lpData, DWORD dwFlags );
		static HFILE OpenFile( LPCSTR lpFileName, ::LPOFSTRUCT lpReOpenBuff, UINT uStyle );
		HANDLE OpenFileById( HANDLE hFile, ::LPFILE_ID_DESCRIPTOR lpFileID, DWORD dwDesiredAccess, DWORD dwShareMode, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlags );
		static BOOL PostQueuedCompletionStatus( HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, ::LPOVERLAPPED lpOverlapped );
		static BOOL ReadFile( HANDLE hFile, void* lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, ::LPOVERLAPPED lpOverlapped );
		static BOOL ReadFileEx( HANDLE hFile, void* lpBuffer, DWORD nNumberOfBytesToRead, ::LPOVERLAPPED lpOverlapped, ::LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine );
		static BOOL ReadFileScatter( HANDLE hFile, ::FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, ::LPOVERLAPPED lpOverlapped );
		static HANDLE ReOpenFile( HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlags );
		static BOOL ReplaceFile( LPCTSTR lpReplacedFileName, LPCTSTR lpReplacementFileName, LPCTSTR lpBackupFileName, DWORD dwReplaceFlags, void* lpExclude, LPVOID lpReserved );
		static DWORD SearchPath( LPCTSTR lpPath, LPCTSTR lpFileName, LPCTSTR lpExtension, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR* lpFilePart );
		static BOOL SetEndOfFile( HANDLE hFile );
		static void SetFileApisToANSI(void);
		static void SetFileApisToOEM(void);
		static BOOL SetFileAttributes( LPCTSTR lpFileName, DWORD dwFileAttributes );
		BOOL SetFileAttributesTransacted( LPCTSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction );
		BOOL SetFileBandwidthReservation( HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests );
		BOOL SetFileCompletionNotificationModes( HANDLE FileHandle, UCHAR Flags );
		BOOL SetFileInformationByHandle( HANDLE hFile, ::FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize );
		BOOL SetFileIoOverlappedRange( HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length );
		static DWORD SetFilePointer( HANDLE hFile, long lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod );
		static BOOL SetFilePointerEx( HANDLE hFile, ::LARGE_INTEGER liDistanceToMove, ::PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod );
		static BOOL SetFileShortName( HANDLE hFile, LPCTSTR lpShortName );
		static BOOL SetFileValidData( HANDLE hFile, LONGLONG ValidDataLength );
		static BOOL UnlockFile( HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh );
		static BOOL UnlockFileEx( HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, ::LPOVERLAPPED lpOverlapped );
		BOOL Wow64DisableWow64FsRedirection( void** OldValue );
		BOOLEAN Wow64EnableWow64FsRedirection( BOOLEAN Wow64FsEnableRedirection );
		BOOL Wow64RevertWow64FsRedirection( void* OldValue );
		static BOOL WriteFile( HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, ::LPOVERLAPPED lpOverlapped );
		static BOOL WriteFileEx( HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, ::LPOVERLAPPED lpOverlapped, ::LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine );
		static BOOL WriteFileGather( HANDLE hFile, ::FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, ::LPOVERLAPPED lpOverlapped );
		static UINT SetHandleCount( UINT uNumber );

		//Directory Management functions

		static BOOL CreateDirectory( LPCTSTR lpPathName, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes );
		static BOOL CreateDirectoryEx( LPCTSTR lpTemplateDirectory, LPCTSTR lpNewDirectory, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes );
		BOOL CreateDirectoryTransacted( LPCTSTR lpTemplateDirectory, LPCTSTR lpNewDirectory, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction );
		static BOOL FindCloseChangeNotification( HANDLE hChangeHandle );
		static HANDLE FindFirstChangeNotification( LPCTSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter );
		static BOOL FindNextChangeNotification( HANDLE hChangeHandle );
		static DWORD GetCurrentDirectory( DWORD nBufferLength, LPTSTR lpBuffer );
		static BOOL ReadDirectoryChangesW( HANDLE hDirectory, void* lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, ::LPOVERLAPPED lpOverlapped, ::LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine );
		static BOOL RemoveDirectory( LPCTSTR lpPathName );
		BOOL RemoveDirectoryTransacted( LPCTSTR lpPathName, HANDLE hTransaction );
		static BOOL SetCurrentDirectory( LPCTSTR lpPathName );

		//Resource functions

		static HANDLE BeginUpdateResource( LPCTSTR pFileName, BOOL bDeleteExistingResources );
		static BOOL EndUpdateResource( HANDLE hUpdate, BOOL fDiscard );
		static BOOL EnumResourceLanguages( HMODULE hModule, LPCTSTR lpType, LPCTSTR lpName, ::ENUMRESLANGPROC lpEnumFunc, LONG_PTR lParam );
		static BOOL EnumResourceLanguagesEx( HMODULE hModule, LPCTSTR lpType, LPCTSTR lpName, ::ENUMRESLANGPROC lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId );
		static BOOL EnumResourceNames( HMODULE hModule, LPCTSTR lpszType, ::ENUMRESNAMEPROC lpEnumFunc, LONG_PTR lParam );
		static BOOL EnumResourceNamesEx( HMODULE hModule, LPCTSTR lpszType, ::ENUMRESNAMEPROC lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId );
		static BOOL EnumResourceTypes( HMODULE hModule, ::ENUMRESTYPEPROC lpEnumFunc, LONG_PTR lParam );
		static BOOL EnumResourceTypesEx( HMODULE hModule, ::ENUMRESTYPEPROC lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId );
		static HRSRC FindResource( HMODULE hModule, LPCTSTR lpName, LPCTSTR lpType );
		static HRSRC FindResourceEx( HMODULE hModule, LPCTSTR lpType, LPCTSTR lpName, WORD wLanguage );
		static BOOL FreeResource( HGLOBAL hglbResource );
		static HGLOBAL LoadResource( HMODULE hModule, HRSRC hResInfo );
		static void* LockResource( HGLOBAL hResData );
		static DWORD SizeofResource( HMODULE hModule, HRSRC hResInfo );
		static BOOL UpdateResource( HANDLE hUpdate, LPCTSTR lpType, LPCTSTR lpName, WORD wLanguage, void* lpData, DWORD cbData );
		static DWORD VerLanguageName( DWORD wLang, LPTSTR szLang, DWORD nSize );

		//System Information functions

		static BOOL DnsHostnameToComputerName(
			CCheckParam< ::LPCTSTR, nsParamChecking::CStringCheck >::TType Hostname,
			CCheckParam< ::LPTSTR, nsParamChecking::CStringCheck >::TType ComputerName,
			CCheckParam< ::LPDWORD, CNullPointerCheck >::TType pSize );

		static UINT EnumSystemFirmwareTables( DWORD FirmwareTableProviderSignature, void* pFirmwareTableBuffer, DWORD BufferSize );
		static DWORD ExpandEnvironmentStrings( LPCTSTR lpSrc, LPTSTR lpDst, DWORD nSize );
		static BOOL GetComputerName( LPTSTR lpBuffer, LPDWORD lpnSize );
		static BOOL GetComputerNameEx( ::COMPUTER_NAME_FORMAT NameType, LPTSTR lpBuffer, LPDWORD lpnSize );
		static DWORD GetFirmwareEnvironmentVariable( LPCTSTR lpName, LPCTSTR lpGuid, void* pBuffer, DWORD nSize );
		static void GetNativeSystemInfo( ::LPSYSTEM_INFO lpSystemInfo );
		static BOOL GetProductInfo( DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType );
		static UINT GetSystemDirectory( LPTSTR lpBuffer, UINT uSize );
		static UINT GetSystemFirmwareTable( DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, void* pFirmwareTableBuffer, DWORD BufferSize );
		static void GetSystemInfo( ::LPSYSTEM_INFO lpSystemInfo );
		static BOOL GetSystemRegistryQuota( PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed );
		static UINT GetSystemWindowsDirectory( LPTSTR lpBuffer, UINT uSize );
		static UINT GetSystemWow64Directory( LPTSTR lpBuffer, UINT uSize );
		static DWORD GetVersion(void);
		static BOOL GetVersionEx( ::LPOSVERSIONINFO lpVersionInfo );
		static UINT GetWindowsDirectoryA( CCheckParam< UINT, CNoCheck >::TType uSize, ::LPSTR lpBuffer );
		static UINT GetWindowsDirectoryW( CCheckParam< UINT, CNoCheck >::TType uSize, ::LPWSTR lpBuffer );
		static BOOL IsProcessorFeaturePresent( DWORD ProcessorFeature );
		static BOOL SetComputerName( CCheckParam< ::LPCTSTR, CNullPointerCheck >::TType lpComputerName );
		static BOOL SetComputerNameEx( ::COMPUTER_NAME_FORMAT NameType, CCheckParam< ::LPCTSTR, CNullPointerCheck >::TType lpBuffer );
		static BOOL SetFirmwareEnvironmentVariable( CCheckParam< ::LPCTSTR, CNullPointerCheck >::TType pName, LPCTSTR lpGuid, void* pBuffer, DWORD nSize );
		static BOOL VerifyVersionInfo( CCheckParam< ::LPOSVERSIONINFOEX, CTRWPointerCheck< sizeof( ::OSVERSIONINFOEX ) > >::TType lpVersionInfo, DWORD dwTypeMask, DWORDLONG dwlConditionMask );
		static ULONGLONG VerSetConditionMask( ULONGLONG dwlConditionMask, DWORD dwTypeBitMask, BYTE dwConditionMask );
		static DWORD EnumerateLocalComputerNames( int NameType, unsigned long ulFlags, void* lpBuffer, unsigned int nSize );

		//Console functions

		BOOL AddConsoleAlias( LPTSTR Source, LPTSTR Target, LPTSTR ExeName );
		static BOOL AllocConsole(void);
		static BOOL AttachConsole( DWORD dwProcessId );
		static HANDLE CreateConsoleScreenBuffer( DWORD dwDesiredAccess, DWORD dwShareMode, const ::SECURITY_ATTRIBUTES* lpSecurityAttributes, DWORD dwFlags, void* lpScreenBufferData );
		static BOOL FillConsoleOutputAttribute( HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, ::COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten );
		static BOOL FillConsoleOutputCharacter( HANDLE hConsoleOutput, TCHAR cCharacter, DWORD nLength, ::COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten );
		static BOOL FlushConsoleInputBuffer( HANDLE hConsoleInput );
		static BOOL FreeConsole(void);
		static BOOL GenerateConsoleCtrlEvent( DWORD dwCtrlEvent, DWORD dwProcessGroupId );
		DWORD GetConsoleAlias( LPTSTR lpSource, LPTSTR lpTargetBuffer, DWORD TargetBufferLength, LPTSTR lpExeName );
		DWORD GetConsoleAliases( LPTSTR lpAliasBuffer, DWORD AliasBufferLength, LPTSTR lpExeName );
		DWORD GetConsoleAliasesLength( LPTSTR lpExeName );
		DWORD GetConsoleAliasExes( LPTSTR lpExeNameBuffer, DWORD ExeNameBufferLength );
		DWORD GetConsoleAliasExesLength( VOID );
		static UINT GetConsoleCP(void);
		static BOOL GetConsoleCursorInfo( HANDLE hConsoleOutput, ::PCONSOLE_CURSOR_INFO lpConsoleCursorInfo );
		static BOOL GetConsoleDisplayMode( LPDWORD lpModeFlags );
		::COORD GetConsoleFontSize( HANDLE hConsoleOutput, DWORD nFont );
		BOOL GetConsoleHistoryInfo( ::PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo );
		static BOOL GetConsoleMode( HANDLE hConsoleHandle, LPDWORD lpMode );
		DWORD GetConsoleOriginalTitle( LPTSTR lpConsoleTitle, DWORD nSize );
		static UINT GetConsoleOutputCP(void);
		static DWORD GetConsoleProcessList( LPDWORD lpdwProcessList, DWORD dwProcessCount );
		static BOOL GetConsoleScreenBufferInfo( HANDLE hConsoleOutput, ::PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo );
		BOOL GetConsoleScreenBufferInfoEx( HANDLE hConsoleOutput, ::PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx );
		BOOL GetConsoleSelectionInfo( ::PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo );
		static DWORD GetConsoleTitle( LPTSTR lpConsoleTitle, DWORD nSize );
		static HWND GetConsoleWindow(void);
		BOOL GetCurrentConsoleFont( HANDLE hConsoleOutput, BOOL bMaximumWindow, ::PCONSOLE_FONT_INFO lpConsoleCurrentFont );
		BOOL GetCurrentConsoleFontEx( HANDLE hConsoleOutput, BOOL bMaximumWindow, ::PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx );
		static ::COORD GetLargestConsoleWindowSize( HANDLE hConsoleOutput );
		static BOOL GetNumberOfConsoleInputEvents( HANDLE hConsoleInput, LPDWORD lpcNumberOfEvents );
		static BOOL GetNumberOfConsoleMouseButtons( LPDWORD lpNumberOfMouseButtons );
		static HANDLE GetStdHandle( DWORD nStdHandle );
		static BOOL PeekConsoleInput( HANDLE hConsoleInput, ::PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead );
		static BOOL ReadConsole( HANDLE hConsoleInput, void* lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, ::PCONSOLE_READCONSOLE_CONTROL pReadcontrol );
		static BOOL ReadConsoleInput( HANDLE hConsoleInput, ::PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead );
		static BOOL ReadConsoleOutput( HANDLE hConsoleOutput, ::PCHAR_INFO lpBuffer, ::COORD dwBufferSize, ::COORD dwBufferCoord, ::PSMALL_RECT lpReadRegion );
		static BOOL ReadConsoleOutputAttribute( HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, ::COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead );
		static BOOL ReadConsoleOutputCharacter( HANDLE hConsoleOutput, LPTSTR lpCharacter, DWORD nLength, ::COORD dwReadCoord, LPDWORD lpNumberOfCharsRead );
		static BOOL ScrollConsoleScreenBuffer( HANDLE hConsoleOutput, const ::SMALL_RECT* lpScrollRectangle, const ::SMALL_RECT* lpClipRectangle, ::COORD dwDestinationOrigin, const ::CHAR_INFO* lpFill );
		static BOOL SetConsoleActiveScreenBuffer( HANDLE hConsoleOutput );
		static BOOL SetConsoleCP( UINT wCodePageID );
		static BOOL SetConsoleCtrlHandler( PHANDLER_ROUTINE HandlerRoutine, BOOL Add );
		static BOOL SetConsoleCursorInfo( HANDLE hConsoleOutput, const ::CONSOLE_CURSOR_INFO* lpConsoleCursorInfo );
		static BOOL SetConsoleCursorPosition( HANDLE hConsoleOutput, ::COORD dwCursorPosition );
		static BOOL SetConsoleMode( HANDLE hConsoleHandle, DWORD dwMode );
		static BOOL SetConsoleDisplayMode( HANDLE hConsoleOutput, DWORD dwFlags, ::PCOORD lpNewScreenBufferDimensions );
		BOOL SetConsoleHistoryInfo( ::PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo );
		static BOOL SetConsoleOutputCP( UINT wCodePageID );
		BOOL SetConsoleScreenBufferInfoEx( HANDLE hConsoleOutput, ::PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx );
		static BOOL SetConsoleScreenBufferSize( HANDLE hConsoleOutput, ::COORD dwSize );
		static BOOL SetConsoleTextAttribute( HANDLE hConsoleOutput, WORD wAttributes );
		static BOOL SetConsoleTitle( LPCTSTR lpConsoleTitle );
		static BOOL SetConsoleWindowInfo( HANDLE hConsoleOutput, BOOL bAbsolute, const ::SMALL_RECT* lpConsoleWindow );
		BOOL SetCurrentConsoleFontEx( HANDLE hConsoleOutput, BOOL bMaximumWindow, ::PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx );
		static BOOL SetStdHandle( DWORD nStdHandle, HANDLE hHandle );
		static BOOL WriteConsoleA( HANDLE hConsoleOutput, const VOID* lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, void* lpReserved );
		static BOOL WriteConsoleW( HANDLE hConsoleOutput, const VOID* lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, void* lpReserved );
		static BOOL WriteConsoleInput( HANDLE hConsoleInput, const ::INPUT_RECORD* lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten );
		static BOOL WriteConsoleOutput( HANDLE hConsoleOutput, const ::CHAR_INFO* lpBuffer, ::COORD dwBufferSize, ::COORD dwBufferCoord, ::PSMALL_RECT lpWriteRegion );
		static BOOL WriteConsoleOutputAttribute( HANDLE hConsoleOutput, const WORD* lpAttribute, DWORD nLength, ::COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten );
		static BOOL WriteConsoleOutputCharacter( HANDLE hConsoleOutput, LPCTSTR lpCharacter, DWORD nLength, ::COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten );
		static BOOL GetConsoleFontInfo( HANDLE h, BOOL b, DWORD dw, PCONSOLE_FONT pConsoleFont );
		static DWORD CtrlRoutine( LPVOID lpParameter );

		//Time functions

		static LONG CompareFileTime( const ::FILETIME* lpFileTime1, const ::FILETIME* lpFileTime2 );
		static BOOL DosDateTimeToFileTime( WORD wFatDate, WORD wFatTime, ::LPFILETIME lpFileTime );
		static BOOL FileTimeToDosDateTime( const ::FILETIME* lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime );
		static BOOL FileTimeToLocalFileTime( const ::FILETIME* lpFileTime, ::LPFILETIME lpLocalFileTime );
		static BOOL FileTimeToSystemTime( const ::FILETIME* lpFileTime, ::LPSYSTEMTIME lpSystemTime );
		static DWORD GetDynamicTimeZoneInformation( ::PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation );
		static BOOL GetFileTime( HANDLE hFile, ::LPFILETIME lpCreationTime, ::LPFILETIME lpLastAccessTime, ::LPFILETIME lpLastWriteTime );
		static void GetLocalTime( ::LPSYSTEMTIME lpSystemTime );
		static void GetSystemTime( ::LPSYSTEMTIME lpSystemTime );
		static BOOL GetSystemTimeAdjustment( PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled );
		static void GetSystemTimeAsFileTime( CCheckParam< ::LPFILETIME, CTRWPointerCheck< sizeof( ::FILETIME ) > >::TType lpSystemTimeAsFileTime );
		static BOOL GetSystemTimes( ::LPFILETIME lpIdleTime, ::LPFILETIME lpKernelTime, ::LPFILETIME lpUserTime );
		static DWORD GetTickCount(void);
		static ULONGLONG GetTickCount64(void);
		static DWORD GetTimeZoneInformation( ::LPTIME_ZONE_INFORMATION lpTimeZoneInformation );
		static BOOL GetTimeZoneInformationForYear( USHORT wYear, ::PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, ::LPTIME_ZONE_INFORMATION ptzi );
		static BOOL LocalFileTimeToFileTime( const ::FILETIME* lpLocalFileTime, ::LPFILETIME lpFileTime );
		static BOOL SetDynamicTimeZoneInformation( const ::DYNAMIC_TIME_ZONE_INFORMATION* lpTimeZoneInformation );
		static BOOL SetFileTime( HANDLE hFile, const ::FILETIME* lpCreationTime, const ::FILETIME* lpLastAccessTime, const ::FILETIME* lpLastWriteTime );
		static BOOL SetLocalTime( const ::SYSTEMTIME* lpSystemTime );
		static BOOL SetSystemTime( const ::SYSTEMTIME* lpSystemTime );
		static BOOL SetSystemTimeAdjustment( DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled );
		static BOOL SetTimeZoneInformation( const ::TIME_ZONE_INFORMATION* lpTimeZoneInformation );
		static BOOL SystemTimeToFileTime( const ::SYSTEMTIME* lpSystemTime, ::LPFILETIME lpFileTime );
		static BOOL SystemTimeToTzSpecificLocalTime( ::LPTIME_ZONE_INFORMATION lpTimeZone, ::LPSYSTEMTIME lpUniversalTime, ::LPSYSTEMTIME lpLocalTime );
		static BOOL TzSpecificLocalTimeToSystemTime( ::LPTIME_ZONE_INFORMATION lpTimeZoneInformation, ::LPSYSTEMTIME lpLocalTime, ::LPSYSTEMTIME lpUniversalTime );

		//Error handling functions

		static BOOL Beep( DWORD dwFreq, DWORD dwDuration );
		static USHORT RtlCaptureStackBackTrace( ULONG FramesToSkip, ULONG FramesToCapture, void** BackTrace, PULONG BackTraceHash );
		static void FatalAppExit( UINT uAction, LPCTSTR lpMessageText );
		static DWORD FormatMessage( DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPTSTR lpBuffer, DWORD nSize, va_list* Arguments );
		static UINT GetErrorMode(void);
		static DWORD GetLastError(void);
		static void* RtlLookupFunctionEntry( ULONGLONG ControlPC, PULONGLONG ImageBase, PUNWIND_HISTORY_TABLE TargetGp );
		static void* RtlPcToFileHeader( void* PcValue, void** BaseOfImage );
		void RtlUnwind( void* TargetFrame, void* TargetIp, ::PEXCEPTION_RECORD ExceptionRecord, void* ReturnValue );
		static UINT SetErrorMode( UINT uMode );
		static void SetLastError( DWORD dwErrCode );
		static HRESULT WerGetFlags( HANDLE hProcess, PDWORD pdwFlags );
		static HRESULT WerRegisterFile( PCWSTR pwzFile, ::WER_REGISTER_FILE_TYPE regFileType, DWORD dwFlags );
		static HRESULT WerRegisterMemoryBlock( void* pvAddress, DWORD dwSize );
		static HRESULT WerSetFlags( DWORD dwFlags );
		static HRESULT WerUnregisterFile( PCWSTR pwzFilePath );
		static HRESULT WerUnregisterMemoryBlock( void* pvAddress );

		//IA64 only
		static void RtlUnwind2( FRAME_POINTERS TargetFrame, void* TargetIp, PEXCEPTION_RECORD ExceptionRecord, void* ReturnValue, PCONTEXT OriginalContext );
		static void RtlUnwindEx( FRAME_POINTERS TargetFrame, void* TargetIp, PEXCEPTION_RECORD ExceptionRecord, void* ReturnValue, PCONTEXT OriginalContext, PUNWIND_HISTORY_TABLE HistoryTable );
		static ULONGLONG RtlVirtualUnwind( ULONGLONG ImageBase, ULONGLONG ControlPC, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PBOOLEAN InFunction, PFRAME_POINTERS EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers );
		//Multilingual User Interface functions

		static BOOL EnumUILanguages( ::UILANGUAGE_ENUMPROC pUILangEnumProc, DWORD dwFlags, LONG_PTR lParam );
		static BOOL GetFileMUInfo( DWORD dwFlags, PCWSTR pcwszFilePath, PFILEMUIINFO pFileMUIInfo, DWORD* pcbFileMUIInfo );
		static BOOL GetFileMUIPath( DWORD dwFlags, PCWSTR pcwszFilePath, PWSTR pwszLanguage, PULONG pcchLanguage, PWSTR pwszFileMUIPath, PULONG pcchFileMUIPath, PULONGLONG pululEnumerator );
		static LANGID GetSystemDefaultUILanguage(void);
		static BOOL GetSystemPreferredUILanguages( DWORD dwFlags, PULONG pulNumLanguages, PWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer );
		static BOOL GetThreadPreferredUILanguages( DWORD dwFlags, PULONG pulNumLanguages, PWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer );
		static LANGID GetThreadUILanguage(void);
		static BOOL GetUILanguageInfo( DWORD dwFlags, PCWSTR pwmszLanguage, PWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pdwAttributes );
		static LANGID GetUserDefaultUILanguage(void);
		static BOOL GetUserPreferredUILanguages ( DWORD dwFlags, PULONG pulNumLanguages, PWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer );
		static BOOL SetThreadPreferredUILanguages( DWORD dwFlags, PCWSTR pwszLanguagesBuffer, PULONG pulNumLanguages );
		static LANGID SetThreadUILanguage( LANGID LangId );

		//Pipe functions

		static BOOL CallNamedPipe( LPCTSTR lpNamedPipeName, void* lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut );
		static BOOL ConnectNamedPipe( HANDLE hNamedPipe, ::LPOVERLAPPED lpOverlapped );
		static HANDLE CreateNamedPipe( LPCTSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes );
		static BOOL CreatePipe( PHANDLE hReadPipe, PHANDLE hWritePipe, ::LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize );
		static BOOL DisconnectNamedPipe( HANDLE hNamedPipe );
		static BOOL GetNamedPipeClientComputerName( HANDLE Pipe, LPTSTR ClientComputerName, ULONG ClientComputerNameLength );
		static BOOL GetNamedPipeClientProcessId( HANDLE Pipe, PULONG ClientProcessId );
		static BOOL GetNamedPipeClientSessionId( HANDLE Pipe, PULONG ClientSessionId );
		static BOOL GetNamedPipeHandleState( HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPTSTR lpUserName, DWORD nMaxUserNameSize );
		static BOOL GetNamedPipeInfo( HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances );
		static BOOL GetNamedPipeServerProcessId( HANDLE Pipe, PULONG ServerProcessId );
		static BOOL GetNamedPipeServerSessionId( HANDLE Pipe, PULONG ServerSessionId );
		static BOOL PeekNamedPipe( HANDLE hNamedPipe, void* lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage );
		static BOOL SetNamedPipeHandleState( HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout );
		static BOOL TransactNamedPipe( HANDLE hNamedPipe, void* lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, ::LPOVERLAPPED lpOverlapped );
		static BOOL WaitNamedPipe( LPCTSTR lpNamedPipeName, DWORD nTimeOut );

		//Volume Management functions

		static BOOL DefineDosDevice( DWORD dwFlags, LPCTSTR lpDeviceName, LPCTSTR lpTargetPath );
		static BOOL DeleteVolumeMountPoint( LPCTSTR lpszVolumeMountPoint );
		static HANDLE FindFirstVolume( LPTSTR lpszVolumeName, DWORD cchBufferLength );
		static HANDLE FindFirstVolumeMountPoint( LPTSTR lpszRootPathName, LPTSTR lpszVolumeMountPoint, DWORD cchBufferLength );
		static BOOL FindNextVolume( HANDLE hFindVolume, LPTSTR lpszVolumeName, DWORD cchBufferLength );
		static BOOL FindNextVolumeMountPoint( HANDLE hFindVolumeMountPoint, LPTSTR lpszVolumeMountPoint, DWORD cchBufferLength );
		static BOOL FindVolumeClose( HANDLE hFindVolume );
		static BOOL FindVolumeMountPointClose( HANDLE hFindVolumeMountPoint );
		static UINT GetDriveType( LPCTSTR lpRootPathName );
		static DWORD GetLogicalDrives(void);
		static DWORD GetLogicalDriveStrings( DWORD nBufferLength, LPTSTR lpBuffer );
		static BOOL GetVolumeInformation( LPCTSTR lpRootPathName, LPTSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPTSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize );
		static BOOL GetVolumeInformationByHandleW( HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize );
		static BOOL GetVolumeNameForVolumeMountPoint( LPCTSTR lpszVolumeMountPoint, LPTSTR lpszVolumeName, DWORD cchBufferLength );
		static BOOL GetVolumePathName( LPCTSTR lpszFileName, LPTSTR lpszVolumePathName, DWORD cchBufferLength );
		static BOOL GetVolumePathNamesForVolumeName( LPCTSTR lpszVolumeName, LPTSTR lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength );
		static DWORD QueryDosDevice( LPCTSTR lpDeviceName, LPTSTR lpTargetPath, DWORD ucchMax );
		static BOOL SetVolumeLabel( LPCTSTR lpRootPathName, LPCTSTR lpVolumeName );
		static BOOL SetVolumeMountPoint( LPCTSTR lpszVolumeMountPoint, LPCTSTR lpszVolumeName );

		//Debugging functions

		static BOOL CheckRemoteDebuggerPresent( HANDLE hProcess, PBOOL pbDebuggerPresent );
		static BOOL ContinueDebugEvent( DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus );
		static BOOL DebugActiveProcess( DWORD dwProcessId );
		static BOOL DebugActiveProcessStop( DWORD dwProcessId );
		static void DebugBreak(void);
		static BOOL DebugBreakProcess( HANDLE Process );
		static BOOL DebugSetProcessKillOnExit( BOOL KillOnExit );
		static void FatalExit( int ExitCode );
		static BOOL FlushInstructionCache( HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize );
		static BOOL GetThreadContext( HANDLE hThread, LPCONTEXT lpContext );
		static BOOL GetThreadSelectorEntry( HANDLE hThread, DWORD dwSelector, ::LPLDT_ENTRY lpSelectorEntry );
		static BOOL IsDebuggerPresent(void);
		static void OutputDebugStringA( LPCSTR lpOutputString );
		static void OutputDebugStringW( LPCWSTR lpOutputString );
		static BOOL ReadProcessMemory( HANDLE hProcess, LPCVOID lpBaseAddress, void* lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead );
		static BOOL SetThreadContext( HANDLE hThread, const ::CONTEXT* lpContext );
		static BOOL WaitForDebugEvent( ::LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds );
		static BOOL Wow64GetThreadContext( HANDLE hThread, ::PWOW64_CONTEXT lpContext );
		static BOOL Wow64SetThreadContext( HANDLE hThread, const ::WOW64_CONTEXT* lpContext );
		static BOOL WriteProcessMemory( HANDLE hProcess, void* lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten );
#ifndef __MINGW32__
		static BOOL Thread32First( HANDLE hSnapshot, ::LPTHREADENTRY32 lpte );
		static BOOL Thread32Next( HANDLE hSnapshot, ::LPTHREADENTRY32 lpte );
		static BOOL Toolhelp32ReadProcessMemory( DWORD th32ProcessID, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T cbRead, SIZE_T* lpNumberOfBytesRead );
		static BOOL Process32First( HANDLE hSnapshot, ::LPPROCESSENTRY32 lppe );
		static BOOL Process32Next( HANDLE hSnapshot, ::LPPROCESSENTRY32 lppe );
		static BOOL Module32First( HANDLE hSnapshot, ::LPMODULEENTRY32 lpme );
		static BOOL Module32Next( HANDLE hSnapshot, ::LPMODULEENTRY32 lpme );
		static BOOL Heap32First( ::LPHEAPENTRY32 lphe, DWORD th32ProcessID, ULONG_PTR th32HeapID );
		static BOOL Heap32ListFirst( HANDLE hSnapshot, ::LPHEAPLIST32 lphl );
		static BOOL Heap32ListNext( HANDLE hSnapshot, ::LPHEAPLIST32 lphl );
		static BOOL Heap32Next( ::LPHEAPENTRY32 lphe );
		static HANDLE CreateToolhelp32Snapshot( DWORD dwFlags, DWORD th32ProcessID );
#endif
		static BOOL IsBadHugeReadPtr( CONST VOID* lp, UINT_PTR ucb );
		static BOOL IsBadHugeWritePtr( void* lp, UINT_PTR ucb );

		//Activation Context functions

		static BOOL ActivateActCtx( CCheckParam< HANDLE, CHandleParamCheck >::TType hActCtx, CCheckParam< ULONG_PTR*, CTWritablePointerCheck< sizeof( ULONG_PTR ) > >::TType pCookie );
		static void AddRefActCtx( CCheckParam< HANDLE, CHandleParamCheck >::TType hActCtx );
		static HANDLE CreateActCtx( CCheckParam< ::PACTCTX, CTRWPointerCheck< sizeof( ::ACTCTX ) > >::TType pActCtx );
		static BOOL DeactivateActCtx( DWORD dwFlags, ULONG_PTR ulCookie );
		static BOOL FindActCtxSectionGuid( DWORD dwFlags, const GUID* lpExtensionGuid, ULONG ulSectionId, const GUID* lpGuidToFind, ::PACTCTX_SECTION_KEYED_DATA ReturnedData );
		static BOOL FindActCtxSectionString( DWORD dwFlags, const GUID* lpExtensionGuid, ULONG ulSectionId, LPCTSTR lpStringToFind, ::PACTCTX_SECTION_KEYED_DATA ReturnedData );
		static BOOL GetCurrentActCtx( HANDLE* lphActCtx );
		#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)
		static void IsolationAwareCleanup(void) const;
		#endif
		static BOOL QueryActCtxW( DWORD dwFlags, HANDLE hActCtx, void* pvSubInstance, ULONG ulInfoClass, void* pvBuffer, SIZE_T cbBuffer, SIZE_T* pcbWrittenOrRequired );
		static BOOL QueryActCtxSettingsW( DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T* pdwWrittenOrRequired );
		static void ReleaseActCtx( HANDLE hActCtx );
		static BOOL ZombifyActCtx( HANDLE hActCtx );

		//Atom functions

		static ATOM AddAtom( LPCTSTR lpString );
		static ATOM DeleteAtom( ATOM nAtom );
		static ATOM FindAtom( LPCTSTR lpString );
		static UINT GetAtomName( ATOM nAtom, LPTSTR lpBuffer, int nSize );
		static ATOM GlobalAddAtom( LPCTSTR lpString );
		static ATOM GlobalDeleteAtom( ATOM nAtom );
		static ATOM GlobalFindAtom( LPCTSTR lpString );
		static UINT GlobalGetAtomName( ATOM nAtom, LPTSTR lpBuffer, int nSize );
		static BOOL InitAtomTable( DWORD nSize );

		//Backup functions

		static BOOL BackupRead( HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, void** lpContext );
		static BOOL BackupSeek( HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, void* *lpContext );
		static BOOL BackupWrite( HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, void** lpContext );
		static void TapeAPIResult( nsCodeQOR::CTLRef< mxTCHAR > StrAPI, DWORD dwResult );
		static DWORD CreateTapePartition( HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize );
		static DWORD EraseTape( HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate );
		static DWORD GetTapeParameters( HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, void* lpTapeInformation );
		static DWORD GetTapePosition( HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh );
		static DWORD GetTapeStatus( HANDLE hDevice );
		static DWORD PrepareTape( HANDLE hDevice, DWORD dwOperation, BOOL bImmediate );
		static DWORD SetTapeParameters( HANDLE hDevice, DWORD dwOperation, void* lpTapeInformation );
		static DWORD SetTapePosition( HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate );
		static DWORD WriteTapemark( HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate );

		//Communications functions

		static BOOL BuildCommDCB( LPCTSTR lpDef, ::LPDCB lpDCB );
		static BOOL BuildCommDCBAndTimeouts( LPCTSTR lpDef, ::LPDCB lpDCB, ::LPCOMMTIMEOUTS lpCommTimeouts );
		static BOOL ClearCommBreak( HANDLE hFile );
		static BOOL ClearCommError( HANDLE hFile, LPDWORD lpErrors, ::LPCOMSTAT lpStat );
		static BOOL CommConfigDialog( LPCTSTR lpszName, HWND hWnd, ::LPCOMMCONFIG lpCC );
		static BOOL EscapeCommFunction( HANDLE hFile, DWORD dwFunc );
		static BOOL GetCommConfig( HANDLE hCommDev, ::LPCOMMCONFIG lpCC, LPDWORD lpdwSize );
		static BOOL GetCommMask( HANDLE hFile, LPDWORD lpEvtMask );
		static BOOL GetCommModemStatus( HANDLE hFile, LPDWORD lpModemStat );
		static BOOL GetCommProperties( HANDLE hFile, ::LPCOMMPROP lpCommProp );
		static BOOL GetCommState( HANDLE hFile, ::LPDCB lpDCB );
		static BOOL GetCommTimeouts( HANDLE hFile, ::LPCOMMTIMEOUTS lpCommTimeouts );
		static BOOL GetDefaultCommConfig( LPCTSTR lpszName, ::LPCOMMCONFIG lpCC, LPDWORD lpdwSize );
		static BOOL PurgeComm( HANDLE hFile, DWORD dwFlags );
		static BOOL SetCommBreak( HANDLE hFile );
		static BOOL SetCommConfig( HANDLE hCommDev, ::LPCOMMCONFIG lpCC, DWORD dwSize );
		static BOOL SetCommMask( HANDLE hFile, DWORD dwEvtMask );
		static BOOL SetCommState( HANDLE hFile, ::LPDCB lpDCB );
		static BOOL SetCommTimeouts( HANDLE hFile, ::LPCOMMTIMEOUTS lpCommTimeouts );
		static BOOL SetDefaultCommConfig( LPCTSTR lpszName, ::LPCOMMCONFIG lpCC, DWORD dwSize );
		static BOOL SetupComm( HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue );
		static BOOL TransmitCommChar( HANDLE hFile, char cChar );
		static BOOL WaitCommEvent( HANDLE hFile, LPDWORD lpEvtMask, ::LPOVERLAPPED lpOverlapped );

		//System functions
		static DWORD AddLocalAlternateComputerName( LPCTSTR lpDnsFQHostname, ULONG ulFlags );
		//Unsupported, may get removed
		static FARPROC DelayLoadFailureHook( LPCSTR pszDllName, LPCSTR pszProcName );
		static void* DecodePointer( void* Ptr );
		static void* DecodeSystemPointer( void* Ptr );
		static void* EncodePointer( void* Ptr );
		static void* EncodeSystemPointer( void* Ptr );

		//Registry functions
		static UINT GetPrivateProfileInt( LPCTSTR lpAppName, LPCTSTR lpKeyName, INT nDefault, LPCTSTR lpFileName );
		static DWORD GetPrivateProfileSection( LPCTSTR lpAppName, LPTSTR lpReturnedString, DWORD nSize, LPCTSTR lpFileName );
		static DWORD GetPrivateProfileSectionNames( LPTSTR lpszReturnBuffer, DWORD nSize, LPCTSTR lpFileName );
		static DWORD GetPrivateProfileString( LPCTSTR lpAppName, LPCTSTR lpKeyName, LPCTSTR lpDefault, LPTSTR lpReturnedString, DWORD nSize, LPCTSTR lpFileName );
		static BOOL GetPrivateProfileStruct( LPCTSTR lpszSection, LPCTSTR lpszKey, void* lpStruct, UINT uSizeStruct, LPCTSTR szFile );
		static UINT GetProfileInt( LPCTSTR lpAppName, LPCTSTR lpKeyName, INT nDefault );
		static DWORD GetProfileSection( LPCTSTR lpAppName, LPTSTR lpReturnedString, DWORD nSize );
		static DWORD GetProfileString( LPCTSTR lpAppName, LPCTSTR lpKeyName, LPCTSTR lpDefault, LPTSTR lpReturnedString, DWORD nSize );
		static BOOL WritePrivateProfileSection( LPCTSTR lpAppName, LPCTSTR lpString, LPCTSTR lpFileName );
		static BOOL WritePrivateProfileString( LPCTSTR lpAppName, LPCTSTR lpKeyName, LPCTSTR lpString, LPCTSTR lpFileName );
		static BOOL WritePrivateProfileStruct( LPCTSTR lpszSection, LPCTSTR lpszKey, void* lpStruct, UINT uSizeStruct, LPCTSTR szFile );
		static BOOL WriteProfileSection( LPCTSTR lpAppName, LPCTSTR lpString );
		static BOOL WriteProfileString( LPCTSTR lpAppName, LPCTSTR lpKeyName, LPCTSTR lpString );

		//Power Management functions
		static BOOL GetDevicePowerState( HANDLE hDevice, BOOL* pfOn );
		static BOOL CancelDeviceWakeupRequest( HANDLE hDevice );
		static BOOL GetSystemPowerStatus( ::LPSYSTEM_POWER_STATUS lpSystemPowerStatus );
		static BOOL IsSystemResumeAutomatic(void);
		static BOOL RequestWakeupLatency( ::LATENCY_TIME latency );
		static EXECUTION_STATE SetThreadExecutionState( EXECUTION_STATE esFlags );
		//NOTE: If we have Vista use SetSuspendState instead
		static BOOL SetSystemPowerState( BOOL fSuspend, BOOL fForce );
		static BOOL SetMessageWaitingIndicator( HANDLE hIndicator, ULONG cmsg );

		//String Functions
		int CompareStringEx( LPCWSTR lpLocaleName, DWORD dwCmpFlags, LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2, ::LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam );
		static int CompareStringA( LCID Locale, DWORD dwCmpFlags, LPCSTR lpString1, int cchCount1, LPCSTR lpString2, int cchCount2 );
		static int CompareStringW( LCID Locale, DWORD dwCmpFlags, LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2 );
		static int FoldString( DWORD dwMapFlags, LPCTSTR lpSrcStr, int cchSrc, LPTSTR lpDestStr, int cchDest );
		static BOOL GetStringTypeA( LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType );
		static BOOL GetStringTypeEx( LCID Locale, DWORD dwInfoType, LPCTSTR lpSrcStr, int cchSrc, LPWORD lpCharType );
		static BOOL GetStringTypeW( DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType );
		static BOOL IsDBCSLeadByte( BYTE TestChar );
		static BOOL IsDBCSLeadByteEx( UINT CodePage, BYTE TestChar );
		static int MultiByteToWideChar( UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar );
		static int WideCharToMultiByte( unsigned int uiCodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar );

		//Device Functions
		static BOOL DeviceIoControl( HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, void* lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, ::LPOVERLAPPED lpOverlapped );

		//Terminal Services Functions
		static BOOL ProcessIdToSessionId( DWORD dwProcessId, DWORD* pSessionId );
		static BOOL TermsrvAppInstallMode(void);
		static DWORD WTSGetActiveConsoleSessionId(void);

		//Dynamic Link Library functions
		static BOOL DisableThreadLibraryCalls( HMODULE hModule );
		static BOOL FreeLibrary( HMODULE hModule );
		static VOID FreeLibraryAndExitThread( HMODULE hModule, DWORD dwExitCode );
		static DWORD GetModuleFileName( HMODULE hModule, LPTSTR lpFilename, DWORD nSize );
		static HMODULE GetModuleHandle( LPCTSTR lpModuleName );
		static FARPROC GetProcAddress( HMODULE hModule, LPCSTR lpProcName );
		static HMODULE LoadLibrary( LPCTSTR lpFileName );
		static HMODULE LoadLibraryEx( LPCTSTR lpFileName, HANDLE hFile, DWORD dwFlags );
		static BOOL GetModuleHandleEx( DWORD dwFlags, LPCTSTR lpModuleName, HMODULE* phModule );
		static DWORD GetDllDirectory( DWORD nBufferLength, LPTSTR lpBuffer );
		static BOOL SetDllDirectory( LPCTSTR lpPathName );

		//Timer functions
		static BOOL QueryPerformanceCounter( CCheckParam< ::LARGE_INTEGER*, CTRWPointerCheck< sizeof( ::LARGE_INTEGER ) > >::TType pPerformanceCount );
		static BOOL QueryPerformanceFrequency( CCheckParam< ::LARGE_INTEGER*, CTRWPointerCheck< sizeof( ::LARGE_INTEGER ) > >::TType lpFrequency );

		//Disk Management Functions
		static BOOL GetDiskFreeSpace( LPCTSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters );
		static BOOL GetDiskFreeSpaceEx( LPCTSTR lpDirectoryName, ::PULARGE_INTEGER lpFreeBytesAvailable, ::PULARGE_INTEGER lpTotalNumberOfBytes, ::PULARGE_INTEGER lpTotalNumberOfFreeBytes );

		//Handle Functions
		static BOOL CloseHandle( HANDLE hObject );
		static BOOL DuplicateHandle( HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions );
		static BOOL GetHandleInformation( HANDLE hObject, LPDWORD lpdwFlags );
		static BOOL SetHandleInformation( HANDLE hObject, DWORD dwMask, DWORD dwFlags );

		//Mail Slot Functions
		static HANDLE CreateMailslot( LPCTSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, ::LPSECURITY_ATTRIBUTES lpSecurityAttributes );
		static BOOL GetMailslotInfo( HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout );
		static BOOL SetMailslotInfo( HANDLE hMailslot, DWORD lReadTimeout );

		static int MulDiv( int nNumber, int nNumerator, int nDenominator );

	};

}//nsWinQAPI

#endif//WINQAPI_MODULES_KERNEL_H_2
