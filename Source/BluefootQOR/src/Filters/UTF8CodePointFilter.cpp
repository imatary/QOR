//UTF8CodePointFilter.cpp

// Copyright Querysoft Limited 2013, 2016
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "BluefootQOR/Filters/UTF8CodePointFilter.h"

//------------------------------------------------------------------------------
namespace nsBluefoot
{
	//------------------------------------------------------------------------------
	byte CUTF8CodePointFilter::scBOM[ 3 ] = 
	{
		0xEF, 0xBB, 0xBF
	};

	//------------------------------------------------------------------------------
	CUTF8CodePointFilter::CUTF8CodePointFilter() : CFilter()
	,	m_Part( BOM )
	,	m_ucSequenceLength( 0 )
	,	m_ucSequence( 0 )
	,	m_bBOMPresent( false )
	{
		ClearCodeUnits();
		m_SourceBuffer.SetCapacity( 1 );
	}

	//------------------------------------------------------------------------------
	CUTF8CodePointFilter::~CUTF8CodePointFilter()
	{
	}

	//------------------------------------------------------------------------------
	CUTF8CodePointFilter::CUTF8CodePointFilter( const CUTF8CodePointFilter& src ) : CFilter( src )
	{
	}

	//------------------------------------------------------------------------------
	CUTF8CodePointFilter& CUTF8CodePointFilter::operator = ( const CUTF8CodePointFilter& src )
	{
		if( &src != this ){}
		return *this;
	}

	//------------------------------------------------------------------------------
	CBuffer* CUTF8CodePointFilter::GetSourceBuffer( void )
	{
		return &m_SourceBuffer;
	}

	//------------------------------------------------------------------------------
	void CUTF8CodePointFilter::ClearCodeUnits( void )
	{
		m_code_unit[ 0 ]  = 0;
		m_code_unit[ 1 ]  = 0;
		m_code_unit[ 2 ]  = 0;
		m_code_unit[ 3 ]  = 0;
	}

	//------------------------------------------------------------------------------
	void CUTF8CodePointFilter::ReadNextBytesFromSourceBuffer( unsigned char ucBytes )
	{
		unsigned long ulBytes = ucBytes;
		byte* pBuffer = m_SinkProxy.GetSource()->GetBuffer()->ReadRequest( ulBytes );
		if( ulBytes == ucBytes && pBuffer )
		{
			while( ucBytes-- )
			{
				m_code_unit[ m_ucSequence++ ] = *pBuffer;
			}
		}
		m_SinkProxy.GetSource()->GetBuffer()->ReadAcknowledge( ulBytes );
	}

	//------------------------------------------------------------------------------
	bool CUTF8CodePointFilter::WriteCodePoint( unsigned int uiCodePoint )
	{
		bool bResult = false;
		unsigned long ulSingleItem = 1;
		unsigned int* pBuffer = reinterpret_cast< unsigned int* >( m_SourceBuffer.WriteRequest( ulSingleItem ) );
		if( ulSingleItem == 1 && pBuffer )
		{
			pBuffer[ 0 ] = uiCodePoint;
			m_SourceBuffer.WriteAcknowledge( ulSingleItem );
			bResult = true;
		}
		return bResult;
	}

	//------------------------------------------------------------------------------
	bool CUTF8CodePointFilter::ReadACodePointFromAUTF8Source( unsigned long& ulUnitsRead )
	{
		m_ucSequence = 0;
		ClearCodeUnits();
		unsigned long ulBytes = 0;
		//unsigned long ulCodePointsWritten = 0;
		unsigned int uiCodePoint = 0;
		if( m_SinkProxy.GetSource()->Read( ulBytes, 1 ) && ulBytes == 1 )
		{
			ReadNextBytesFromSourceBuffer();

			if( m_code_unit[ 0 ] < 0x80 )
			{
				// 1-byte sequence
				uiCodePoint = m_code_unit[ 0 ];
				ulUnitsRead += WriteCodePoint( uiCodePoint ) ? 1 : 0;
				return true;
			}
			else if( m_code_unit[ 0 ] < 0xC2 )
			{
				return true;
			}
			else if( m_code_unit[ 0 ] < 0xE0 )
			{
				// 2-byte sequence
				if( m_SinkProxy.GetSource()->Read( ulBytes, 1 ) && ulBytes == 1 )
				{
					ReadNextBytesFromSourceBuffer();

					if( ( m_code_unit[ 1 ] & 0xC0 ) != 0x80 )
					{
						return true;
					}
					else
					{
						uiCodePoint = ( ( m_code_unit[ 0 ] << 6 ) + m_code_unit[ 1 ] - 0x3080 );
						ulUnitsRead += WriteCodePoint( uiCodePoint ) ? 1 : 0;
						return true;
					}
				}
				else
				{
					return false;
				}
			}
			else if( m_code_unit[ 0 ] < 0xF0 )
			{
				// 3-byte sequence
				if( m_SinkProxy.GetSource()->Read( ulBytes, 2 ) && ulBytes == 2 )
				{
					ReadNextBytesFromSourceBuffer( 2 );

					if( ( m_code_unit[ 1 ] & 0xC0 ) != 0x80 || ( m_code_unit[ 2 ] & 0xC0 ) != 0x80 )
					{
						return true;
					}
					else if( m_code_unit[ 0 ] == 0xE0 && m_code_unit[ 1 ] < 0xA0 )
					{
						return true;
					}
					else
					{
						uiCodePoint = ( ( m_code_unit[ 0 ] << 12 ) + ( m_code_unit[ 1 ] << 6 ) + m_code_unit[ 2 ] - 0xE2080 );
						ulUnitsRead += WriteCodePoint( uiCodePoint ) ? 1 : 0;
						return true;
					}
				}
				else
				{
					return false;
				}
			}
			else if( m_code_unit[ 0 ] < 0xF5 )
			{
				// 4-byte sequence
				if( m_SinkProxy.GetSource()->Read( ulBytes, 3 ) && ulBytes == 3 )
				{
					ReadNextBytesFromSourceBuffer( 3 );

					if( ( m_code_unit[ 1 ] & 0xC0 ) != 0x80 || ( m_code_unit[ 2 ] & 0xC0 ) != 0x80 || ( m_code_unit[ 3 ] & 0xC0 ) != 0x80 )
					{
						return true;
					}
					else if( m_code_unit[ 0 ] == 0xF0 && m_code_unit[ 1 ] < 0x90 )
					{
						return true;
					}
					else if( m_code_unit[ 0 ] == 0xF4 && m_code_unit[ 1 ] >= 0x90 )
					{
						return true;
					}
					else
					{
						uiCodePoint = ( ( m_code_unit[ 0 ] << 18 ) + ( m_code_unit[ 1 ] << 12 ) + ( m_code_unit[ 2 ] << 6 ) + m_code_unit[ 3 ]- 0x3C820280 );
						ulUnitsRead += WriteCodePoint( uiCodePoint ) ? 1 : 0;
						return true;
					}
				}
				else
				{
					return false;
				}
			}
			else
			{
				// > U+10FFFF
				return true;
			}
		}
		else
		{
			return false;
		}
	}

	//------------------------------------------------------------------------------
	bool CUTF8CodePointFilter::Read( unsigned long& ulUnitsRead, unsigned long ulUnitsToRead )
	{
		while( ulUnitsRead < ulUnitsToRead )
		{
			if( !ReadACodePointFromAUTF8Source( ulUnitsRead ) )
			{
				break;
			}
		}

		return ulUnitsRead > 0 ? true : false;
	}
	
	//------------------------------------------------------------------------------
	void CUTF8CodePointFilter::ProcessBOMUnit( byte testByte, unsigned long& ulIndex )
	{
		if( testByte == scBOM[ m_ucSequence ] )
		{
			m_ucSequence++;
			if( m_ucSequence == 3 )
			{
				m_Part = Text;
				m_bBOMPresent = true;
				m_ucSequence = 0;
			}
		}
		else
		{
			m_Part = Text;
			ulIndex = 0;
			m_ucSequence = 0;
			m_bBOMPresent = false;
		}
	}
	
	//------------------------------------------------------------------------------
	void CUTF8CodePointFilter::ProcessFirstCodeUnit( byte testByte )
	{
		m_code_unit[ 0 ] = testByte;
		if( testByte < 0x80 )
		{
			//Write character			
			unsigned int uiCodePoint = testByte;
			WriteCodePoint( uiCodePoint );
			unsigned long ulCodePointWritten = 0;
			m_SourceProxy.GetSink()->Write( ulCodePointWritten, 1 );
			m_ucSequence = 0;
			m_ucSequenceLength = 0;
			ClearCodeUnits();
		}
		else if( testByte < 0xC2 )
		{
			//Continuation or overlong 2-byte sequence
			m_ucSequenceLength = 0;
			m_ucSequence = 0;
		}
		else if( testByte < 0xE0 )
		{
			//2-byte sequence
			m_ucSequenceLength = 2;
			m_ucSequence++;
		}
		else if( testByte < 0xF0 )
		{
			//3-byte sequence
			m_ucSequenceLength = 3;
			m_ucSequence++;
		}
		else if( testByte < 0xF5 )
		{
			//4-byte sequence
			m_ucSequenceLength = 4;
			m_ucSequence++;
		}
		else
		{
			// > U+10FFFF
			m_ucSequenceLength = 0;
			m_ucSequence = 0;
		}
	}

	//------------------------------------------------------------------------------
	void CUTF8CodePointFilter::ProcessSecondCodeUnit( byte testByte )
	{
		m_code_unit[ 1 ] = testByte;
		switch( m_ucSequenceLength )
		{
		case 2:
			if( ( testByte & 0xC0 ) != 0x80 )
			{
				//Error overlong sequence!
			}
			else
			{
				unsigned int uiCodePoint = ( m_code_unit[ 0 ] << 6 ) + m_code_unit[ 1 ] - 0x3080;
				WriteCodePoint( uiCodePoint );
				unsigned long ulCodePointWritten = 0;
				m_SourceProxy.GetSink()->Write( ulCodePointWritten, 1 );
				m_ucSequenceLength = 0;
				m_ucSequence = 0;
				ClearCodeUnits();
			}
			break;
		case 3:
			if( ( ( m_code_unit[ 1 ] & 0xC0 ) != 0x80 ) || ( m_code_unit[ 0 ] == 0xE0 && m_code_unit[ 1 ] < 0xA0 ) )
			{
				//Error overlong sequence
				m_ucSequenceLength = 0;
				m_ucSequence = 0;
			}
			else
			{
				m_ucSequence++;
			}
			break;
		case 4:
			if( ( ( m_code_unit[ 1 ] & 0xC0 ) != 0x80 ) || ( m_code_unit[ 0 ] == 0xF0 && m_code_unit[ 1 ] < 0x90 ) )
			{
				//Error overlong sequence
				m_ucSequenceLength = 0;
				m_ucSequence = 0;
			}
			else if( m_code_unit[ 0 ] == 0xF4 && m_code_unit[ 1 ] >= 0x90 )
			{
				//Error > U+10FFFF
				m_ucSequenceLength = 0;
				m_ucSequence = 0;
			}
			else
			{
				m_ucSequence++;
			}
			break;
		}
	}

	//------------------------------------------------------------------------------
	void CUTF8CodePointFilter::ProcessThirdCodeUnit( byte testByte )
	{
		m_code_unit[ 2 ] = testByte;
		if( ( m_code_unit[ 2 ] & 0xC0 ) != 0x80 )
		{
			//Error
			m_ucSequenceLength = 0;
			m_ucSequence = 0;
		}
		else
		{
			unsigned int uiCodePoint = ( m_code_unit[ 0 ] << 12 ) + ( m_code_unit[ 1 ] << 6 ) + m_code_unit[ 2 ] - 0xE2080;
			WriteCodePoint( uiCodePoint );
			unsigned long ulCodePointWritten = 0;
			m_SourceProxy.GetSink()->Write( ulCodePointWritten, 1 );
			m_ucSequenceLength = 0;
			m_ucSequence = 0;
			ClearCodeUnits();
		}
	}

	//------------------------------------------------------------------------------
	void CUTF8CodePointFilter::ProcessFourthCodeUnit( byte testByte )
	{
		m_code_unit[ 3 ] = testByte;
		if( ( m_code_unit[ 3 ] & 0xC0 ) != 0x80 )
		{
			//Error
			m_ucSequenceLength = 0;
			m_ucSequence = 0;
		}
		else
		{
			unsigned int uiCodePoint = ( m_code_unit[ 0 ] << 18 ) + ( m_code_unit[ 1 ] << 12 ) + ( m_code_unit[ 2 ] << 6 ) + m_code_unit[ 3 ] - 0x3C82080;
			WriteCodePoint( uiCodePoint );
			unsigned long ulCodePointWritten = 0;
			m_SourceProxy.GetSink()->Write( ulCodePointWritten, 1 );
			m_ucSequenceLength = 0;
			m_ucSequence = 0;
			ClearCodeUnits();
		}
	}
	
	//------------------------------------------------------------------------------
	bool CUTF8CodePointFilter::Write( unsigned long& ulUnitsWritten, unsigned long ulUnitsToWrite )
	{
		unsigned long ulMaxByteCount = ulUnitsToWrite * 4;
		byte* pBuffer = m_SinkProxy.GetSource()->GetBuffer()->ReadRequest( ulMaxByteCount );

		for( ulUnitsWritten = 0; ulUnitsWritten < ulUnitsToWrite; ulUnitsWritten++ )
		{
			byte testByte = pBuffer[ ulUnitsWritten ];

			switch( m_Part )
			{
			case BOM:
				{
					ProcessBOMUnit( testByte, ulUnitsWritten );
				}
				break;
			case Text:
				{
					switch( m_ucSequence )
					{
					case 0:
						ProcessFirstCodeUnit( testByte );
						break;
					case 1:
						ProcessSecondCodeUnit( testByte );
						break;
					case 2:
						ProcessThirdCodeUnit( testByte );
						break;
					case 3:
						ProcessFourthCodeUnit( testByte );
						break;
					}
				}
				break;
			}
		}

		m_SinkProxy.GetSource()->GetBuffer()->ReadAcknowledge( ulMaxByteCount );

		return ulUnitsWritten > 0 ? true : false;
	}

}//nsBluefoot


