//WinQLThread.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "WinQL/Application/Threading/WinQLThread.h"
#include "WinQL/CodeServices/Locale/WinQLLocale.h"
#include "WinQL/Application/ErrorSystem/WinQLFunctionContext.h"
#include "WinQL/CodeServices/Handles/WinQLSyncHandle.h"
#include "WinQL/Application/Resources/WinQLResourceManager.h"
#include "WinQAPI/Kernel32.h"
#include "WinQAPI/AdvAPI32.h"
#include "WinQAPI/User32.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	using namespace nsWinQAPI;

	static CThread theWindowsPrimaryThread;

	__QCMP_DECLARE_PERTHREAD CThread* t_pCurrentWin32Thread = 0;

	//------------------------------------------------------------------------------
	__QOR_INTERFACE( __WINQL ) CThread* GetCurrentWin32Thread( void )
	{
		return t_pCurrentWin32Thread;
	}

	// {56B0CC6E-DF76-4B6F-93E7-D0938F51FE9E}
	__QOR_IMPLEMENT_OCLASS_GUID( CThread, 0x56b0cc6e, 0xdf76, 0x4b6f, 0x93, 0xe7, 0xd0, 0x93, 0x8f, 0x51, 0xfe, 0x9e )

	//------------------------------------------------------------------------------
	//Create a Thread object for an existing system thread such as the primary thread
	CThread::CThread( /*CSyncHandle& ThreadHandle*/ ) : m_pCRTThreadData( 0 ), m_pResourceManager( 0 )
	{
		_WINQ_FCONTEXT( "CThread::CThread" );
		m_bWinQLThread = false;					//Attaching to an exisitng thread not running our own
		m_hThread.Attach( this );				//attach this instance to its handle
		m_hThread = CKernel32::Instance().GetCurrentThread();			//Get the raw handle and attach to our own handle object
		m_bCloseHandle = false;					//Don't close the handle later as it's not ours
		t_pCurrentWin32Thread = this;
		m_Name = 0;
		m_pImpl = 0;
	}

	//------------------------------------------------------------------------------
	//Create a temporary thread object for an existing thread
	CThread::CThread( unsigned long dwDesiredAccess, bool bInheritHandle, unsigned long dwThreadId ) : m_pCRTThreadData( 0 ), m_pResourceManager( 0 )
	{
		_WINQ_FCONTEXT( "CThread::CThread" );
		__QOR_PROTECT
		{
			m_bWinQLThread = false;	//Opening someone else's thread not running our own
			m_hThread = CKernel32::OpenThread( dwDesiredAccess, bInheritHandle ? TRUE : FALSE, dwThreadId );
			m_bCloseHandle = true;
			m_Name = 0;
			m_pImpl = 0;
		}__QOR_ENDPROTECT
	}

	//------------------------------------------------------------------------------
	//Create a remote thread in another process
	CThread::CThread( void* hProcess, nsWin32::LPSECURITY_ATTRIBUTES lpThreadAttributes, Cmp_ulong_ptr dwStackSize, nsWin32::PTHREAD_START_ROUTINE lpStartAddress, void* lpParameter, unsigned long dwCreationFlags, unsigned long* lpThreadId ) : m_pCRTThreadData( 0 ), m_pResourceManager( 0 )
	{
		_WINQ_FCONTEXT( "CThread::CThread" );
		__QOR_PROTECT
		{
			m_bWinQLThread = true;
			m_hThread = CKernel32::CreateRemoteThread(
					hProcess,
					reinterpret_cast< ::LPSECURITY_ATTRIBUTES >( lpThreadAttributes ),
					dwStackSize,
					reinterpret_cast< ::LPTHREAD_START_ROUTINE >( lpStartAddress ),
					lpParameter, dwCreationFlags, lpThreadId );

			m_bCloseHandle = false;
			m_Name = 0;
			m_pImpl = 0;
		}__QOR_ENDPROTECT
	}

	//------------------------------------------------------------------------------
	//Create a new thread in this process
	CThread::CThread( nsWin32::LPSECURITY_ATTRIBUTES lpThreadAttributes, Cmp_ulong_ptr dwStackSize, nsWin32::LPTHREAD_START_ROUTINE lpStartAddress, void* lpParameter, unsigned long dwCreationFlags, unsigned long* lpThreadId ) : m_pCRTThreadData( 0 ), m_pResourceManager( 0 )
	{
		_WINQ_FCONTEXT( "CThread::CThread" );
		__QOR_PROTECT
		{
			m_bWinQLThread = true;
			m_fpThreadFunction = lpStartAddress;
			m_pThreadFunctionParam = lpParameter;

			m_hThread = CKernel32::CreateThread(
					reinterpret_cast< ::LPSECURITY_ATTRIBUTES >( lpThreadAttributes ),
					dwStackSize,
					reinterpret_cast< ::LPTHREAD_START_ROUTINE>( &StaticThreadFunction ),
					reinterpret_cast< void* >( this ), dwCreationFlags, lpThreadId );

			m_bCloseHandle = false;
			m_Name = 0;
			m_pImpl = 0;
		}__QOR_ENDPROTECT
	}

	//------------------------------------------------------------------------------
	unsigned long CThread::InstanceThreadFunction()
	{
		unsigned long ulResult = ( unsigned long )( -1 );

		t_pCurrentWin32Thread = this;
		if( m_fpThreadFunction )
		{			
			ulResult = (*m_fpThreadFunction)( m_pThreadFunctionParam );
		}
		t_pCurrentWin32Thread = 0;
		return ulResult;
	}

	//------------------------------------------------------------------------------
	unsigned long CThread::StaticThreadFunction( void* vpThread )
	{
		unsigned long ulResult = ( unsigned long )( -1 );
		CThread* pThread = reinterpret_cast< CThread* >( vpThread );
		if( pThread )
		{
			ulResult = pThread->InstanceThreadFunction();
		}
		return ulResult;
	}

	//------------------------------------------------------------------------------
	//Get a reference to a new thread in this process
	nsCodeQOR::CTCRef< CThread > CThread::Create( unsigned long ulCreationFlags, nsWin32::LPSECURITY_ATTRIBUTES pSecurityAttributes, Cmp_ulong_ptr ulStackSize )
	{
		unsigned long ulThreadId = 0;

		CThread* pNewThread = new CThread( pSecurityAttributes, ulStackSize, &StartRoutine, (void*)(&pNewThread), ulCreationFlags | CREATE_SUSPENDED, &ulThreadId );

		nsCodeQOR::CTCRef< CThread > Ref( pNewThread );

		if( ( ulCreationFlags & CREATE_SUSPENDED ) == 0 )
		{
			pNewThread->Resume();
		}
		return Ref;
	}

	//------------------------------------------------------------------------------
	//Internal thread startup routine, simply calls back into the new Thread object
	unsigned long CThread::StartRoutine( void* vppThread )
	{
		CThread** ppThread = reinterpret_cast< CThread** >( vppThread );

		unsigned long ulResult = (unsigned long)(-1);

		if( ppThread && *ppThread )
		{
			CThread* pThread = *ppThread;				
			ulResult = pThread->Run();
		}
		return ulResult;	
	}

	//------------------------------------------------------------------------------
	//override this routine to do something useful in your derived thread class
	unsigned long CThread::Run()
	{
		if( m_bWinQLThread )	//Check this is our thread to Run with, a thread weve created, we're not wrapping an OS or COM thread
		{
			while( m_ulWinQLThreadRefCount > 0 )		//idle while references to CThread object remain
			{
				Sleep( 100 );
			}
		}
		return 0;
	}

	//------------------------------------------------------------------------------
	void CThread::AddRef( void )
	{
		m_ulWinQLThreadRefCount++;
	}

	//------------------------------------------------------------------------------
	void CThread::Release( void )
	{
		--m_ulWinQLThreadRefCount;
	}

	//------------------------------------------------------------------------------
	//Thread object cleanup
	CThread::~CThread()
	{
		_WINQ_FCONTEXT( "CThread::~CThread" );
		if( !m_bCloseHandle )			//If we don't want the handle to be automatically closed then we need to explicitly drop it
		{
			m_hThread.Drop();
		}
	}
	
	//------------------------------------------------------------------------------
	CThreadResourceManager& CThread::ResourceManager( void )
	{
		if( m_pResourceManager == 0 )
		{
			nsCodeQOR::CTCRef< CThread > Ref = GetCurrent();
			m_pResourceManager = new CThreadResourceManager( Ref );
		}

		return *m_pResourceManager;
	}
	
	//------------------------------------------------------------------------------
	//rude exit from a Windows thread, avoid if at all possible
	void CThread::Exit( unsigned long dwExitCode )
	{
		_WINQ_SFCONTEXT( "CThread::Exit" );
		__QOR_PROTECT
		{
			CKernel32::ExitThread( dwExitCode );
		}__QOR_ENDPROTECT
	}

	//------------------------------------------------------------------------------
	//Get a reference to the calling thread
	nsCodeQOR::CTCRef< CThread > CThread::GetCurrent()
	{
		_WINQ_SFCONTEXT( "CThread::GetCurrent" );	
		nsCodeQOR::CTCRef< CThread > RefThread( t_pCurrentWin32Thread );
		return RefThread;
	}

	//------------------------------------------------------------------------------
	//Get the Id of the calling thread
	unsigned long CThread::GetCurrentId()
	{
		_WINQ_SFCONTEXT( "CThread::GetCurrentId" );
		return CKernel32::GetCurrentThreadId();
	}

	//--------------------------------------------------------------------------------
	//Get the Id of this thread object
	unsigned long CThread::GetId()
	{
		_WINQ_FCONTEXT( "CThread::GetId" );
		DWORD dwResult = 0;
		__QOR_PROTECT
		{
			dwResult = CKernel32::GetThreadId( m_hThread.Use() );
		}__QOR_ENDPROTECT
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	bool CThread::GetIOPendingFlag( int* lpIOIsPending )
	{
		_WINQ_FCONTEXT( "CThread::GetIOPEndingFlag" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetThreadIOPendingFlag( m_hThread.Use(), lpIOIsPending ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	int CThread::GetPriority()
	{
		_WINQ_FCONTEXT( "CThread::GetPriority" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = CKernel32::GetThreadPriority( m_hThread.Use() );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//------------------------------------------------------------------------------
	bool CThread::GetPriorityBoost( int* pDisablePriorityBoost )
	{				
		_WINQ_FCONTEXT( "CThread::GetPriorityBoost" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetThreadPriorityBoost( m_hThread.Use(), pDisablePriorityBoost ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	bool CThread::GetTimes( nsWin32::LPFILETIME lpCreationTime, nsWin32::LPFILETIME lpExitTime, nsWin32::LPFILETIME lpKernelTime, nsWin32::LPFILETIME lpUserTime )
	{
		_WINQ_FCONTEXT( "CThread::GetTimes" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetThreadTimes( m_hThread.Use(), reinterpret_cast< ::LPFILETIME >( lpCreationTime ), reinterpret_cast< ::LPFILETIME >( lpExitTime ), reinterpret_cast< ::LPFILETIME >( lpKernelTime ), reinterpret_cast< ::LPFILETIME >( lpUserTime ) ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	unsigned long CThread::Resume()
	{
		_WINQ_FCONTEXT( "CThread::Resume" );
		DWORD dwResult = 0;
		__QOR_PROTECT
		{
			dwResult = CKernel32::ResumeThread( m_hThread.Use() );
		}__QOR_ENDPROTECT
		return dwResult;
	}

	//------------------------------------------------------------------------------
	Cmp_ulong_ptr CThread::SetAffinityMask( Cmp_ulong_ptr dwThreadAffinityMask )
	{
		_WINQ_FCONTEXT( "CThread::SetAffinityMask" );
		DWORD_PTR Result = 0;
		__QOR_PROTECT
		{
			Result = CKernel32::SetThreadAffinityMask( m_hThread.Use(), dwThreadAffinityMask );
		}__QOR_ENDPROTECT
		return Result;
	}

	//------------------------------------------------------------------------------
	unsigned long CThread::SetIdealProcessor( unsigned long dwIdealProcessor )
	{
		_WINQ_FCONTEXT( "CThread::SetIdealProcessor" );
		DWORD dwResult = 0;
		__QOR_PROTECT
		{
			dwResult = CKernel32::SetThreadIdealProcessor( m_hThread.Use(), dwIdealProcessor );
		}__QOR_ENDPROTECT
		return dwResult;
	}

	//------------------------------------------------------------------------------
	bool CThread::SetPriority( int nPriority )
	{
		_WINQ_FCONTEXT( "CThread::SetPriority" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::SetThreadPriority( m_hThread.Use(), nPriority ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	bool CThread::SetPriorityBoost( bool bDisablePriorityBoost )
	{
		_WINQ_FCONTEXT( "CThread::SetPriorityBoost" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::SetThreadPriorityBoost( m_hThread.Use(), bDisablePriorityBoost ? TRUE : FALSE ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	unsigned long CThread::Suspend()
	{
		_WINQ_FCONTEXT( "CThread::Suspend" );
		DWORD dwResult = 0;
		__QOR_PROTECT
		{
			dwResult = CKernel32::SuspendThread( m_hThread.Use() );
		}__QOR_ENDPROTECT
		return dwResult;
	}

	//------------------------------------------------------------------------------
	//Rude termination of a Windows thread. Avoid this completely
	bool CThread::Terminate( unsigned long dwExitCode )
	{
		_WINQ_FCONTEXT( "CThread::Terminate" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::TerminateThread( m_hThread.Use(), dwExitCode ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	unsigned long CThread::Wow64Suspend()
	{
		_WINQ_FCONTEXT( "CThread::Wow64Suspend" );
		DWORD dwResult = 0;
		__QOR_PROTECT
		{
			dwResult = CKernel32::Wow64SuspendThread( m_hThread.Use() );
		}__QOR_ENDPROTECT
		return dwResult;
	}

	//--------------------------------------------------------------------------------
	bool CThread::QueryCycleTime( Cmp_unsigned__int64* CycleTime )
	{
		_WINQ_FCONTEXT( "CThread::QueryCycleTime" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::QueryThreadCycleTime( m_hThread.Use(), CycleTime ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	//TODO: Consider moving this to an IOThread sub class to avoid User32 dependency in base CThread
	/*
	bool CThread::AttachInput( CThread* pToThread, bool bAttach )
	{
		_WINQ_FCONTEXT( "CThread::AttachInput" );
		bool bResult = FALSE;
		__QOR_PROTECT
		{
			if( pToThread != NULL )
			{
				nsWinQAPI::CUser32 User32Lib;
				bResult = User32Lib.AttachThreadInput( GetId(), pToThread->GetId(), bAttach ? TRUE : FALSE ) ? true : false;
			}
		}__QOR_ENDPROTECT
		return bResult;
	}
	*/
	//------------------------------------------------------------------------------
	bool CThread::GetContext( nsWin32::CONTEXT* lpContext )
	{
		_WINQ_FCONTEXT( "CThread::GetContext" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetThreadContext( m_hThread.Use(), reinterpret_cast< ::LPCONTEXT >( lpContext ) ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	bool CThread::SetContext( const nsWin32::CONTEXT* lpContext )
	{
		_WINQ_FCONTEXT( "CThread::SetContext" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::SetThreadContext( m_hThread.Use(), reinterpret_cast< const ::CONTEXT* >( lpContext ) ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	bool CThread::Wow64GetContext( nsWin32::PWOW64_CONTEXT lpContext )
	{
		_WINQ_FCONTEXT( "CThread::Wow64GetContext" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::Wow64GetThreadContext( m_hThread.Use(), reinterpret_cast< ::PWOW64_CONTEXT >( lpContext ) ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	bool CThread::Wow64SetContext( const nsWin32::WOW64_CONTEXT* lpContext )
	{
		_WINQ_FCONTEXT( "CThread::Wow64SetContext" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::Wow64SetThreadContext( m_hThread.Use(), reinterpret_cast< const ::WOW64_CONTEXT* >( lpContext ) ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//------------------------------------------------------------------------------
	bool CThread::GetSelectorEntry( unsigned long dwSelector, nsWin32::LPLDT_ENTRY lpSelectorEntry )
	{
		_WINQ_FCONTEXT( "CThread::GetSelectorEntry" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = CKernel32::GetThreadSelectorEntry( m_hThread.Use(), dwSelector, reinterpret_cast< ::LPLDT_ENTRY >( lpSelectorEntry ) ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CThread::GetUserNameT( TCHAR* lpBuffer, unsigned long* lpnSize )
	{
		_WINQ_FCONTEXT( "CThread::GetUserName" );
		bool bResult = false;
		__QOR_PROTECT
		{
			nsWinQAPI::CAdvAPI32 AdvAPI32Lib;
			bResult = AdvAPI32Lib.GetUserName( lpBuffer, lpnSize ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	nsCodeQOR::CTCRef< CSyncHandle > CThread::Handle()
	{
		_WINQ_FCONTEXT( "CThread::Handle" );
		return &m_hThread;
	}

	//--------------------------------------------------------------------------------
	void* CThread::CRTThreadData()
	{
		return m_pCRTThreadData;
	}

	//--------------------------------------------------------------------------------
	bool CThread::SetCRTThreadData( void* pData )
	{
		bool bResult = false;
		if( m_pCRTThreadData == 0 )
		{
			m_pCRTThreadData = pData;
			bResult = true;
		}
		return bResult;
	}

	//--------------------------------------------------------------------------------
	mxTCHAR* CThread::Name( void )
	{
		if( m_Name != 0 )
		{
			return m_Name;
		}
		else
		{
			return _T( "unnamed" );
		}
	}

	//--------------------------------------------------------------------------------
	CThreadLocaleInfo* CThread::UpdateLocaleInfo()
	{
		CThreadLocaleInfo* pThreadLocaleInfo = 0;    

		if ( !( Data().OwnLocale() & CLocale::GlobalLocaleStatus() ) || !LocaleInfoPtr() ) 
		{
			//TODO: _mlock(_SETLOCALE_LOCK);
			__QCMP_TRY
			{
				pThreadLocaleInfo = CLocale::PtrThreadLocaleInfo()->UpdateExNoLock( LocaleInfoPtr() );
			}
			__QCMP_FINALLY
			{
				//TODO: _munlock(_SETLOCALE_LOCK);
			}
		} 
		else 
		{
			pThreadLocaleInfo = LocaleInfoPtr();
		}

		if( !pThreadLocaleInfo )
		{
			//TODO: _amsg_exit(_RT_LOCALE);
		}

		return pThreadLocaleInfo;
	}

	//--------------------------------------------------------------------------------
	CMBCInfo* CThread::UpdatetMBCInfo()
	{
		CMBCInfo* pThreadMBCInfo = 0;

		if ( !( Data().OwnLocale() & CLocale::GlobalLocaleStatus() ) || !Data().LocaleData().LocaleInfoPtr() ) 
		{
			
			//TODO:CLocks::Lock(CLocks::E_MB_CP_LOCK);

			__QCMP_TRY
			{

				if ( ( pThreadMBCInfo = Data().LocaleData().MBCInfoPtr() ) != CLocale::GlobalMBCInfoPtr() )
				{
					//Decrement the reference count in the old mbc info structure and free it, if necessary
					if ( ( pThreadMBCInfo != 0 ) && ( pThreadMBCInfo->Release() == 0 ) && pThreadMBCInfo != &CLocaleThreadData::sInitialMBCInfo )
					{
						//Free it
						delete pThreadMBCInfo;						
					}

					//Point to the current mbc info structure and increment its reference count.
					 
					pThreadMBCInfo = Data().LocaleData().MBCInfoPtr() = CLocale::GlobalMBCInfoPtr();
					pThreadMBCInfo->AddRef();				
				}
			}
			__QCMP_FINALLY
			{
				//TODO:CLocks::Unlock(CLocks::E_MB_CP_LOCK);				
			}
		} 
		else 
		{
			pThreadMBCInfo = Data().LocaleData().MBCInfoPtr();
		}

		if(!pThreadMBCInfo)
		{
			//TODO:Error
			//TODO: _amsg_exit(_RT_LOCALE);
		}

		return pThreadMBCInfo;
	}

	//--------------------------------------------------------------------------------
	void CThread::UpdateLocale( CThreadLocaleInfo*& ptloci )
	{
		if( ( ptloci != CLocale::PtrThreadLocaleInfo() ) && !( Data().OwnLocale() & CLocale::GlobalLocaleStatus() ) )
		{
			ptloci = UpdateLocaleInfo();
		}
	}

	//--------------------------------------------------------------------------------
	void CThread::UpdateMBCodePage( CMBCInfo*& ptmbci )
	{
		if( ( ptmbci != CLocale::GlobalMBCInfoPtr() ) && !( Data().OwnLocale() & CLocale::GlobalLocaleStatus() ) )
		{
			ptmbci = UpdatetMBCInfo();
		}
	}
	
	//------------------------------------------------------------------------------
	nsCodeQOR::CThreadContextBase* CThread::GetCurrentImpl( void )
	{
		if( t_pCurrentWin32Thread )
		{
			return t_pCurrentWin32Thread->m_pImpl;
		}
		return 0;
	}

	//------------------------------------------------------------------------------
	void CThread::SetCurrentImpl( nsCodeQOR::CThreadContextBase* pImpl )
	{
		t_pCurrentWin32Thread->m_pImpl = pImpl;
	}

}//nsWin32
