//WinQLPipe.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Win32 Pipes

//Based on P.J. Naughter 1998, ref www.codeproject.com

#ifndef WINQL_COMMS_PIPE_H_3
#define WINQL_COMMS_PIPE_H_3

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "WinQL/CodeServices/Handles/WinQLHandle.h"
#include "WinQL/System/Security/WinQLSecurity.h"
#include "WinQL/System/Devices/WinQLDeviceFile.h"
#include "WinQL/CodeServices/Text/WinString.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	__QCMP_STATIC_CONSTANT( unsigned long, Pipe_Client_End = 0x00000000 );
	__QCMP_STATIC_CONSTANT( unsigned long, Pipe_Server_End = 0x00000001 );
	__QCMP_STATIC_CONSTANT( unsigned long, Pipe_Wait = 0x00000000 );
	__QCMP_STATIC_CONSTANT( unsigned long, Pipe_NoWait = 0x00000001 );
	__QCMP_STATIC_CONSTANT( unsigned long, Pipe_ReadMode_Byte = 0x00000000 );
	__QCMP_STATIC_CONSTANT( unsigned long, Pipe_ReadMode_Message = 0x00000002 );
	__QCMP_STATIC_CONSTANT( unsigned long, Pipe_Type_Byte = 0x00000000 );
	__QCMP_STATIC_CONSTANT( unsigned long, Pipe_Type_Message = 0x00000004 );
	__QCMP_STATIC_CONSTANT( unsigned long, Pipe_Accept_Remote_Clients = 0x00000000 );
	__QCMP_STATIC_CONSTANT( unsigned long, Pipe_Reject_Remote_Clients = 0x00000008 );

	//--------------------------------------------------------------------------------
	class __QOR_INTERFACE( __WINQL ) CPipe : public CDeviceFile
	{
	public:

		//--------------------------------------------------------------------------------
		enum eAccess
		{
			InBound		= 0x00000001,
			OutBound	= 0x00000002,
			Duplex		= 0x00000003
		};

		__QCMP_STATIC_CONSTANT( unsigned long,	Unlimited_Instances		= 255 );
		__QCMP_STATIC_CONSTANT( unsigned long,	Wait					= 0x00000000 );
		__QCMP_STATIC_CONSTANT( unsigned long,	NoWait					= 0x00000001 );
		__QCMP_STATIC_CONSTANT( unsigned long,	ReadMode_Byte			= 0x00000000 );
		__QCMP_STATIC_CONSTANT( unsigned long,	ReadMode_Message		= 0x00000002 );
		__QCMP_STATIC_CONSTANT( unsigned long,	Type_Byte				= 0x00000000 );
		__QCMP_STATIC_CONSTANT( unsigned long,	Type_Message			= 0x00000004 );
		__QCMP_STATIC_CONSTANT( unsigned long,	Accept_RemoteClients	= 0x00000000 );
		__QCMP_STATIC_CONSTANT( unsigned long,	Reject_RemoteClients	= 0x00000008 );

		typedef nsCodeQOR::CTLRef< CPipe > refType;

		__QOR_DECLARE_OCLASS_ID( CPipe );

		CPipe();
		CPipe( CDeviceHandle::ref_type hExisting );
		virtual ~CPipe();

		static bool Instance( void** hReadPipe, void** hWritePipe, nsWin32::LPSECURITY_ATTRIBUTES lpPipeAttributes, unsigned long nSize );

		bool Attach( void* hPipe );
		bool Call( const TCHAR* lpszServerName, const TCHAR* lpszPipeName, void* pInBuffer, unsigned long nInBuffer, void* pOutBuffer, unsigned long nOutBuffer, unsigned long& BytesRead, unsigned long nTimeout );
		bool Close( void );
		bool ConnectClient( nsWin32::OVERLAPPED* pOverlapped );
		bool Create( const TCHAR*, unsigned long OpenMode, unsigned long PipeMode, unsigned long nMaxInstances, unsigned long nOutBufferSize, unsigned long nInBufferSize, unsigned long nDefaultTimeout, nsWin32::SECURITY_ATTRIBUTES* pSecurityAttributes );
		void* Detach( void );
		bool DisconnectClient( void );
		bool Flush( void );
		bool GetClientComputerName( TCHAR* ClientComputerName, unsigned long ClientComputerNameLength );
		bool GetClientProcessId( unsigned long& ClientProcessId );
		bool GetClientSessionId( unsigned long& ClientSessionId );
		bool GetClientUserName( CTString& strUserName );
		bool GetCollectionTimeout( unsigned long& CollectDataTimeout ) const;
		bool GetCurrentInstances( unsigned long& CurrrentInstances ) const;
		bool GetHandleState( unsigned long* pState, unsigned long* pCurInstances, unsigned long* pMaxCollectionCount, unsigned long* pCollectDataTimeout, TCHAR* UserName, unsigned long nMaxUserNameSize );
		bool GetInboundBufferSize( unsigned long& InboundBufferSize ) const;
		bool GetInfo( unsigned long* pFlags, unsigned long* pOutBufferSize, unsigned long* pInBufferSize, unsigned long* pMaxInstances );
		bool GetMaxCollectionCount( unsigned long& MaxCollectionCount ) const;
		bool GetMaxInstances( unsigned long& MaxInstances ) const;
		bool GetOutboundBufferSize( unsigned long& OutboundBufferSize ) const;
		bool GetServerProcessId( unsigned long& ServerProcessId );
		bool GetServerSessionId( unsigned long& pServerSessionId );
		bool IsBlocking( bool& bIsBlocking ) const;
		bool IsClient( bool& bIsClient ) const;
		bool IsOpen( void );
		bool IsServer( bool& bIsServer ) const;
		bool IsMessaging( bool& bIsMessaging ) const;
		bool Open( const TCHAR* lpszServerName, const TCHAR* lpszPipeName, unsigned long DesiredAccess, unsigned long ShareMode, nsWin32::SECURITY_ATTRIBUTES* pSecurityAttributes, unsigned long FlagsAndAttributes );
		bool Peek( void* pBuffer, unsigned long nBufferSize, unsigned long& BytesRead, unsigned long& TotalBytesAvail, unsigned long& BytesLeftThisMessage );
		bool Read( void* pBuffer, unsigned long NumberOfBytesToRead, unsigned long& NumberOfBytesRead, OVERLAPPED* pOverlapped );
		bool Read( void* pBuffer, unsigned long NumberOfBytesToRead, OVERLAPPED* pOverlapped, nsWin32::LPOVERLAPPED_COMPLETION_ROUTINE pCompletionRoutine );
		bool SetCollectionTimeout( unsigned long DataTimeout );
		bool SetMaxCollectionCount( unsigned long CollectionCount );
		bool SetHandleState( unsigned long* pMode, unsigned long* pMaxCollectionCount, unsigned long* pCollectDataTimeout );
		bool SetMode( bool bByteMode, bool bBlockingMode );
		bool ServerAvailable( const TCHAR* lpszServerName, const TCHAR* lpszPipeName, unsigned long Timeout );
		bool Transact( void* pBuffer, unsigned long nInBufferSize, void* pOutBuffer, unsigned long nOutBufferSize, unsigned long& BytesRead, OVERLAPPED* pOverlapped );
		bool Write( const void* pBuffer, unsigned long NumberOfBytesToWrite, unsigned long& NumberOfBytesWritten, OVERLAPPED* pOverlapped );
		bool Write( const void* pBuffer, unsigned long NumberOfBytesToWrite, nsWin32::OVERLAPPED* pOverLapped, nsWin32::LPOVERLAPPED_COMPLETION_ROUTINE pCompletionRoutine );
		bool GetOverlappedResult( nsWin32::OVERLAPPED& Overlapped, unsigned long& ulNumberOfBytesTransferred, bool bWait );
		//void* Handle( void );

	protected:

		//void* m_hPipe;

	};

}//nsWin32

#endif//WINQL_COMMS_PIPE_H_3
