//WinQLSocket.cpp

// Copyright Querysoft Limited 2013, 2016, 2017
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/Application/ErrorSystem/WinQLError.h"
#include "WinQL/Application/Comms/Network/WinQLSocket.h"
#include "WinQL/Application/Comms/Network/WinQLSocketEvent.h"
#include "WinQL/Application/IO/WinQLOverlappedHandler.h"
#include "WinQAPI/WS2_32.h"

//--------------------------------------------------------------------------------
namespace nsWin32
{
	using namespace nsWinQAPI;

	__QOR_IMPLEMENT_OCLASS_LUID( CSocket );

	nsCodeQOR::mxGUID CSocket::WSAID_AcceptEx	= { 0xb5367df1, 0xcbac, 0x11cf, { 0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92 } };

	//--------------------------------------------------------------------------------
	const int sizeofAddressByFamily(const unsigned short usFamily) 
	{
		int iResult = 16;
		switch (usFamily)
		{
			case nsBluefoot::ISocket::AF_Unspecified:
			case nsBluefoot::ISocket::AF_Unix:
			case nsBluefoot::ISocket::AF_INet:
			case nsBluefoot::ISocket::AF_ImpLink:
			case nsBluefoot::ISocket::AF_Pup:
			case nsBluefoot::ISocket::AF_Chaos:
			case nsBluefoot::ISocket::AF_Ns:
			//case nsBluefoot::ISocket::AF_Ipx:
			case nsBluefoot::ISocket::AF_Iso:
			//case nsBluefoot::ISocket::AF_Osi:
			case nsBluefoot::ISocket::AF_Ecma:
			case nsBluefoot::ISocket::AF_DataKit:
			case nsBluefoot::ISocket::AF_Ccitt:
			case nsBluefoot::ISocket::AF_Sna:
			case nsBluefoot::ISocket::AF_DecNet:
			case nsBluefoot::ISocket::AF_Dli:
			case nsBluefoot::ISocket::AF_Lat:
			case nsBluefoot::ISocket::AF_HYLink:
			case nsBluefoot::ISocket::AF_AppleTalk:
			case nsBluefoot::ISocket::AF_NetBIOS:
			case nsBluefoot::ISocket::AF_VoiceView:
			case nsBluefoot::ISocket::AF_FireFox:
			case nsBluefoot::ISocket::AF_Unknown1:
			case nsBluefoot::ISocket::AF_Ban:
			case nsBluefoot::ISocket::AF_Atm:
			case nsBluefoot::ISocket::AF_INet6:
			case nsBluefoot::ISocket::AF_Cluster:
			case nsBluefoot::ISocket::AF_1284_4:
			case nsBluefoot::ISocket::AF_Irda:
			case nsBluefoot::ISocket::AF_NetDes:
			case nsBluefoot::ISocket::AF_TcnProcess:
			case nsBluefoot::ISocket::AF_TcnMessage:
			case nsBluefoot::ISocket::AF_IclFxbm:
				break;
			case nsBluefoot::ISocket::AF_Bth:					// Bluetooth RFCOMM/L2CAP protocols
				return 30;

			case nsBluefoot::ISocket::AF_Link:
			case nsBluefoot::ISocket::AF_Max:
			default:
				break;
		}
		return iResult;
	}

	//--------------------------------------------------------------------------------
	CSocket::Internet_SocketAddress::Internet_SocketAddress( unsigned char ucA, unsigned char ucB, unsigned char ucC, unsigned char ucD, unsigned short usPort )
	{
		memset( &sin_addr, 0, sizeof( in_addr ) + 8 );
		sin_family = AF_INet;
		sin_port = CWS2_32::Instance().htons( usPort );
		sin_addr.S_un.S_un_b.s_b1 = ucA;
		sin_addr.S_un.S_un_b.s_b2 = ucB;
		sin_addr.S_un.S_un_b.s_b3 = ucC;
		sin_addr.S_un.S_un_b.s_b4 = ucD;	
	}

	//--------------------------------------------------------------------------------
	CSocket::CSocket() : m_Library( CWS2_32::Instance() )
	{
		_WINQ_FCONTEXT( "CSocket::CSocket" );
		m_Socket = INVALID_SOCKET;
	}

	//--------------------------------------------------------------------------------
	CSocket::CSocket( Cmp_uint_ptr Socket ) : m_Library( CWS2_32::Instance() )
	{
		_WINQ_FCONTEXT( "CSocket::CSocket" );
		m_Socket = Socket;
	}

	//--------------------------------------------------------------------------------
	CSocket::~CSocket()
	{
		_WINQ_FCONTEXT( "CSocket::~CSocket" );
		if( m_Socket != INVALID_SOCKET )
		{
			m_Library.closesocket( m_Socket );
			m_Socket = INVALID_SOCKET;
		}
	}

	//--------------------------------------------------------------------------------
	void CSocket::Create( eAddressFamily iAF, eType iType, eProtocol iProtocol )
	{
		_WINQ_FCONTEXT( "CSocket::Create" );
		__QOR_PROTECT
		{
			m_Socket = m_Library.socket( iAF, iType, iProtocol );
		}__QOR_ENDPROTECT
	}

	//--------------------------------------------------------------------------------
	void CSocket::Create(eAddressFamily iAF, eType iType, eProtocol iProtocol, WSAProtocolInfo* pProtocolInfo, unsigned int Group, unsigned long ulFlags )
	{
		_WINQ_FCONTEXT( "CSocket::Create" );
		__QOR_PROTECT
		{
			m_Socket = m_Library.WSASocket( iAF, iType, iProtocol, reinterpret_cast< ::LPWSAPROTOCOL_INFO >( pProtocolInfo ), Group, ulFlags );
		}__QOR_ENDPROTECT
	}

	//--------------------------------------------------------------------------------
	int CSocket::Bind( const Address& Address )
	{
		_WINQ_FCONTEXT( "CSocket::Bind" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.bind( m_Socket, reinterpret_cast< const ::sockaddr* >( &Address ), sizeof( ::sockaddr ) );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::Listen( int iBacklog )
	{
		_WINQ_FCONTEXT( "CSocket::Listen" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.listen( m_Socket, iBacklog );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	nsBluefoot::ISocket::ref_type CSocket::Accept( Address& Addr )
	{
		_WINQ_FCONTEXT( "CSocket::Accept" );

		int addrlen = 0;
		SOCKET s = m_Library.accept(m_Socket, reinterpret_cast< ::sockaddr*>(&Addr), &addrlen );
		return new_shared_ref<CSocket>(s).AsRef<nsBluefoot::ISocket>();
	}

	//--------------------------------------------------------------------------------
	CSocket CSocket::Accept( Address& Addr, fpConditionProc pfnCondition, Cmp_ulong_ptr CallbackData )
	{
		_WINQ_FCONTEXT( "CSocket::Accept" );
		int addrlen = 0;
		CSocket Result( m_Library.WSAAccept( m_Socket, reinterpret_cast< ::sockaddr* >( &Addr ), &addrlen, reinterpret_cast< ::LPCONDITIONPROC >( pfnCondition ), CallbackData ) );
		return Result;
	}

	//--------------------------------------------------------------------------------
	int CSocket::Connect( const Address& Addr )
	{
		_WINQ_FCONTEXT( "CSocket::Connect" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.connect( m_Socket, reinterpret_cast< const ::sockaddr* >( &Addr), sizeofAddressByFamily(Addr.sa_family) );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::Connect( const Address& Addr, WSABuf* pCallerData, WSABuf* pCalleeData, QualityOfService* pSQOS, QualityOfService* pGQOS )
	{
		_WINQ_FCONTEXT( "CSocket::Connect" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.WSAConnect( m_Socket, reinterpret_cast< const ::sockaddr* >( &Addr), sizeofAddressByFamily(Addr.sa_family), reinterpret_cast< ::LPWSABUF >( pCallerData ), reinterpret_cast< ::LPWSABUF >( pCalleeData ), reinterpret_cast< ::LPQOS >( pSQOS ), reinterpret_cast< ::LPQOS >( pGQOS ) );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	bool CSocket::ConnectByList( SocketAddressList* pSocketAddressList, unsigned long* pLocalAddressLength, CSocket::Address* pLocalAddress, unsigned long* pulRemoteAddressLength, CSocket::Address* pRemoteAddress, const timeval* pTimeout )
	{
		_WINQ_FCONTEXT( "CSocket::ConnectByList" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = m_Library.WSAConnectByList( m_Socket, reinterpret_cast< ::PSOCKET_ADDRESS_LIST >( pSocketAddressList ), pLocalAddressLength, reinterpret_cast< ::LPSOCKADDR >( pLocalAddress ), pulRemoteAddressLength, reinterpret_cast< ::LPSOCKADDR >( pRemoteAddress ), reinterpret_cast< const ::timeval* >( pTimeout ), 0 ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CSocket::ConnectByName( TCHAR* pNodeName, TCHAR* pServiceName, unsigned long* pulLocalAddressLength, CSocket::Address* pLocalAddress, unsigned long* pulRemoteAddressLength, CSocket::Address* pRemoteAddress, const timeval* pTimeout )
	{
		_WINQ_FCONTEXT( "CSocket::ConnectByName" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = m_Library.WSAConnectByName( m_Socket,pNodeName, pServiceName, pulLocalAddressLength, reinterpret_cast< ::LPSOCKADDR >( pLocalAddress ), pulRemoteAddressLength, reinterpret_cast< ::LPSOCKADDR >( pRemoteAddress ), reinterpret_cast< const ::timeval* >( pTimeout ), 0 ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::Duplicate( unsigned long ulProcessId, WSAProtocolInfo* pProtocolInfo )
	{
		_WINQ_FCONTEXT( "CSocket::Duplicate" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.WSADuplicateSocket( m_Socket, ulProcessId, reinterpret_cast< ::LPWSAPROTOCOL_INFO >( pProtocolInfo ) );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::GetPeerName( Address& Addr )
	{
		_WINQ_FCONTEXT( "CSocket::GetPeerName" );
		int iResult = 0;
		__QOR_PROTECT
		{
			int addrlen = 0;
			iResult = m_Library.getpeername( m_Socket, reinterpret_cast< ::sockaddr* >( &Addr), &addrlen );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::GetSockName( Address& Address )
	{
		_WINQ_FCONTEXT( "CSocket::GetSockName" );
		int iResult = 0;
		__QOR_PROTECT
		{
			int addrlen = 0;
			iResult = m_Library.getsockname( m_Socket, reinterpret_cast< ::sockaddr* >( &Address ), &addrlen );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::GetSockOpt( int iLevel, int iOptName, char* pOptVal, int* pOptLen )
	{
		_WINQ_FCONTEXT( "CSocket::GetSockOpt" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.getsockopt( m_Socket, iLevel, iOptName, pOptVal, pOptLen );
		}__QOR_ENDPROTECT
		return iResult;
	}
		
	//--------------------------------------------------------------------------------
	int CSocket::HToNL( unsigned long ulHost, unsigned long* pulNet )
	{
		_WINQ_FCONTEXT( "CSocket::HToNL" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.WSAHtonl( m_Socket, ulHost, pulNet );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::HToNS( unsigned short usHost, unsigned short* pusNet )
	{
		_WINQ_FCONTEXT( "CSocket::HToNS" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.WSAHtons( m_Socket, usHost, pusNet );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::IOCtl( long lCmd, unsigned long* pArg )
	{
		_WINQ_FCONTEXT( "CSocket::IOCtl" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.ioctlsocket( m_Socket, lCmd, pArg );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::IOCtl( unsigned long ulIoControlCode, void* pvInBuffer, unsigned long cbInBuffer, void* pvOutBuffer, unsigned long cbOutBuffer, unsigned long* pcbBytesReturned, OVERLAPPED* lpOverlapped, fpWSAOverlappedCompletionRoutine lpCompletionRoutine )
	{
		_WINQ_FCONTEXT( "CSocket::IOCtl" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.WSAIoctl( m_Socket, ulIoControlCode, pvInBuffer, cbInBuffer, pvOutBuffer, cbOutBuffer, pcbBytesReturned, reinterpret_cast< LPWSAOVERLAPPED >( lpOverlapped ), reinterpret_cast< ::LPWSAOVERLAPPED_COMPLETION_ROUTINE >( lpCompletionRoutine ) );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	CSocket CSocket::JoinLeaf( const Address& Address, WSABuf* pCallerData, WSABuf* pCalleeData, QualityOfService* pSQOS, QualityOfService* pGQOS, unsigned long ulFlags )
	{			
		_WINQ_FCONTEXT( "CSocket::JoinLeaf" );
		CSocket Result( m_Library.WSAJoinLeaf( m_Socket, reinterpret_cast< const ::sockaddr* >( &Address ), sizeof(::sockaddr), reinterpret_cast< LPWSABUF >( pCallerData ), reinterpret_cast< LPWSABUF >( pCalleeData ), reinterpret_cast< ::LPQOS >( pSQOS ), reinterpret_cast< ::LPQOS >( pGQOS ), ulFlags ) );
		return Result;
	}

	//--------------------------------------------------------------------------------
	int CSocket::NToHL( unsigned long ulNet, unsigned long* pulHost )
	{
		_WINQ_FCONTEXT( "CSocket::NToHL" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.WSANtohl( m_Socket, ulNet, pulHost );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::NToHS( unsigned short usNet, unsigned short* pusHost )
	{
		_WINQ_FCONTEXT( "CSocket::NToHS" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.WSANtohs( m_Socket, usNet, pusHost );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::AsyncReceive(char* pBuffer, int iLen, void* pSyncObject)
	{
		_WINQ_FCONTEXT("CSocket::AsyncReceive");
		int iResult = 0;
		__QOR_PROTECT
		{
			WSABUF tmpBuffer;
			tmpBuffer.buf = pBuffer;
			tmpBuffer.len = iLen;
			unsigned long ulNumberOfBytesRecvd = 0;
			unsigned long ulFlags = 0;
			iResult = m_Library.WSARecv(m_Socket, reinterpret_cast< ::LPWSABUF >(&tmpBuffer), 1, &ulNumberOfBytesRecvd, &ulFlags, reinterpret_cast< ::LPWSAOVERLAPPED >(pSyncObject), reinterpret_cast< ::LPWSAOVERLAPPED_COMPLETION_ROUTINE >(&COverlappedHandler::OnOverlappedSocketReadCompleted));
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::Receive( char* szBuf, int iLen, int iFlags )
	{
		_WINQ_FCONTEXT( "CSocket::Receive" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.recv( m_Socket, szBuf, iLen, iFlags );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::Receive( WSABuf* pBuffers, unsigned long ulBufferCount, unsigned long* pulNumberOfBytesRecvd, unsigned long* pulFlags, OVERLAPPED* pOverlapped, fpWSAOverlappedCompletionRoutine pCompletionRoutine )
	{
		_WINQ_FCONTEXT( "CSocket::Receive" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.WSARecv( m_Socket, reinterpret_cast< ::LPWSABUF >( pBuffers ), ulBufferCount, pulNumberOfBytesRecvd, pulFlags, reinterpret_cast< ::LPWSAOVERLAPPED >( pOverlapped ), reinterpret_cast< ::LPWSAOVERLAPPED_COMPLETION_ROUTINE >( pCompletionRoutine ) );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::RecvDisconnect( WSABuf* pInboundDisconnectData )
	{
		_WINQ_FCONTEXT( "CSocket::RecvDisconnect" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.WSARecvDisconnect( m_Socket, reinterpret_cast< ::LPWSABUF >( pInboundDisconnectData ) );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::ReceiveFrom( char* Buffer, int iLen, int iFlags, Address& From )
	{
		_WINQ_FCONTEXT( "CSocket::ReceiveFrom" );
		int iResult = 0;
		__QOR_PROTECT
		{
			int fromLen = 0;
			iResult = m_Library.recvfrom( m_Socket, Buffer, iLen, iFlags, reinterpret_cast< ::sockaddr* >( &From ), &fromLen );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::ReceiveFrom( WSABuf* pBuffers, unsigned long ulBufferCount, unsigned long* pulNumberOfBytesRecvd, unsigned long* pulFlags, Address& From, OVERLAPPED* pOverlapped, fpWSAOverlappedCompletionRoutine pCompletionRoutine )
	{
		_WINQ_FCONTEXT( "CSocket::ReceiveFrom" );
		int iResult = 0;
		__QOR_PROTECT
		{
			int fromLen = 0;
			iResult = m_Library.WSARecvFrom( m_Socket, reinterpret_cast< ::LPWSABUF >( pBuffers ), ulBufferCount, pulNumberOfBytesRecvd, pulFlags, reinterpret_cast< ::sockaddr* >( &From ), &fromLen, reinterpret_cast< ::LPWSAOVERLAPPED >( pOverlapped ), reinterpret_cast< ::LPWSAOVERLAPPED_COMPLETION_ROUTINE >( pCompletionRoutine ) );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::AsyncSend(char* Buffer, int iLen, void* pSyncObject)
	{
		_WINQ_FCONTEXT("CSocket::Send");
		int iResult = 0;
		__QOR_PROTECT
		{
			WSABUF tmpBuffer;
			tmpBuffer.buf = Buffer;
			tmpBuffer.len = iLen;
			unsigned long ulNumberOfBytesSent = 0;
			iResult = m_Library.WSASend(m_Socket, reinterpret_cast< ::LPWSABUF >(&tmpBuffer), 1, &ulNumberOfBytesSent, 0, reinterpret_cast< ::LPWSAOVERLAPPED >(pSyncObject), (LPWSAOVERLAPPED_COMPLETION_ROUTINE)(&COverlappedHandler::OnOverlappedSocketWriteCompleted) );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::Send( const char* Buffer, int iLen )
	{
		_WINQ_FCONTEXT( "CSocket::Send" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.send( m_Socket, Buffer, iLen, 0 );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::Send( WSABuf* pBuffers, unsigned long ulBufferCount, unsigned long* pulNumberOfBytesSent, unsigned long ulFlags, OVERLAPPED* pOverlapped, fpWSAOverlappedCompletionRoutine pCompletionRoutine )
	{
		_WINQ_FCONTEXT( "CSocket::Send" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.WSASend( m_Socket, reinterpret_cast< ::LPWSABUF >( pBuffers ), ulBufferCount, pulNumberOfBytesSent, ulFlags, reinterpret_cast< ::LPWSAOVERLAPPED >( pOverlapped ), reinterpret_cast< LPWSAOVERLAPPED_COMPLETION_ROUTINE >( pCompletionRoutine ) );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::SendDisconnect( WSABuf* pOutboundDisconnectData )
	{
		_WINQ_FCONTEXT( "CSocket::SendDisconnect" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.WSASendDisconnect( m_Socket, reinterpret_cast< ::LPWSABUF >( pOutboundDisconnectData ) );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::SendMsg( WSAMsg* pMsg, unsigned long ulFlags, unsigned long* pulNumberOfBytesSent, OVERLAPPED* pOverlapped, fpWSAOverlappedCompletionRoutine pCompletionRoutine )
	{
		_WINQ_FCONTEXT( "CSocket::SendMsg" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.WSASendMsg( m_Socket, reinterpret_cast< ::LPWSAMSG >( pMsg ), ulFlags, pulNumberOfBytesSent, reinterpret_cast< ::LPWSAOVERLAPPED >( pOverlapped ), reinterpret_cast< ::LPWSAOVERLAPPED_COMPLETION_ROUTINE >( pCompletionRoutine ) );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::SendTo( const char* Buffer, int iLen, int iFlags, const Address& To)
	{
		_WINQ_FCONTEXT( "CSocket::SendTo" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.sendto( m_Socket, Buffer, iLen, iFlags, reinterpret_cast< const ::sockaddr* >( &To ), sizeofAddressByFamily(To.sa_family));
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::SendTo( WSABuf* pBuffers, unsigned long ulBufferCount, unsigned long* pulNumberOfBytesSent, unsigned long ulFlags, const CSocket::Address* pTo, int iToLen, OVERLAPPED* pOverlapped, fpWSAOverlappedCompletionRoutine pCompletionRoutine )
	{
		_WINQ_FCONTEXT( "CSocket::SendTo" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.WSASendTo( m_Socket, reinterpret_cast< ::LPWSABUF >( pBuffers ), ulBufferCount, pulNumberOfBytesSent, ulFlags, reinterpret_cast< const ::sockaddr* >( pTo ), iToLen, reinterpret_cast< ::LPWSAOVERLAPPED >( pOverlapped ), reinterpret_cast< ::LPWSAOVERLAPPED_COMPLETION_ROUTINE >( pCompletionRoutine ) );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::SetSockOpt( int iLevel, int iOptName, const char* pOptVal, int iOptLen )
	{
		_WINQ_FCONTEXT( "CSocket::SetSockOpt" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.setsockopt( m_Socket, iLevel, iOptName, pOptVal, iOptLen );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::Shutdown( int iHow )
	{
		_WINQ_FCONTEXT( "CSocket::Shutdown" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.shutdown( m_Socket, iHow );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::EnumNetworkEvents( CSocketEvent& EventObject, WSANetworkEvents* pNetworkEvents )
	{
		_WINQ_FCONTEXT( "CSocket::EnumNetworkEvents" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.WSAEnumNetworkEvents( m_Socket, reinterpret_cast< HANDLE >( EventObject.Handle() ), reinterpret_cast< ::LPWSANETWORKEVENTS >( pNetworkEvents ) );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::EventSelect( CSocketEvent& EventObject, long lNetworkEvents )
	{
		_WINQ_FCONTEXT( "CSocket::EventSelect" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.WSAEventSelect( m_Socket, reinterpret_cast< HANDLE >( EventObject.Handle() ), lNetworkEvents );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	bool CSocket::GetOverlappedResult( OVERLAPPED* pOverlapped, unsigned long* pcbTransfer, int fWait, unsigned long* pulFlags )
	{
		_WINQ_FCONTEXT( "CSocket::GetOverlappedResult" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = m_Library.WSAGetOverlappedResult( m_Socket, reinterpret_cast< ::LPWSAOVERLAPPED >( pOverlapped ), pcbTransfer, fWait, pulFlags ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CSocket::GetQOSByName( WSABuf* pQOSName, QualityOfService* pQOS )
	{
		_WINQ_FCONTEXT( "CSocket::GetQOSByName" );
		bool bResult = false;
		__QOR_PROTECT
		{
			bResult = m_Library.WSAGetQOSByName( m_Socket, reinterpret_cast< ::LPWSABUF >( pQOSName ), reinterpret_cast< ::LPQOS >( pQOS ) ) ? true : false;
		}__QOR_ENDPROTECT
		return bResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::AsyncSelect( CWindowHandle& hWnd, unsigned int uiMsg, long lEvent )
	{
		_WINQ_FCONTEXT( "CSocket::AsyncSelect" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.WSAAsyncSelect( m_Socket, reinterpret_cast< ::HWND >( hWnd.Use() ), uiMsg, lEvent );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CSocket::IsInSet( FDSet* pSet )
	{
		_WINQ_FCONTEXT( "CSocket::IsInSet" );
		int iResult = 0;
		__QOR_PROTECT
		{
			iResult = m_Library.__WSAFDIsSet( m_Socket, reinterpret_cast< ::fd_set* >( pSet ) );
		}__QOR_ENDPROTECT
		return iResult;
	}

	//--------------------------------------------------------------------------------
	Cmp_uint_ptr CSocket::ID()
	{
		_WINQ_FCONTEXT( "CSocket::ID" );
		return m_Socket;
	}

	//--------------------------------------------------------------------------------
	int CSocket::GetLastError()
	{
		_WINQ_FCONTEXT( "CSocket::GetLastError" );
		return m_Library.WSAGetLastError();
	}

}//nsWin32
