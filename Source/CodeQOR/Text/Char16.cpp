//Char16.cpp

// Copyright Querysoft Limited 2015
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//16-bit Character type

#include "CodeQOR/Text/Char16.h"
#include "CodeQOR/Text/Char32.h"
#include "CodeQOR/Text/Char8.h"
#include "CodeQOR/CodePages/CodePage.h"
#include "AppocritaQOR/SubSystems/Thread.h"

//--------------------------------------------------------------------------------
namespace nsCodeQOR
{

#	ifndef QT_NO_CODEC_FOR_C_STRINGS
#	  ifdef QT_NO_TEXTCODEC
#	   define QT_NO_CODEC_FOR_C_STRINGS
#	  endif
#	endif

#	define FLAG(x) (1 << (x))

	//------------------------------------------------------------------------------
	CChar16::CChar16() : CChar()
	{
	}		

	//------------------------------------------------------------------------------
	CChar16::CChar16( const unsigned short& ch )
	{
		 m = ch;
	}

	//------------------------------------------------------------------------------
	CChar16::CChar16( const short& rc ) 
	{
		m = ( static_cast< unsigned short >( rc ) );
	}

	//------------------------------------------------------------------------------
	CChar16::CChar16( int ch )
	{
		m = ( static_cast< unsigned short >( ch ) );
	}

	//--------------------------------------------------------------------------------
	CChar16::CChar16( const unsigned int& ch )
	{
		m = ( static_cast< unsigned short >( ch ) );
	}

	//--------------------------------------------------------------------------------
	CChar16::CChar16( const CChar8& ch8 )
	{
		CCodePage* pCodePage = 0;
		nsQOR::IThread::ref_type pCurrentThread = nsQOR::CThread::GetCurrent();
		if( pCurrentThread )
		{
			pCodePage = pCurrentThread->GetCodePage();
		}

		if( pCodePage )
		{
			m = static_cast< unsigned short >( pCodePage->Decode( static_cast< unsigned int >( ch8.m ) ) );
		}
		else
		{
			m = ch8.m;
		}
	}

	//--------------------------------------------------------------------------------
	CChar16::CChar16( const CChar16& ch16 )
	{
		m = ch16.m;
	}

	//--------------------------------------------------------------------------------
	CChar16::CChar16( const CChar32& ch32 )
	{
		m = static_cast< unsigned short >( ch32.m );
	}

	//--------------------------------------------------------------------------------
	//Constructs a CChar16 corresponding to 8-bit character ch.
	CChar16::CChar16( const byte& ch )
	{
		CCodePage* pCodePage = 0;

		nsQOR::IThread::ref_type pCurrentThread = nsQOR::CThread::GetCurrent();
		if( pCurrentThread )
		{
			pCodePage = pCurrentThread->GetCodePage();
		}

		if( pCodePage )
		{
			m = static_cast< unsigned short >( pCodePage->Decode( static_cast< unsigned int >( ch ) ) );
		}
		else
		{
			m = ch;
		}
	}

	//------------------------------------------------------------------------------
	CChar16::CChar16( byte ucLowByte, byte ucHighByte )
	{
		m =  ( unsigned short( ( ucHighByte << 8 ) | ucLowByte ) );
	}
		
	//------------------------------------------------------------------------------
	CChar16::CChar16( eSpecialCharacter sc )
	{
		m = ( static_cast< unsigned short >( sc ) );
	}

	//--------------------------------------------------------------------------------
	CChar16 CChar16::MirroredChar() const
	{
		return CChar16( static_cast< unsigned short >( m + UnicodeGetProp( static_cast< ULookupType >( m ) )->mirrorDiff ) );
	}

	//--------------------------------------------------------------------------------
	CTString< CChar16 > CChar16::Decomposition() const
	{
		unsigned short buffer[3];
		int length;
		int tag;
		const unsigned short *d = DecompositionHelper( static_cast< unsigned int >( m ), &length, &tag, buffer );
		return CTString< CChar16 >( reinterpret_cast< const CChar16* >( d ), static_cast< unsigned short >( length ) );
	}

	//------------------------------------------------------------------------------
	const unsigned short CChar16::Unicode() const 
	{ 
		return m; 
	}

	//------------------------------------------------------------------------------
	unsigned short& CChar16::Unicode() 
	{ 
		return m; 
	}
		
	//------------------------------------------------------------------------------
	CChar8 CChar16::ToLocal8Bit( void ) const
	{
		CChar8 c;
		nsQOR::IThread::ref_type pCurrentThread = nsQOR::CThread::GetCurrent();
		if( pCurrentThread && pCurrentThread->GetCodePage() )
		{
			c = static_cast< unsigned char >( pCurrentThread->GetCodePage()->Encode( Unicode() ) );
		}
		else
		{
			c = static_cast< unsigned char >( m );
		}
		return c;
	}

	//------------------------------------------------------------------------------
	bool CChar16::IsHighSurrogate() const 
	{
		return ( ( m & 0xfc00 ) == 0xd800 );
	}
		
	//------------------------------------------------------------------------------
	bool CChar16::IsLowSurrogate() const 
	{
		return ( ( m & 0xfc00 ) == 0xdc00 );
	}
		
	//------------------------------------------------------------------------------
	unsigned char CChar16::cell() const 
	{ 
		return unsigned char( m & 0xff ); 
	}

	//------------------------------------------------------------------------------
	unsigned char CChar16::row() const 
	{ 
		return unsigned char( ( m >> 8 ) & 0xff ); 
	}
				
	//------------------------------------------------------------------------------
	void CChar16::setCell( unsigned char acell )
	{ 
		m = unsigned short( ( m & 0xff00 ) + acell ); 
	}
		
	//------------------------------------------------------------------------------
	void CChar16::setRow( unsigned char arow )
	{ 
		m = unsigned short( ( unsigned short( arow ) << 8 ) + ( m & 0x00ff ) ); 
	}

	//--------------------------------------------------------------------------------
	CChar16 CChar16::ToLower() const
	{
		const nsUnicodeTables::Properties* p = UnicodeGetProp( static_cast< ULookupType >( m ) );
		if( !p->lowerCaseSpecial )
		{
			return m + p->lowerCaseDiff;
		}
		return m;
	}

	//--------------------------------------------------------------------------------
	CChar16 CChar16::ToUpper() const
	{
		const nsUnicodeTables::Properties* p = UnicodeGetProp( static_cast< ULookupType >( m ) );
		if( !p->upperCaseSpecial )
		{
			return m + p->upperCaseDiff;
		}
		return m;
	}

	//--------------------------------------------------------------------------------
	CChar16 CChar16::ToTitleCase() const
	{
		const nsUnicodeTables::Properties* p = UnicodeGetProp( static_cast< ULookupType >( m ) );
		if( !p->titleCaseSpecial )
		{
			return m + p->titleCaseDiff;
		}
		return m;
	}

	//--------------------------------------------------------------------------------
	CChar16 CChar16::ToCaseFolded() const
	{
		return m + UnicodeGetProp( m )->caseFoldDiff;
	}

	//--------------------------------------------------------------------------------
	const char CChar16::ToAscii() const
	{
		CCodePage* pCodePage = 0;
		nsQOR::IThread::ref_type pCurrentThread = nsQOR::CThread::GetCurrent();

		if( pCurrentThread )
		{
			pCodePage = pCurrentThread->GetCodePage();
		}

		if( pCodePage )
		{
			return static_cast< char >( pCodePage->Encode( static_cast< unsigned int >( m ) ) );
		}
		else
		{
			return m > 0xff ? 0 : char( m );
		}		
	}

	//--------------------------------------------------------------------------------
	CChar16 CChar16::FromAscii( char c )
	{
		CCodePage* pCodePage = 0;
		nsQOR::IThread::ref_type pCurrentThread = nsQOR::CThread::GetCurrent();

		if( pCurrentThread )
		{
			pCodePage = pCurrentThread->GetCodePage();
		}

		if( pCodePage )
		{
			return CChar16( static_cast< unsigned short >( pCodePage->Decode( static_cast< int >( c ) ) ) );
		}
		else
		{
			return CChar16( static_cast< unsigned short >( static_cast< unsigned char >( c ) ) );
		}
	}

/*
QDataStream &operator<<(QDataStream &out, const QChar &chr)
{
    out << quint16(chr.unicode());
    return out;
}
QDataStream &operator>>(QDataStream &in, QChar &chr)
{
    quint16 u;
    in >> u;
    chr.unicode() = ushort(u);
    return in;
}
*/

	//------------------------------------------------------------------------------
    __QOR_INTERFACE( __CODEQOR ) bool operator == ( const CChar16& x0, const CChar16& x1 )
	{
		return x0.m == x1.m;
	}

	//------------------------------------------------------------------------------	
    __QOR_INTERFACE( __CODEQOR ) bool operator != ( const CChar16& x0, const CChar16& x1 )
	{
		return x0.m != x1.m;
	}
	
	//------------------------------------------------------------------------------	
    __QOR_INTERFACE( __CODEQOR ) bool operator != ( const CChar16& x0, const int x1 )
	{
		return x0.m != x1;
	}

	//------------------------------------------------------------------------------
	__QOR_INTERFACE( __CODEQOR ) bool operator <= ( const CChar16& x0, const CChar16& x1 )
	{
		return x0.m <= x1.m;
	}

	//------------------------------------------------------------------------------
	__QOR_INTERFACE( __CODEQOR ) bool operator >= ( const CChar16& x0, const CChar16& x1 )
	{
		return x0.m >= x1.m;
	}
	//------------------------------------------------------------------------------

	__QOR_INTERFACE( __CODEQOR ) bool operator < ( const CChar16& x0, const CChar16& x1 )
	{
		return x0.m < x1.m;
	}

	//------------------------------------------------------------------------------
	__QOR_INTERFACE( __CODEQOR ) bool operator > ( const CChar16& x0, const CChar16& x1 )
	{
		return x0.m > x1.m;
	}

}//nsCodeQOR
