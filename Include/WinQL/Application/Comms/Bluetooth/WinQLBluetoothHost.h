//WinQLBluetoothHost.h

// Copyright Querysoft Limited 2013, 2016
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//Win32 Bluetooth Host

#ifndef WINQL_COMMS_BLUETOOTHHOST_H_3
#define WINQL_COMMS_BLUETOOTHHOST_H_3

#ifdef	__QCMP_OPTIMIZEINCLUDE
#pragma	__QCMP_OPTIMIZEINCLUDE
#endif//__QCMP_OPTIMIZEINCLUDE

#include "WinQL/WinQL.h"
#include <map>
#include <vector>
#include "WinQL/CodeServices/WinQLPolicy.h"
#include "WinQL/CodeServices/Text/WinString.h"
#include "WinQL/GUI/Window.h"
#include "WinQL/GUI/Views/WindowView.h"
#include "WinQL/GUI/Controllers/BaseWindowController.h"
#include "WinQL/GUI/Controllers/Parts/DeviceChangeController.h"
#include "WinQL/GUI/MessageHandler.h"
#include "WinQL/Application/Comms/Bluetooth/WinQLBluetoothRemoteDevice.h"
#include "WinQL/Application/Comms/Bluetooth/WinQLBluetoothFindRadioSession.h"
#include "WinQL/Application/Comms/Bluetooth/WinQLBluetoothAuthenticationSession.h"
#include "WinQL/Application/Comms/Bluetooth/WinQLBluetoothFindDeviceSession.h"
#include "WinQL/Application/Comms/Bluetooth/WinQLBluetoothClient.h"
#include "WinQL/System/Devices/BluetoothRadio/WinQLBluetoothRadio.h"

//--------------------------------------------------------------------------------
namespace nsWinQAPI
{
	class __QOR_INTERFACE( __WINQAPI ) CBthProps;
}//nsWinQAPI

//--------------------------------------------------------------------------------
namespace nsWin32
{
	//--------------------------------------------------------------------------------
	//Non radio specific host side Bluetooth functions
	class __QOR_INTERFACE( __WINQL ) CBluetoothHost
	{
	public:

		//--------------------------------------------------------------------------------
		class __QOR_INTERFACE( __WINQL ) CBluetoothHostWindowClass : public CWindowClass
		{
		public:

			typedef nsCodeQOR::CTLRef< CBluetoothHostWindowClass > refType;

			__QOR_DECLARE_OCLASS_ID( CBluetoothHostWindowClass );

			CBluetoothHostWindowClass();
			virtual ~CBluetoothHostWindowClass();

			virtual const TCHAR* Name( void );
		};

		//--------------------------------------------------------------------------------
		class __QOR_INTERFACE( __WINQL ) CBluetoothDeviceChangeController : public CDeviceChangeController
		{
		public:

			__QOR_DECLARE_OCLASS_ID( CBluetoothDeviceChangeController );

			CBluetoothDeviceChangeController( CBluetoothHost& Host, nsMammut::CModel* pModelItem, nsQOR::CController::ref_type Parent );
			~CBluetoothDeviceChangeController();

			virtual long OnDeviceChange( COSWindow& Window, Cmp_uint_ptr wParam, Cmp_long_ptr lParam );

		private:

			long OnDBTCustomEvent( sDeviceBroadcastHeader* pDeviceBroadcastHeader );
			CBluetoothHost& m_Host;
		};

		//--------------------------------------------------------------------------------
		class __QOR_INTERFACE( __WINQL ) CBluetoothHostMessageHandler : public CMessageHandler
		{
		public:

			//--------------------------------------------------------------------------------
			CBluetoothHostMessageHandler( CBluetoothHost& Host ) : CMessageHandler(), m_Host( Host )
			{
			}

			//--------------------------------------------------------------------------------
			virtual ~CBluetoothHostMessageHandler()
			{
			}

			//--------------------------------------------------------------------------------
			virtual int OnIdle( long lCount ) // return 1 if more idle processing
			{
				return m_Host.ScanForDevices();				
			}

		private:

			CBluetoothHost& m_Host;

			CBluetoothHostMessageHandler( const CBluetoothHostMessageHandler& src );
			CBluetoothHostMessageHandler& operator = ( const CBluetoothHostMessageHandler& src );
		};

		typedef nsCodeQOR::CTLRef< CBluetoothHost > refType;

		typedef int (*fp_Device_Callback)( void* pvParam, const CBluetoothRemoteDevice::Info * pDevice );

		typedef std::map< const BluetoothAddr, CBluetoothRemoteDevice::refType > AddrDeviceMapType;
		typedef std::vector< CBluetoothRadio::refType > VecRadiosType;
		typedef std::map< void*, CBluetoothRadio* > HandleRadioMapType;
		typedef std::map< nsCodeQOR::mxGUID, CBluetoothClient* > ServiceClientClassMapType;

		//--------------------------------------------------------------------------------
		struct ClassOfDevicePairs
		{
			unsigned long ulCODMask;                          //  ClassOfDevice mask to compare
			const wchar_t* pcszDescription;                    //  Descriptive string of mask

		};

		//--------------------------------------------------------------------------------
		struct Select_Device_Params
		{
			unsigned long dwSize;                       //  IN  sizeof this structure

			unsigned long cNumOfClasses;                //  IN  Number in prgClassOfDevice - if ZERO search for all devices
			ClassOfDevicePairs* prgClassOfDevices;		//  IN  Array of CODs to find.

			wchar_t*  pszInfo;                          //  IN  If not NULL, sets the "information" text

			void*    hwndParent;                        //  IN  parent window - NULL == no parent

			int    fForceAuthentication;				//  IN  If TRUE, authenication will be forced before returning
			int    fShowAuthenticated;					//  IN  If TRUE, authenticated devices will be shown in the picker
			int    fShowRemembered;						//  IN  If TRUE, remembered devices will be shown in the picker
			int    fShowUnknown;						//  IN  If TRUE, unknown devices that are not authenticated or "remember" will be shown.

			int    fAddNewDeviceWizard;					//  IN  If TRUE, invokes the add new device wizard.
			int    fSkipServicesPage;					//  IN  If TRUE, skips the "Services" page in the wizard.

			fp_Device_Callback pfnDeviceCallback;		//  IN  If non-NULL, a callback that will be called for each device. If the
														//      the callback returns TRUE, the item will be added. If the callback is
														//      is FALSE, the item will not be shown.
			void*  pvParam;								//  IN  Parameter to be passed to pfnDeviceCallback as the pvParam.

			unsigned long   cNumDevices;                //  IN  number calles wants - ZERO == no limit.
														//  OUT the number of devices returned.

			CBluetoothRemoteDevice::Info*  pDevices;	//  OUT pointer to an array for BLUETOOTH_DEVICE_INFOs.
														//      call BluetoothSelectDevicesFree() to free
		};

		//--------------------------------------------------------------------------------
		enum eScanState
		{
			eInitial,
			eFirst,
			eNext,
			eLast,
		};

		__QOR_DECLARE_OCLASS_ID( CBluetoothHost );
		
		static CBluetoothHostWindowClass s_WindowClass;

		CBluetoothHost();
		virtual ~CBluetoothHost();

		void AuthenticateDevice( COSWindow::refType Window, CBluetoothRemoteDevice::refType Device, CWString strPassKey );
		void AuthenticateDeviceEx( COSWindow::refType ParentWindow, CBluetoothRemoteDevice::refType Device, BluetoothOutOfBandData* pbtOobData, CBluetoothRemoteDevice::Authentication_Requirements AuthentRequirements );

		bool EnableDiscovery( bool bEnabled );
		bool EnableIncomingConnections( bool bEnabled );

		void EnumerateInstalledServices( CBluetoothRemoteDevice::refType Device );

		bool IsConnectable( void );
		bool IsDiscoverable( void );
		bool IsVersionAvailable( unsigned char ucMajor, unsigned char ucMinor );

		void SetLocalServiceInfo( nsCodeQOR::mxGUID* pClassGuid, unsigned long ulInstance, const BluetoothLocalServiceInfo* pServiceInfoIn );

		CFindBluetoothRadioSession::refType FindRadio( CBluetoothRadio::refType& Radio );

		void StartMonitoringRadios( void );
		void StopMonitoringRadios( void );

		unsigned long ScanForDevices( void );		

		AddrDeviceMapType& Devices( void );
		VecRadiosType& Radios( void );

		long OnHCIEvent( BluetoothHCIEventInfo* pEventInfo, void* pRadioHandle  );
		long OnL2CAPEvent( BluetoothL2CAPEventInfo* pEventInfo, void* pRadioHandle  );
		long OnDeviceInRange( BluetoothRadioInRange* pEventInfo, void* pRadioHandle );
		long OnDeviceOutOfRange( BluetoothAddress* pEventInfo, void* pRadioHandle  );
		bool OnAuthenticationRequest( CBluetoothRemoteDevice::Authentication_CallbackParams* pAuthCallbackParams );

		void RegisterServiceClient( nsCodeQOR::mxGUID& ServiceUUID, CBluetoothClient* pClient );
		void UnregisterServiceClient( nsCodeQOR::mxGUID& ServiceUUID, CBluetoothClient* pClient );

	private:

		unsigned long InstanceMonitorThreadProc( void );
		static unsigned long __QCMP_STDCALLCONVENTION StaticMonitorThreadProc( void* pvHost );
		
		void EnumerateRadios( void );
		CBluetoothRadio::refType RadioFromHandle( void* pRadioHandle );

		bool SelectDevices( Select_Device_Params* pParams );
		bool SelectDevicesFree( Select_Device_Params* pParams );

		void ConnectRegisteredServiceClients( CBluetoothRemoteDevice::refType Device );
		void DisconnectRegisteredServiceClients( CBluetoothRemoteDevice::refType Device, CBluetoothClient* pClient );

		AddrDeviceMapType m_MapRemoteDevices;
		VecRadiosType m_VecRadios;
		HandleRadioMapType m_MapRadioHandles;
		ServiceClientClassMapType m_MapServiceClients;
		COSWindow* m_pHostWindow;
		CBaseWindowController m_BaseWindowController;
		CBluetoothDeviceChangeController m_DeviceChangeController;
		CAuthenticateBluetoothSession m_AuthenticationSession;
		unsigned long m_ulMonitorThreadID;
		CThread* m_pBluetoothHostMonitorThread;
		eScanState m_ScanState;
		CFindBluetoothDeviceSession::refType m_FindDeviceSession;
		CBluetoothRemoteDevice::refType m_Proto;

		nsWinQAPI::CBthProps& m_Library;

		CBluetoothHost( const CBluetoothHost& );
		CBluetoothHost& operator = ( const CBluetoothHost& );
	};

}//nsWin32

#endif//WINQL_COMMS_BLUETOOTHHOST_H_3
