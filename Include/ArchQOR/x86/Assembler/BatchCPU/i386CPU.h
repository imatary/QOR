//i386CPU.h

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef ARCHQOR_X86PC_I386CPU_H_2
#define ARCHQOR_X86PC_I386CPU_H_2

#include "i286CPU.h"

//------------------------------------------------------------------------------
namespace nsArch
{
//------------------------------------------------------------------------------
namespace nsx86
{
	//------------------------------------------------------------------------------
	//80386
	class __QOR_INTERFACE( __ARCHQOR ) Ci386CPU : public Ci286CPU
	{
	public:

		Ci386CPU( CCodeGeneratorBase* codeGenerator ) __QCMP_THROW;
		virtual ~Ci386CPU() __QCMP_THROW;
		void db( Cmp_unsigned__int8 x ) __QCMP_THROW;
		void dw( Cmp_unsigned__int16 x ) __QCMP_THROW;
		void dd( Cmp_unsigned__int32 x ) __QCMP_THROW;
		void dq( Cmp_unsigned__int64 x ) __QCMP_THROW;
		void dint8( Cmp__int8 x ) __QCMP_THROW;
		void duint8( Cmp_unsigned__int8 x ) __QCMP_THROW;
		void dint16( Cmp__int16 x ) __QCMP_THROW;
		void duint16( Cmp_unsigned__int16 x ) __QCMP_THROW;
		void dint32( Cmp__int32 x ) __QCMP_THROW;
		void duint32( Cmp_unsigned__int32 x ) __QCMP_THROW;
		void dint64( Cmp__int64 x ) __QCMP_THROW;
		void duint64( Cmp_unsigned__int64 x ) __QCMP_THROW;
		void dsysint( Cmp_int_ptr x ) __QCMP_THROW;
		void dsysuint( Cmp_uint_ptr x ) __QCMP_THROW;
		void dfloat( float x ) __QCMP_THROW;
		void ddouble( double x ) __QCMP_THROW;
		void dptr( void* x ) __QCMP_THROW;
		void dmm( const MMData& x ) __QCMP_THROW;
		void dxmm( const XMMData& x ) __QCMP_THROW;
		void data( const void* data, Cmp_uint_ptr size ) __QCMP_THROW;

		template< typename T >
		inline void dstruct( const T& x ) __QCMP_THROW 
		{ 
			embed( &x, sizeof( T ) ); 
		}

		// [i386 Instructions]
		void bsf( const CGPReg& dst, const CGPReg& src );
		void bsf( const CGPReg& dst, const CMem& src );
		void bsr( const CGPReg& dst, const CGPReg& src );
		void bsr( const CGPReg& dst, const CMem& src );
		void bt( const CGPReg& dst, const CGPReg& src );
		void bt( const CGPReg& dst, const CImm& src );
		void bt( const CMem& dst, const CGPReg& src );
		void bt( const CMem& dst, const CImm& src );
		void btc( const CGPReg& dst, const CGPReg& src );
		void btc( const CGPReg& dst, const CImm& src );
		void btc( const CMem& dst, const CGPReg& src );
		void btc( const CMem& dst, const CImm& src );
		void btr( const CGPReg& dst, const CGPReg& src );
		void btr( const CGPReg& dst, const CImm& src );
		void btr( const CMem& dst, const CGPReg& src );
		void btr( const CMem& dst, const CImm& src );
		void bts( const CGPReg& dst, const CGPReg& src );
		void bts( const CGPReg& dst, const CImm& src );
		void bts( const CMem& dst, const CGPReg& src );
		void bts( const CMem& dst, const CImm& src );
		void cwde();
		void movzx( const CGPReg& dst, const CGPReg& src );
		void movzx( const CGPReg& dst, const CMem& src );

#if	( QOR_ARCH_WORDSIZE == 32 )
		void popad();
#endif // ( QOR_ARCH_WORDSIZE == 32 )
		void popf();
#if	( QOR_ARCH_WORDSIZE == 32 )
		//Pop Stack into EFLAGS Register (32-bit).
		void popfd();
#else
		//Pop Stack into EFLAGS Register (64-bit).
		void popfq();
#endif

#if	( QOR_ARCH_WORDSIZE == 32 )
		void pushad();
#endif // ( QOR_ARCH_WORDSIZE == 32 )

		inline void pushf();
#if	( QOR_ARCH_WORDSIZE == 32 )
		void pushfd();
#else
		inline void pushfq();
#endif // ( QOR_ARCH_WORDSIZE == 32 )
		inline void rep_lodsw();
		void rep_movsw();
		void rep_stosw();
		void repe_cmpsw();
		void repe_scasw();
		void repne_cmpsw();
		void repne_scasw();
		void set( CONDITION cc, const CGPReg& dst );
		void set( CONDITION cc, const CMem& dst );
		void seta( const CGPReg& dst );
		void seta( const CMem& dst );
		void setae( const CGPReg& dst );
		void setae( const CMem& dst );
		void setb( const CGPReg& dst );
		void setb( const CMem& dst );
		void setbe( const CGPReg& dst );
		void setbe( const CMem& dst );
		void setc( const CGPReg& dst );
		void setc( const CMem& dst );
		void sete( const CGPReg& dst );
		void sete( const CMem& dst );
		void setg( const CGPReg& dst );
		void setg( const CMem& dst );
		void setge( const CGPReg& dst );
		void setge( const CMem& dst );
		void setl( const CGPReg& dst );
		void setl( const CMem& dst );
		void setle( const CGPReg& dst );
		void setle( const CMem& dst );
		void setna( const CGPReg& dst );
		void setna( const CMem& dst );
		void setnae( const CGPReg& dst );
		void setnae( const CMem& dst );
		void setnb( const CGPReg& dst );
		void setnb( const CMem& dst );
		void setnbe( const CGPReg& dst );
		void setnbe( const CMem& dst );
		void setnc( const CGPReg& dst );
		void setnc( const CMem& dst );
		void setne( const CGPReg& dst );
		void setne( const CMem& dst );
		void setng( const CGPReg& dst );
		void setng( const CMem& dst );
		void setnge( const CGPReg& dst );
		void setnge( const CMem& dst );
		void setnl( const CGPReg& dst );
		void setnl( const CMem& dst );
		void setnle( const CGPReg& dst );
		void setnle( const CMem& dst );
		void setno( const CGPReg& dst );
		void setno( const CMem& dst );
		void setnp( const CGPReg& dst );
		void setnp( const CMem& dst );
		void setns( const CGPReg& dst );
		void setns( const CMem& dst );
		void setnz( const CGPReg& dst );
		void setnz( const CMem& dst );
		void seto( const CGPReg& dst );
		void seto( const CMem& dst );
		void setp( const CGPReg& dst );
		void setp( const CMem& dst );
		void setpe( const CGPReg& dst );
		void setpe( const CMem& dst );
		void setpo( const CGPReg& dst );
		void setpo( const CMem& dst );
		void sets( const CGPReg& dst );
		void sets( const CMem& dst );
		void setz( const CGPReg& dst );
		void setz( const CMem& dst );
		void shld( const CGPReg& dst, const CGPReg& src1, const CGPReg& src2 );
		void shld( const CGPReg& dst, const CGPReg& src1, const CImm& src2 );
		void shld( const CMem& dst, const CGPReg& src1, const CGPReg& src2 );
		void shld( const CMem& dst, const CGPReg& src1, const CImm& src2 );
		void shrd( const CGPReg& dst, const CGPReg& src1, const CGPReg& src2 );
		void shrd( const CGPReg& dst, const CGPReg& src1, const CImm& src2 );
		void shrd( const CMem& dst, const CGPReg& src1, const CGPReg& src2 );
		void shrd( const CMem& dst, const CGPReg& src1, const CImm& src2 );
		
	private:

		Ci386CPU( const Ci386CPU& src );//no copy constructor
		Ci386CPU& operator = ( const Ci386CPU& src );//no assignment
	};

}//nsx86
}//nsArch

#endif//ARCHQOR_X86PC_I386CPU_H_2
