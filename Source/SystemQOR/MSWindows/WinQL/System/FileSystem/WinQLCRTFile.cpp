//WinQLCRTFile.cpp

// Copyright Querysoft Limited 2013
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "WinQL/Application/ErrorSystem/WinQLError.h"
__QCMP_WARNING_PUSH
__QCMP_WARNING_DISABLE( __QCMP_WARN_THIS_USED_IN_BASE_INIT_LIST, "Safe usafe: stored in member for later use" );
#include "WinQL/System/FileSystem/WinQLCRTFile.h"
#include "WinQL/Application/Threading/WinQLThread.h"
#include "WinQL/CodeServices/Handles/WinQLHandle.h"
#include "WinQL/CodeServices/Text/WinQLFormatter.h"
#include "WinQL/System/WinQLSystem.h"
#include "WinQL/Application/Console/WinQLConsole.h"
#include "WinQL/Application/Console/WinQLConsoleScreenBuffer.h"
#include "WinQL/Definitions/Constants.h"
__QCMP_WARNING_POP
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
//#include <fcntl.h>
#include <stdarg.h>
#include "WinQL/Application/Process/WinQLProcess.h"
#include "WinQAPI/Kernel32.h"

template < typename _CountofType, size_t _SizeOfArray >
		char ( *__countof_helper( UNALIGNED _CountofType ( &_Array )[ _SizeOfArray ] ) )[ _SizeOfArray ];
#		define _countof( _Array ) sizeof( *__countof_helper( _Array ) )

#define _ADDRESSOF(v)   ( &reinterpret_cast<char const &>(v) )
//--------------------------------------------------------------------------------
namespace nsWin32
{
	using namespace nsWinQAPI;

	//TODO: These belong in fcntl_types.h
	/*
	__QCMP_STATIC_CONSTANT( int, OReadOnly =		0x00000 );			//open for reading only
	__QCMP_STATIC_CONSTANT( int, OWriteOnly =		0x00001 );			//open for writing only
	__QCMP_STATIC_CONSTANT( int, OReadWrite =		0x00002 );			//open for reading and writing
	__QCMP_STATIC_CONSTANT( int, OAppend =			0x00008 );			//writes done at eof
	__QCMP_STATIC_CONSTANT( int, OCreate =			0x00100 );			//create and open file
	__QCMP_STATIC_CONSTANT( int, OTruncate =		0x00200 );			//open and truncate
	__QCMP_STATIC_CONSTANT( int, OExclusive =		0x00400 );			//open only if file doesn't already exist

	__QCMP_STATIC_CONSTANT( int, OText =			0x04000 );			//file mode is text (translated). OText files have <cr><lf> sequences translated to <lf> on read()'s, and <lf> sequences translated to <cr><lf> on write()'s
	__QCMP_STATIC_CONSTANT( int, OBinary =			0x08000 );			//file mode is binary (untranslated)
	__QCMP_STATIC_CONSTANT( int, OWText =			0x10000 );			//file mode is UTF16 (translated)
	__QCMP_STATIC_CONSTANT( int, OU16Text =			0x20000 );			//file mode is UTF16 no BOM (translated)
	__QCMP_STATIC_CONSTANT( int, OU8Text =			0x40000 );			//file mode is UTF8  no BOM (translated)

	__QCMP_STATIC_CONSTANT( int, ORaw =				OBinary );			//file mode is binary (untranslated)
	__QCMP_STATIC_CONSTANT( int, ONoInherit =		0x0080 );			//child process doesn't inherit file // Open handle inherit bit
	__QCMP_STATIC_CONSTANT( int, OTemporary =		0x0040 );			//temporary file bit// Temporary file bit - file is deleted when last handle is closed
	__QCMP_STATIC_CONSTANT( int, OShortLived =		0x1000 );			//temporary storage file, try not to flush// temporary access hint
	__QCMP_STATIC_CONSTANT( int, OSequential =		0x0020 );			//file access is primarily sequential sequential/random access hints
	__QCMP_STATIC_CONSTANT( int, ORandom =			0x0010 );			//file access is primarily random

	__QCMP_STATIC_CONSTANT( int, OCloseOnExec =		1 );

	__QCMP_STATIC_CONSTANT( int, ONonBlocking =		0 );				//Non-blocking mode.
	*/
	CCRTFile CCRTFile::_iob[ _IOB_ENTRIES ];

	CCRTFile::TFileDescriptorMap CCRTFile::s_FileDescriptorMap;
	CCriticalSection CCRTFile::s_FileDesMapLock;

	CCRTFile* CCRTFile::s_pStdIn = 0;					//0
	CCRTFile* CCRTFile::s_pStdOut = (CCRTFile*)(1);		//1
	CCRTFile* CCRTFile::s_pStdErr = (CCRTFile*)(2);		//2

	int CCRTFile::_fmode = OBinary;
	int CCRTFile::_commode = _IOCOMMIT;
	int CCRTFile::_umaskval = 0;

	char CCRTFile::_bufin[ 4096 ];
	void* CCRTFile::_stdbuf[] = { 0, 0 };// Buffer pointers for stdout and stderr

	nsWin32::CErrorHelper CCRTFile::m_sErrorHelper;
	nsWin32::CStringHelper CCRTFile::m_sStringHelper;
	nsWin32::CTimeHelper CCRTFile::m_Win32TimeHelper;
	nsWin32::CInterlockedHelper CCRTFile::m_sInterlockedHelper;

	//--------------------------------------------------------------------------------
	char CCRTFile::sachLookupTrailBytes[ 256 ] =
	{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
			3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0
	};

	//--------------------------------------------------------------------------------
	CCRTFile* CCRTFile::StdFile( int i )
	{
		CCRTFile* pFile = CCRTFile::s_FileDescriptorMap.Find( i );

		if( pFile == 0 )
		{
			if( i == 0 )
			{
				CConsole::__initconin();
				//pFile = CConsole::ConsoleInputFile();
				pFile->_flag |= _IORW;
			}

			if( i == 1 )
			{
				CConsole::__initconout();
				pFile = CConsole::ConsoleOutputFile();
			}

			if( pFile != 0 )
			{
				pFile->m_chFlags = (unsigned char)( FOPEN | FTEXT | FDEV );
				pFile->_file = i;
				s_FileDescriptorMap.Insert( i, pFile );
			}
		}

		return pFile;
	}

	//--------------------------------------------------------------------------------
	void CCRTFile::ioInit( STARTUPINFO& StartupInfo )
	{
		int iInheritedHandleCount = 0;
		char* pposFile = 0;
		intptr_t* pposFileHandle = 0;

        // Allocate and initialize the first array of ioinfo structs. This array is pointed to by __pioinfo[0]

        //Process inherited file handle information, if any
        if( ( StartupInfo.cbReserved2 != 0 ) && ( StartupInfo.lpReserved2 != 0 ) )
        {
            //Get the number of handles inherited.
			iInheritedHandleCount = *( reinterpret_cast< int* >( StartupInfo.lpReserved2 ) );
            //Set pointers to the start of the passed file info and OS void* values.
            pposFile = reinterpret_cast< char* >( StartupInfo.lpReserved2 + sizeof( int ) );
            pposFileHandle = reinterpret_cast< intptr_t* >( pposFile + iInheritedHandleCount );

            /*
             * Ensure cfi_len does not exceed the number of supported
             * handles!
             */

            /*
             * Allocate sufficient arrays of ioinfo structs to hold inherited
             * file information.
             */
			for ( int i = 0 ; i < iInheritedHandleCount ; i++, pposFile++, pposFileHandle++ )
			{
				CFileHandle FileHandle( (void*)*pposFileHandle );
				nsWin32::CFile File( FileHandle );
                if ( ( *pposFileHandle != (intptr_t)Invalid_Handle_Value ) &&
                     ( *pposFileHandle != _NO_CONSOLE_FILENO ) &&
                     ( *pposFile & FOPEN ) &&
                     ( ( *pposFile & FPIPE ) ||
					 ( File.GetType() != File_Type_Unknown ) ) )
                {
					nsCodeQOR::CTMapPair< int, CCRTFile* > newItem;
					CCRTFile* pfinherited = new CCRTFile( i, "", FileHandle );
					pfinherited->m_chFlags = *pposFile;
					newItem.Second() = pfinherited;
					CCRTFile::s_FileDescriptorMap.Append( newItem );
                }
                /*
                 * Allocate another array of ioinfo structs
                 */
                    /*
                     * No room for another array of ioinfo structs, reduce
                     * the number of inherited handles we process.
                     */
                /*
                 * Update __pioinfo[] and _nhandle
                 */
            /*
             * Validate and copy the passed file information
             */
                /*
                 * Copy the passed file info iff it appears to describe
                 * an open, valid file or device.
                 *
                 * Note that GetFileType cannot be called for pipe handles
                 * since it may 'hang' if there is blocked read pending on
                 * the pipe in the parent.
                 */
                    /* Allocate the lock for this handle. */
			}
		}
        /*
         * If valid void*-s for standard input, output and error were not
         * inherited, try to obtain them directly from the OS. Also, set the
         * appropriate bits in the osfile fields.
         */
		for ( int fh = 0 ; fh < 3 ; fh++ )
		{
			CCRTFile* pFile = CCRTFile::s_FileDescriptorMap.Find( fh );
			if( pFile == 0 )
			{
				CCRTFile* pnewFile;// = new CCRTFile();

				if( fh == 0 )
				{
					pnewFile = CConsole::ConsoleInputFile();
				}
				else
				{
					pnewFile = CConsole::ConsoleOutputFile();
				}
				pnewFile->m_chFlags = (unsigned char)(FOPEN | FTEXT | FDEV );
				pnewFile->_file = fh;
				CCRTFile::s_FileDescriptorMap.Insert( fh, pnewFile );
			}
			else
			{
				pFile->m_chFlags |= FTEXT;
			}
                /*
                 * mark the handle as open in text mode.
                 */
                    /*
                     * obtained a valid void* from GetStdHandle
                     */
                    /*
                     * finish setting osfile: determine if it is a character
                     * device or pipe.
                     */
                    /* Allocate the lock for this handle. */
					//else
                    /*
                     * For stdin, stdout & stderr, if there is no valid void*,
                     * treat the CRT handle as being open in text mode on a
                     * device with _NO_CONSOLE_FILENO underlying it. We use this
                     * value different from _INVALID_HANDLE_VALUE to distinguish
                     * between a failure in opening a file & a program run
                     * without a console.
                     */
                /*
                 * handle was passed to us by parent process. make
                 * sure it is text mode.
                 */
		}
        /*
         * Set the number of supported void*-s to _nhandle
         */
	}

	//--------------------------------------------------------------------------------
	CCRTFile::CCRTFile() : CFile()
	{
		_ptr = 0;
		_cnt = 0;
		_base = 0;
		_flag = 0;
		_file = 0;
		_charbuf = 0;
		_bufsiz = 0;
		_tmpfname = 0;

        m_chFlags = 0;
        m_chPipe = 10;
        m_chTextMode = 0;
        m_bchUnicode = 0;
        m_achPipeBuffer[ 0 ] = 10;
		m_achPipeBuffer[ 1 ] = 10;
        m_i64StartPos = 0;
        m_bUTF8Translations = false;
	}

	//--------------------------------------------------------------------------------
	CCRTFile::CCRTFile( int iFileDescriptor, const char* szMode ) : CFile()
	{
		_ptr = 0;
		_cnt = 0;
		_base = 0;
		_flag = 0;
		_file = iFileDescriptor;
		_charbuf = 0;
		_bufsiz = 0;
		_tmpfname = 0;

        m_chFlags = 0;
        m_chPipe = 10;
        m_chTextMode = 0;
        m_bchUnicode = 0;
        m_achPipeBuffer[ 0 ] = 10;
		m_achPipeBuffer[ 1 ] = 10;
        m_i64StartPos = 0;
        m_bUTF8Translations = false;
	}

	//--------------------------------------------------------------------------------
	CCRTFile::CCRTFile( int fD, const char* szMode, CFileHandle& OSFileHandle ) : CFile( OSFileHandle )
	{
		_ptr = 0;
		_cnt = 0;
		_base = 0;
		_flag = 0;
		_file = fD;
		_charbuf = 0;
		_bufsiz = 0;
		_tmpfname = 0;

        m_chFlags = 0;
        m_chPipe = 10;
        m_chTextMode = 0;
        m_bchUnicode = 0;
        m_achPipeBuffer[ 0 ] = 10;
		m_achPipeBuffer[ 1 ] = 10;
        m_i64StartPos = 0;
        m_bUTF8Translations = false;
	}

	//--------------------------------------------------------------------------------
	CCRTFile::CCRTFile( CFileHandle& OSFileHandle ) : CFile( OSFileHandle )
	{
		_ptr = 0;
		_cnt = 0;
		_base = 0;
		_flag = 0;
		_file = 0;
		_charbuf = 0;
		_bufsiz = 0;
		_tmpfname = 0;

        m_chFlags = 0;
        m_chPipe = 10;
        m_chTextMode = 0;
        m_bchUnicode = 0;
        m_achPipeBuffer[ 0 ] = 10;
		m_achPipeBuffer[ 1 ] = 10;
        m_i64StartPos = 0;
        m_bUTF8Translations = false;
	}

	//--------------------------------------------------------------------------------
	CCRTFile::CCRTFile( const char* lpFileName, unsigned long dwDesiredAccess, unsigned long dwShareMode, nsWin32::LPSECURITY_ATTRIBUTES lpSecurityAttributes, unsigned long dwCreationDisposition, unsigned long dwFlagsAndAttributes, void* hTemplateFile ) :
		CFile( lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile )
	{
		_ptr = 0;
		_cnt = 0;
		_base = 0;
		_flag = 0;
		_file = 0;
		_charbuf = 0;
		_bufsiz = 0;
		_tmpfname = 0;

        m_chFlags = 0;
        m_chPipe = 10;
        m_chTextMode = 0;
        m_bchUnicode = 0;
        m_achPipeBuffer[ 0 ] = 10;
		m_achPipeBuffer[ 1 ] = 10;
        m_i64StartPos = 0;
        m_bUTF8Translations = false;
	}

	//--------------------------------------------------------------------------------
	CCRTFile::CCRTFile( const char* szFileName, const char* szMode ) : CFile()
	{
		_ptr = 0;
		_cnt = 0;
		_base = 0;
		_flag = 0;
		_file = 0;
		_charbuf = 0;
		_bufsiz = 0;
		_tmpfname = 0;

        m_chFlags = 0;
        m_chPipe = 10;
        m_chTextMode = 0;
        m_bchUnicode = 0;
        m_achPipeBuffer[ 0 ] = 10;
		m_achPipeBuffer[ 1 ] = 10;
        m_i64StartPos = 0;
        m_bUTF8Translations = false;

        if( *szFileName == '\0' )
        {
			(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EINVAL;
        }
		else
		{
			CCriticalSectionLock Lock( m_Lock );

			// open the stream
			LOpen( szFileName, szMode, _SH_DENYNO );
		}

	}

	//--------------------------------------------------------------------------------
	CCRTFile::CCRTFile( int fD, char cFlags, CFileHandle& OSFileHandle ) : CFile( OSFileHandle )
	{
		_file = fD;
		m_chFlags = cFlags;
		_ptr = 0;
		_cnt = 0;
		_base = 0;
		_flag = 0;
		_charbuf = 0;
		_bufsiz = 0;
		_tmpfname = 0;

        m_chPipe = 10;
        m_chTextMode = 0;
        m_bchUnicode = 0;
        m_achPipeBuffer[ 0 ] = 10;
		m_achPipeBuffer[ 1 ] = 10;
        m_i64StartPos = 0;
        m_bUTF8Translations = false;
	}

	//--------------------------------------------------------------------------------
	CCRTFile::~CCRTFile()
	{
	}

	//--------------------------------------------------------------------------------
	//Resets the error and eof indicators for a stream to 0
	void CCRTFile::ClearError( void )
	{
		CCriticalSectionLock Lock( m_Lock );
		_flag &= ~( _IOERR | _IOEOF );
        m_chFlags &= ~(FEOFLAG);
	}

	//--------------------------------------------------------------------------------
	void CCRTFile::FreeBuffer()
	{
		if( IsInUse() && UsesCustomBuffer() )
		{
			free( _base );
			_flag &= ~( _IOMYBUF | _IOSETVBUF );
			_base = _ptr = 0;
			_cnt = 0;
		}
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::Close( void )
	{
		int iResult = eof;
        // If stream is a string, simply clear flag and return -1/*EOF*/
        if( _flag & _IOSTRG )
		{
			_flag = 0;
		}
        else
		{	// Stream is a real file.
			CCriticalSectionLock Lock( m_Lock );

			if( IsInUse() ) // Stream is in use:
			{
               //(1) flush stream
               //(2) free the buffer
               //(3) close the file
               //(4) delete the file if temporary

                iResult = Flush();
                FreeBuffer();

                if( LClose() < 0 )
				{
					iResult = eof;
				}
                else if ( _tmpfname != NULL )
				{
					/*Temporary file (i.e., one created by tmpfile() call). delete, if
					necessary (don't have to on Windows NT because it was done by the
					system when the handle was closed). also, free up the heap block
					holding the pathname.*/
					delete _tmpfname;
					_tmpfname = 0;
                }

			}
			_flag = 0;
        }

		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::LClose()
	{
		int iResult = 0;

		// validate file handle
		//_CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
		//_VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
		//_VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);

		{
			CCriticalSectionLock Lock( m_Lock );

			if ( m_chFlags & FOPEN )
			{

				unsigned long dwDOSResult = 0;

				/*Close the underlying OS file handle. Special cases:
				*      1. If _get_osfhandle(fh) is Invalid_Handle_Value, don't try
				*         to actually close it. Just reset the lowio info so the
				*         handle can be reused. The standard handles are setup like
				*         this in Windows app, or a background app.
				*      2. If fh is STDOUT or STDERR, and if STDOUT and STDERR are
				*         mapped to the same OS file handle, skip the CloseHandle
				*         is skipped (without error). STDOUT and STDERR are the only
				*         handles for which this support is provided. Other handles
				*         are mapped to the same OS file handle only at the
				*         programmer's risk.
				*/

				if( ( Handle() == Invalid_Handle_Value ) ||
						( ( ( _file == 1 && ( s_pStdErr->m_chFlags & FOPEN ) ) ||
						( _file == 2 && ( s_pStdOut->m_chFlags & FOPEN ) ) ) && ( s_pStdOut->Handle() == s_pStdErr->Handle() ) ) )
				{
					//m_pFile = 0;
					m_Handle().Drop();
					dwDOSResult = 0L;
				}
				else
				{
					Close();
					m_Handle().Drop();
					//delete m_pFile ;
				}

				dwDOSResult = m_sErrorHelper.GetLastError();

				m_chFlags = 0;                // clear file flags

				if( dwDOSResult )
				{
					// OS error
					//TODO: CDOSError::MapError( dwDOSResult );
					iResult = -1;
				}

				iResult = 0;
			}
			else
			{
				(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
				iResult = -1;
				//_ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
			}
		}

		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::Commit()
	{
        int iResult = 0;

		CCriticalSectionLock Lock( m_Lock );

		if ( m_chFlags & FOPEN )
		{
			if( ! FlushBuffers() )
			{
				iResult = m_sErrorHelper.GetLastError();
			}
		}

		// map the OS return code to C errno value and return code
		if( iResult != 0 )
		{
			nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = iResult;
			(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
			iResult = -1;
		}

        //_ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
        return iResult;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::Create( const char* szPath, int iMode )
	{
		errno_t e = OpenSHelper( szPath, OCreate + OTruncate + OReadWrite, _SH_DENYNO, iMode, 1 );
		return( e == 0 ? 0 : -1 );
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::WCreate( const wchar_t* wszPath, int iMode )
	{
		errno_t e = OpenSHelper( wszPath, OCreate + OTruncate + OReadWrite, _SH_DENYNO, iMode, 1 );
		return( e == 0 ? 0 : -1 );
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::_dup()
	{
        int newfh = -1;

		CCriticalSectionLock Lock( m_Lock );

		if( m_chFlags & FOPEN )
		{
			newfh = _dup_nolock();
		}
		else
		{
			(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
			nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = 0;
			newfh = -1;
		}

        return newfh;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::_dup_nolock()
	{
        //int newfh;
  //      unsigned long dosretval;                // o.s. return value
  //      char fileinfo;                  // m_chFlags info for file
  //      intptr_t new_osfhandle;
  //      int success = 0;
		//CCRTFile* pNewFile = 0;

  //      fileinfo = m_chFlags;         /* get file info for file */

  //      if( !( m_chFlags & FOPEN ) )
		//{
		//	return -1;
		//}

  //      // create duplicate handle
  //      if( ( pNewFile = new CCRTFile() ) == 0 )
  //      {
		//	errno = EMFILE;         // too many files error
		//	nsWin32::nsCodeServices::t_pCurrentWin32Thread->Data().m_ulDOSErrNumber = 0;
		//	//nsCodeServices::CThread::CThread::GetCurrent()->DOSErrno() = 0;
		//	return 0;              // return error to caller
  //      }

		//{
		//	//duplicate the file handle
		//	nsWin32::nsCodeServices::CHandle Handle( m_pFile->Handle() );
	 //
		//	if( !( Handle.Duplicate( nsWin32::nsCodeServices::CProcess::ThisProcess()->Handle(),
		//		nsWin32::nsCodeServices::CProcess::ThisProcess()->Handle(), (void**)&new_osfhandle, 0L, true, nsWin32::Duplicate_Same_Access ) ) )
		//	{
		//		dosretval = m_sErrorHelper.GetLastError();
		//	}
		//	else
		//	{
		//		pNewFile->m_pFile = new nsWin32::nsFileSystem::CFile( *m_pFile );
		//		dosretval = 0;
		//	}

		//	Handle.Detach();//Detach the object from the handle so that the handle isn't closed when the object goes out of scope

		//	if( dosretval )
		//	{
		//		// o.s. error -- map errpr and release handle
		//		//TODO: CDOSError::MapError( dosretval );
		//	}
		//	else
		//	{
		//		//copy the _osfile value, with the FNOINHERIT bit cleared
		//		pNewFile->m_chFlags = fileinfo & ~FNOINHERIT;
		//		pNewFile->m_chTextMode = m_chTextMode;
		//		pNewFile->m_bchUnicode = m_bchUnicode;
		//		success = 1;
		//	}
		//}

		//if( !success )
		//{
		//	pNewFile->m_chFlags &= ~FOPEN;
		//}

		return 0;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::EoF( void )
	{
        return( ( _flag & _IOEOF ) );
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::Error( void )
	{
		return( ( _flag & _IOERR) );
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::GetC( void )
	{
        int iResult = 0;

		CCriticalSectionLock Lock( m_Lock );
		iResult = ( --_cnt >= 0 ? 0xff & *_ptr++ : FillBuffer() );

        return iResult;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::GetPos( fpos_t* pPos )
	{
        //_VALIDATE_RETURN((stream != NULL), EINVAL, -1);
        //_VALIDATE_RETURN((pos != NULL), EINVAL, -1);

        if( ( *pPos = Telli64() ) != __QCMP_i64_SUFFIX(-1) )
		{
			return( 0 );
		}
        else
		{
			return( -1 );
		}
	}

	//--------------------------------------------------------------------------------
	char* CCRTFile::GetS( char* string, int iCount )
	{

        //char* pch = string;
        char* pResult = string;
		//int ch;
		/*
        //_VALIDATE_RETURN(( string != NULL ) || ( count == 0 ), EINVAL, NULL);
        //_VALIDATE_RETURN(( count >= 0 ), EINVAL, NULL);
        //_VALIDATE_RETURN(( str != NULL ), EINVAL, NULL);

		if( iCount == 0 )
		{
			return 0;
		}

        nsSync::CCriticalSectionLock Lock( m_Lock );

#ifndef _UNICODE
        //_VALIDATE_STREAM_ANSI_SETRET(stream, EINVAL, retval, NULL);
#endif

        if( pResult != 0 )
		{
			while( --iCount )
			{
                ch = _fgettc_nolock();
				if( ch == _TEOF )
				{
					if( pch == string )
					{
						pResult = 0;
						goto done;
					}

					break;
				}

                if( ( *pch++ = ch ) == '\n' )
				{
					break;
				}
			}
			*pch = '\0';
		}

done:
*/
		return pResult;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::FileNo( void )
	{
		return _file;
	}

	//--------------------------------------------------------------------------------
	void CCRTFile::Lock( void )
	{
		m_Lock.Enter();
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::PrintF( const char* szFormat, va_list vargs )
	{
        int iResult = 0;

        CCriticalSectionLock Lock( m_Lock );

		int buffing = _stbuf();
		CFormatter Formatter( this );
		iResult = Formatter.OutputA_l( szFormat/*, 0*/, vargs );
		FlushTempBuffer( buffing );

        return iResult;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::WPrintF( const wchar_t* szFormat, va_list vargs )
	{
		int iResult = 0;
		CCriticalSectionLock Lock( m_Lock );
		int buffing = _stbuf();
		CFormatter Formatter( this );
		iResult = Formatter.OutputW_l( szFormat/*, 0*/, vargs );
		FlushTempBuffer( buffing );
		return iResult;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::PutC( int ch )
	{
        int iResult = 0;

        //_VALIDATE_RETURN((str != NULL), EINVAL, -1/*EOF*/);

        CCriticalSectionLock Lock( m_Lock );

        //_VALIDATE_STREAM_ANSI_SETRET(str, EINVAL, retval, -1/*EOF*/);
		iResult = ( --_cnt >= 0 ? 0xff & (*_ptr++ = (char)(ch) ) :  FlushBuffer( ch ) );

        return iResult;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::PutS( const char* sz )
	{
        int buffing;
        size_t length;
        size_t ndone;

        //_VALIDATE_RETURN((string != NULL), EINVAL, -1/*EOF*/);
        //_VALIDATE_RETURN((stream != NULL), EINVAL, -1/*EOF*/);
        //_VALIDATE_STREAM_ANSI_RETURN(stream, EINVAL, -1/*EOF*/);

        length = strlen( sz );

        CCriticalSectionLock Lock( m_Lock );

        buffing = _stbuf();
        ndone = WriteNoLock( sz,1,length );
        FlushTempBuffer( buffing );

        return( ndone == length ? 0 : -1/*EOF*/ );
	}

	//--------------------------------------------------------------------------------
	size_t CCRTFile::Read( void* ptr, size_t size, size_t nmemb )
	{
		return ReadS( ptr, SIZE_MAX, size, nmemb );
	}

	//--------------------------------------------------------------------------------
	CCRTFile* CCRTFile::Reopen( const char* szFileName, const char* szMode )
	{
		CCRTFile* fp = 0;
		ReopenHelper( &fp, szFileName, szMode, _SH_DENYNO );
		return fp;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::ScanF( const char* szFormat, va_list vargs )
	{
		return 0;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::Seek( long int lOffset, int iWhence )
	{
        int iResult = 0;

        //_VALIDATE_RETURN( (stream != NULL), EINVAL, -1);
        //_VALIDATE_RETURN( ((whence == SEEK_SET) || (whence == SEEK_CUR) || (whence == SEEK_END)), EINVAL, -1);

		CCriticalSectionLock Lock( m_Lock );
		iResult = SeekNoLock( lOffset, iWhence );

        return iResult;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::SeekO( off_t Offset , int iWhence )
	{
		return Seek( (long)Offset, iWhence );
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::SetPos( const fpos_t* pPos )
	{
        //_VALIDATE_RETURN( (stream != NULL), EINVAL, -1);
        //_VALIDATE_RETURN( (pos != NULL), EINVAL, -1);

        return( Seeki64( *pPos, SEEK_SET ) );
	}
	/*
	//--------------------------------------------------------------------------------
	long int CCRTFile::Tell( void )
	{
        long lResult = 0;

        //_VALIDATE_RETURN( (stream != NULL), EINVAL, (-1L) );

        CCriticalSectionLock Lock( m_Lock );
        lResult = TellNoLock();
        return lResult;
	}
	*/
	//--------------------------------------------------------------------------------
	off_t CCRTFile::TellO( void )
	{
		return (off_t)Tell();
	}

	//--------------------------------------------------------------------------------
	Cmp__int64 CCRTFile::Telli64()
	{
		CCriticalSectionLock Lock( m_Lock );
		Cmp__int64 iResult = Telli64NoLock();
        return iResult;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::TryLock( void )
	{
		return m_Lock.TryEnter();
	}

	//--------------------------------------------------------------------------------
	void CCRTFile::Unlock( void )
	{
		m_Lock.Leave();
	}

	//--------------------------------------------------------------------------------
	size_t CCRTFile::Write( const void* pvBuffer, size_t size, size_t Count )
	{
        size_t Result = 0;

        if( !( size == 0 || Count == 0 ) )
		{
			//_VALIDATE_RETURN( (stream != NULL) ,EINVAL, 0);
			CCriticalSectionLock Lock( m_Lock );
			Result = WriteNoLock( pvBuffer, size, Count );
		}

        return Result;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::GetCUnlocked( void )
	{
		return ( --_cnt >= 0 ? 0xff & *_ptr++ : FillBuffer() );
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::PutCUnlocked( int i )
	{
		return ( --_cnt >= 0 ? 0xff & (*_ptr++ = (char)(i) ) :  FlushBuffer( i ) );
	}

	//--------------------------------------------------------------------------------
	wint_t CCRTFile::PutCNoLockW( wchar_t ch )
	{
        if( !( _flag & _IOSTRG ) )
        {
            if( m_chTextMode == __IOINFO_TM_UTF16LE )
            {
                // binary (Unicode) mode
                if( ( _cnt -= sizeof( wchar_t ) ) >= 0 )
				{
                    return (wint_t) ( 0xffff & ( *( ( (wchar_t*)( _ptr )++ ) ) = (wchar_t)ch ) );
                }
				else
				{
                    return (wint_t) FlushBufferW( ch );
                }
            }
            else if ( m_chTextMode == __IOINFO_TM_UTF8 )
            {
                /*This is for files open for unicode writes. We need 2 chars
                 * instead of 1. Note that even if we are writing UTF8, we don't
                 * really need to worry about it here. _write will take care of
                 * proper conversion.
                 */
                char* p = (char *)&ch;

                if( ( --_cnt >= 0 ? 0xff & ( *_ptr++ = (char)( *p ) ) :  FlushBuffer( *p ) ) == -1/*EOF*/)
				{
                    return WEOF;
				}

                ++p;

                if( ( --_cnt >= 0 ? 0xff & ( *_ptr++ = (char)( *p ) ) :  FlushBuffer( *p ) ) == -1/*EOF*/ )
				{
                    return WEOF;
				}

                return (wint_t)( 0xffff & ch );
            }
            else if( ( m_chFlags & FTEXT ) )
            {
				/*
                int size, i;
                char mbc[ MB_LEN_MAX ];

                // text (multi-byte) mode
                if( wctomb_s( &size, mbc, MB_LEN_MAX, ch ) != 0 )
                {
					//Conversion failed; errno is set by wctomb_s;
					// we return WEOF to indicate failure.
					return WEOF;
                }
                for( i = 0; i < size; i++ )
                {
					if( ( --_cnt >= 0 ? 0xff & ( *_ptr++ = (char)( mbc[i] ) ) :  FlushBuffer( mbc[i] ) ) == -1 )//EOF
					{
						return WEOF;
					}
                }
				*/
                return (wint_t)( 0xffff & ch );
            }
        }
        // binary (Unicode) mode
        if( ( _cnt -= sizeof(wchar_t) ) >= 0 )
		{
			*( (wchar_t*)( _ptr ) ) = wchar_t(ch);
			wint_t wtResult = *( (wchar_t*)( _ptr ) ) & 0xffff;
			_ptr += ( sizeof( wchar_t ) / sizeof( *_ptr ) );
			return wtResult;
		}
        else
		{
			return (wint_t) FlushBufferW( ch );
		}
	}

	//--------------------------------------------------------------------------------
	void CCRTFile::Rewind( void )
	{
        //_VALIDATE_RETURN_VOID( (str != NULL), EINVAL);

        CCriticalSectionLock Lock( m_Lock );// Lock the file

        DoFlush();// Flush the stream

        _flag &= ~(_IOERR|_IOEOF);// Clear errors
        m_chFlags &= ~(FEOFLAG);

        // Set flags [note: DoFlush set _cnt=0 and _ptr=_base]
        if( _flag & _IORW )
		{
            _flag &= ~( _IOREAD | _IOWRT );
		}

        // Position to beginning of file
        if( LSeek( 0L, 0 ) == -1 )
		{
			_flag |= _IOERR;
		}
	}

	//--------------------------------------------------------------------------------
	void CCRTFile::SetBuffer( char* pchBuffer )
	{
        if( pchBuffer == 0 )
		{
			SetVBuffer( 0, m_scusIONoBuffering, 0 );
		}
        else
		{
			SetVBuffer( pchBuffer, 0/*_IOFBF*/, 1024/*BUFSIZ*/ );
		}
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::SetVBuffer( char* pchBuffer, int iType, size_t size )
	{
        int iResult = 0;

        //_VALIDATE_RETURN( (str != NULL), EINVAL, -1 );

        // (1) Make sure type is one of the three legal values.
        // (2) If we are buffering, make sure size is between 2 and INT_MAX.

        //_VALIDATE_RETURN( (type == m_scusIONoBuffering) || (type == _IOFBF) || (type == _IOLBF), EINVAL, -1 );

        if( ( iType == 0/*_IOFBF*/ ) || ( iType == 1/*_IOLBF*/ ) )
        {

        }

        //force size to be even by masking down to the nearest multiple of 2

        size &= (size_t)~1;

		CCriticalSectionLock Lock( m_Lock );

        //Flush the current buffer and free it, if it is ours.

        DoFlush();
        FreeBuffer();

        /* Clear a bunch of bits in stream->_flag (all bits related to
         * buffering and those which used to be in stream2->_flag2). Most
         * of these should never be set when setvbuf() is called, but it
         * doesn't cost anything to be safe.
         */

        _flag &= ~( _IOMYBUF | _IOYOURBUF | m_scusIONoBuffering | _IOSETVBUF | _IOFEOF | _IOFLRTN | _IOCTRLZ );

        /*NOTE: Cases 2 and 3 (below) cover type == _IOFBF or type == _IOLBF
         * Line buffering is treated as the same as full buffering, so the
         * _IOLBF bit in stream->_flag is never set. Finally, since _IOFBF is
         * defined to be 0, full buffering is simply assumed whenever m_scusIONoBuffering
         * is not set.
         */

        //CASE 1: No Buffering.
        if( iType & m_scusIONoBuffering )
		{
			_flag |= m_scusIONoBuffering;
			pchBuffer = (char *)&( _charbuf );
			size = 2;
        }
        else if( pchBuffer == 0 ) //CASE 2: Default Buffering -- Allocate a buffer for the user.
		{
			if ( ( pchBuffer = (char*)malloc( size ) ) == 0 )
			{
				iResult = -1;
			}
			else
			{
				_flag |= _IOMYBUF | _IOSETVBUF;
			}
        }
        else	//CASE 3: User Buffering -- Use the buffer supplied by the user.
		{
			_flag |= _IOYOURBUF | _IOSETVBUF;
        }

		if( iResult == 0 )
		{
			_bufsiz = (int)size;
			_ptr = _base = pchBuffer;
			_cnt = 0;
		}

        return iResult ;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::UngetC( int i )
	{
        int iResult = 0;

        //_VALIDATE_RETURN( (stream != NULL), EINVAL, -1/*EOF*/);

        CCriticalSectionLock Lock( m_Lock );

        iResult = UngetCNoLock( i );

        return iResult;
	}


	//--------------------------------------------------------------------------------
	int CCRTFile::LWriteText( const void*& pvBuffer, unsigned long& ulDOSResult, unsigned int& uiCount, char& chTMode, int& iLFCount, int& iWritten, int& iCharCount )
	{
		int iResult = 0;
		// text mode, translate LF's to CR/LF's on output
		ulDOSResult = 0;          // no OS error yet

		if( chTMode == __IOINFO_TM_ANSI )
		{
			char ch;				// current character
			char* p = 0, *q = 0;	// pointers into buf and lfbuf resp.
			char lfbuf[ BUF_SIZE ];
			p = (char *)pvBuffer;        // start at beginning of buffer
			while( (unsigned)( p - (char *)pvBuffer ) < uiCount )
			{
				q = lfbuf;      // start at beginning of lfbuf
				// fill the lf buf, except maybe last char
				while( q - lfbuf < sizeof( lfbuf ) - 1 && (unsigned)( p - (char *)pvBuffer ) < uiCount )
				{
					ch = *p++;
					if( ch == LF )
					{
						++iLFCount;
						*q++ = CR;
					}
					*q++ = ch;
				}

				// write the lf buf and update total
				if( CFile::Write( lfbuf, (int)( q - lfbuf ), (unsigned long*)&iWritten, 0 ) )
				{
					iCharCount += iWritten;
					if( iWritten < q - lfbuf )
					{
						break;
					}
				}
				else
				{
					ulDOSResult = m_sErrorHelper.GetLastError();
					break;
				}
			}
		}
		else if( chTMode == __IOINFO_TM_UTF16LE )
		{
			char lfbuf[BUF_SIZE];
			wchar_t wch;            /* current wide char */
			wchar_t* pu = (wchar_t*)pvBuffer;
			wchar_t* qu = NULL;

			while( (unsigned)( (char *)pu - (char *)pvBuffer) < uiCount )
			{
				qu = (wchar_t*)lfbuf; // start at beginning of lfbuf

				// fill the lf buf, except maybe last wchar_t
				while( ( ( (char *)qu - lfbuf ) < ( sizeof( lfbuf ) - 2 ) ) && ( (unsigned)( (char*)pu - (char*)pvBuffer ) < uiCount ) )
				{
					wch = *pu++;
					if( wch == LF )
					{
						iLFCount+=2;
						*qu++ = CR;
					}
					*qu++ = wch;
				}

				// write the lf buf and update total
				if( CFile::Write( lfbuf, (int)( (char*)qu - lfbuf ), (unsigned long*)&iWritten, 0 ) )
				{
					iCharCount += iWritten;
					if( iWritten < ( (char *)qu - lfbuf ) )
					{
						break;
					}
				}
				else
				{
					ulDOSResult = m_sErrorHelper.GetLastError();
					break;
				}
			}
		}
		else
		{
			/*

			char utf8_buf[ ( BUF_SIZE * 2 ) / 3 ];
			wchar_t utf16_buf[ BUF_SIZE / 6 ];

			wchar_t wch;            // current wide char
			wchar_t* pu = (wchar_t*)pvBuffer;
			wchar_t* qu = 0;

			pu = (wchar_t*)pvBuffer;
			while( (unsigned)( (char *)pu - (char *)pvBuffer ) < uiCount )
			{
				int bytes_converted = 0;
				qu = utf16_buf; // start at beginning of lfbuf

				while( ( ( (char *)qu - (char *)utf16_buf ) < ( sizeof( utf16_buf ) - 2 ) ) && ( (unsigned)( (char *)pu - (char *)pvBuffer ) < uiCount ) )
				{
					wch = *pu++;
					if( wch == LF )
					{
						// no need to count the linefeeds here: we calculate the written chars in another way
						*qu++ = CR;
					}
					*qu++ = wch;
				}

				bytes_converted = m_sStringHelper.WideCharToMultiByte( CCodePage::UTF8, 0, utf16_buf,
                ( (int)( (char *)qu - (char *)utf16_buf ) ) / 2,
                utf8_buf, sizeof( utf8_buf ), 0, 0 );

				if( bytes_converted == 0 )
				{
					ulDOSResult = m_sErrorHelper.GetLastError();
					break;
				}
				else
				{
					int bytes_written = 0;
					do
					{
						if( m_pFile->Write( utf8_buf + bytes_written, bytes_converted - bytes_written, (unsigned long*)&iWritten, 0 ) )
						{
							bytes_written += iWritten;
						}
						else
						{
							ulDOSResult = m_sErrorHelper.GetLastError();
							break;
						}
					} while( bytes_converted > bytes_written );

					if( bytes_converted > bytes_written )
					{
						break;
					}
					// if this chunk has been committed successfully, update charcount
					iCharCount = (int)((char *)pu - (char *)pvBuffer);
				}
			}
			*/
		}
		return iResult;
	}

	//--------------------------------------------------------------------------------
	void CCRTFile::LWriteUConsole( const void*& pvBuffer, char& chTMode, unsigned int& uiCount, int& iLFCount, int& iCharCount, unsigned long& ulDOSResult )
	{
		CConsoleHelper ConsoleHelper;

		unsigned int consoleCP = ConsoleHelper.GetCP();
		char mboutbuf[ 5/*MB_LEN_MAX*/ ];
		wchar_t tmpchar = 0;
		int size = 0;
		int written = 0;
		char* pch;

		for( pch = (char *)pvBuffer; (unsigned)( pch - (char *)pvBuffer ) < uiCount; )
		{
			bool bCR = false;

			if( chTMode == __IOINFO_TM_ANSI )
			{
				/*
				bCR = *pch == LF;
				//Here we need to do double convert. i.e. convert from multibyte to unicode
				// and then from unicode to multibyte in Console codepage.

				if( !( SBChar(*pch).isleadbyte( 0 ) ) )
				{
					if( mbtowc( &tmpchar, pch, 1 ) == -1 )
					{
						break;
					}
				}
				else if( ( uiCount - ( pch - (char*)pvBuffer ) ) > 1 )
				{
					if( mbtowc( &tmpchar, pch, 2 ) == -1 )
					{
						break;
					}
					//Increment pch to accomodate DBCS character.
					++pch;
				}
				else
				{
					break;
				}
				*/
				++pch;
			}
			else if( chTMode == __IOINFO_TM_UTF8 || chTMode == __IOINFO_TM_UTF16LE )
			{
				/*Note that bCR set above is not valid in case of UNICODE
				* stream. We need to set it using unicode character.
				*/
				tmpchar = *(wchar_t*)pch;
				bCR = tmpchar == LF;
				pch += 2;
			}

			if( chTMode == __IOINFO_TM_ANSI )
			{
				if( ( size = m_sStringHelper.WideCharToMultiByte( consoleCP, 0, &tmpchar, 1, mboutbuf, sizeof( mboutbuf ), 0, 0 ) ) == 0 )
				{
					break;
				}
				else
				{
					if( CFile::Write( mboutbuf, size, (unsigned long*)&written, 0 ) )
					{
						iCharCount += written;
						if( written < size )
						{
							break;
						}
					}
					else
					{
						ulDOSResult = m_sErrorHelper.GetLastError();
						break;
					}
				}

				if( bCR )
				{
					size = 1;
					mboutbuf[0] = CR;
					if( CFile::Write( mboutbuf, size, (unsigned long*)&written, 0 ) )
					{
						if( written < size )
						{
							break;
						}
						iLFCount ++;
						iCharCount++;
					}
					else
					{
						ulDOSResult = m_sErrorHelper.GetLastError();
						break;
					}
				}
			}
			else if ( chTMode == __IOINFO_TM_UTF8 || chTMode == __IOINFO_TM_UTF16LE )
			{
				if ( _putwch_nolock(tmpchar) == tmpchar )
				{
					iCharCount++;
				}
				else
				{
					ulDOSResult = m_sErrorHelper.GetLastError();
					break;
				}
				if (bCR) /* emit carriage return */
				{
					size = 1;
					tmpchar = CR;
					if ( _putwch_nolock(tmpchar) == tmpchar )
					{
						iCharCount++;
						iLFCount++;
					}
					else
					{
						ulDOSResult = m_sErrorHelper.GetLastError();
						break;
					}
				}
			}
		}
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::LWrite( const void* buf, unsigned cnt )
	{
		CConsoleHelper ConsoleHelper;
		int r = 0;                          // return value

		//_CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
		//_VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
		//_VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);

		{
			CCriticalSectionLock Lock( m_Lock );

			if( m_chFlags & FOPEN && cnt > 0 )
			{
				//r = _write_nolock( fh, buf, cnt );    // write bytes

				int lfcount;            // count of line feeds
				int charcount;          // count of chars written so far
				int written;            // count of chars written on this write
				unsigned long dosretval = 0;	// o.s. return value
				char tmode;				// textmode - ANSI or UTF-16
				bool toConsole = 0;     // true when writing to console
				bool isCLocale = 0;     // true when locale handle is C locale

				lfcount = charcount = 0;        /* nothing written yet */

				//_VALIDATE_CLEAR_OSSERR_RETURN( (buf != NULL), EINVAL, -1 );

				tmode = m_chTextMode;

				if( tmode == __IOINFO_TM_UTF16LE || tmode == __IOINFO_TM_UTF8 )
				{
					// For a UTF-16 file, the count must always be an even number
					//_VALIDATE_CLEAR_OSSERR_RETURN(((cnt & 1) == 0), EINVAL, -1);
				}

				if( m_chFlags & FAPPEND )
				{
					// appending - seek to end of file; ignore error, because maybe file doesn't allow seeking
#	if _INTEGRAL_MAX_BITS >= 64
					(void)LSeeki64NoLock( 0, nsWin32::File_End );
#	else  // _INTEGRAL_MAX_BITS >= 64
					(void)LSeekNoLock( fh, 0, nsWin32::File_End );
#	endif  // _INTEGRAL_MAX_BITS >= 64
				}

				// check for text mode with LF's in the buffer

				/*Note that in case the handle belongs to Console, write file will
				* generate garbage output. For user to print these characters
				* correctly, we will need to print ANSI.
				*
				* Also note that in case of printing to Console, we still have to
				* convert the characters to console codepage.
				*/

				if( _isatty() && ( m_chFlags & FTEXT ) )
				{
					unsigned long dwMode;
					CFileHandle fHandle( 0 );
					CConsoleScreenBuffer Console( fHandle.Use(), dynamic_cast< CFileHandle& >( *(Handle()) ).Use() );
					isCLocale = true;//TODO: ( nsWin32::nsCodeServices::t_pCurrentWin32Thread->Data().m_LocaleData.LocaleInfoPtr()->Handles()[ CLocale::LCCTYPE ] == CLocale::_CLOCALEHANDLE );
					toConsole = ConsoleHelper.GetDisplayMode( dwMode );
				}

				// don't need double conversion if it's ANSI mode C locale
				if( toConsole && !( isCLocale && ( tmode == __IOINFO_TM_ANSI ) ) )
				{
					LWriteUConsole( buf, tmode, cnt, lfcount, charcount, dosretval );
				}
				else if( m_chFlags & FTEXT )
				{
					LWriteText( buf, dosretval, cnt, tmode, lfcount, written, charcount );
				}
				else
				{
					// binary mode, no translation
					if( CFile::Write( (void*)buf, cnt, (unsigned long*)&written, 0 ) )
					{
						dosretval = 0;
						charcount = written;
					}
					else
					{
						dosretval = m_sErrorHelper.GetLastError();
					}
				}

				if( charcount == 0 )
				{
					/* If nothing was written, first check if an o.s. error, otherwise we return -1 and
					set errno to ENOSPC, unless a device and first char was CTRL-Z */
					if( dosretval != 0 )
					{
                        // o.s. error happened, map error
                        if( dosretval == ERROR_ACCESS_DENIED )
						{
                            // wrong read/write mode should return EBADF, not EACCES
							(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
							nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = dosretval;
                        }
                        else
						{
							//TODO: CDOSError::MapError( dosretval );
							r = -1;
						}
					}
					else if( ( m_chFlags & FDEV ) && *(char *)buf == CTRLZ )
					{
						r = 0;
					}
					else
					{
						(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = ENOSPC;
						nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = 0;
						r = -1;
					}
				}
				else
				{
					// return adjusted bytes written
					r = ( charcount - lfcount );
				}
			}
			else
			{
				(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
				nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = 0;
				r = -1;
				//_ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
			}
		}

		return r;
	}

	//--------------------------------------------------------------------------------
	Cmp__int64 CCRTFile::LSeeki64NoLock( Cmp__int64 i64Pos, int iMethod )
	{
        DINT NewPos;				// new file position
        unsigned long ulErr;		// error code from API call

        NewPos.bigint = i64Pos;

        if( Handle() == Invalid_Handle_Value )
        {
            (*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
            //_ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
            return( __QCMP_i64_SUFFIX(-1) );
		}

		if( ( ( NewPos.twoints.lowerhalf = SetPointer( NewPos.twoints.lowerhalf, &( NewPos.twoints.upperhalf ), iMethod ) ) == -1L ) && ( ( ulErr = m_sErrorHelper.GetLastError() ) != NO_ERROR ) )
        {
			//TODO: CDOSError::MapError( ulErr );
			return( __QCMP_i64_SUFFIX(-1) );
        }

        m_chFlags &= ~FEOFLAG;		// clear the ctrl-z flag on the file
        return( NewPos.bigint );	// return
	}

	//--------------------------------------------------------------------------------
	wint_t CCRTFile::_putwch_nolock( wchar_t ch )
	{
		nsWin32::CConsoleHelper ConsoleHelper;
		int size, num_written;
		static int use_w = 2;
		char mbc[ 5/*MB_LEN_MAX*/ + 1 ];
		if( use_w )
		{
			if( nsWin32::CConsole::ConsoleOutputFile() == (nsWin32::CFile*)(-2) )
			{
				nsWin32::CConsole::__initconout();
			}

			// write character to console file handle

			if( nsWin32::CConsole::ConsoleOutputFile() == (nsWin32::CFile*)(-1) )
			{
				return WEOF;
			}
			else if( !CKernel32::WriteConsoleW( nsWin32::CConsole::ConsoleOutputFile()->Handle(), (void*)&ch, 1, (unsigned long*)&num_written, 0 ) )
			{
				if( use_w == 2 && m_sErrorHelper.GetLastError() == ERROR_CALL_NOT_IMPLEMENTED )
				{
					use_w = 0;
				}
				else
				{
					return WEOF;
				}
			}
			else
			{
				use_w = 1;
			}
		}

		if ( use_w == 0 )
		{
			size = m_sStringHelper.WideCharToMultiByte( ConsoleHelper.GetOutputCP(), 0, (wchar_t*)&ch, 1, mbc, 5/*MB_LEN_MAX*/, 0, 0 );
			if( ( nsWin32::CConsole::ConsoleOutputFile() == (nsWin32::CFile*)(-1) ) || !CKernel32::WriteConsole( nsWin32::CConsole::ConsoleOutputFile()->Handle(), (void*)mbc, size, (unsigned long*)&num_written, 0 ) )
			{
				// return error indicator
				return WEOF;
			}
		}
		return ch;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::FillBuffer()
	{

		if( !IsInUse() || _flag & _IOSTRG )
		{
			return( -1/*_TEOF*/ );
		}

		if( _flag & _IOWRT )
		{
			_flag |= _IOERR;
			return( -1/*_TEOF*/ );
		}

		_flag |= _IOREAD;

		// Get a buffer, if necessary.

		if( !UsesAnyBuffer() )
		{
			GetBuffer();
		}
		else
		{
			_ptr = _base;
		}

		_cnt = LRead( _base, _bufsiz );

		if( ( _cnt == 0 ) || ( _cnt == -1 ) )
		{
			_flag |= _cnt ? _IOERR : _IOEOF;
			_cnt = 0;
			return( -1/*_TEOF*/ );
		}

		if( !( _flag & ( _IOWRT | _IORW ) ) && ( ( m_chFlags & ( FTEXT | FEOFLAG ) ) == ( FTEXT | FEOFLAG ) ) )
		{
			_flag |= _IOCTRLZ;
		}

		/* Check for small _bufsiz (_SMALL_BUFSIZ). If it is small and if it is our buffer, then this must be
		the first FillBuffer after an fseek on a read-access-only stream. Restore _bufsiz to its larger value
		(_INTERNAL_BUFSIZ) so that the next FillBuffer call, if one is made, will fill the whole buffer. */
		if( ( _bufsiz == _SMALL_BUFSIZ ) && ( _flag & _IOMYBUF ) && !( _flag & _IOSETVBUF ) )
		{
			_bufsiz = _INTERNAL_BUFSIZ;
		}

		_cnt--;
		return( 0xff & *_ptr++ );
	}

	//--------------------------------------------------------------------------------
	void CCRTFile::GetBuffer()
	{
        // Try to get a big buffer
		_base = (char*)malloc(_INTERNAL_BUFSIZ);
        if( _base != nullptr )
        {
			// Got a big buffer
			_flag |= _IOMYBUF;
			_bufsiz = _INTERNAL_BUFSIZ;
        }
        else
		{
			// Did NOT get a buffer - use single char buffering.
			_flag |= m_scusIONoBuffering;
			_base = (char *)&(_charbuf);
			_bufsiz = 2;
        }

        _ptr = _base;
        _cnt = 0;
        return;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::LRead( void* pvBuffer, unsigned uCount )
	{
        int iResult = 0;                          // return value

        // validate handle
        //_CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
        //_VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
        //_VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);
        //_VALIDATE_CLEAR_OSSERR_RETURN((cnt <= INT_MAX), EINVAL, -1);

        {
			CCriticalSectionLock Lock( m_Lock );
            if( m_chFlags & FOPEN )
			{
                iResult = LReadNoLock( pvBuffer, uCount );
			}
            else
			{
                (*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
				nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = 0;
                iResult = -1;
                //_ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
            }
        }

        return iResult;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::InitRead( char& chTextMode, void*& pvInputBuffer, unsigned& uCount, void*& pRawBuffer )
	{
		int iResult = 0;
		switch( chTextMode )
		{
		case __IOINFO_TM_UTF8 :
			/* For a UTF-8 file, we need 2 buffers, because after reading we need to convert it into
			UNICODE - MultiByteToWideChar doesn't do in-place conversions. */

			/* MultiByte To WideChar conversion may double the size of the buffer required & hence we
			divide uCount by 2 */

			/* Since we are reading UTF8 stream, uCount bytes read may vary from uCount wchar_t
			characters to uCount/4 wchar_t characters. For this reason if we need to read uCount
			characters, we will allocate MBCS buffer of uCount. In case uCount is 0, we will have 4
			as minimum value. This will make sure we don't overflow for reading from pipe case.

			In this case the numbers of wchar_t characters that we can read is uCount/2. This means
			that the buffer size that we will require is uCount/2.
			 */

			// For UTF8 we want the count to be an even number
			//_VALIDATE_CLEAR_OSSERR_RETURN(((uCount & 1) == 0), EINVAL, -1);

			uCount = ( uCount / 2) < 4 ? 4 : ( uCount / 2 );

			pRawBuffer = malloc( uCount );

			if( !pRawBuffer )
			{
				(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = ENOMEM;
				nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = ENOMEM;//E_nomem;
				iResult = -1;
				break;
			}
			m_i64StartPos = LSeeki64NoLock( 0, nsWin32::File_Current );
			break;

		case __IOINFO_TM_UTF16LE :

			// For UTF16 the count always needs to be an even number
			//_VALIDATE_CLEAR_OSSERR_RETURN(((uCount & 1) == 0), EINVAL, -1);

			uCount &= (~1);

			// Fall Through to default

		default :

			// For non-UTF8 files, we need only 1 buffer - make pRawBuffer point to the users input buffer
			pRawBuffer = pvInputBuffer;
		}

		return iResult;
	}

	//--------------------------------------------------------------------------------
	void CCRTFile::InitReadPipe( char*& pchBuffer, int& iBytesRead, unsigned& uCount, char& chTextMode )
	{
		// a pipe/device and pipe lookahead non-empty: read the lookahead * char
		*pchBuffer++ = m_chPipe;
		++iBytesRead;
		--uCount;
		m_chPipe = LF;           // mark as empty

		// For UTF16, there maybe one more look ahead char. For UTF8, there maybe 2 more look ahead chars
		if( ( chTextMode != __IOINFO_TM_ANSI ) && ( m_achPipeBuffer[ 0 ] != LF ) && uCount != 0 )
		{
			*pchBuffer++ = m_achPipeBuffer[ 0 ];
			++iBytesRead;
			--uCount;
			m_achPipeBuffer[ 0 ] = LF;   // mark as empty

			if( ( chTextMode == __IOINFO_TM_UTF8 ) && ( m_achPipeBuffer[ 1 ] != LF ) && uCount != 0 )
			{
				*pchBuffer++ = m_achPipeBuffer[ 1 ];
				++iBytesRead;
				--uCount;
				m_achPipeBuffer[ 1 ] = LF;   // mark as empty
			}
		}
	}

	//--------------------------------------------------------------------------------
	void CCRTFile::OnReadError( int& iResult, unsigned long& ulDOSResult )
	{
		/* ReadFile has reported an error. recognize two special cases.
		 *
		 *      1. map ERROR_ACCESS_DENIED to EBADF
		 *
		 *      2. just return 0 if ERROR_BROKEN_PIPE has occurred. it
		 *         means the handle is a read-handle on a pipe for which
		 *         all write-handles have been closed and all data has been
		 *         read. */

		if( ( ulDOSResult = m_sErrorHelper.GetLastError() ) == ERROR_ACCESS_DENIED )
		{
			// wrong read/write mode should return EBADF, not EACCES
			(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
			nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = ulDOSResult;
			iResult = -1;
		}
		else if ( ulDOSResult == ERROR_BROKEN_PIPE )
		{
			iResult = 0;
		}
		else
		{
			//TODO: CDOSError::MapError( ulDOSResult );
			iResult = -1;
		}
	}

	//--------------------------------------------------------------------------------
	void CCRTFile::PostReadTextUTF16LE( char& chTextMode, int& iOSBytesRead, void*& pRawBuffer, unsigned long& ulDOSResult, int& iBytesRead, int& iResult, void*& pvInputBuffer, unsigned& uInputSize )
	{
		Cmp__int64 i64FilePos	= 0;		// file position after seek
		wchar_t wchPeek		= 0;		// peek-ahead wchar_t
		wchar_t* pu			= 0;
		wchar_t* qu			= 0;		// wchar_t pointers into buffer for UTF16

		// set CRLF flag to indicate LF at beginning of buffer
		if( ( iOSBytesRead != 0) && ( *(wchar_t *)pRawBuffer == LF ) )
		{
			m_chFlags |= FCRLF;
		}
		else
		{
			m_chFlags &= ~FCRLF;
		}

		// convert chars in the buffer: pu is src, qu is dest
		pu = qu = (wchar_t *)pRawBuffer;
		while( (char *)pu < (char *)pRawBuffer + iBytesRead )
		{
			if ( *pu == CTRLZ )
			{
				// if fh is not a device, set ctrl-z flag
				if( !( m_chFlags & FDEV ) )
				{
					m_chFlags |= FEOFLAG;
				}
				else
				{
					*qu++ = *pu++;
				}
				break;              // stop translating
			}
			else if( *pu != CR )
			{
				*qu++ = *pu++;
			}
			else
			{
				// *pu is CR, so must check next wchar_t for LF
				if( (char *)pu < (char *)pRawBuffer + iBytesRead - 2 )
				{
					if( *(pu+1) == LF )
					{
						pu += 2;
						*qu++ = LF;  // convert CR-LF to LF
					}
					else
					{
						*qu++ = *pu++;    // store char normally
					}
				}
				else
				{
					// This is the hard part.  We found a CR at end of buffer.  We must peek ahead to see if next wchar_t is an LF.
					++pu;

					ulDOSResult = 0;
					if( !CFile::Read( &wchPeek, 2, (unsigned long*)&iOSBytesRead, 0 ) )
					{
						ulDOSResult = m_sErrorHelper.GetLastError();
					}

					if( ulDOSResult != 0 || iOSBytesRead == 0 )
					{
						// couldn't read ahead, store CR
						*qu++ = CR;
					}
					else
					{	/* chPeek now has the extra character -- we
						 * now have several possibilities:
						 * 1. wchar_t is not LF; just seek back and
						 * copy CR
						 * 2. wchar_t is LF; seek back and discard CR
						 * 3. disk file, wchar_t is LF but this is a
						 * one-byte read: store LF, don't seek back.
						 */
						if( m_chFlags & ( FDEV | FPIPE ) )
						{
							// non-seekable device
							if( wchPeek == LF )
							{
								*qu++ = LF;
							}
							else
							{
								char* pwpeekchr = (char *)&wchPeek;
								*qu++ = CR;
								m_chPipe = *pwpeekchr;
								++pwpeekchr;
								m_achPipeBuffer[ 0 ] = *pwpeekchr;
								m_achPipeBuffer[ 1 ] = LF; // Mark as empty
							}
						}
						else
						{
							if( (char *)qu == pRawBuffer && wchPeek == LF )
							{
								*qu++ = LF;// nothing read yet; must make some progress
							}
							else
							{	// seek back
								i64FilePos = LSeeki64NoLock( -2, nsWin32::File_Current );
								if( wchPeek != LF )
								{
									*qu++ = CR;
								}
							}
						}
					}
				}
			}
		}

		// we now change iBytesRead to reflect the true number of chars in the buffer
		iBytesRead = (int)( (char *)qu - (char *)pRawBuffer );
	}

	//--------------------------------------------------------------------------------
	void CCRTFile::PostReadText( char& chTextMode, int& iOSBytesRead, void*& pRawBuffer, unsigned long& ulDOSResult, int& iBytesRead, int& iResult, void*& pvInputBuffer, unsigned& uInputSize )
	{
		Cmp__int64 i64FilePos	= 0;		// file position after seek
		char chPeek			= 0;		// peek-ahead character
		char* p				= 0;
		char* q				= 0;		// pointers into buffer

		// now must translate CR-LFs to LFs in the buffer

		// For ANSI & UTF8, we read byte by byte.
		// For UTF16, we need to read 2 bytes (wchar_t's) at a time
		if( chTextMode != __IOINFO_TM_UTF16LE )
		{
			// set CRLF flag to indicate LF at beginning of buffer
			if( ( iOSBytesRead != 0 ) && ( *(char *)pRawBuffer == LF ) )
			{
				m_chFlags |= FCRLF;
			}
			else
			{
				m_chFlags &= ~FCRLF;
			}

			// convert chars in the buffer: p is src, q is dest
			p = q = (char*)pRawBuffer;
			while( p < (char *)pRawBuffer + iBytesRead )
			{
				if( *p == CTRLZ )
				{
					// if fh is not a device, set ctrl-z flag
					if( !( m_chFlags & FDEV ) )
					{
						m_chFlags |= FEOFLAG;
					}
					else
					{
						*q++ = *p++;
					}
					break;              // stop translating
				}
				else if( *p != CR )
				{
					*q++ = *p++;
				}
				else
				{
					// *p is CR, so must check next char for LF
					if( p < (char *)pRawBuffer + iBytesRead - 1 )
					{
						if( *( p + 1 ) == LF )
						{
							p += 2;
							*q++ = LF;  // convert CR-LF to LF
						}
						else
						{
							*q++ = *p++; // store char normally
						}
					}
					else
					{
						// This is the hard part.  We found a CR at end of buffer.  We must peek ahead to see if next char is an LF.
						++p;

						ulDOSResult = 0;
						if( !CFile::Read( &chPeek, 1, (unsigned long*)&iOSBytesRead, 0 ) )
						{
							ulDOSResult = m_sErrorHelper.GetLastError();
						}

						if( ulDOSResult != 0 || iOSBytesRead == 0 )
						{
							// couldn't read ahead, store CR
							*q++ = CR;
						}
						else
						{
							/* chPeek now has the extra character -- we now
							 * have several possibilities:
							 *
							 * 1. disk file and char is not LF; just seek
							 *    back and copy CR
							 * 2. disk file and char is LF; seek back and
							 *    discard CR
							 * 3. disk file, char is LF but this is a
							 *    one-byte read: store LF, don't seek back
							 * 4. pipe/device and char is LF; store LF.
							 * 5. pipe/device and char isn't LF, store CR
							 *    and put char in pipe lookahead buffer.
							 */
							if( m_chFlags & ( FDEV | FPIPE ) )
							{
								// non-seekable device
								if( chPeek == LF )
								{
									*q++ = LF;
								}
								else
								{
									*q++ = CR;
									m_chPipe = chPeek;
								}
							}
							else
							{
								// disk file
								if( q == pRawBuffer && chPeek == LF )
								{
									// nothing read yet; must make some progress
									*q++ = LF;
								}
								else
								{
									// seek back
									i64FilePos = LSeeki64NoLock( __QCMP_i64_SUFFIX(-1), nsWin32::File_Current );
									if( chPeek != LF )
									{
										*q++ = CR;
									}
								}
							}
						}
					}
				}
			}

			// we now change bytes_read to reflect the true number of chars in the buffer
			iBytesRead = (int)( q - (char *)pRawBuffer );

			if( ( chTextMode == __IOINFO_TM_UTF8 ) && ( iBytesRead != 0 ) )
			{
				//// UTF8 reads need to be converted into UTF16

				//--q; // q has gone beyond the last char

				///* If the last byte is a standalone UTF-8 char. We then take the whole buffer.
				//Otherwise we skip back till we come to a lead byte. If the leadbyte forms a
				//complete UTF-8 character will the remaining part of the buffer, then again we
				//take the whole buffer. If not, we skip to one byte which should be the final
				//trail byte of the previous UTF-8 char or a standalone UTF-8 character
				// */

				//if( _utf8_is_independent( *q ) )
				//{
				//	++q;// Final byte is standalone, we reset q, because we will now consider the full buffer which we have read
				//}
				//else
				//{
				//	int ctr = 1;
				//	int cnt_trailbytes;

				//	while( !_utf8_is_leadbyte( *q ) && ctr <= 4 && q >= (char *)pRawBuffer )
				//	{
				//		--q;
				//		++ctr;
				//	}

				//	cnt_trailbytes = _utf8_no_of_trailbytes( *q );

				//	if( cnt_trailbytes == 0 )
				//	{
				//		/*Should have exited the while by finding a lead
				//		 * byte else, the file has incorrect UTF-8 chars
				//		 */
				//		errno = EILSEQ;
				//		iResult = -1;
				//		return;
				//	}

				//	if( cnt_trailbytes + 1 == ctr )
				//	{
				//		q += ctr;//The leadbyte + the remaining bytes form a full set
				//	}
				//	else
				//	{
				//		// Seek back
				//		if( m_chFlags & ( FDEV | FPIPE ) )
				//		{
				//			/*non-seekable device. Put the extra chars in _pipech & _pipech2.
				//			We would have a maximum of 3 extra chars
				//			 */
				//			m_chPipe = *q;
				//			++q;

				//			if( ctr >= 2 )
				//			{
				//				m_achPipeBuffer[ 0 ] = *q;
				//				++q;
				//			}

				//			if( ctr == 3 )
				//			{
				//				m_achPipeBuffer[ 1 ] = *q;
				//				++q;
				//			}

				//			q -= ctr;// We need to point q back to beyond whatever we actually took in.
				//		}
				//		else
				//		{
				//			// We have read extra chars, so we seek back
				//			i64FilePos = LSeeki64NoLock( -ctr, nsWin32::File_Current );
				//		}
				//	}
				//}

				//iBytesRead = (int)( q - (char *)pRawBuffer );
				//iBytesRead = m_sStringHelper.MultiByteToWideChar( CCodePage::UTF8, 0, (const char*)pRawBuffer, iBytesRead, (wchar_t*)pvInputBuffer, uInputSize / 2 );

				//if( !iBytesRead )
				//{
				//	//TODO: CDOSError::MapError( m_sErrorHelper.GetLastError() );
				//	iResult = -1;
				//	return;
				//}

				//m_bUTF8Translations = ( iBytesRead != (int)(q - (char *)pRawBuffer) );

				//// MultiByteToWideChar returns no of wchar_t's. Double it
				//iBytesRead = iBytesRead * 2;
			}
		}
		else
		{
			PostReadTextUTF16LE( chTextMode, iOSBytesRead, pRawBuffer, ulDOSResult, iBytesRead, iResult, pvInputBuffer, uInputSize );
		}
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::LReadNoLock ( void* pvInputBuffer, unsigned uCount )
	{
		if( uCount == 0 || ( m_chFlags & FEOFLAG ) )
		{
			return 0;// nothing to read or at -1/*EOF*/, so return 0 read
		}

		int iBytesRead		= 0;		// number of bytes read
		char* pchBuffer		= 0;		// buffer to read to
		int iOSBytesRead	= 0;		// bytes read on OS call
		unsigned long ulDOSResult	= 0;		// o.s. return value
		char chTextMode		= m_chTextMode;	// textmode - ANSI/UTF-8/UTF-16
		void* pRawBuffer	= 0;		// buffer to read to
		int iResult			= -2;		// return value
		unsigned uInputSize = uCount;

		// validate fh
		//_CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
		//_VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
		//_VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);
		//_VALIDATE_CLEAR_OSSERR_RETURN((uCount <= INT_MAX), EINVAL, -1);
		//_VALIDATE_CLEAR_OSSERR_RETURN( (pvInputBuffer != NULL), EINVAL, -1 );

		if( InitRead( chTextMode, pvInputBuffer, uCount, pRawBuffer ) == 0 )
		{
			pchBuffer = (char*)pRawBuffer;

			if( ( m_chFlags & ( FPIPE | FDEV ) ) && m_chPipe != LF && uCount != 0 )
			{
				InitReadPipe( pchBuffer, iBytesRead, uCount, chTextMode );
			}
			// read the data
			if( !CFile::Read( pchBuffer, uCount, (unsigned long*)&iOSBytesRead, 0 ) || iOSBytesRead < 0 || (size_t)iOSBytesRead > uCount )
			{
				OnReadError( iResult, ulDOSResult );
			}
			else
			{
				iBytesRead += iOSBytesRead;          // update bytes read

				if( m_chFlags & FTEXT )
				{
					PostReadText( chTextMode, iOSBytesRead, pRawBuffer, ulDOSResult, iBytesRead, iResult, pvInputBuffer, uInputSize );
				}
			}
		}

		if( pRawBuffer != pvInputBuffer )
		{
			free( pRawBuffer );
		}

		return ( iResult == -2 ) ? iBytesRead : iResult ;
	}

	//--------------------------------------------------------------------------------
	Cmp__int64 CCRTFile::Telli64NoLock()
	{
		size_t offset;
		Cmp__int64 filepos;
		char* p;
		char* max;
		size_t rdcnt;
		char tmode;

		if( _cnt < 0 )
		{
			_cnt = 0;
		}

		if( ( filepos = LSeeki64( __QCMP_i64_SUFFIX(0), SEEK_CUR ) ) < 0L )
		{
			return(__QCMP_i64_SUFFIX(-1));
		}

        tmode = m_chTextMode;

        if( !UseBigBuffer() )            // m_scusIONoBuffering or no buffering designated
		{
			return( filepos - _cnt );
		}

        offset = (size_t)( _ptr - _base );

		if( _flag & ( _IOWRT | _IOREAD ) )
		{
			if( tmode == __IOINFO_TM_UTF8 && m_bUTF8Translations )
			{
				size_t curpos = (size_t)( _ptr - _base) / sizeof( wchar_t );

				if( _cnt == 0 )
				{
					return filepos;
				}
				else
				{
					unsigned long bytes_read;
					char buf[ _INTERNAL_BUFSIZ ];

					Cmp__int64 basepos = LSeeki64( m_i64StartPos, SEEK_SET );

					if( basepos != m_i64StartPos )
					{
						return -1;
					}

					if( !CFile::Read( buf, _INTERNAL_BUFSIZ, &bytes_read, 0 ) )
					{
						return -1;
					}

					if( LSeeki64( filepos, SEEK_SET ) < 0 )
					{
						return -1;
					}

					if( curpos > bytes_read )
					{
						return -1;
					}

					p = buf;
					while( curpos-- && ( p < buf + bytes_read ) )
					{
						if( *p == CR )
						{
							// *p is CR, so must check next char for LF
							if( p < (char *)buf + bytes_read - 1 )
							{
								if( *( p + 1 ) == LF )
								{
									p++;
								}
							}
						}
						else
						{
							p += _utf8_no_of_trailbytes( *p );
						}
						p++;
					}
					return basepos + (size_t)( p - buf );
				}
			}

			if( m_chFlags & FTEXT )
			{
				for( p = _base; p < _ptr; p++ )
				{
					if( *p == '\n' )  // adjust for '\r'
					{
						offset++;
					}
				}
			}
        }
        else if( !( _flag & _IORW ) )
		{
			(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EINVAL;
			return(__QCMP_i64_SUFFIX(-1));
        }

        if( filepos == __QCMP_i64_SUFFIX(0) )
		{
			return( (Cmp__int64)offset );
		}

        if( _flag & _IOREAD )    // go to preceding sector
		{
			if( _cnt == 0 )  // filepos holds correct location
			{
				offset = 0;
			}
			else
			{
				rdcnt = _cnt + (size_t)( _ptr - _base );

				// If text mode, adjust for the cr/lf substitution.
				if( m_chFlags & FTEXT )
				{
					/* (1) If we're not at eof, simply copy _bufsiz onto rdcnt to get the # of untranslated
					chars read. (2) If we're at eof, we must look through the buffer expanding the '\n'
					chars one at a time. */

					/* [NOTE: Performance issue -- it is faster to do the two LSeek() calls than to blindly go
					through and expand the '\n' chars regardless of whether we're at eof or not.] */

					if( LSeeki64( __QCMP_i64_SUFFIX(0), SEEK_END ) == filepos )
					{
						max = _base + rdcnt;
						for( p = _base; p < max; p++ )
						{
							if( *p == '\n' )
							{
								// adjust for '\r'
								rdcnt++;
							}
						}

						/* If last byte was ^Z, the lowio read didn't tell us about it.  Check flag
						and bump count, if necessary. */

						if( _flag & _IOCTRLZ )
						{
							++rdcnt;
						}
					}
					else
					{
						if( LSeeki64( filepos, SEEK_SET ) < 0 )
						{
							return (-1);
						}

						/* We want to set rdcnt to the number of bytes originally read into the
						stream buffer (before crlf->lf translation). In most cases, this
						will just be _bufsiz. However, the buffer size may have been changed,
						due to fseek optimization, at the END of the last FillBuffer call. */

						if( ( rdcnt <= _SMALL_BUFSIZ ) && ( _flag & _IOMYBUF ) && !( _flag & _IOSETVBUF ) )
						{
							/* The translated contents of the buffer is small and we
							are not at eof. The buffer size must have been set to
							_SMALL_BUFSIZ during the last FillBuffer call. */
							rdcnt = _SMALL_BUFSIZ;
						}
						else
						{
							rdcnt = _bufsiz;
						}

						/* If first byte in untranslated buffer was a '\n', assume it was preceeded
						by a '\r' which was discarded by the previous read operation and count
						the '\n'. */
						if( m_chFlags & FCRLF )
						{
							++rdcnt;
						}
					}
				}

				if( tmode == __IOINFO_TM_UTF8 )
				{
					rdcnt /= sizeof(wchar_t);
				}

				filepos -= (Cmp__int64)rdcnt;
			}
		}

        if( tmode == __IOINFO_TM_UTF8 )
		{
            offset /= sizeof( wchar_t );
		}
        return( filepos + (Cmp__int64)offset );
	}

	//--------------------------------------------------------------------------------
	Cmp__int64 CCRTFile::LSeeki64( Cmp__int64 pos, int mthd )
	{
        Cmp__int64 i64Result = __QCMP_i64_SUFFIX(-1);

        //_CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1i64 );
        //_VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1i64);
        //_VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1i64);

        CCriticalSectionLock Lock( m_Lock );

		// make sure the file is open (after locking)
		if( m_chFlags & FOPEN )
		{
			i64Result = LSeeki64NoLock( pos, mthd );  // seek
		}
		else
		{
			(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
			nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = 0;
			i64Result =  __QCMP_i64_SUFFIX(-1);
			//_ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
		}

        return i64Result;
	}

    //--------------------------------------------------------------------------------
    wint_t CCRTFile::_fgetc_nolock()
    {
        //TODO:
        wint_t Result = 0;
        return Result;
    }

	//--------------------------------------------------------------------------------
	wint_t CCRTFile::_fgetwc_nolock()
	{
		//if( !( _flag & _IOSTRG ) && m_chTextMode != __IOINFO_TM_ANSI )
  //      {
  //          /* This is for files open with "u" - Unicode Mode. We need to read
  //          2 chars instead of 1. This is required even for UTF8, because read
  //          converts UTF8 to a regular Wide Char */

  //          int ch;
  //          wchar_t wch;
  //          char * p = (char *)&wch;

  //          ch = ( --_cnt >= 0 ? 0xff & *_ptr++ : FillBuffer() );
  //          if( ch == -1/*EOF*/ )
		//	{
  //              return WEOF;
		//	}
  //          *p = (char)ch;
  //          ++p;
  //          ch = (--_cnt >= 0 ? 0xff & *_ptr++ : FillBuffer() );
  //          if( ch == -1/*EOF*/ )
		//	{
  //              return WEOF;
		//	}
  //          *p = (char)ch;
  //          return wch;
  //      }

  //      if( !( _flag & _IOSTRG ) && ( m_chFlags & FTEXT ) )
  //      {
		//	int size = 1;
		//	int ch;
		//	char mbc[ 4 ];
		//	wchar_t wch;

  //          // text (multi-byte) mode
  //          if( ( ch = ( --_cnt >= 0 ? 0xff & *_ptr++ : FillBuffer() ) ) == -1/*EOF*/ )
		//	{
		//		return WEOF;
		//	}

  //          mbc[ 0 ] = (char)ch;

  //          if( SBUChar( (unsigned char)mbc[ 0 ] ).isleadbyte(0) )
  //          {
  //              if( ( ch = ( --_cnt >= 0 ? 0xff & *_ptr++ : FillBuffer() ) ) == -1/*EOF*/ )
  //              {
		//			UngetCNoLock( mbc[ 0 ] );
		//			return WEOF;
  //              }
  //              mbc[ 1 ] = (char)ch;
  //              size = 2;
  //          }

  //          if( mbtowc( &wch, mbc, size ) == -1 )
  //          {
		//		// Conversion failed! Set errno and return failure.
		//		errno = EILSEQ;
		//		return WEOF;
  //          }
  //          return wch;
  //      }

  //      // binary (Unicode) mode
  //      if( ( _cnt -= sizeof(wchar_t) ) >= 0 )
		//{
		//	return *( (wchar_t*)(_ptr++ ) );
		//}
  //      else
		//{
		//	return (wint_t) _filwbuf();
		//}
		return 0;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::UngetCNoLock( int ch )
	{
        //_VALIDATE_STREAM_ANSI_RETURN(str, EINVAL, -1/*EOF*/);

        // Stream must be open for read and can NOT be currently in write mode. Also, UngetC() character cannot be -1/*EOF*/. */
        if( ( ch == -1/*EOF*/ ) || !( ( _flag & _IOREAD ) || ( ( _flag & _IORW ) && !( _flag & _IOWRT ) ) ) )
		{
			return -1/*EOF*/;
		}

        // If stream is unbuffered, get one.
        if( _base == 0 )
        {
            GetBuffer();
        }

        // now we know _base != NULL; since file must be buffered

        if( _ptr == _base )
		{
			if( _cnt )
			{
                // my back is against the wall; i've already done UngetC, and there's no room for this one
				return(-1/*EOF*/);
			}
			_ptr++;
        }

        if( _flag & _IOSTRG )
		{
            // If stream opened by sscanf do not modify buffer
			if( *--_ptr != (char)ch )
			{
				++_ptr;
				return( -1/*EOF*/ );
			}
        }
		else
		{
			*--_ptr = (char)ch;
		}

        _cnt++;
        _flag &= ~_IOEOF;
        _flag |= _IOREAD;       // may already be set

        return( 0xff & ch );
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::_filwbuf()
	{
        //_VALIDATE_RETURN(str != NULL, EINVAL, _TEOF);

        if( !IsInUse() || _flag & _IOSTRG )
		{
			return(WEOF);
		}

        if( _flag & _IOWRT )
		{
			_flag |= _IOERR;
			return(WEOF);
        }

        _flag |= _IOREAD;

        // Get a buffer, if necessary.

        if( !UsesAnyBuffer() )
        {
            GetBuffer();
        }
        else
        {
            _ptr = _base;
        }

        _cnt = LRead( _base, _bufsiz );

        if( ( _cnt == 0 ) || ( _cnt == 1 ) || _cnt == -1 )
		{
			_flag |= _cnt ? _IOERR : _IOEOF;
			_cnt = 0;
			return( WEOF );
        }

        if( !( _flag & ( _IOWRT | _IORW ) ) && ( ( m_chFlags & ( FTEXT | FEOFLAG ) ) == ( FTEXT | FEOFLAG ) ) )
		{
			_flag |= _IOCTRLZ;
		}
        /* Check for small _bufsiz (_SMALL_BUFSIZ). If it is small and
           if it is our buffer, then this must be the first FillBuffer after
           an fseek on a read-access-only stream. Restore _bufsiz to its
           larger value (_INTERNAL_BUFSIZ) so that the next FillBuffer call,
           if one is made, will fill the whole buffer. */
        if( ( _bufsiz == _SMALL_BUFSIZ ) && ( _flag & _IOMYBUF) && !( _flag & _IOSETVBUF ) )
        {
			_bufsiz = _INTERNAL_BUFSIZ;
        }
        _cnt -= sizeof( wchar_t );
        return( 0xffff & *( (wchar_t*)( _ptr++) ) );
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::_stbuf()
	{
        int index;

        // do nothing if not a tty device
        if( !_isatty() )
		{
			return 0;
		}

        // Make sure stream is stdout/stderr and init _stdbuf index
        if( _file == 1 )//( this == stdout )
		{
			index = 0;
		}
        else if( _file == 2 )//( this == stderr )
		{
			index = 1;
		}
        else
		{
			return 0;
		}

        // Make sure the stream is not already buffered.
        if( UsesAnyBuffer() )
		{
			return 0;
		}

        // Allocate a buffer for this stream if we haven't done so yet.
        if( ( _stdbuf[ index ] == NULL ) && ( ( _stdbuf[ index ] = malloc( _INTERNAL_BUFSIZ ) ) == NULL ) )
		{
			// Cannot allocate buffer. Use _charbuf this time
			_ptr = _base = (char*)&( _charbuf );
			_cnt = _bufsiz = 2;
        }
        else
		{
			// Set up the buffer
			_ptr = _base = (char*)_stdbuf[ index ];
			_cnt = _bufsiz = _INTERNAL_BUFSIZ;
        }

        _flag |= ( _IOWRT | _IOYOURBUF | _IOFLRTN );

        return 1;
	}

	//--------------------------------------------------------------------------------
	void CCRTFile::FlushTempBuffer( int flag )
	{
        //_ASSERTE(flag == 0 || flag == 1);

        if( flag )
		{
			if( _flag & _IOFLRTN )
			{
				// Flush the stream and tear down temp buffering.
				Flush();
				_flag &= ~( _IOYOURBUF | _IOFLRTN );
				_bufsiz = 0;
				_base = _ptr = 0;
			}
        }
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::FlushBufferW( int ch )
	{
        int charcount;
        int written;

        if( !( _flag & ( _IOWRT | _IORW ) ) )
		{
			(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
			_flag |= _IOERR;
			return( -1/*EOF*/ );
        }
		else if( ( _flag & _IOSTRG ) )
		{
			(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = ERANGE;
			_flag |= _IOERR;
			return( -1/*EOF*/ );
        }

        /* Check that _IOREAD is not set or, if it is, then so is _IOEOF. Note
           that _IOREAD and IOEOF both being set implies switching from read to
           write at end-of-file, which is allowed by ANSI. Note that resetting
           the _cnt and _ptr fields amounts to doing an fflush() on the stream
           in this case. Note also that the _cnt field has to be reset to 0 for
           the error path as well (i.e., _IOREAD set but _IOEOF not set) as
           well as the non-error path. */

        if( _flag & _IOREAD )
		{
			_cnt = 0;
			if( _flag & _IOEOF )
			{
				_ptr = _base;
				_flag &= ~_IOREAD;
			}
			else
			{
				_flag |= _IOERR;
				return( -1/*EOF*/ );
			}
        }

        _flag |= _IOWRT;
        _flag &= ~_IOEOF;
        written = charcount = _cnt = 0;

        // Get a buffer for this stream, if necessary.
        if( !UsesAnyBuffer() )
		{
            /* Do NOT get a buffer if (1) stream is stdout/stderr, and
               (2) stream is NOT a tty.
               [If stdout/stderr is a tty, we do NOT set up single char
               buffering. This is so that later temporary buffering will
               not be thwarted by the m_scusIONoBuffering bit being set (see
               _stbuf/FlushTempBuffer usage).]
            */
			if( !( ( ( _file == 1/*stdout*/ ) || ( _file == 2/*stderr*/ ) ) && ( _isatty() ) ) )
			{
				GetBuffer();
			}

        }

        if( UseBigBuffer() ) // If big buffer is assigned to stream...
		{
			//_ASSERTE(("inconsistent IOB fields", stream->_ptr - stream->_base >= 0));

			charcount = (int)( _ptr - _base );
			_ptr = _base + sizeof(char);
			_cnt = _bufsiz - (int)sizeof(char);

			if( charcount > 0 )
			{
				written = LWrite( _base, charcount );
			}
			else
			{
				if ( m_chFlags & FAPPEND )
				{
					if( LSeeki64( 0L, SEEK_END ) == -1 )
					{
						_flag |= _IOERR;
						return( -1/*EOF*/ );
					}
				}
			}

			*(wchar_t*)( _base ) = (wchar_t)( ch & 0xffff );
        }
		else
		{
			// Perform single character output (either m_scusIONoBuffering or no buffering)
			charcount = sizeof(char);
			//written = LWrite( &ch, charcount );
            {
				char mbc[4];
				*(wchar_t*)mbc = (wchar_t)(ch & 0xffff);
				written = LWrite( mbc, charcount );
            }
        }

        // See if the LWrite() was successful.
        if( written != charcount )
		{
			_flag |= _IOERR;
			return( -1/*EOF*/ );
        }

        return( ch & 0xffff );
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::FlushBuffer( int ch )
	{
        int charcount;
        int written;

        if( !( _flag & ( _IOWRT | _IORW ) ) )
		{
			(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
			_flag |= _IOERR;
			return( -1/*EOF*/ );
        }
		else if( ( _flag & _IOSTRG ) )
		{
			(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = ERANGE;
			_flag |= _IOERR;
			return( -1/*EOF*/ );
        }

        /* Check that _IOREAD is not set or, if it is, then so is _IOEOF. Note
           that _IOREAD and IOEOF both being set implies switching from read to
           write at end-of-file, which is allowed by ANSI. Note that resetting
           the _cnt and _ptr fields amounts to doing an fflush() on the stream
           in this case. Note also that the _cnt field has to be reset to 0 for
           the error path as well (i.e., _IOREAD set but _IOEOF not set) as
           well as the non-error path. */

        if( _flag & _IOREAD )
		{
			_cnt = 0;
			if( _flag & _IOEOF )
			{
				_ptr = _base;
				_flag &= ~_IOREAD;
			}
			else
			{
				_flag |= _IOERR;
				return( -1/*EOF*/ );
			}
        }

        _flag |= _IOWRT;
        _flag &= ~_IOEOF;
        written = charcount = _cnt = 0;

        // Get a buffer for this stream, if necessary.
        if( !UsesAnyBuffer() )
		{
            /* Do NOT get a buffer if (1) stream is stdout/stderr, and
               (2) stream is NOT a tty.
               [If stdout/stderr is a tty, we do NOT set up single char
               buffering. This is so that later temporary buffering will
               not be thwarted by the m_scusIONoBuffering bit being set (see
               _stbuf/FlushTempBuffer usage).]
            */
			if( !( ( ( _file == 1/*stdout*/ ) || ( _file == 2/*stderr*/ ) ) && ( _isatty() ) ) )
			{
				GetBuffer();
			}

        }

        if( UseBigBuffer() ) // If big buffer is assigned to stream...
		{
			//_ASSERTE(("inconsistent IOB fields", stream->_ptr - stream->_base >= 0));

			charcount = (int)( _ptr - _base );
			_ptr = _base + sizeof(char);
			_cnt = _bufsiz - (int)sizeof(char);

			if( charcount > 0 )
			{
				written = LWrite( _base, charcount );
			}
			else
			{
				if ( m_chFlags & FAPPEND )
				{
					if( LSeeki64( 0L, SEEK_END ) == -1 )
					{
						_flag |= _IOERR;
						return( -1/*EOF*/ );
					}
				}
			}

			*_base = (char)ch;
        }
		else
		{	// Perform single character output (either m_scusIONoBuffering or no buffering)
			charcount = sizeof(char);
			written = LWrite( &ch, charcount );
        }

        // See if the LWrite() was successful.
        if( written != charcount )
		{
			_flag |= _IOERR;
			return( -1/*EOF*/ );
        }

        return( ch & 0xff );
	}

	//--------------------------------------------------------------------------------
	size_t CCRTFile::WriteNoLock( const void* pvBuffer, size_t size, size_t num )
	{
        const char* pchData;			// point to where data comes from next
        size_t Total;                   // total bytes to write
        size_t count;                   // num bytes left to write
        unsigned bufsize;               // size of stream buffer
        unsigned nbytes;                // number of bytes to write now
        unsigned nactuallywritten;      // number of bytes actually written by write() call
        unsigned nwritten;              // number of bytes we consider written
        int c;                          // a temp char

        if( size == 0 || num ==0 )
		{
            return 0;
		}

        //_VALIDATE_RETURN( (stream != NULL) ,EINVAL, 0);
        //_VALIDATE_RETURN( (buffer != NULL) ,EINVAL, 0);
        //_VALIDATE_RETURN(num <= (SIZE_MAX / size), EINVAL, 0);

        pchData = (const char*)pvBuffer;
        count = Total = size * num;

        if( UsesAnyBuffer() )
		{
            // already has buffer, use its size
            bufsize = _bufsiz;
		}
        else
		{
			// assume will get _INTERNAL_BUFSIZ buffer
			bufsize = _INTERNAL_BUFSIZ;
		}

        // here is the main loop -- we go through here until we're done
        while( count != 0 )
		{
			// if the buffer is big and has room, copy data to buffer
			if( UseBigBuffer() && _cnt != 0 )
			{
				if( _cnt < 0 )
				{
                    //_ASSERTE(("Inconsistent Stream Count. Flush between consecutive read and write", stream->_cnt >= 0));
                    _flag |= _IOERR;
                    return ( ( Total - count ) / size );
                }

                // how much do we want?
                nbytes = ( count < (unsigned)_cnt) ? (unsigned)count : _cnt;
                memcpy( _ptr, pchData, nbytes );

                // update stream and amt of data written
                count -= nbytes;
                _cnt -= nbytes;
                _ptr += nbytes;
                pchData += nbytes;
			}
			else if( count >= bufsize )
			{
				/* If we have more than bufsize chars to write, write data by calling write with an integral
				number of bufsiz blocks.  If we reach here and we have a big buffer, it must be full so
				flush it.*/

				if( UseBigBuffer() )
				{
					if( DoFlush() )
					{
						return ( ( Total - count ) / size );// error
					}
				}

				// calc chars to read -- (count/bufsize) * bufsize
				nbytes =( bufsize ? (unsigned)( count - count % bufsize ) : (unsigned)count );
				nactuallywritten = LWrite( pchData, nbytes );
				if( nactuallywritten == (unsigned)-1/*EOF*/ )
				{
					_flag |= _IOERR;
					return ( ( Total - count ) / size );// error
				}

				nwritten = ( nactuallywritten > nbytes ? nbytes : nactuallywritten );

				// update count and data to reflect write

				count -= nwritten;
				pchData += nwritten;

				if( nactuallywritten < nbytes )
				{
					_flag |= _IOERR;
					return ( ( Total - count ) / size );// error
				}
			}
			else
			{
				// buffer full and not enough chars to do direct write, so do a FlushBuffer.
				c = *pchData;  // FlushBuffer write one char, this is it
				if( FlushBuffer( c ) == -1/*EOF*/ )
				{
					return ( ( Total - count ) / size );// error or eof
				}
				++pchData;
				--count;				// FlushBuffer wrote a char -- update count
				bufsize = _bufsiz > 0 ? _bufsiz : 1;// update buffer size
			}
        }

        return num;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::DoFlush()
	{
        int rc = 0;
        int nchar;

        if( ( _flag & ( _IOREAD | _IOWRT ) ) == _IOWRT && UseBigBuffer() &&  ( nchar = (int)(_ptr - _base ) ) > 0 )
        {
			if( LWrite( _base, nchar ) == nchar )
			{
				if( _IORW & _flag )
				{	// if this is a read/write file, clear _IOWRT so that next operation can be a read
					_flag &= ~_IOWRT;
				}
			}
			else
			{
				_flag |= _IOERR;
				rc = -1/*EOF*/;
			}
        }

		_ptr = _base;
        _cnt = 0;

        return rc;
	}

	//--------------------------------------------------------------------------------
	size_t CCRTFile::ReadS( void* buffer, size_t bufferSize, size_t elementSize, size_t count )
	{
		size_t retval = 0;

		if( elementSize == 0 || count == 0 )
		{
			return 0;
		}

		// only checking for stream == NULL here for _lock_str()
		// the rest of the validation is in ReadNoLockS()
		//if (stream == NULL )
		//{
		//	if (bufferSize != SIZE_MAX)
		//	{
		//		memset(buffer, _BUFFER_FILL_PATTERN, bufferSize);
		//	}

		//	_VALIDATE_RETURN((stream != NULL), EINVAL, 0);
		//}

		CCriticalSectionLock Lock( m_Lock );

		// do the read; ReadNoLockS will make sure we do not buffer overrun
        retval = ReadNoLockS( buffer, bufferSize, elementSize, count );

		return retval;
	}

	//--------------------------------------------------------------------------------
	size_t CCRTFile::ReadNoLockS( void* buffer, size_t bufferSize, size_t elementSize, size_t num )
	{
		char* data;                     // point inside the destination buffer to where we need to copy the read chars
		size_t dataSize;                // space left in the destionation buffer (in bytes)
		size_t total;                   // total bytes to read
		size_t count;                   // num bytes left to read
		unsigned streambufsize;         // size of stream buffer
		unsigned nbytes;                // how much to read now
		unsigned nread;                 // how much we did read
		int c;                          // a temp char

		data = (char*)buffer;
		dataSize = bufferSize;

		if( elementSize == 0 || num == 0 )
		{
			return 0;
		}

		//_VALIDATE_RETURN((buffer != NULL), EINVAL, 0);
		if( num > ( SIZE_MAX / elementSize ) )
		{
			if( bufferSize != SIZE_MAX )
			{
				memset( buffer, _BUFFER_FILL_PATTERN, bufferSize );
			}

			//_VALIDATE_RETURN((stream != NULL), EINVAL, 0);
			//_VALIDATE_RETURN(num <= (SIZE_MAX / elementSize), EINVAL, 0);
		}

		count = total = elementSize * num;

		if( UsesAnyBuffer() )
		{
			// already has buffer, use its size
			streambufsize = _bufsiz;
		}
		else
		{
			// assume will get _INTERNAL_BUFSIZ buffer
			streambufsize = _INTERNAL_BUFSIZ;
		}

		// here is the main loop -- we go through here until we're done
		while( count != 0 )
		{
			// if the buffer exists and has characters, copy them to user buffer
			if( UsesAnyBuffer() && _cnt != 0 )
			{
				if( _cnt < 0 )
				{
					//_ASSERTE(("Inconsistent Stream Count. Flush between consecutive read and write", stream->_cnt >= 0));
					_flag |= _IOERR;
					return ( ( total - count ) / elementSize );
				}

				// how much do we want?
				nbytes = ( count < (size_t)_cnt ) ? (unsigned)count : _cnt;
				if( nbytes > dataSize )
				{
					if( bufferSize != SIZE_MAX )
					{
						memset( buffer, _BUFFER_FILL_PATTERN, bufferSize );
					}
					//_VALIDATE_RETURN(("buffer too small", 0), ERANGE, 0)
				}

				memcpy/*_s*/( data/*, dataSize*/, _ptr, nbytes );

				// update stream and amt of data read
				count -= nbytes;
				_cnt -= nbytes;
				_ptr += nbytes;
				data += nbytes;
				dataSize -= nbytes;
			}
			else if( count >= streambufsize )
			{
				/* If we have more than streambufsize chars to read, get data
					by calling read with an integral number of bufsiz
					blocks.  Note that if the stream is text mode, read
					will return less chars than we ordered. */
				if( streambufsize )
				{
					/* In 64bit apps size_t is bigger than unsigned
					 * (which is 32bit even in 64 bit machines), so
					 * we need to split the read into INT_MAX chunks
					 * since LRead() only support up to _signed_ int
					 * (even though the in parameter is unsigned).
					 */
					if( count > 2147483647/*INT_MAX*/ )
					{
						// calc chars to read -- the largest multiple of streambufsize smaller then INT_MAX
						nbytes = (unsigned)( 2147483647/*INT_MAX*/ - 2147483647/*INT_MAX*/ % streambufsize );
					}
					else
					{
						// calc chars to read -- (count/streambufsize) * streambufsize
						nbytes = (unsigned)( count - count % streambufsize );
					}
				}
				else
				{
					nbytes = ( count > 2147483647/*INT_MAX*/ )?(unsigned)2147483647/*INT_MAX*/: (unsigned)count;
				}

				if( nbytes > dataSize )
				{
					if( bufferSize != SIZE_MAX )
					{
						memset( buffer, _BUFFER_FILL_PATTERN, bufferSize );
					}
					//_VALIDATE_RETURN(("buffer too small", 0), ERANGE, 0)
				}

				nread = LRead( data, nbytes );

				if( nread == 0 )
				{
						// end of file -- out of here
						_flag |= _IOEOF;
						return ( ( total - count ) / elementSize );
				}
				else if ( nread == (unsigned)-1 )
				{
					// error -- out of here
					_flag |= _IOERR;
					return ( ( total - count ) / elementSize );
				}

				// update count and data to reflect read
				count -= nread;
				data += nread;
				dataSize -= nread;
			}
			else
			{
				// less than streambufsize chars to read, so call FillBuffer to fill buffer
				if( ( c = FillBuffer() ) == -1/*EOF*/ )
				{
					// error or eof, stream flags set by FillBuffer
					return ( ( total - count ) / elementSize );
				}

				// FillBuffer returned a char -- store it
				if( dataSize == 0 )
				{
					if( bufferSize != SIZE_MAX )
					{
						memset( buffer, _BUFFER_FILL_PATTERN, bufferSize );
					}
					//_VALIDATE_RETURN(("buffer too small", 0), ERANGE, 0)
				}
				*data++ = (char) c;
				--count;
				--dataSize;

				// update buffer size
				streambufsize = _bufsiz;
			}
		}

		// we finished successfully, so just return num
		return num;
	}

	//--------------------------------------------------------------------------------
	errno_t CCRTFile::ReopenHelper( CCRTFile** pfile, const char* filename, const char* mode, int shflag )
	{
        //_VALIDATE_RETURN_ERRCODE( (pfile != NULL), EINVAL);
        *pfile = 0;
        //_VALIDATE_RETURN_ERRCODE( (filename != NULL), EINVAL);
        //_VALIDATE_RETURN_ERRCODE( (mode != NULL), EINVAL);
        //_VALIDATE_RETURN_ERRCODE( (str != NULL), EINVAL);

        if( *filename == '\0' )
        {
            (*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EINVAL;
            return (*nsBaseCRT::CCRTErrorDomain::ErrNo() );
        }

        CCriticalSectionLock Lock( m_Lock );

        // If the stream is in use, try to close it. Ignore possible * error (ANSI 4.9.5.4).
        if( IsInUse() )
        {
            CloseNoLock();
        }

        _ptr = _base = 0;
        _cnt = _flag = 0;
        *pfile = LOpen( filename, mode, shflag );

        if( *pfile )
		{
            return 0;
		}

        return (*nsBaseCRT::CCRTErrorDomain::ErrNo() );
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::CloseNoLock()
	{
        int result = -1/*EOF*/;

        //_VALIDATE_RETURN((str != NULL), EINVAL, -1/*EOF*/);

        if( IsInUse() )
		{
            /* Stream is in use:
                   (1) flush stream
                   (2) free the buffer
                   (3) close the file
                   (4) delete the file if temporary
            */

            result = DoFlush();
            FreeBuffer();

            if( LClose() < 0 )
			{
				result = -1/*EOF*/;
			}
            else if( _tmpfname != 0 )
			{
                /*temporary file (i.e., one created by tmpfile()
                 * call). delete, if necessary (don't have to on
                 * Windows NT because it was done by the system when
                 * the handle was closed). also, free up the heap
                 * block holding the pathname.
                 */

				free( _tmpfname );
				_tmpfname = NULL;
			}
        }

        _flag = 0;
        return result ;
	}

	//--------------------------------------------------------------------------------
	CCRTFile* CCRTFile::LOpen ( const char* szFilename, const char* szMode, int iSHFlag )
	{
  //      int iModeFlag		= 0;
  //      int iStreamFlag		= _commode;
  //      bool bComModeSet	= false;
  //      bool bScanSet		= false;
  //      bool bWhileFlag		= true;
  //      bool bEncodingFlag	= false;

  //      //_ASSERTE(filename != NULL);
  //      //_ASSERTE(mode != NULL);
  //      //_ASSERTE(str != NULL);

  //      // Parse the user's specification string as set flags in
  //      //(1) modeflag - system call flags word
  //      //(2) iStreamFlag - stream handle flags word.

  //      while( *szMode == ' ' )// Skip leading spaces
  //      {
  //          ++szMode;
  //      }

  //      // First mode character must be 'r', 'w', or 'a'.

  //      switch( *szMode )
		//{
  //      case 'r':
		//	iModeFlag = OReadOnly;
		//	iStreamFlag |= _IOREAD;
		//	break;
  //      case 'w':
		//	iModeFlag = OWriteOnly | OCreate | OTruncate;
		//	iStreamFlag |= _IOWRT;
		//	break;
  //      case 'a':
		//	iModeFlag = OWriteOnly | OCreate | OAppend;
		//	iStreamFlag |= _IOWRT;
		//	break;
  //      default:
		//	//_VALIDATE_RETURN(("Invalid file open mode",0), EINVAL, NULL);
		//	return 0;
  //      }

  //      // There can be up to three more optional mode characters:
  //      // (1) A single '+' character,
  //      // (2) One of 't' and 'b' and
  //      // (3) One of 'c' and 'n'.

  //      while( *++szMode && bWhileFlag )
		//{
  //          switch( *szMode )
		//	{
  //          case ' ':
  //              break;// skip spaces

  //          case '+':
		//		if( iModeFlag & OReadWrite )
		//		{
		//			bWhileFlag = false;
		//		}
		//		else
		//		{
		//			iModeFlag |= OReadWrite;
		//			iModeFlag &= ~(OReadOnly | OWriteOnly);
		//			iStreamFlag |= _IORW;
		//			iStreamFlag &= ~(_IOREAD | _IOWRT);
		//		}
		//		break;

  //          case 'b':

		//		if( iModeFlag & ( OText | OBinary ) )
		//		{
		//			bWhileFlag = false;
		//		}
		//		else
		//		{
		//			iModeFlag |= OBinary;
		//		}
		//		break;

  //          case 't':

		//		if( iModeFlag & ( OText | OBinary ) )
		//		{
		//			bWhileFlag = false;
		//		}
		//		else
		//		{
		//			iModeFlag |= OText;
		//		}
		//		break;

  //          case 'c':

  //              if( bComModeSet )
		//		{
		//			bWhileFlag = false;
		//		}
  //              else
		//		{
		//			bComModeSet = true;
		//			iStreamFlag |= _IOCOMMIT;
  //              }
  //              break;

  //          case 'n':
		//		if( bComModeSet )
		//		{
		//			bWhileFlag = false;
		//		}
		//		else
		//		{
		//			bComModeSet = true;
		//			iStreamFlag &= ~_IOCOMMIT;
		//		}
		//		break;

  //          case 'S':
		//		if( bScanSet )
		//		{
		//			bWhileFlag = false;
		//		}
		//		else
		//		{
		//			bScanSet = true;
		//			iModeFlag |= OSequential;
		//		}
		//		break;

  //          case 'R':
		//		if( bScanSet )
		//		{
		//			bWhileFlag = false;
		//		}
		//		else
		//		{
		//			bScanSet = true;
		//			iModeFlag |= ORandom;
		//		}
		//		break;

  //          case 'T':
		//		if( iModeFlag & OShortLived )
		//		{
		//			bWhileFlag = false;
		//		}
		//		else
		//		{
		//			iModeFlag |= OShortLived;
		//		}
		//		break;

  //          case 'D':
		//		if( iModeFlag & OTemporary )
		//		{
		//			bWhileFlag = false;
		//		}
		//		else
		//		{
		//			iModeFlag |= OTemporary;
		//		}
		//		break;

  //          case 'N':
		//		iModeFlag |= ONoInherit;
		//		break;

  //          case ',':
  //              bEncodingFlag = 1;
  //              bWhileFlag = false;
  //              break;

  //          default:
		//		//_VALIDATE_RETURN(("Invalid file open mode",0), EINVAL, NULL);
		//		return 0;
  //          }
		//}

  //      if( bEncodingFlag )
  //      {
  //          static const char ccsField[] = "ccs=";
  //          static const char utf8encoding[] = "UTF-8";
  //          static const char utf16encoding[] = "UTF-16LE";
  //          static const char unicodeencoding[] = "UNICODE";

  //          // Skip spaces
  //          while( *szMode == ' ' )
  //          {
  //              ++szMode;
  //          }

  //          //The length that we want to compare is numbers of elements in csField -1 since this number also contains NULL terminator

  //          if( strncmp( ccsField, szMode, ( _countof( ccsField ) ) - 1 ) != 0 )
		//	{
  //              //_VALIDATE_RETURN(("Invalid file open mode",0), EINVAL, NULL);
		//		return 0;
		//	}

  //          szMode += _countof( ccsField ) - 1;

  //          if( stricmp( szMode, utf8encoding ) == 0 )
		//	{
  //              szMode += _countof( utf8encoding ) - 1;
  //              iModeFlag |= OU8Text;
  //          }
  //          else if( stricmp( szMode, utf16encoding ) == 0 )
		//	{
  //              szMode += _countof( utf16encoding ) - 1;
  //              iModeFlag |= OU16Text;
  //          }
  //          else if( stricmp( szMode, unicodeencoding ) == 0 )
		//	{
  //              szMode += _countof( unicodeencoding ) - 1;
  //              iModeFlag |= OWText;
  //          }
  //          else
		//	{
  //              //_VALIDATE_RETURN(("Invalid file open mode",0), EINVAL, NULL);
		//		return 0;
		//	}
  //      }

  //      while( *szMode == ' ' )// Skip trailing spaces
  //      {
  //          ++szMode;
  //      }

  //      //_VALIDATE_RETURN( (*szMode == _T('\0')), EINVAL, NULL);

  //      // Try to open the file.  Note that if neither 't' nor 'b' is specified, OpenSHelper will use the default.
  //      if( OpenSHelper( szFilename, iModeFlag, iSHFlag, _S_IREAD | _S_IWRITE, 1 ) != 0 )
		//{
		//	return 0;
		//}

  //      _flag = iStreamFlag;
  //      _cnt = 0;
  //      _tmpfname = _base = _ptr = 0;

        return this;
	}

	//--------------------------------------------------------------------------------
	template< typename _tchar >
	errno_t CCRTFile::OpenSHelper( const _tchar* tszPath, int iOFlag, int iSHFlag, int iPMode, int bSecure )
	{
        errno_t Result = 0;
        //int unlock_flag = 0;

        //_VALIDATE_RETURN_ERRCODE( (path != NULL), EINVAL);

        if( bSecure )
		{
            //_VALIDATE_RETURN_ERRCODE(((pmode & (~(_S_IREAD | _S_IWRITE))) == 0), EINVAL);
		}

		Result = OpenNoLockS( tszPath, iOFlag, iSHFlag, iPMode, bSecure );

        return Result;
	}

	//--------------------------------------------------------------------------------
	char CCRTFile::DecodeOpenFlags( int& iOFlag, SECURITY_ATTRIBUTES& SecurityAttributes, int& iFMode, unsigned long& dwFileAccess, int& iSHFlag, unsigned long& dwFileShare, unsigned long& dwFileCreate )
	{
		char chFileFlags = 0;

		iFMode = CCRTFile::_fmode;

        if( iOFlag & ONoInherit )
		{
            SecurityAttributes.bInheritHandle = 0;
            chFileFlags = FNOINHERIT;
        }
        else
		{
            SecurityAttributes.bInheritHandle = 1;
            chFileFlags = 0;
        }

        // figure out binary/text mode
        if( ( iOFlag & OBinary ) == 0 )
		{
            if( iOFlag & ( OText | OWText | OU16Text | OU8Text ) )
			{
                chFileFlags |= FTEXT;
			}
            else if( iFMode != OBinary )   // check default mode
			{
                chFileFlags |= FTEXT;
			}
		}

        //decode the access flags

        switch( iOFlag & ( OReadOnly | OWriteOnly | OReadWrite ) )
		{
		case OReadOnly:         // read access
            dwFileAccess = nsWin32::Generic_Read;
            break;
		case OWriteOnly:         // write access
            /*giving it read access as well because in append (a, not a+), we need
             to read the BOM to determine the encoding (ie. ANSI, UTF8, UTF16)
             */
            if( ( iOFlag & OAppend ) && ( iOFlag & ( OWText | OU16Text | OU8Text ) ) != 0 )
            {
                dwFileAccess = nsWin32::Generic_Read | nsWin32::Generic_Write;
            }
            else
            {
                dwFileAccess = nsWin32::Generic_Write;
            }
            break;
		case OReadWrite:           // read and write access
			dwFileAccess = nsWin32::Generic_Read | nsWin32::Generic_Write;
			break;
		default:				// error, bad iOFlag
			nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = 0;//not an OS error
			//*pfh = -1;
			//_VALIDATE_RETURN_ERRCODE(( "Invalid open flag" , 0 ), EINVAL);
        }

        //decode sharing flags

        switch( iSHFlag )
		{
        case _SH_DENYRW:        // exclusive access
            dwFileShare = 0L;
            break;

        case _SH_DENYWR:        // share read access
            dwFileShare = nsWin32::File_Share_Read;
            break;

        case _SH_DENYRD:        // share write access
            dwFileShare = nsWin32::File_Share_Write;
            break;

        case _SH_DENYNO:        // share read and write access
            dwFileShare = nsWin32::File_Share_Read | nsWin32::File_Share_Write;
            break;

        case _SH_SECURE:       // share read access only if read-only
            if( dwFileAccess == nsWin32::Generic_Read )
			{
                dwFileShare = nsWin32::File_Share_Read;
			}
            else
			{
                dwFileShare = 0L;
			}
            break;

        default:                // error, bad shflag
			nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = 0;// not an OS error
            //*pfh = -1;
            //_VALIDATE_RETURN_ERRCODE(( "Invalid sharing flag" , 0 ), EINVAL);
        }

        //decode open/create method flags

        switch( iOFlag & ( OCreate | OExclusive | OTruncate ) )
		{
        case 0:
        case OExclusive:                   // ignore EXCL w/o CREAT
            dwFileCreate = nsWin32::Open_Existing;
            break;

        case OCreate:
            dwFileCreate = nsWin32::Open_Always;
            break;

        case OCreate | OExclusive:
        case OCreate | OTruncate | OExclusive:
            dwFileCreate = nsWin32::Create_New;
            break;

        case OTruncate:
        case OTruncate | OExclusive:        // ignore EXCL w/o CREAT
            dwFileCreate = nsWin32::Truncate_Existing;
            break;

        case OCreate | OTruncate:
            dwFileCreate = nsWin32::Create_Always;
            break;

        default:
            // this can't happen ... all cases are covered
			nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = 0;
            //*pfh = -1;
            //_VALIDATE_RETURN_ERRCODE(( "Invalid open flag" , 0 ), EINVAL);
        }

		return chFileFlags;
	}

	//--------------------------------------------------------------------------------
	//decode file attribute flags if _O_CREAT was specified
	unsigned long CCRTFile::DecodeOpenAttributes( int& iOFlag, unsigned long& dwFileAccess, unsigned long& dwFileShare, int& iPMode, unsigned int& uiOSPlatform )
	{
		unsigned long dwFileAttributes = nsWin32::File_Attribute_Normal;     // default

        if( iOFlag & OCreate )
		{
            if( !( ( iPMode & ~_umaskval ) & _S_IWRITE ) )
			{
                dwFileAttributes = nsWin32::File_Attribute_ReadOnly;
			}
        }

        //Set temporary file (delete-on-close) attribute if requested.

        if( iOFlag & OTemporary )
		{
            dwFileAttributes |= nsWin32::File_Flag_Delete_On_Close;
            dwFileAccess |= Delete;
            //TODO: if( uiOSPlatform == Ver_Platform_Win32_NT )
			{
                dwFileShare |= File_Share_Delete;
			}
        }

        //Set temporary file (delay-flush-to-disk) attribute if requested.

        if( iOFlag & OShortLived )
		{
			dwFileAttributes |= nsWin32::File_Attribute_Temporary;
		}

        //Set sequential or random access attribute if requested.
        if( iOFlag & OSequential )
		{
            dwFileAttributes |= nsWin32::File_Flag_Sequential_Scan;
		}
        else if ( iOFlag & ORandom )
		{
            dwFileAttributes |= nsWin32::File_Flag_Random_Access;
		}

		return dwFileAttributes;
	}

	//--------------------------------------------------------------------------------
	template< typename _tchar >
	bool CCRTFile::OnOpenError( unsigned long& dwFileAccess, int& iOFlag, const _tchar* tszPath, unsigned long& dwFileShare, unsigned long& dwFileCreate, SECURITY_ATTRIBUTES& SecurityAttributes, unsigned long& dwFileAttributes, errno_t& Result )
	{
		bool bResult = true;
		//delete m_pFile;

        if( ( dwFileAccess & ( nsWin32::Generic_Read | nsWin32::Generic_Write ) ) == ( nsWin32::Generic_Read | nsWin32::Generic_Write ) && ( iOFlag & OWriteOnly ) )
        {
            /*We just failed on CreateFile(). We might be trying open something for read while it cannot
			be read (eg. pipes or devices). So try again with nsWin32::Generic_Write and we will have to use the default
			encoding.  We won't be able to determine the encoding from reading the BOM. */
            dwFileAccess &= ~nsWin32::Generic_Read;
			m_h = CKernel32::CreateFile( tszPath, dwFileAccess, dwFileShare, reinterpret_cast< ::LPSECURITY_ATTRIBUTES >( &SecurityAttributes ), dwFileCreate, dwFileAttributes, 0 );
			//m_pFile = new nsFileSystem::CFile( tszPath, dwFileAccess, dwFileShare, &SecurityAttributes, dwFileCreate, dwFileAttributes, 0 );
            if( Handle() == Invalid_Handle_Value )
            {
                m_chFlags &= ~FOPEN;
				//TODO: CDOSError::MapError( m_sErrorHelper.GetLastError() );
                Result = (*nsBaseCRT::CCRTErrorDomain::ErrNo() );
				bResult = false;
            }
        }
        else
        {
            m_chFlags &= ~FOPEN;
            //TODO: CDOSError::MapError( m_sErrorHelper.GetLastError() );
            Result = (*nsBaseCRT::CCRTErrorDomain::ErrNo() );
			bResult = false;
        }

		return bResult;
	}

	//--------------------------------------------------------------------------------
	bool CCRTFile::PostOpenTextMode( int& iOFlag, char& chFileFlags, int& fmode, errno_t& Result, char& tmode, unsigned long& dwFileAccess, unsigned long& dwFileCreate )
	{
		bool bResult = true;
		char ch;						// character at end of file
		int iFilePos = 0;				// length of file - 1
        if( !( chFileFlags & ( FDEV | FPIPE ) ) && ( chFileFlags & FTEXT ) && ( iOFlag & OReadWrite ) )
        {
            /* We have a text mode file.  If it ends in CTRL-Z, we wish to remove the CTRL-Z character, so
			that appending will work. We do this by seeking to the end of file, reading the last byte, and
			shortening the file if it is a CTRL-Z.
			*/
            if( ( iFilePos = LSeekNoLock( -1, SEEK_END ) ) == -1 )
			{
                // OS error -- should ignore negative seek error, since that means we had a zero-length file.
				if( nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() != ERROR_NEGATIVE_SEEK )
				{
                    LCloseNoLock();
                    Result = (*nsBaseCRT::CCRTErrorDomain::ErrNo() );
					bResult = false;
                    goto exit;
                }
            }
            else
			{
                // Seek was OK, read the last char in file. The last char is a CTRL-Z if and only if LRead returns 0 and ch ends up with a CTRL-Z.
                ch = 0;
                if( LReadNoLock( &ch, 1 ) == 0 && ch == 26 )
				{
                    // read was OK and we got CTRL-Z! Wipe it out!
                    if( ChangeSizeNoLock( iFilePos ) == -1 )
                    {
                        LCloseNoLock();
                        Result = (*nsBaseCRT::CCRTErrorDomain::ErrNo() );
						bResult = false;
                        goto exit;
                    }
                }

                // now rewind the file to the beginning
                if( ( iFilePos = LSeekNoLock( 0, SEEK_SET ) ) == -1 )
				{
                    LCloseNoLock();
                    Result = (*nsBaseCRT::CCRTErrorDomain::ErrNo() );
					bResult = false;
                    goto exit;
                }
            }
        }

		if( chFileFlags & FTEXT )
		{
            int count;

            // Set default tmode per oflag. BOM will change the defualt
            // If oflag does not specify file type get type from _fmode
            if( ( iOFlag & ( OText | OWText | OU16Text | OU8Text ) ) == 0 )
            {
                // Type specified in default mode?
                if( ( fmode & ( OText | OWText | OU16Text | OU8Text ) ) == 0 )
				{
                    iOFlag |= OText; // default to ANSI
				}
                else
				{
                    iOFlag |= fmode & ( OText | OWText | OU16Text | OU8Text );
				}
            }

            // Now oflags should be set to one of the text modes
            //_ASSERTE( (iOFlag & (_O_TEXT | OWText | _O_U16TEXT | _O_U8TEXT) ) != 0 );

            switch( iOFlag & ( OText | OWText | OU16Text | OU8Text ) )
            {
            case OText :
                tmode = __IOINFO_TM_ANSI;
                break;
            case OWText :
            case OWText | OText :
                if ( ( iOFlag & ( OWriteOnly | OCreate | OTruncate ) ) == ( OWriteOnly | OCreate | OTruncate ) )
				{
                    tmode = __IOINFO_TM_UTF16LE;
				}
                break;
            case OU16Text :
            case OU16Text | OText :
                tmode = __IOINFO_TM_UTF16LE;
                break;

            case OU8Text :
            case OU8Text | OText :
                tmode = __IOINFO_TM_UTF8;
                break;
            }

            //If the file hasn't been opened with the UNICODE flags then we have nothing to do
			// textmode's already set to default specified in iOFlag
            if( ( iOFlag & ( OWText | OU16Text | OU8Text ) ) != 0 )
			{
				int bom = 0;
				int bWriteBom = 0;
				int bCheckBom = 0;

                if( !( chFileFlags & FDEV ) )
				{
					switch ( dwFileAccess & ( nsWin32::Generic_Read | nsWin32::Generic_Write ) )
					{
                    case nsWin32::Generic_Read :
                        {
                            bCheckBom = 1;
                            break;
                        }

                    case nsWin32::Generic_Write :
                        {
                            switch( dwFileCreate )
							{
                                // Write BOM if empty file
                            case nsWin32::Open_Existing :
                            case nsWin32::Open_Always :
								{
									// Check if the file contains at least one byte
									// Fall through otherwise
									if( LSeeki64NoLock( 0, SEEK_END ) != 0 )
									{
										if( LSeeki64NoLock( 0, SEEK_SET ) == -1 )
										{
											LCloseNoLock();
											Result = (*nsBaseCRT::CCRTErrorDomain::ErrNo() );
											bResult = false;
											goto exit;
										}
										break;
									}
								}

								// New or truncated file. Always write BOM
                            case nsWin32::Create_New :
                            case nsWin32::Create_Always :
                            case nsWin32::Truncate_Existing :
								{
									bWriteBom = 1;
									break;
								}
                            }
                            break;
                        }

                    case nsWin32::Generic_Read | nsWin32::Generic_Write :
						{
							switch ( dwFileCreate )
							{
								// Check for existing BOM, Write BOM if empty file
                            case nsWin32::Open_Existing :
                            case nsWin32::Open_Always:
								{
									// Check if the file contains at least one byte
									// Fall through otherwise
									if( LSeeki64NoLock( 0, SEEK_END ) != 0 )
									{
										if( LSeeki64NoLock( 0, SEEK_SET ) == -1 )
										{
											LCloseNoLock();
											Result = (*nsBaseCRT::CCRTErrorDomain::ErrNo() );
											bResult = false;
											goto exit;
										}
										bCheckBom = 1;
									}
									else
									{
										bWriteBom = 1; // reset if file is not zero size
									}
									break;
								}

								// New or truncated file. Always write BOM
                            case nsWin32::Create_New :
                            case nsWin32::Truncate_Existing :
                            case nsWin32::Create_Always :
								{
									bWriteBom = 1;
									break;
								}
							}
							break;
						}
					}
                }

                if ( bCheckBom )
				{
                    count = LReadNoLock( &bom, UTF8_BOMLEN );

                    // This branch should never be taken if bWriteBom is 1 and count > 0

                    if( count > 0 && bWriteBom == 1 )
					{
                        //_ASSERTE(0 && "Internal Error");
                        bWriteBom = 0;
                    }

                    switch( count )
					{

                    case -1 :
                        LCloseNoLock();
                        Result = (*nsBaseCRT::CCRTErrorDomain::ErrNo() );
						bResult = false;
                        goto exit;

                    case UTF8_BOMLEN:
                        if( bom == UTF8_BOM )
						{
                            tmode = __IOINFO_TM_UTF8;
                            break;
                        }

                    case UTF16_BOMLEN:
                        if( ( bom & BOM_MASK ) == UTF16BE_BOM )
						{
                            LCloseNoLock();
                            //_ASSERTE(0 && "Only UTF-16 little endian & UTF-8 is supported for reads");
                            Result = (*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EINVAL;
							bResult = false;
                            goto exit;
                        }

                        if( ( bom & BOM_MASK ) == UTF16LE_BOM )
						{
                            // We have read 3 bytes, so we should seek back 1 byte
                            if( ( iFilePos = LSeekNoLock( UTF16_BOMLEN, SEEK_SET ) ) == -1 )
							{
                                LCloseNoLock();
                                Result = (*nsBaseCRT::CCRTErrorDomain::ErrNo() );
								bResult = false;
                                goto exit;
                            }
                            tmode = __IOINFO_TM_UTF16LE;
                            break;
                        }

                        // Fall through to default case to lseek to beginning of file

                    default:

                        if( ( iFilePos = LSeekNoLock( 0, SEEK_SET ) ) == -1 )
						{
                            // No BOM, so we should seek back to the beginning of the file
                            LCloseNoLock();
                            Result = (*nsBaseCRT::CCRTErrorDomain::ErrNo() );
							bResult = false;
                            goto exit;
                        }
                        break;
                    }
				}

                if( bWriteBom )
				{
                    int written = 0;
                    int bomlen = 0;
                    bom = 0;

                    // If we are creating a new file, we write a UTF-16LE or UTF8 BOM
                    switch( tmode )
                    {
                    case __IOINFO_TM_UTF16LE :
                        {
                            bom = UTF16LE_BOM;
                            bomlen = UTF16_BOMLEN;
                            break;
                        }
                    case __IOINFO_TM_UTF8 :
                        {
                            bom = UTF8_BOM;
                            bomlen = UTF8_BOMLEN;
                            break;
                        }
                    }

                    while( bomlen > written )
					{
                        int tmp = 0;
                        // Note that write may write less than bomlen characters, but not really fail.
                        // Retry till write fails or till we wrote all the characters.
                        if( ( tmp = LWrite( ( (char *)(&bom) ) + written, bomlen - written ) ) == -1 )
						{
                            LCloseNoLock();
                            Result = (*nsBaseCRT::CCRTErrorDomain::ErrNo() );
							bResult = false;
                            break;
                        }
                        written += tmp;
                    }
				}
            }
        }

exit:
		return bResult;
	}

	//--------------------------------------------------------------------------------
	template< typename _tchar >
	errno_t CCRTFile::PostOpen( int& iOFlag, char& chFileFlags, int& fmode, unsigned long& dwFileAccess, unsigned long& dwFileCreate, unsigned long& dwFileAttribute, const _tchar* tszPath, unsigned long& dwFileShare, SECURITY_ATTRIBUTES& SecurityAttributes )
	{
		errno_t Result = 0;
		char tmode = __IOINFO_TM_ANSI;  // textmode - ANSI/UTF-8/UTF-16
		unsigned long isdev = GetType();                    // device indicator in low byte

        // find out what type of file (file/device/pipe)
		if( isdev == File_Type_Unknown )
		{
            unsigned long dwLastError = 0;
            m_chFlags &= ~FOPEN;
            dwLastError = m_sErrorHelper.GetLastError();
            //TODO: CDOSError::MapError( dwLastError );
			//delete m_pFile;
			m_h = 0;
			//m_pFile = 0;
            if( dwLastError == ERROR_SUCCESS )
            {
               /*If GetFileType returns File_Type_Unknown but doesn't fail, GetLastError returns ERROR_SUCCESS.
                * This function is not designed to deal with unknown types of files and must return an error.
               */
               (*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EACCESS;
            }
            Result = (*nsBaseCRT::CCRTErrorDomain::ErrNo() );
        }
		else
		{

			// use isdev value to set flags
			if( isdev == nsWin32::File_Type_Char )
			{
				chFileFlags |= FDEV;
			}
			else if( isdev == nsWin32::File_Type_Pipe )
			{
				chFileFlags |= FPIPE;
			}

			chFileFlags |= FOPEN;
			m_chFlags = chFileFlags;

			// TextMode set to ANSI by default, if we find a BOM, then we reset it to the appropriate type below
			m_chTextMode = __IOINFO_TM_ANSI;

			if( PostOpenTextMode( iOFlag, chFileFlags, fmode, Result, tmode, dwFileAccess, dwFileCreate ) )
			{

				m_chTextMode = tmode;
				m_bchUnicode = ( ( iOFlag & OWText ) == 0 ) ? 0 : 1;

				//Set FAPPEND flag if appropriate. Don't do this for devices or pipes.

				if( !( chFileFlags & ( FDEV | FPIPE ) ) && ( iOFlag & OAppend ) )
				{
					m_chFlags |= FAPPEND;
				}

				//re-open the file with write access only if we opened the file with read access to read the BOM before
				if( ( dwFileAccess & ( nsWin32::Generic_Read | nsWin32::Generic_Write ) ) == ( nsWin32::Generic_Read | nsWin32::Generic_Write ) && ( iOFlag & OWriteOnly ) )
				{
					// we will have to reopen the file again with the write access (but not read)
					//delete m_pFile;
					//m_pFile = 0;
					m_h = 0;
					dwFileAccess &= ~nsWin32::Generic_Read;
					// we want to use nsWin32::Open_Existing here, because the user can open the an non-existing
					// file for append with _O_EXCL flag
					dwFileCreate = nsWin32::Open_Existing;
					//m_pFile = new nsFileSystem::CFile( tszPath, dwFileAccess, dwFileShare, &SecurityAttributes, dwFileCreate, dwFileAttribute, 0 );
					m_h = CKernel32::CreateFile( tszPath, dwFileAccess, dwFileShare, reinterpret_cast< ::LPSECURITY_ATTRIBUTES >( &SecurityAttributes ), dwFileCreate, dwFileAttribute, 0 );
					if( Handle() == Invalid_Handle_Value )
					{
						//TODO: CDOSError::MapError( m_sErrorHelper.GetLastError() );
						m_chFlags &= ~FOPEN;
						//delete m_pFile;
						m_h = 0;
						//m_pFile = 0;
						Result = (*nsBaseCRT::CCRTErrorDomain::ErrNo() );
					}
				}
			}
		}
		return Result;
	}

	//--------------------------------------------------------------------------------
	template< typename _tchar >
	errno_t CCRTFile::OpenNoLockS( const _tchar* tszPath, int oflag, int shflag, int pmode, int bSecure )
	{

  //      char chFileFlags;                 // _osfile flags
  //      int fmode = 0;
  //      unsigned int uiOSPlatform = 0;
		//OSVersionInfo verInfo = {0};
  //      verInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
  //      unsigned long dwFileAccess;				// OS file access (requested)
  //      unsigned long dwFileShare;				// OS file sharing mode
  //      unsigned long dwFileCreate;				// OS method of opening/creating
  //      unsigned long dwFileAttribute;			// OS file attribute flags
  //      SECURITY_ATTRIBUTES SecurityAttributes;
  //      errno_t Result = 0;
  //      SecurityAttributes.nLength = sizeof( SecurityAttributes );
  //      SecurityAttributes.lpSecurityDescriptor = NULL;
		//fmode = CCRTFile::_fmode;
		//System().Info().GetVersionExT( &verInfo );
		//uiOSPlatform = verInfo.dwPlatformId;

		//chFileFlags = DecodeOpenFlags( oflag, SecurityAttributes, fmode, dwFileAccess, shflag, dwFileShare, dwFileCreate );
		//dwFileAttribute = DecodeOpenAttributes( oflag, dwFileAccess, dwFileShare, pmode, uiOSPlatform );

		//m_pFile = new nsFileSystem::CFile( tszPath, dwFileAccess, dwFileShare, &SecurityAttributes, dwFileCreate, dwFileAttribute, 0 );
		//
		//bool bOpen = true;

		//if( m_pFile->Handle() == Invalid_Handle_Value )
  //      {
		//	bOpen = OnOpenError( dwFileAccess, oflag, tszPath, dwFileShare, dwFileCreate, SecurityAttributes, dwFileAttribute, Result );
  //      }

		//if( bOpen )
		//{
		//	Result = PostOpen( oflag, chFileFlags, fmode, dwFileAccess, dwFileCreate, dwFileAttribute, tszPath, dwFileShare, SecurityAttributes );
		//}

  //      return Result;
		return 0;
	}

	//--------------------------------------------------------------------------------
	long CCRTFile::LSeekNoLock( long pos, int mthd )
	{
        unsigned long newpos;			// new file position
        unsigned long dosretval;		// o.s. return value
        void* osHandle;		// o.s. handle value

        // tell o.s. to seek

//#if SEEK_SET != FILE_BEGIN || SEEK_CUR != nsWin32::File_Current || SEEK_END != nsWin32::File_End
    //#error Xenix and Win32 seek constants not compatible
//#endif  /* SEEK_SET != FILE_BEGIN || SEEK_CUR != nsWin32::File_Current || SEEK_END != nsWin32::File_End */

        if( ( osHandle = Handle() ) == (void*)-1 )
        {
            (*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
            //_ASSERTE(("Invalid file descriptor",0));
            return -1;
        }

		if( ( newpos = SetPointer( pos, NULL, mthd ) ) == -1 )
		{
			dosretval = m_sErrorHelper.GetLastError();
		}
        else
		{
			dosretval = 0;
		}

        if( dosretval )
		{
			// o.s. error
			//TODO: CDOSError::MapError( dosretval );
			return -1;
        }

        m_chFlags &= ~FEOFLAG;        // clear the ctrl-z flag on the file
        return newpos;             // return
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::LCloseNoLock()
	{
		/*Close the underlying OS file handle. Special cases:
         *      1. If _get_osfhandle(fh) is Invalid_Handle_Value, don't try
         *         to actually close it. Just reset the lowio info so the
         *         handle can be reused. The standard handles are setup like
         *         this in Windows app, or a background app.
         *      2. If fh is STDOUT or STDERR, and if STDOUT and STDERR are
         *         mapped to the same OS file handle, skip the CloseHandle
         *         is skipped (without error). STDOUT and STDERR are the only
         *         handles for which this support is provided. Other handles
         *         are mapped to the same OS file handle only at the
         *         programmer's risk.
         */

		//delete m_pFile;
		//m_pFile = 0;
		Close();
		m_Handle().Drop();
        m_chFlags = 0;		// clear file flags
        return 0;
	}

	//--------------------------------------------------------------------------------
	errno_t CCRTFile::ChangeSizeNoLock( Cmp__int64 i64Size )
	{
		/*
        Cmp__int64 filend;
        Cmp__int64 extend;
        Cmp__int64 place;
        int cnt;
        int oldmode;
        Cmp__int64 retval = 0;
        errno_t err = 0;

        // Get current file position and seek to end
        if( ( ( place = LSeeki64NoLock( __QCMP_i64_SUFFIX(0), SEEK_CUR ) ) == __QCMP_i64_SUFFIX(-1) ) || ( ( filend = LSeeki64NoLock( __QCMP_i64_SUFFIX(0), SEEK_END ) ) == __QCMP_i64_SUFFIX(-1) ) )
		{
            return errno;
		}

        extend = i64Size - filend;

        // Grow or shrink the file as necessary

        if( extend > __QCMP_i64_SUFFIX(0) )
		{
			nsWin32::nsCodeServices::CWin32Allocator Allocator;
            // extending the file
			char* bl = (char*) Allocator.Allocate( _INTERNAL_BUFSIZ, HEAP_ZERO_MEMORY );

            if( !bl )
			{
                err = errno = ENOMEM;
                retval= __QCMP_i64_SUFFIX(-1);
            }
			else
			{
                oldmode = SetModeNoLock( OBinary );

                // pad out with nulls
                do
				{
                    cnt = ( extend >= (Cmp__int64)_INTERNAL_BUFSIZ ) ? _INTERNAL_BUFSIZ : (int)extend;
                    if( ( cnt = LWrite( bl, ( extend >= (Cmp__int64)_INTERNAL_BUFSIZ) ? _INTERNAL_BUFSIZ : (int)extend ) ) == -1 )
                    {
                        // Error on write
						if( nsWin32::nsCodeServices::t_pCurrentWin32Thread->Data().m_ulDOSErrNumber == ERROR_ACCESS_DENIED )
						{
                            err = errno = EACCESS;
						}
                        retval = cnt;
                        break; // leave write loop
                    }
                }
                while( ( extend -= (Cmp__int64)cnt ) > __QCMP_i64_SUFFIX(0) );

                SetModeNoLock( oldmode );

                Allocator.Free( bl );
            }
        }
        else if( extend < __QCMP_i64_SUFFIX(0) )
		{
            // shortening the file

            //Set file pointer to new eof...and truncate it there.
            retval = LSeeki64NoLock( i64Size, SEEK_SET );

            if( retval != __QCMP_i64_SUFFIX(-1) )
            {
				if( ( retval = m_pFile->SetEOF() ? 0 : -1 ) == -1 )
                {
                    err = errno = EACCESS;
					nsWin32::nsCodeServices::t_pCurrentWin32Thread->Data().m_ulDOSErrNumber = m_sErrorHelper.GetLastError();
                }
            }
        }

		// Common return code

        if( retval == -1 || ( LSeeki64NoLock( place, SEEK_SET ) == __QCMP_i64_SUFFIX(-1) ) )
        {
            return errno;
        }
		*/
        return 0;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::SeekNoLock( long offset, int whence )
	{
        if( !IsInUse() )
		{
			(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EINVAL;
			return(-1);
        }

        // Clear -1/*EOF*/ flag

        _flag &= ~_IOEOF;

        /* If seeking relative to current location, then convert to
           a seek relative to beginning of file.  This accounts for
           buffering, etc. by letting fseek() tell us where we are. */

        if( whence == SEEK_CUR )
		{
			offset += TellNoLock();
			whence = SEEK_SET;
        }

        // Flush buffer as necessary
        DoFlush();

        /* If file opened for read/write, clear flags since we don't know
           what the user is going to do next. If the file was opened for
           read access only, decrease _bufsiz so that the next FillBuffer
           won't cost quite so much */

        if( _flag & _IORW )
		{
			_flag &= ~(_IOWRT|_IOREAD);
		}
        else if( ( _flag & _IOREAD ) && ( _flag & _IOMYBUF ) && !( _flag & _IOSETVBUF ) )
		{
			_bufsiz = _SMALL_BUFSIZ;
		}

        // Seek to the desired locale and return.

        return( LSeek( offset, whence ) == -1L ? -1 : 0 );
	}

	//--------------------------------------------------------------------------------
	long CCRTFile::TellNoLock()
	{
        unsigned int offset;
        long filepos;
        char* p;
        char* max;
        //int fd;
        unsigned int rdcnt;

        //_VALIDATE_RETURN( (str != NULL), EINVAL, (-1L) );

        if( _cnt < 0 )
		{
            _cnt = 0;
		}

        if( ( filepos = LSeek( 0L, SEEK_CUR ) ) < 0L )
		{
            return(-1L);
		}

        if( !UseBigBuffer() )            /* m_scusIONoBuffering or no buffering designated */
		{
            return( filepos - _cnt );
		}

        offset = (unsigned)( _ptr - _base );

        if( _flag & ( _IOWRT | _IOREAD ) )
		{
            if( m_chFlags & FTEXT )
			{
                for( p = _base; p < _ptr; p++ )
				{
                    if( *p == '\n' )  // adjust for '\r'
					{
                        offset++;
					}
				}
			}
        }
        else if( !( _flag & _IORW ) )
		{
            (*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EINVAL;
            return(-1L);
        }

        if( filepos == 0L )
		{
            return((long)offset);
		}

        if( _flag & _IOREAD )    // go to preceding sector
		{
            if( _cnt == 0 )  // filepos holds correct location
			{
                offset = 0;
			}
            else
			{
                /* Subtract out the number of unread bytes left in the buffer.
                   [We can't simply use _iob[]._bufsiz because the last read
                   may have hit -1 and, thus, the buffer was not completely
                   filled.] */

                rdcnt = _cnt + (unsigned)(_ptr - _base);

                // If text mode, adjust for the cr/lf substitution. If binary mode, we're outta here.
                if( m_chFlags & FTEXT )
				{
                    /* (1) If we're not at eof, simply copy _bufsiz onto rdcnt
                       to get the # of untranslated chars read. (2) If we're at
                       eof, we must look through the buffer expanding the '\n'
                       chars one at a time. */

                    /* [NOTE: Performance issue -- it is faster to do the two
                       LSeek() calls than to blindly go through and expand the
                       '\n' chars regardless of whether we're at eof or not.] */

                    if( LSeek( 0L, SEEK_END ) == filepos )
					{
                        max = _base + rdcnt;
                        for( p = _base; p < max; p++ )
						{
                            if( *p == '\n' )
							{
                                // adjust for '\r'
                                rdcnt++;
							}
						}
                        // If last byte was ^Z, the lowio read didn't tell us about it. Check flag and bump count, if necessary.
                        if( _flag & _IOCTRLZ )
						{
                            ++rdcnt;
						}
                    }
                    else
					{
                        if( LSeek( filepos, SEEK_SET ) < 0 )
						{
                            return (-1);
						}

                        /* We want to set rdcnt to the number of bytes
                           originally read into the stream buffer (before
                           crlf->lf translation). In most cases, this will
                           just be _bufsiz. However, the buffer size may have
                           been changed, due to fseek optimization, at the
                           END of the last FillBuffer call. */

                        if( ( rdcnt <= _SMALL_BUFSIZ ) && ( _flag & _IOMYBUF ) && !( _flag & _IOSETVBUF ) )
                        {
                            /* The translated contents of the buffer is small
                               and we are not at eof. The buffer size must have
                               been set to _SMALL_BUFSIZ during the last
                               FillBuffer call. */
                            rdcnt = _SMALL_BUFSIZ;
                        }
                        else
						{
                            rdcnt = _bufsiz;
						}

                        /* If first byte in untranslated buffer was a '\n',
                           assume it was preceeded by a '\r' which was
                           discarded by the previous read operation and count
                           the '\n'. */
                        if ( m_chFlags & FCRLF )
						{
                            ++rdcnt;
						}
                    }

                }
                filepos -= (long)rdcnt;
            }
		}

        return( filepos + (long)offset );
	}

	//--------------------------------------------------------------------------------
	long CCRTFile::LSeek( long pos, int mthd )
	{
        int r;

        //_CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
        //_VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
        //_VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);

        CCriticalSectionLock Lock( m_Lock );

		if( m_chFlags & FOPEN )
		{
			r = LSeekNoLock( pos, mthd );
		}
		else
		{
			(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
			nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = 0;
			r = -1;
			//_ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
		}
        return r;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::Seeki64( Cmp__int64 offset, int whence )
	{
        int retval;

        //_ASSERTE(stream != NULL);

        CCriticalSectionLock Lock( m_Lock );

		retval = Seeki64NoLock( offset, whence );

        return(retval);
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::Seeki64NoLock( Cmp__int64 offset, int whence )
	{
        //_ASSERTE(str != NULL);

        if( !IsInUse() || ( ( whence != SEEK_SET ) && ( whence != SEEK_CUR ) && ( whence != SEEK_END ) ) )
		{
			(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EINVAL;
			return(-1);
        }

        // Clear -1/*EOF*/ flag

        _flag &= ~_IOEOF;

        /* If seeking relative to current location, then convert to
           a seek relative to beginning of file.  This accounts for
           buffering, etc. by letting fseek() tell us where we are. */

        if( whence == SEEK_CUR )
		{
			offset += Telli64NoLock();
			whence = SEEK_SET;
        }

        // Flush buffer as necessary
        DoFlush();

        /* If file opened for read/write, clear flags since we don't know
           what the user is going to do next. If the file was opened for
           read access only, decrease _bufsiz so that the next FillBuffer
           won't cost quite so much */

        if( _flag & _IORW )
		{
			_flag &= ~( _IOWRT | _IOREAD );
		}
        else if( ( _flag & _IOREAD ) && ( _flag & _IOMYBUF ) && !( _flag & _IOSETVBUF ) )
		{
			_bufsiz = _SMALL_BUFSIZ;
		}

        // Seek to the desired locale and return.

        return( LSeeki64( offset, whence ) == __QCMP_i64_SUFFIX(-1) ? -1 : 0);
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::_eof()
	{
        Cmp__int64 i64Here = 0;
        Cmp__int64 i64End = 0;
        int iResult = 0;

        //_CHECK_FH_CLEAR_OSSERR_RETURN( filedes, EBADF, -1 );
        //_VALIDATE_CLEAR_OSSERR_RETURN((filedes >= 0 && (unsigned)filedes < (unsigned)_nhandle), EBADF, -1);
        //_VALIDATE_CLEAR_OSSERR_RETURN((_osfile(filedes) & FOPEN), EBADF, -1);

        // Lock the file
        CCriticalSectionLock Lock( m_Lock );

		if( m_chFlags & FOPEN )
		{
			// See if the current position equals the end of the file.

			if( ( ( i64Here = LSeeki64NoLock( __QCMP_i64_SUFFIX(0), SEEK_CUR ) ) == __QCMP_i64_SUFFIX(-1) ) || ( ( i64End = LSeeki64NoLock( __QCMP_i64_SUFFIX(0), SEEK_END ) ) == __QCMP_i64_SUFFIX(-1) ) )
			{
				iResult = -1;
			}
			else if( i64Here == i64End )
			{
				iResult = 1;
			}
			else
			{
				LSeeki64NoLock( i64Here, SEEK_SET );
				iResult = 0;
			}
		}
		else
		{
			(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
			nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = 0;
			iResult = -1;
			//_ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
		}

        return iResult;
	}

	//--------------------------------------------------------------------------------
	template< typename _tchar >
	int CCRTFile::Open( const _tchar* tszPath, int iOFlag, ... )
	{
        va_list vargs;
        int iPMode = 0;
        errno_t Result;

        //_VALIDATE_RETURN( (path != NULL), EINVAL, -1);

        va_start( vargs, iOFlag );
        iPMode = va_arg( vargs, int );
        va_end( vargs );

		// Last parameter passed as 0 because we don't want to validate pmode from open
		Result = OpenNoLockS( tszPath, iOFlag, _SH_DENYNO, iPMode, 0 );

        if( Result != 0 )
        {
            (*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = Result;
        }
        return Result;
	}

	//--------------------------------------------------------------------------------
	template< typename _tchar >
	int CCRTFile::OpenS( const _tchar* tszPath, int iOFlag, int iSHFlag, ... )
	{
        va_list vargs;
        int iPMode = 0;
        errno_t e;

        va_start( vargs, iSHFlag );
        iPMode = va_arg( vargs, int );
        va_end( vargs );

        // Last parameter passed as 0 because we don't want to validate pmode from open
        e = OpenSHelper( tszPath, iOFlag, iSHFlag, iPMode, 0 );

        return e ? -1 : 0;
	}

	//--------------------------------------------------------------------------------
	long CCRTFile::LTell()
	{
		return( LSeek( 0L, 1 ) );
	}

	//--------------------------------------------------------------------------------
	Cmp__int64 CCRTFile::LTelli64()
	{
		return( LSeeki64( __QCMP_i64_SUFFIX(0), SEEK_CUR ) );
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::UMask( int iMode )
	{
        int iOldMode = 0;

        iMode &= ( _S_IREAD | _S_IWRITE );// silently ignore non-Windows modes

        UMaskS( iMode, &iOldMode );
        return iOldMode;
	}

	//--------------------------------------------------------------------------------
	errno_t CCRTFile::UMaskS( int iMode, int* pOldMode )
	{
		//_VALIDATE_RETURN_ERRCODE((poldmode != NULL), EINVAL);
		*pOldMode = _umaskval;
		//_VALIDATE_RETURN_ERRCODE(((mode & ~(_S_IREAD | _S_IWRITE)) == 0), EINVAL);

		// only user read/write permitted
		iMode &= ( _S_IREAD | _S_IWRITE );
		_umaskval = iMode;
		return 0;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::_pipe( FILE* phandles[2], unsigned psize, int iTextmode )
	{
		/*
        unsigned long dosretval;                    // o.s. return value

		CCRTFile* handle1;
        int toomanyfiles = 0;

		nsWin32::nsCodeServices::CHandle ReadHandle( const_cast< void* >( Invalid_Handle_Value ) );
		nsWin32::nsCodeServices::CHandle WriteHandle( const_cast< void* >( Invalid_Handle_Value ) );
        void* tmpReadHandle, *tmpWriteHandle;
        SECURITY_ATTRIBUTES SecurityAttributes;

        //_VALIDATE_CLEAR_OSSERR_RETURN( (phandles != NULL), EINVAL, -1 );
        phandles[0] = phandles[1] = 0;

        //_VALIDATE_CLEAR_OSSERR_RETURN(((textmode & ~(ONoInherit | _O_BINARY | _O_TEXT)) == 0), EINVAL, -1);
        //_VALIDATE_CLEAR_OSSERR_RETURN((textmode & (_O_BINARY | _O_TEXT)) != (_O_BINARY | _O_TEXT), EINVAL, -1);

        SecurityAttributes.nLength = sizeof(SecurityAttributes);
        SecurityAttributes.lpSecurityDescriptor = NULL;

        if( m_chTextMode & ONoInherit )
		{
            SecurityAttributes.bInheritHandle = 0;
        }
        else
		{
            SecurityAttributes.bInheritHandle = 1;
        }

		if( !m_sPipeHelper.Create( &tmpReadHandle, &tmpWriteHandle, &SecurityAttributes, psize ) )
		{
            // o.s. error
			dosretval = m_sErrorHelper.GetLastError();
			//TODO: CDOSError::MapError( dosretval );
            return -1;
        }

		ReadHandle.Attach( tmpReadHandle );
		WriteHandle.Attach( tmpWriteHandle );

        // now we must allocate C Runtime handles for Read and Write handles

        m_chFlags = (FOPEN | FPIPE | FTEXT);
        m_chTextMode = 0;
        m_bchUnicode = 0;


		if( ( handle1 = new CCRTFile() ) != 0 )
		{
			int fmode = 0;
			handle1->m_chFlags = (FOPEN | FPIPE | FTEXT);
			handle1->m_chTextMode = 0;
			handle1->m_bchUnicode = 0;

			//_ERRCHECK(_get_fmode(&fmode));
			if( ( iTextmode & OBinary ) || ( ( ( iTextmode & OText ) == 0 ) && ( _fmode == OBinary ) ) )
			{
				// binary mode
				m_chFlags &= ~FTEXT;
				handle1->m_chFlags &= ~FTEXT;
			}

			if( iTextmode & ONoInherit )
			{
				m_chFlags |= FNOINHERIT;
				handle1->m_chFlags |= FNOINHERIT;
			}

			///TODO:m_Handle = (intptr_t)ReadHandle;
			///TODO:handle1->m_Handle = (intptr_t)WriteHandle;
		}
		else
		{
			m_chFlags = 0;
			toomanyfiles = 1;
		}

        // If error occurred, close Win32 handles and return -1
        if( toomanyfiles )
		{
            errno = EMFILE;
			nsCodeServices::t_pCurrentWin32Thread->Data().m_ulDOSErrNumber = 0;
            return -1;
        }
		else
		{
			ReadHandle.Detach();
			WriteHandle.Detach();
		}

        phandles[0] = this;
        phandles[1] = handle1;
		*/
        return 0;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::SetMode( int iMode )
	{
        int iResult = 0;

        //_VALIDATE_RETURN( ( ( mode == _O_TEXT ) || ( mode == _O_BINARY ) || ( mode == OWText ) || ( mode == _O_U8TEXT ) || ( mode == _O_U16TEXT ) ), EINVAL, -1 );
        //_CHECK_FH_RETURN( fh, EBADF, -1 );
        //_VALIDATE_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
        //_VALIDATE_RETURN((_osfile(fh) & FOPEN), EBADF, -1);

        CCriticalSectionLock Lock( m_Lock );// lock the file

		if( m_chFlags & FOPEN )
		{
			iResult = SetModeNoLock( iMode );// set the text/binary mode
		}
		else
		{
            (*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
            //_ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
            iResult = -1;
		}

        return iResult;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::SetModeNoLock( int iMode )
	{
		int iResult = 0;
        int iOldMode;
        int iOldTextMode;

        iOldMode = m_chFlags & FTEXT;
        iOldTextMode = m_chTextMode;

        switch( iMode )
		{
            case OBinary :
                m_chFlags &= ~FTEXT;
                break;

            case OText :
                m_chFlags |= FTEXT;
                m_chTextMode = __IOINFO_TM_ANSI;
                break;

            case OU8Text :
                m_chFlags |= FTEXT;
                m_chTextMode = __IOINFO_TM_UTF8;
                break;

            case OU16Text:
            case OWText :
                m_chFlags |= FTEXT;
                m_chTextMode = __IOINFO_TM_UTF16LE;
                break;
        }

        if( iOldMode == 0 )
		{
            iResult = OBinary;
        }
		else
		{
			if( iOldTextMode == __IOINFO_TM_ANSI )
			{
				iResult = OText;
			}
			else
			{
				iResult = OWText;
			}
		}

		return iResult;
	}

	//--------------------------------------------------------------------------------
	errno_t CCRTFile::_set_fmode( int mode )
	{
		//_VALIDATE_RETURN_ERRCODE(((mode == _O_TEXT) || (mode == _O_BINARY) || (mode == OWText)), EINVAL);

		//_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
		m_sInterlockedHelper.Exchange( (volatile long*)(&_fmode), mode );
		//_END_SECURE_CRT_DEPRECATION_DISABLE

		return 0;
	}

	//--------------------------------------------------------------------------------
	errno_t CCRTFile::_get_fmode( int* pMode )
	{
		//_VALIDATE_RETURN_ERRCODE((pMode != NULL), EINVAL);

		//_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
		*pMode = _fmode;
		//_END_SECURE_CRT_DEPRECATION_DISABLE
		return 0;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::Locking( int iLockMode, long lBytes )
	{
        int iResult = 0;

        // validate file handle
        //_CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
        //_VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
        //_VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);

        CCriticalSectionLock Lock( m_Lock );

		if( m_chFlags & FOPEN )
		{
			iResult = LockingNoLock( iLockMode, lBytes );
		}
		else
		{
			(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
			nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = 0;
			iResult = -1;
			//_ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
		}

        return iResult;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::LockingNoLock ( int iLockMode, long lBytes )
	{
        unsigned long ulDOSResult;		// OS return code
        long lLockOffset;
        int iRetries;			// retry count

        // obtain current position in file by calling LSeek
        // Use LSeekNoLock as we already own lock
        lLockOffset = LSeekNoLock( 0L, 1 );
        if( lLockOffset == -1 )
		{
			return -1;
		}

        iRetries = ( iLockMode == _LK_LOCK || iLockMode == _LK_RLCK ) ? 9 : 0;// set retry count based on mode

        // ask OS to lock the file until success or retry count finished

		for (;;)
		{
			ulDOSResult = 0;
			if( iLockMode == _LK_UNLCK )
			{
				if( !( CFile::Unlock( lLockOffset, 0L, lBytes, 0L ) ) )
				{
					ulDOSResult = m_sErrorHelper.GetLastError();
				}
			}
			else
			{
				if( !( CFile::Lock( lLockOffset, 0L, lBytes, 0L ) ) )
				{
					ulDOSResult = m_sErrorHelper.GetLastError();
				}
			}

			if( iRetries <= 0 || ulDOSResult == 0 )
			{
				break;  // exit loop on success or retry exhausted
			}

			//TODO: m_sThreadHelper.Sleep( 100L );

			--iRetries;
        }

        if( ulDOSResult != 0 )
		{
			// OS error occurred -- file was already locked; if a blocking call, then return EDEADLK, otherwise map error normally
			if( iLockMode == _LK_LOCK || iLockMode == _LK_RLCK )
			{
				(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EDEADLK;
				nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = ulDOSResult;
			}
			else
			{
				//TODO: CDOSError::MapError( ulDOSResult );
			}
			return -1;
        }
        else
		{
			return 0;
		}
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::ChangeSize( long lSize )
	{
		errno_t e;
		e = ChangeSizeS( (Cmp__int64)lSize ) ;
		return e == 0 ? 0 : -1 ;
	}

	//--------------------------------------------------------------------------------
	errno_t CCRTFile::ChangeSizeS( Cmp__int64 i64Size )
	{
        int iResult = 0;

        //_CHECK_FH_CLEAR_OSSERR_RETURN_ERRCODE( filedes, EBADF );
        //_VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((filedes >= 0 && (unsigned)filedes < (unsigned)_nhandle), EBADF);
        //_VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((_osfile(filedes) & FOPEN), EBADF);
        //_VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((size >= 0), EINVAL);

        CCriticalSectionLock Lock( m_Lock );

		if( m_chFlags & FOPEN )
		{
			iResult = ChangeSizeNoLock( i64Size );
		}
		else
		{
			//_ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
			iResult = (*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
        }

        return iResult;
	}

	//--------------------------------------------------------------------------------
	long CCRTFile::Length()
	{
        long lResult = 0;
        long lHere = 0;

        //_CHECK_FH_CLEAR_OSSERR_RETURN( filedes, EBADF, -1L );
        //_VALIDATE_CLEAR_OSSERR_RETURN((filedes >= 0 && (unsigned)filedes < (unsigned)_nhandle), EBADF, -1L);
        //_VALIDATE_CLEAR_OSSERR_RETURN((_osfile(filedes) & FOPEN), EBADF, -1L);

        CCriticalSectionLock Lock( m_Lock );
		if( m_chFlags & FOPEN )
		{
			// Seek to end to get length of file.
			if( ( lHere = LSeekNoLock( 0L, SEEK_CUR ) ) == -1L )
			{
                lResult = -1L;   // return error
			}
			else
			{
                lResult = LSeekNoLock( 0L, SEEK_END );
                if ( lHere != lResult )
				{
					LSeekNoLock( lHere, SEEK_SET );
				}
			}
		}
		else
		{
			(*nsBaseCRT::CCRTErrorDomain::ErrNo() ) = EBADF;
			nsWin32::t_pCurrentWin32Thread->Data().DOSErrorNumber() = 0;
			lResult = -1L;
			//_ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
		}

        return lResult ;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::_fstat32( _stat32* buf )
	{

        //int isdev;          // 0 for a file, 1 for a device
		int retval = 0;
		/*
        BY_HANDLE_FILE_INFORMATION bhfi;
        FILETIME LocalFTime;
        SystemTime SysTime;

        //_VALIDATE_CLEAR_OSSERR_RETURN( (buf != NULL), EINVAL, -1 );
        memset( buf, 0, sizeof(*buf) );

        //_CHECK_FH_CLEAR_OSSERR_RETURN( fildes, EBADF, -1 );
        //_VALIDATE_CLEAR_OSSERR_RETURN((fildes >= 0 && (unsigned)fildes < (unsigned)_nhandle), EBADF, -1);
        //_VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fildes) & FOPEN), EBADF, -1);

        nsSync::CCriticalSectionLock Lock( m_Lock );// Lock the file

        if( !( m_chFlags & FOPEN ) )
		{
			errno = EBADF;
			retval = -1;
			//_ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
			goto done;
		}

        // Find out what kind of handle underlies file
		isdev = m_pFile->GetType() & ~nsWin32::File_Type_Remote;

        if( isdev != nsWin32::File_Type_Disk )
		{
            // not a disk file. probably a device or pipe

            if( ( isdev == nsWin32::File_Type_Char ) || ( isdev == nsWin32::File_Type_Pipe ) )
			{
                //treat pipes and devices similarly. no further info is available from any API,
				//so set the fields as reasonably as possible and return.

                if( isdev == nsWin32::File_Type_Char )
				{
                    buf->st_mode = _S_IFCHR;
				}
                else
				{
                    buf->st_mode = _S_IFIFO;
				}

                buf->st_rdev = buf->st_dev = (nsWin32::_dev_t)_file;
                buf->st_nlink = 1;
                buf->st_uid = buf->st_gid = buf->st_ino = 0;
                buf->st_atime = buf->st_mtime = buf->st_ctime = 0;
                if ( isdev == nsWin32::File_Type_Char )
				{
                    buf->st_size = 0;
                }
                else
				{
					nsWin32::nsComms::CPipe Pipe;
                    unsigned long ulAvail;
					unsigned long ulBytesRead;
					unsigned long ulBytesLeft;
                    int rc;
					Pipe.Attach( m_pFile->Handle() );
					rc = Pipe.Peek( 0, 0, ulBytesRead, ulAvail, ulBytesLeft );

                    if( rc )
					{
                        buf->st_size = (nsWin32::off_t)ulAvail;
                    }
                    else
					{
                        buf->st_size = (nsWin32::off_t)0;
                    }
                }

                goto done;
			}
            else if( isdev == File_Type_Unknown )
			{
                errno = EBADF;
                retval = -1;
                goto done;      // join common return code
            }
            else
			{
                // according to the documentation, this cannot happen, but play it safe anyway.
				CDOSError::MapError( m_sErrorHelper.GetLastError() );
                retval = -1;
                goto done;
            }
		}


        // set the common fields
        buf->st_ino = buf->st_uid = buf->st_gid = buf->st_mode = 0;
        buf->st_nlink = 1;

        // use the file handle to get all the info about the file

		if( !m_pFile->GetInformation( &bhfi ) )
		{
			CDOSError::MapError( m_sErrorHelper.GetLastError() );
            retval = -1;
            goto done;
        }

        if( bhfi.dwFileAttributes & nsWin32::File_Attribute_ReadOnly )
		{
            buf->st_mode |= ( _S_IREAD + ( _S_IREAD >> 3 ) + ( _S_IREAD >> 6 ) );
		}
        else
		{
            buf->st_mode |= ( ( _S_IREAD | _S_IWRITE ) + ( ( _S_IREAD | _S_IWRITE ) >> 3 ) + ( ( _S_IREAD | _S_IWRITE ) >> 6 ) );
		}

        // set file date fields
        if( bhfi.ftLastWriteTime.dwLowDateTime || bhfi.ftLastWriteTime.dwHighDateTime )
        {
            if( !m_Win32TimeHelper.FileTimeToLocalFileTime( &(bhfi.ftLastWriteTime), &LocalFTime ) || !m_Win32TimeHelper.FileTimeToSystemTime( &LocalFTime, &SysTime ) )
            {
                retval = -1;
                goto done;
            }

			///TODO: buf->st_mtime = __loctotime32_t( SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, -1 );
        }
		else
		{
            buf->st_mtime = 0 ;
		}

        if ( bhfi.ftLastAccessTime.dwLowDateTime || bhfi.ftLastAccessTime.dwHighDateTime )
        {
            if ( !m_Win32TimeHelper.FileTimeToLocalFileTime( &( bhfi.ftLastAccessTime ), &LocalFTime ) || !m_Win32TimeHelper.FileTimeToSystemTime( &LocalFTime, &SysTime ) )
            {
                retval = -1;
                goto done;
            }

            ///TODO: buf->st_atime = __loctotime32_t( SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, -1 );
        }
        else
		{
            buf->st_atime = buf->st_mtime;
		}

        if( bhfi.ftCreationTime.dwLowDateTime || bhfi.ftCreationTime.dwHighDateTime )
        {
            if( !m_Win32TimeHelper.FileTimeToLocalFileTime( &(bhfi.ftCreationTime), &LocalFTime ) || !m_Win32TimeHelper.FileTimeToSystemTime( &LocalFTime, &SysTime ) )
            {
                retval = -1;
                goto done;
            }

            ///TODO: buf->st_ctime = __loctotime32_t( SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, -1 );
        }
        else
		{
            buf->st_ctime = buf->st_mtime;
		}

        buf->st_size = bhfi.nFileSizeLow;
        buf->st_mode |= _S_IFREG;

        // On DOS, this field contains the drive number, but the drive number is not available on this platform.
        //Also, for UNC network names, there is no drive number.

        buf->st_rdev = buf->st_dev = 0;

		// Common return code
done:
*/
        return retval ;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::FlushNoLock()
	{
        //if ( str == NULL ) return(flsall(FFLUSHNULL));
        if( DoFlush() != 0 )
		{
			return( -1/*EOF*/ );//DoFlush failed, don't attempt to commit
        }

        if( _flag & _IOCOMMIT )
		{
			return ( Commit() ? -1/*EOF*/ : 0 );// commit to ensure data is written to disk
        }

        return 0;
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::fflush()
	{
        int rc;

        // if stream is NULL, flush all streams
        //if( stream == NULL ) return(flsall(FFLUSHNULL));

        CCriticalSectionLock Lock( m_Lock );

        rc = FlushNoLock();

        return(rc);
	}

	//--------------------------------------------------------------------------------
	int CCRTFile::Flush( void )
	{
        int iResult = 0;
        int nchar;

        if( ( _flag & ( _IOREAD | _IOWRT ) ) == _IOWRT && UseBigBuffer() && ( nchar = (int)( _ptr - _base ) ) > 0 )
        {
			if ( LWrite( _base, nchar ) == nchar )
			{
				// if this is a read/write file, clear _IOWRT so that next operation can be a read
				if( _IORW & _flag )
				{
					_flag &= ~_IOWRT;
				}
			}
			else
			{
				_flag |= _IOERR;
				iResult = eof;
			}
        }

        _ptr = _base;
        _cnt = 0;

        return iResult;
	}

}//nsWin32

